(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
(function (global){(function (){
const { FS, MPQ } = require('@wowserhq/stormjs');

global.window.FS = FS;
global.window.MPQ = MPQ;
}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"@wowserhq/stormjs":4}],2:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _stream = _interopRequireDefault(require("./stream"));

var _stormlib = _interopRequireDefault(require("../stormlib.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class File {
  constructor(handle) {
    this.handle = handle;
    this.data = null;
    this._name = null;
    this._pos = 0;
  }

  get name() {
    this._ensureHandle();

    if (!this._name) {
      this._name = new _stormlib.default.Str(_stormlib.default.MAX_PATH);
    }

    if (_stormlib.default.SFileGetFileName(this.handle, this._name)) {
      return this._name.toJS();
    } else {
      const errno = _stormlib.default.GetLastError();

      throw new Error(`File name could not be read (error ${errno})`);
    }
  }

  get pos() {
    return this._pos;
  }

  set pos(pos) {
    this._ensureHandle();

    const result = _stormlib.default.SFileSetFilePointer(this.handle, pos, _stormlib.default.NULLPTR, _stormlib.default.FILE_BEGIN);

    if (result === _stormlib.default.SFILE_INVALID_SIZE) {
      const errno = _stormlib.default.GetLastError();

      throw new Error(`File pos could not be set (error ${errno})`);
    }

    this._pos = pos;
  }

  get size() {
    this._ensureHandle();

    const size = _stormlib.default.SFileGetFileSize(this.handle, _stormlib.default.NULLPTR);

    if (size === _stormlib.default.SFILE_INVALID_SIZE) {
      const errno = _stormlib.default.GetLastError();

      throw new Error(`File size could not be determined (error ${errno})`);
    }

    return size;
  }

  close() {
    if (this.handle) {
      if (_stormlib.default.SFileCloseFile(this.handle)) {
        this.handle.delete();
        this.handle = null;

        if (this.data) {
          this.data.delete();
          this.data = null;
        }

        if (this._name) {
          this._name.delete();

          this._name = null;
        }
      } else {
        const errno = _stormlib.default.GetLastError();

        throw new Error(`Archive could not be closed (error ${errno})`);
      }
    }
  }

  createStream() {
    this._ensureHandle();

    return new _stream.default(this);
  }

  read() {
    this._ensureHandle();

    const size = this.size;

    if (!this.data) {
      this.data = new _stormlib.default.Buf(size);
    }

    this.pos = 0;

    const success = _stormlib.default.SFileReadFile(this.handle, this.data, size, _stormlib.default.NULLPTR, _stormlib.default.NULLPTR);

    if (success) {
      return this.data.toJS();
    } else {
      this.data.delete();
      this.data = null;

      const errno = _stormlib.default.GetLastError();

      throw new Error(`File could not be read (error ${errno})`);
    }
  }

  _ensureHandle() {
    if (!this.handle) {
      throw new Error('Invalid handle');
    }
  }

}

var _default = File;
exports.default = _default;
},{"../stormlib.js":7,"./stream":3}],3:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _stream = _interopRequireDefault(require("stream"));

var _stormlib = _interopRequireDefault(require("../stormlib.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const STREAM_CHUNK_SIZE = 64 * 1024;

class FileStream extends _stream.default.Readable {
  constructor(file) {
    super({
      highWaterMark: STREAM_CHUNK_SIZE
    });
    this._file = file;
    this._size = file.size;
    this._pos = 0;
    this._buffer = new _stormlib.default.Buf(Math.min(STREAM_CHUNK_SIZE, this._size));
    this.on('end', () => {
      this.destroy();
    });
  }

  _destroy() {
    this._buffer.delete();

    this._buffer = null;
    this._file = null;
  }

  _die(error) {
    this.destroy();
    this.emit('error', error);
  }

  _read(size) {
    if (!this._file.handle) {
      this._die(new Error('Missing file handle'));

      return;
    }

    try {
      this._file.pos = this._pos;
    } catch (error) {
      this._die(error);

      return;
    }

    const read = Math.min(STREAM_CHUNK_SIZE, size, this._size - this._pos);

    let success = _stormlib.default.SFileReadFile(this._file.handle, this._buffer, read, _stormlib.default.NULLPTR, _stormlib.default.NULLPTR);

    if (success) {
      if (read === STREAM_CHUNK_SIZE) {
        this.push(this._buffer.toJS());
      } else {
        this.push(this._buffer.toJS().subarray(0, read));
      }

      this._pos += read;

      if (this._pos === this._size) {
        this.push(null);
      }
    } else {
      const errno = _stormlib.default.GetLastError();

      this._die(new Error(`File could not be streamed (error ${errno})`));
    }
  }

}

var _default = FileStream;
exports.default = _default;
},{"../stormlib.js":7,"stream":180}],4:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "File", {
  enumerable: true,
  get: function () {
    return _index.default;
  }
});
Object.defineProperty(exports, "MPQ", {
  enumerable: true,
  get: function () {
    return _mpq.default;
  }
});
exports.FS = void 0;

var _index = _interopRequireDefault(require("./file/index"));

var _mpq = _interopRequireDefault(require("./mpq"));

var _stormlib = _interopRequireDefault(require("./stormlib.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const FS = _stormlib.default.FS;
exports.FS = FS;
},{"./file/index":2,"./mpq":5,"./stormlib.js":7}],5:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _index = _interopRequireDefault(require("./file/index"));

var _stormlib = _interopRequireDefault(require("./stormlib.js"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

class MPQ {
  constructor(handle) {
    this.handle = handle;
  }

  close() {
    if (this.handle) {
      if (_stormlib.default.SFileCloseArchive(this.handle)) {
        this.handle.delete();
        this.handle = null;
      } else {
        const errno = _stormlib.default.GetLastError();

        throw new Error(`Archive could not be closed (error ${errno})`);
      }
    }
  }

  hasFile(fileName) {
    this._ensureHandle();

    if (_stormlib.default.SFileHasFile(this.handle, fileName)) {
      return true;
    } else {
      const errno = _stormlib.default.GetLastError();

      if (errno === _stormlib.default.ERROR_FILE_NOT_FOUND) {
        return false;
      } else {
        throw new Error(`File presence check failed (error ${errno})`);
      }
    }
  }

  openFile(fileName) {
    this._ensureHandle();

    const fileHandle = new _stormlib.default.VoidPtr();

    if (_stormlib.default.SFileOpenFileEx(this.handle, fileName, 0, fileHandle)) {
      return new _index.default(fileHandle);
    } else {
      fileHandle.delete();

      const errno = _stormlib.default.GetLastError();

      throw new Error(`File could not be opened (error ${errno})`);
    }
  }

  patch(path, prefix = '') {
    this._ensureHandle();

    if (!_stormlib.default.SFileOpenPatchArchive(this.handle, path, prefix, 0)) {
      const errno = _stormlib.default.GetLastError();

      throw new Error(`Patch failed (error ${errno})`);
    }
  }

  search(mask, listfile = '') {
    this._ensureHandle();

    const findData = new _stormlib.default.SFileFindData();

    const findHandle = _stormlib.default.SFileFindFirstFile(this.handle, mask, findData, listfile);

    if (findHandle.isNull()) {
      const errno = _stormlib.default.GetLastError();

      findData.delete();
      findHandle.delete();

      if (errno === _stormlib.default.ERROR_NO_MORE_FILES) {
        return [];
      } else {
        throw new Error(`Find failed (error ${errno})`);
      }
    }

    const results = [];
    results.push(findData.toJS());

    while (_stormlib.default.SFileFindNextFile(findHandle, findData)) {
      results.push(findData.toJS());
    }

    _stormlib.default.SFileFindClose(findHandle);

    findData.delete();
    findHandle.delete();
    return results;
  }

  _ensureHandle() {
    if (!this.handle) {
      throw new Error('Invalid handle');
    }
  }

  static async open(path, mode = '') {
    await _stormlib.default.ready;
    let flags = 0;

    if (mode === 'r') {
      flags |= _stormlib.default.STREAM_FLAG_READ_ONLY;
    }

    const handle = new _stormlib.default.VoidPtr();
    const priority = 0;

    if (_stormlib.default.SFileOpenArchive(path, priority, flags, handle)) {
      return new MPQ(handle);
    } else {
      const errno = _stormlib.default.GetLastError();

      throw new Error(`Archive could not be opened (error ${errno})`);
    }
  }

}

var _default = MPQ;
exports.default = _default;
},{"./file/index":2,"./stormlib.js":7}],6:[function(require,module,exports){
(function (process,Buffer,__filename,__argument0,__argument1,__argument2,__argument3,__dirname){(function (){

var StormLib = (function() {
  var _scriptDir = typeof document !== 'undefined' && document.currentScript ? document.currentScript.src : undefined;
  if (typeof __filename !== 'undefined') _scriptDir = _scriptDir || __filename;
  return (
function(StormLib) {
  StormLib = StormLib || {};

/**
 * @license
 * Copyright 2010 The Emscripten Authors
 * SPDX-License-Identifier: MIT
 */

// The Module object: Our interface to the outside world. We import
// and export values on it. There are various ways Module can be used:
// 1. Not defined. We create it here
// 2. A function parameter, function(Module) { ..generated code.. }
// 3. pre-run appended it, var Module = {}; ..generated code..
// 4. External script tag defines var Module.
// We need to check if Module already exists (e.g. case 3 above).
// Substitution will be replaced with actual code on later stage of the build,
// this way Closure Compiler will not mangle it (e.g. case 4. above).
// Note that if you want to run closure, and also to use Module
// after the generated code, you will need to define   var Module = {};
// before the code. Then that object will be used in the code, and you
// can continue to use Module afterwards as well.
var Module = typeof StormLib !== 'undefined' ? StormLib : {};

// --pre-jses are emitted after the Module integration code, so that they can
// refer to Module (if they choose; they can also define Module)


// Sometimes an existing Module object exists with properties
// meant to overwrite the default module functionality. Here
// we collect those properties and reapply _after_ we configure
// the current environment's defaults to avoid having to be so
// defensive during initialization.
var moduleOverrides = {};
var key;
for (key in Module) {
  if (Module.hasOwnProperty(key)) {
    moduleOverrides[key] = Module[key];
  }
}

var arguments_ = [];
var thisProgram = './this.program';
var quit_ = function(status, toThrow) {
  throw toThrow;
};

// Determine the runtime environment we are in. You can customize this by
// setting the ENVIRONMENT setting at compile time (see settings.js).

var ENVIRONMENT_IS_WEB = false;
var ENVIRONMENT_IS_WORKER = false;
var ENVIRONMENT_IS_NODE = false;
var ENVIRONMENT_IS_SHELL = false;
ENVIRONMENT_IS_WEB = typeof window === 'object';
ENVIRONMENT_IS_WORKER = typeof importScripts === 'function';
// N.b. Electron.js environment is simultaneously a NODE-environment, but
// also a web environment.
ENVIRONMENT_IS_NODE = typeof process === 'object' && typeof process.versions === 'object' && typeof process.versions.node === 'string';
ENVIRONMENT_IS_SHELL = !ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_NODE && !ENVIRONMENT_IS_WORKER;

if (Module['ENVIRONMENT']) {
  throw new Error('Module.ENVIRONMENT has been deprecated. To force the environment, use the ENVIRONMENT compile-time option (for example, -s ENVIRONMENT=web or -s ENVIRONMENT=node)');
}



// `/` should be present at the end if `scriptDirectory` is not empty
var scriptDirectory = '';
function locateFile(path) {
  if (Module['locateFile']) {
    return Module['locateFile'](path, scriptDirectory);
  }
  return scriptDirectory + path;
}

// Hooks that are implemented differently in different runtime environments.
var read_,
    readAsync,
    readBinary,
    setWindowTitle;

var nodeFS;
var nodePath;

if (ENVIRONMENT_IS_NODE) {
  if (ENVIRONMENT_IS_WORKER) {
    scriptDirectory = require('path').dirname(scriptDirectory) + '/';
  } else {
    scriptDirectory = __dirname + '/';
  }


/**
 * @license
 * Copyright 2019 The Emscripten Authors
 * SPDX-License-Identifier: MIT
 */

  read_ = function shell_read(filename, binary) {
    var ret = tryParseAsDataURI(filename);
    if (ret) {
      return binary ? ret : ret.toString();
    }
    if (!nodeFS) nodeFS = require('fs');
    if (!nodePath) nodePath = require('path');
    filename = nodePath['normalize'](filename);
    return nodeFS['readFileSync'](filename, binary ? null : 'utf8');
  };

  readBinary = function readBinary(filename) {
    var ret = read_(filename, true);
    if (!ret.buffer) {
      ret = new Uint8Array(ret);
    }
    assert(ret.buffer);
    return ret;
  };




  if (process['argv'].length > 1) {
    thisProgram = process['argv'][1].replace(/\\/g, '/');
  }

  arguments_ = process['argv'].slice(2);

  // MODULARIZE will export the module in the proper place outside, we don't need to export here

  process['on']('uncaughtException', function(ex) {
    // suppress ExitStatus exceptions from showing an error
    if (!(ex instanceof ExitStatus)) {
      throw ex;
    }
  });

  process['on']('unhandledRejection', abort);

  quit_ = function(status) {
    process['exit'](status);
  };

  Module['inspect'] = function () { return '[Emscripten Module object]'; };



} else
if (ENVIRONMENT_IS_SHELL) {


  if (typeof read != 'undefined') {
    read_ = function shell_read(f) {
      var data = tryParseAsDataURI(f);
      if (data) {
        return intArrayToString(data);
      }
      return read(f);
    };
  }

  readBinary = function readBinary(f) {
    var data;
    data = tryParseAsDataURI(f);
    if (data) {
      return data;
    }
    if (typeof readbuffer === 'function') {
      return new Uint8Array(readbuffer(f));
    }
    data = read(f, 'binary');
    assert(typeof data === 'object');
    return data;
  };

  if (typeof scriptArgs != 'undefined') {
    arguments_ = scriptArgs;
  } else if (typeof arguments != 'undefined') {
    arguments_ = arguments;
  }

  if (typeof quit === 'function') {
    quit_ = function(status) {
      quit(status);
    };
  }

  if (typeof print !== 'undefined') {
    // Prefer to use print/printErr where they exist, as they usually work better.
    if (typeof console === 'undefined') console = /** @type{!Console} */({});
    console.log = /** @type{!function(this:Console, ...*): undefined} */ (print);
    console.warn = console.error = /** @type{!function(this:Console, ...*): undefined} */ (typeof printErr !== 'undefined' ? printErr : print);
  }


} else

// Note that this includes Node.js workers when relevant (pthreads is enabled).
// Node.js workers are detected as a combination of ENVIRONMENT_IS_WORKER and
// ENVIRONMENT_IS_NODE.
if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {
  if (ENVIRONMENT_IS_WORKER) { // Check worker, not web, since window could be polyfilled
    scriptDirectory = self.location.href;
  } else if (document.currentScript) { // web
    scriptDirectory = document.currentScript.src;
  }
  // When MODULARIZE, this JS may be executed later, after document.currentScript
  // is gone, so we saved it, and we use it here instead of any other info.
  if (_scriptDir) {
    scriptDirectory = _scriptDir;
  }
  // blob urls look like blob:http://site.com/etc/etc and we cannot infer anything from them.
  // otherwise, slice off the final part of the url to find the script directory.
  // if scriptDirectory does not contain a slash, lastIndexOf will return -1,
  // and scriptDirectory will correctly be replaced with an empty string.
  if (scriptDirectory.indexOf('blob:') !== 0) {
    scriptDirectory = scriptDirectory.substr(0, scriptDirectory.lastIndexOf('/')+1);
  } else {
    scriptDirectory = '';
  }


  // Differentiate the Web Worker from the Node Worker case, as reading must
  // be done differently.
  {


/**
 * @license
 * Copyright 2019 The Emscripten Authors
 * SPDX-License-Identifier: MIT
 */

  read_ = function shell_read(url) {
    try {
      var xhr = new XMLHttpRequest();
      xhr.open('GET', url, false);
      xhr.send(null);
      return xhr.responseText;
    } catch (err) {
      var data = tryParseAsDataURI(url);
      if (data) {
        return intArrayToString(data);
      }
      throw err;
    }
  };

  if (ENVIRONMENT_IS_WORKER) {
    readBinary = function readBinary(url) {
      try {
        var xhr = new XMLHttpRequest();
        xhr.open('GET', url, false);
        xhr.responseType = 'arraybuffer';
        xhr.send(null);
        return new Uint8Array(/** @type{!ArrayBuffer} */(xhr.response));
      } catch (err) {
        var data = tryParseAsDataURI(url);
        if (data) {
          return data;
        }
        throw err;
      }
    };
  }

  readAsync = function readAsync(url, onload, onerror) {
    var xhr = new XMLHttpRequest();
    xhr.open('GET', url, true);
    xhr.responseType = 'arraybuffer';
    xhr.onload = function xhr_onload() {
      if (xhr.status == 200 || (xhr.status == 0 && xhr.response)) { // file URLs can return 0
        onload(xhr.response);
        return;
      }
      var data = tryParseAsDataURI(url);
      if (data) {
        onload(data.buffer);
        return;
      }
      onerror();
    };
    xhr.onerror = onerror;
    xhr.send(null);
  };




  }

  setWindowTitle = function(title) { document.title = title };
} else
{
  throw new Error('environment detection error');
}


// Set up the out() and err() hooks, which are how we can print to stdout or
// stderr, respectively.
var out = Module['print'] || console.log.bind(console);
var err = Module['printErr'] || console.warn.bind(console);

// Merge back in the overrides
for (key in moduleOverrides) {
  if (moduleOverrides.hasOwnProperty(key)) {
    Module[key] = moduleOverrides[key];
  }
}
// Free the object hierarchy contained in the overrides, this lets the GC
// reclaim data used e.g. in memoryInitializerRequest, which is a large typed array.
moduleOverrides = null;

// Emit code to handle expected values on the Module object. This applies Module.x
// to the proper local x. This has two benefits: first, we only emit it if it is
// expected to arrive, and second, by using a local everywhere else that can be
// minified.
if (Module['arguments']) arguments_ = Module['arguments'];if (!Object.getOwnPropertyDescriptor(Module, 'arguments')) Object.defineProperty(Module, 'arguments', { configurable: true, get: function() { abort('Module.arguments has been replaced with plain arguments_') } });
if (Module['thisProgram']) thisProgram = Module['thisProgram'];if (!Object.getOwnPropertyDescriptor(Module, 'thisProgram')) Object.defineProperty(Module, 'thisProgram', { configurable: true, get: function() { abort('Module.thisProgram has been replaced with plain thisProgram') } });
if (Module['quit']) quit_ = Module['quit'];if (!Object.getOwnPropertyDescriptor(Module, 'quit')) Object.defineProperty(Module, 'quit', { configurable: true, get: function() { abort('Module.quit has been replaced with plain quit_') } });

// perform assertions in shell.js after we set up out() and err(), as otherwise if an assertion fails it cannot print the message
// Assertions on removed incoming Module JS APIs.
assert(typeof Module['memoryInitializerPrefixURL'] === 'undefined', 'Module.memoryInitializerPrefixURL option was removed, use Module.locateFile instead');
assert(typeof Module['pthreadMainPrefixURL'] === 'undefined', 'Module.pthreadMainPrefixURL option was removed, use Module.locateFile instead');
assert(typeof Module['cdInitializerPrefixURL'] === 'undefined', 'Module.cdInitializerPrefixURL option was removed, use Module.locateFile instead');
assert(typeof Module['filePackagePrefixURL'] === 'undefined', 'Module.filePackagePrefixURL option was removed, use Module.locateFile instead');
assert(typeof Module['read'] === 'undefined', 'Module.read option was removed (modify read_ in JS)');
assert(typeof Module['readAsync'] === 'undefined', 'Module.readAsync option was removed (modify readAsync in JS)');
assert(typeof Module['readBinary'] === 'undefined', 'Module.readBinary option was removed (modify readBinary in JS)');
assert(typeof Module['setWindowTitle'] === 'undefined', 'Module.setWindowTitle option was removed (modify setWindowTitle in JS)');
assert(typeof Module['TOTAL_MEMORY'] === 'undefined', 'Module.TOTAL_MEMORY has been renamed Module.INITIAL_MEMORY');
if (!Object.getOwnPropertyDescriptor(Module, 'read')) Object.defineProperty(Module, 'read', { configurable: true, get: function() { abort('Module.read has been replaced with plain read_') } });
if (!Object.getOwnPropertyDescriptor(Module, 'readAsync')) Object.defineProperty(Module, 'readAsync', { configurable: true, get: function() { abort('Module.readAsync has been replaced with plain readAsync') } });
if (!Object.getOwnPropertyDescriptor(Module, 'readBinary')) Object.defineProperty(Module, 'readBinary', { configurable: true, get: function() { abort('Module.readBinary has been replaced with plain readBinary') } });
if (!Object.getOwnPropertyDescriptor(Module, 'setWindowTitle')) Object.defineProperty(Module, 'setWindowTitle', { configurable: true, get: function() { abort('Module.setWindowTitle has been replaced with plain setWindowTitle') } });
var IDBFS = 'IDBFS is no longer included by default; build with -lidbfs.js';
var PROXYFS = 'PROXYFS is no longer included by default; build with -lproxyfs.js';
var WORKERFS = 'WORKERFS is no longer included by default; build with -lworkerfs.js';





/**
 * @license
 * Copyright 2017 The Emscripten Authors
 * SPDX-License-Identifier: MIT
 */

// {{PREAMBLE_ADDITIONS}}

var STACK_ALIGN = 16;

// stack management, and other functionality that is provided by the compiled code,
// should not be used before it is ready

/** @suppress{duplicate} */
var stackSave;
/** @suppress{duplicate} */
var stackRestore;
/** @suppress{duplicate} */
var stackAlloc;

stackSave = stackRestore = stackAlloc = function() {
  abort('cannot use the stack before compiled code is ready to run, and has provided stack access');
};

function staticAlloc(size) {
  abort('staticAlloc is no longer available at runtime; instead, perform static allocations at compile time (using makeStaticAlloc)');
}

function dynamicAlloc(size) {
  assert(DYNAMICTOP_PTR);
  var ret = HEAP32[DYNAMICTOP_PTR>>2];
  var end = (ret + size + 15) & -16;
  assert(end <= HEAP8.length, 'failure to dynamicAlloc - memory growth etc. is not supported there, call malloc/sbrk directly');
  HEAP32[DYNAMICTOP_PTR>>2] = end;
  return ret;
}

function alignMemory(size, factor) {
  if (!factor) factor = STACK_ALIGN; // stack alignment (16-byte) by default
  return Math.ceil(size / factor) * factor;
}

function getNativeTypeSize(type) {
  switch (type) {
    case 'i1': case 'i8': return 1;
    case 'i16': return 2;
    case 'i32': return 4;
    case 'i64': return 8;
    case 'float': return 4;
    case 'double': return 8;
    default: {
      if (type[type.length-1] === '*') {
        return 4; // A pointer
      } else if (type[0] === 'i') {
        var bits = Number(type.substr(1));
        assert(bits % 8 === 0, 'getNativeTypeSize invalid bits ' + bits + ', type ' + type);
        return bits / 8;
      } else {
        return 0;
      }
    }
  }
}

function warnOnce(text) {
  if (!warnOnce.shown) warnOnce.shown = {};
  if (!warnOnce.shown[text]) {
    warnOnce.shown[text] = 1;
    err(text);
  }
}





/**
 * @license
 * Copyright 2020 The Emscripten Authors
 * SPDX-License-Identifier: MIT
 */


// Wraps a JS function as a wasm function with a given signature.
function convertJsFunctionToWasm(func, sig) {

  // If the type reflection proposal is available, use the new
  // "WebAssembly.Function" constructor.
  // Otherwise, construct a minimal wasm module importing the JS function and
  // re-exporting it.
  if (typeof WebAssembly.Function === "function") {
    var typeNames = {
      'i': 'i32',
      'j': 'i64',
      'f': 'f32',
      'd': 'f64'
    };
    var type = {
      parameters: [],
      results: sig[0] == 'v' ? [] : [typeNames[sig[0]]]
    };
    for (var i = 1; i < sig.length; ++i) {
      type.parameters.push(typeNames[sig[i]]);
    }
    return new WebAssembly.Function(type, func);
  }

  // The module is static, with the exception of the type section, which is
  // generated based on the signature passed in.
  var typeSection = [
    0x01, // id: section,
    0x00, // length: 0 (placeholder)
    0x01, // count: 1
    0x60, // form: func
  ];
  var sigRet = sig.slice(0, 1);
  var sigParam = sig.slice(1);
  var typeCodes = {
    'i': 0x7f, // i32
    'j': 0x7e, // i64
    'f': 0x7d, // f32
    'd': 0x7c, // f64
  };

  // Parameters, length + signatures
  typeSection.push(sigParam.length);
  for (var i = 0; i < sigParam.length; ++i) {
    typeSection.push(typeCodes[sigParam[i]]);
  }

  // Return values, length + signatures
  // With no multi-return in MVP, either 0 (void) or 1 (anything else)
  if (sigRet == 'v') {
    typeSection.push(0x00);
  } else {
    typeSection = typeSection.concat([0x01, typeCodes[sigRet]]);
  }

  // Write the overall length of the type section back into the section header
  // (excepting the 2 bytes for the section id and length)
  typeSection[1] = typeSection.length - 2;

  // Rest of the module is static
  var bytes = new Uint8Array([
    0x00, 0x61, 0x73, 0x6d, // magic ("\0asm")
    0x01, 0x00, 0x00, 0x00, // version: 1
  ].concat(typeSection, [
    0x02, 0x07, // import section
      // (import "e" "f" (func 0 (type 0)))
      0x01, 0x01, 0x65, 0x01, 0x66, 0x00, 0x00,
    0x07, 0x05, // export section
      // (export "f" (func 0 (type 0)))
      0x01, 0x01, 0x66, 0x00, 0x00,
  ]));

   // We can compile this wasm module synchronously because it is very small.
  // This accepts an import (at "e.f"), that it reroutes to an export (at "f")
  var module = new WebAssembly.Module(bytes);
  var instance = new WebAssembly.Instance(module, {
    'e': {
      'f': func
    }
  });
  var wrappedFunc = instance.exports['f'];
  return wrappedFunc;
}

var freeTableIndexes = [];

// Weak map of functions in the table to their indexes, created on first use.
var functionsInTableMap;

// Add a wasm function to the table.
function addFunctionWasm(func, sig) {
  var table = wasmTable;

  // Check if the function is already in the table, to ensure each function
  // gets a unique index. First, create the map if this is the first use.
  if (!functionsInTableMap) {
    functionsInTableMap = new WeakMap();
    for (var i = 0; i < table.length; i++) {
      var item = table.get(i);
      // Ignore null values.
      if (item) {
        functionsInTableMap.set(item, i);
      }
    }
  }
  if (functionsInTableMap.has(func)) {
    return functionsInTableMap.get(func);
  }

  // It's not in the table, add it now.

  // Make sure functionsInTableMap is actually up to date, that is, that this
  // function is not actually in the wasm Table despite not being tracked in
  // functionsInTableMap.
  for (var i = 0; i < table.length; i++) {
    assert(table.get(i) != func, 'function in Table but not functionsInTableMap');
  }

  var ret;
  // Reuse a free index if there is one, otherwise grow.
  if (freeTableIndexes.length) {
    ret = freeTableIndexes.pop();
  } else {
    ret = table.length;
    // Grow the table
    try {
      table.grow(1);
    } catch (err) {
      if (!(err instanceof RangeError)) {
        throw err;
      }
      throw 'Unable to grow wasm table. Set ALLOW_TABLE_GROWTH.';
    }
  }

  // Set the new value.
  try {
    // Attempting to call this with JS function will cause of table.set() to fail
    table.set(ret, func);
  } catch (err) {
    if (!(err instanceof TypeError)) {
      throw err;
    }
    assert(typeof sig !== 'undefined', 'Missing signature argument to addFunction');
    var wrapped = convertJsFunctionToWasm(func, sig);
    table.set(ret, wrapped);
  }

  functionsInTableMap.set(func, ret);

  return ret;
}

function removeFunctionWasm(index) {
  functionsInTableMap.delete(wasmTable.get(index));
  freeTableIndexes.push(index);
}

// 'sig' parameter is required for the llvm backend but only when func is not
// already a WebAssembly function.
function addFunction(func, sig) {
  assert(typeof func !== 'undefined');
  if (typeof sig === 'undefined') {
    err('warning: addFunction(): You should provide a wasm function signature string as a second argument. This is not necessary for asm.js and asm2wasm, but can be required for the LLVM wasm backend, so it is recommended for full portability.');
  }

  return addFunctionWasm(func, sig);
}

function removeFunction(index) {
  removeFunctionWasm(index);
}



var funcWrappers = {};

function getFuncWrapper(func, sig) {
  if (!func) return; // on null pointer, return undefined
  assert(sig);
  if (!funcWrappers[sig]) {
    funcWrappers[sig] = {};
  }
  var sigCache = funcWrappers[sig];
  if (!sigCache[func]) {
    // optimize away arguments usage in common cases
    if (sig.length === 1) {
      sigCache[func] = function dynCall_wrapper() {
        return dynCall(sig, func);
      };
    } else if (sig.length === 2) {
      sigCache[func] = function dynCall_wrapper(arg) {
        return dynCall(sig, func, [arg]);
      };
    } else {
      // general case
      sigCache[func] = function dynCall_wrapper() {
        return dynCall(sig, func, Array.prototype.slice.call(arguments));
      };
    }
  }
  return sigCache[func];
}


/**
 * @license
 * Copyright 2020 The Emscripten Authors
 * SPDX-License-Identifier: MIT
 */




function makeBigInt(low, high, unsigned) {
  return unsigned ? ((+((low>>>0)))+((+((high>>>0)))*4294967296.0)) : ((+((low>>>0)))+((+((high|0)))*4294967296.0));
}

/** @param {Array=} args */
function dynCall(sig, ptr, args) {
  if (args && args.length) {
    // j (64-bit integer) must be passed in as two numbers [low 32, high 32].
    assert(args.length === sig.substring(1).replace(/j/g, '--').length);
    assert(('dynCall_' + sig) in Module, 'bad function pointer type - no table for sig \'' + sig + '\'');
    return Module['dynCall_' + sig].apply(null, [ptr].concat(args));
  } else {
    assert(sig.length == 1);
    assert(('dynCall_' + sig) in Module, 'bad function pointer type - no table for sig \'' + sig + '\'');
    return Module['dynCall_' + sig].call(null, ptr);
  }
}

var tempRet0 = 0;

var setTempRet0 = function(value) {
  tempRet0 = value;
};

var getTempRet0 = function() {
  return tempRet0;
};

function getCompilerSetting(name) {
  throw 'You must build with -s RETAIN_COMPILER_SETTINGS=1 for getCompilerSetting or emscripten_get_compiler_setting to work';
}

// The address globals begin at. Very low in memory, for code size and optimization opportunities.
// Above 0 is static memory, starting with globals.
// Then the stack.
// Then 'dynamic' memory for sbrk.
var GLOBAL_BASE = 1024;



/**
 * @license
 * Copyright 2010 The Emscripten Authors
 * SPDX-License-Identifier: MIT
 */

// === Preamble library stuff ===

// Documentation for the public APIs defined in this file must be updated in:
//    site/source/docs/api_reference/preamble.js.rst
// A prebuilt local version of the documentation is available at:
//    site/build/text/docs/api_reference/preamble.js.txt
// You can also build docs locally as HTML or other formats in site/
// An online HTML version (which may be of a different version of Emscripten)
//    is up at http://kripken.github.io/emscripten-site/docs/api_reference/preamble.js.html


var wasmBinary;if (Module['wasmBinary']) wasmBinary = Module['wasmBinary'];if (!Object.getOwnPropertyDescriptor(Module, 'wasmBinary')) Object.defineProperty(Module, 'wasmBinary', { configurable: true, get: function() { abort('Module.wasmBinary has been replaced with plain wasmBinary') } });
var noExitRuntime;if (Module['noExitRuntime']) noExitRuntime = Module['noExitRuntime'];if (!Object.getOwnPropertyDescriptor(Module, 'noExitRuntime')) Object.defineProperty(Module, 'noExitRuntime', { configurable: true, get: function() { abort('Module.noExitRuntime has been replaced with plain noExitRuntime') } });


if (typeof WebAssembly !== 'object') {
  abort('No WebAssembly support found. Build with -s WASM=0 to target JavaScript instead.');
}


/**
 * @license
 * Copyright 2019 The Emscripten Authors
 * SPDX-License-Identifier: MIT
 */

// In MINIMAL_RUNTIME, setValue() and getValue() are only available when building with safe heap enabled, for heap safety checking.
// In traditional runtime, setValue() and getValue() are always available (although their use is highly discouraged due to perf penalties)

/** @param {number} ptr
    @param {number} value
    @param {string} type
    @param {number|boolean=} noSafe */
function setValue(ptr, value, type, noSafe) {
  type = type || 'i8';
  if (type.charAt(type.length-1) === '*') type = 'i32'; // pointers are 32-bit
    switch(type) {
      case 'i1': HEAP8[((ptr)>>0)]=value; break;
      case 'i8': HEAP8[((ptr)>>0)]=value; break;
      case 'i16': HEAP16[((ptr)>>1)]=value; break;
      case 'i32': HEAP32[((ptr)>>2)]=value; break;
      case 'i64': (tempI64 = [value>>>0,(tempDouble=value,(+(Math_abs(tempDouble))) >= 1.0 ? (tempDouble > 0.0 ? ((Math_min((+(Math_floor((tempDouble)/4294967296.0))), 4294967295.0))|0)>>>0 : (~~((+(Math_ceil((tempDouble - +(((~~(tempDouble)))>>>0))/4294967296.0)))))>>>0) : 0)],HEAP32[((ptr)>>2)]=tempI64[0],HEAP32[(((ptr)+(4))>>2)]=tempI64[1]); break;
      case 'float': HEAPF32[((ptr)>>2)]=value; break;
      case 'double': HEAPF64[((ptr)>>3)]=value; break;
      default: abort('invalid type for setValue: ' + type);
    }
}

/** @param {number} ptr
    @param {string} type
    @param {number|boolean=} noSafe */
function getValue(ptr, type, noSafe) {
  type = type || 'i8';
  if (type.charAt(type.length-1) === '*') type = 'i32'; // pointers are 32-bit
    switch(type) {
      case 'i1': return HEAP8[((ptr)>>0)];
      case 'i8': return HEAP8[((ptr)>>0)];
      case 'i16': return HEAP16[((ptr)>>1)];
      case 'i32': return HEAP32[((ptr)>>2)];
      case 'i64': return HEAP32[((ptr)>>2)];
      case 'float': return HEAPF32[((ptr)>>2)];
      case 'double': return HEAPF64[((ptr)>>3)];
      default: abort('invalid type for getValue: ' + type);
    }
  return null;
}





// Wasm globals

var wasmMemory;

// In fastcomp asm.js, we don't need a wasm Table at all.
// In the wasm backend, we polyfill the WebAssembly object,
// so this creates a (non-native-wasm) table for us.
var wasmTable = new WebAssembly.Table({
  'initial': 444,
  'maximum': 444 + 0,
  'element': 'anyfunc'
});


//========================================
// Runtime essentials
//========================================

// whether we are quitting the application. no code should run after this.
// set in exit() and abort()
var ABORT = false;

// set by exit() and abort().  Passed to 'onExit' handler.
// NOTE: This is also used as the process return code code in shell environments
// but only when noExitRuntime is false.
var EXITSTATUS = 0;

/** @type {function(*, string=)} */
function assert(condition, text) {
  if (!condition) {
    abort('Assertion failed: ' + text);
  }
}

// Returns the C function with a specified identifier (for C++, you need to do manual name mangling)
function getCFunc(ident) {
  var func = Module['_' + ident]; // closure exported function
  assert(func, 'Cannot call unknown function ' + ident + ', make sure it is exported');
  return func;
}

// C calling interface.
/** @param {string|null=} returnType
    @param {Array=} argTypes
    @param {Arguments|Array=} args
    @param {Object=} opts */
function ccall(ident, returnType, argTypes, args, opts) {
  // For fast lookup of conversion functions
  var toC = {
    'string': function(str) {
      var ret = 0;
      if (str !== null && str !== undefined && str !== 0) { // null string
        // at most 4 bytes per UTF-8 code point, +1 for the trailing '\0'
        var len = (str.length << 2) + 1;
        ret = stackAlloc(len);
        stringToUTF8(str, ret, len);
      }
      return ret;
    },
    'array': function(arr) {
      var ret = stackAlloc(arr.length);
      writeArrayToMemory(arr, ret);
      return ret;
    }
  };

  function convertReturnValue(ret) {
    if (returnType === 'string') return UTF8ToString(ret);
    if (returnType === 'boolean') return Boolean(ret);
    return ret;
  }

  var func = getCFunc(ident);
  var cArgs = [];
  var stack = 0;
  assert(returnType !== 'array', 'Return type should not be "array".');
  if (args) {
    for (var i = 0; i < args.length; i++) {
      var converter = toC[argTypes[i]];
      if (converter) {
        if (stack === 0) stack = stackSave();
        cArgs[i] = converter(args[i]);
      } else {
        cArgs[i] = args[i];
      }
    }
  }
  var ret = func.apply(null, cArgs);

  ret = convertReturnValue(ret);
  if (stack !== 0) stackRestore(stack);
  return ret;
}

/** @param {string=} returnType
    @param {Array=} argTypes
    @param {Object=} opts */
function cwrap(ident, returnType, argTypes, opts) {
  return function() {
    return ccall(ident, returnType, argTypes, arguments, opts);
  }
}

var ALLOC_NORMAL = 0; // Tries to use _malloc()
var ALLOC_STACK = 1; // Lives for the duration of the current function call
var ALLOC_DYNAMIC = 2; // Cannot be freed except through sbrk
var ALLOC_NONE = 3; // Do not allocate

// allocate(): This is for internal use. You can use it yourself as well, but the interface
//             is a little tricky (see docs right below). The reason is that it is optimized
//             for multiple syntaxes to save space in generated code. So you should
//             normally not use allocate(), and instead allocate memory using _malloc(),
//             initialize it with setValue(), and so forth.
// @slab: An array of data, or a number. If a number, then the size of the block to allocate,
//        in *bytes* (note that this is sometimes confusing: the next parameter does not
//        affect this!)
// @types: Either an array of types, one for each byte (or 0 if no type at that position),
//         or a single type which is used for the entire block. This only matters if there
//         is initial data - if @slab is a number, then this does not matter at all and is
//         ignored.
// @allocator: How to allocate memory, see ALLOC_*
/** @type {function((TypedArray|Array<number>|number), string, number, number=)} */
function allocate(slab, types, allocator, ptr) {
  var zeroinit, size;
  if (typeof slab === 'number') {
    zeroinit = true;
    size = slab;
  } else {
    zeroinit = false;
    size = slab.length;
  }

  var singleType = typeof types === 'string' ? types : null;

  var ret;
  if (allocator == ALLOC_NONE) {
    ret = ptr;
  } else {
    ret = [_malloc,
    stackAlloc,
    dynamicAlloc][allocator](Math.max(size, singleType ? 1 : types.length));
  }

  if (zeroinit) {
    var stop;
    ptr = ret;
    assert((ret & 3) == 0);
    stop = ret + (size & ~3);
    for (; ptr < stop; ptr += 4) {
      HEAP32[((ptr)>>2)]=0;
    }
    stop = ret + size;
    while (ptr < stop) {
      HEAP8[((ptr++)>>0)]=0;
    }
    return ret;
  }

  if (singleType === 'i8') {
    if (slab.subarray || slab.slice) {
      HEAPU8.set(/** @type {!Uint8Array} */ (slab), ret);
    } else {
      HEAPU8.set(new Uint8Array(slab), ret);
    }
    return ret;
  }

  var i = 0, type, typeSize, previousType;
  while (i < size) {
    var curr = slab[i];

    type = singleType || types[i];
    if (type === 0) {
      i++;
      continue;
    }
    assert(type, 'Must know what type to store in allocate!');

    if (type == 'i64') type = 'i32'; // special case: we have one i32 here, and one i32 later

    setValue(ret+i, curr, type);

    // no need to look up size unless type changes, so cache it
    if (previousType !== type) {
      typeSize = getNativeTypeSize(type);
      previousType = type;
    }
    i += typeSize;
  }

  return ret;
}

// Allocate memory during any stage of startup - static memory early on, dynamic memory later, malloc when ready
function getMemory(size) {
  if (!runtimeInitialized) return dynamicAlloc(size);
  return _malloc(size);
}


/**
 * @license
 * Copyright 2019 The Emscripten Authors
 * SPDX-License-Identifier: MIT
 */

// runtime_strings.js: Strings related runtime functions that are part of both MINIMAL_RUNTIME and regular runtime.

// Given a pointer 'ptr' to a null-terminated UTF8-encoded string in the given array that contains uint8 values, returns
// a copy of that string as a Javascript String object.

var UTF8Decoder = typeof TextDecoder !== 'undefined' ? new TextDecoder('utf8') : undefined;

/**
 * @param {number} idx
 * @param {number=} maxBytesToRead
 * @return {string}
 */
function UTF8ArrayToString(heap, idx, maxBytesToRead) {
  var endIdx = idx + maxBytesToRead;
  var endPtr = idx;
  // TextDecoder needs to know the byte length in advance, it doesn't stop on null terminator by itself.
  // Also, use the length info to avoid running tiny strings through TextDecoder, since .subarray() allocates garbage.
  // (As a tiny code save trick, compare endPtr against endIdx using a negation, so that undefined means Infinity)
  while (heap[endPtr] && !(endPtr >= endIdx)) ++endPtr;

  if (endPtr - idx > 16 && heap.subarray && UTF8Decoder) {
    return UTF8Decoder.decode(heap.subarray(idx, endPtr));
  } else {
    var str = '';
    // If building with TextDecoder, we have already computed the string length above, so test loop end condition against that
    while (idx < endPtr) {
      // For UTF8 byte structure, see:
      // http://en.wikipedia.org/wiki/UTF-8#Description
      // https://www.ietf.org/rfc/rfc2279.txt
      // https://tools.ietf.org/html/rfc3629
      var u0 = heap[idx++];
      if (!(u0 & 0x80)) { str += String.fromCharCode(u0); continue; }
      var u1 = heap[idx++] & 63;
      if ((u0 & 0xE0) == 0xC0) { str += String.fromCharCode(((u0 & 31) << 6) | u1); continue; }
      var u2 = heap[idx++] & 63;
      if ((u0 & 0xF0) == 0xE0) {
        u0 = ((u0 & 15) << 12) | (u1 << 6) | u2;
      } else {
        if ((u0 & 0xF8) != 0xF0) warnOnce('Invalid UTF-8 leading byte 0x' + u0.toString(16) + ' encountered when deserializing a UTF-8 string on the asm.js/wasm heap to a JS string!');
        u0 = ((u0 & 7) << 18) | (u1 << 12) | (u2 << 6) | (heap[idx++] & 63);
      }

      if (u0 < 0x10000) {
        str += String.fromCharCode(u0);
      } else {
        var ch = u0 - 0x10000;
        str += String.fromCharCode(0xD800 | (ch >> 10), 0xDC00 | (ch & 0x3FF));
      }
    }
  }
  return str;
}

// Given a pointer 'ptr' to a null-terminated UTF8-encoded string in the emscripten HEAP, returns a
// copy of that string as a Javascript String object.
// maxBytesToRead: an optional length that specifies the maximum number of bytes to read. You can omit
//                 this parameter to scan the string until the first \0 byte. If maxBytesToRead is
//                 passed, and the string at [ptr, ptr+maxBytesToReadr[ contains a null byte in the
//                 middle, then the string will cut short at that byte index (i.e. maxBytesToRead will
//                 not produce a string of exact length [ptr, ptr+maxBytesToRead[)
//                 N.B. mixing frequent uses of UTF8ToString() with and without maxBytesToRead may
//                 throw JS JIT optimizations off, so it is worth to consider consistently using one
//                 style or the other.
/**
 * @param {number} ptr
 * @param {number=} maxBytesToRead
 * @return {string}
 */
function UTF8ToString(ptr, maxBytesToRead) {
  return ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : '';
}

// Copies the given Javascript String object 'str' to the given byte array at address 'outIdx',
// encoded in UTF8 form and null-terminated. The copy will require at most str.length*4+1 bytes of space in the HEAP.
// Use the function lengthBytesUTF8 to compute the exact number of bytes (excluding null terminator) that this function will write.
// Parameters:
//   str: the Javascript string to copy.
//   heap: the array to copy to. Each index in this array is assumed to be one 8-byte element.
//   outIdx: The starting offset in the array to begin the copying.
//   maxBytesToWrite: The maximum number of bytes this function can write to the array.
//                    This count should include the null terminator,
//                    i.e. if maxBytesToWrite=1, only the null terminator will be written and nothing else.
//                    maxBytesToWrite=0 does not write any bytes to the output, not even the null terminator.
// Returns the number of bytes written, EXCLUDING the null terminator.

function stringToUTF8Array(str, heap, outIdx, maxBytesToWrite) {
  if (!(maxBytesToWrite > 0)) // Parameter maxBytesToWrite is not optional. Negative values, 0, null, undefined and false each don't write out any bytes.
    return 0;

  var startIdx = outIdx;
  var endIdx = outIdx + maxBytesToWrite - 1; // -1 for string null terminator.
  for (var i = 0; i < str.length; ++i) {
    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! So decode UTF16->UTF32->UTF8.
    // See http://unicode.org/faq/utf_bom.html#utf16-3
    // For UTF8 byte structure, see http://en.wikipedia.org/wiki/UTF-8#Description and https://www.ietf.org/rfc/rfc2279.txt and https://tools.ietf.org/html/rfc3629
    var u = str.charCodeAt(i); // possibly a lead surrogate
    if (u >= 0xD800 && u <= 0xDFFF) {
      var u1 = str.charCodeAt(++i);
      u = 0x10000 + ((u & 0x3FF) << 10) | (u1 & 0x3FF);
    }
    if (u <= 0x7F) {
      if (outIdx >= endIdx) break;
      heap[outIdx++] = u;
    } else if (u <= 0x7FF) {
      if (outIdx + 1 >= endIdx) break;
      heap[outIdx++] = 0xC0 | (u >> 6);
      heap[outIdx++] = 0x80 | (u & 63);
    } else if (u <= 0xFFFF) {
      if (outIdx + 2 >= endIdx) break;
      heap[outIdx++] = 0xE0 | (u >> 12);
      heap[outIdx++] = 0x80 | ((u >> 6) & 63);
      heap[outIdx++] = 0x80 | (u & 63);
    } else {
      if (outIdx + 3 >= endIdx) break;
      if (u >= 0x200000) warnOnce('Invalid Unicode code point 0x' + u.toString(16) + ' encountered when serializing a JS string to an UTF-8 string on the asm.js/wasm heap! (Valid unicode code points should be in range 0-0x1FFFFF).');
      heap[outIdx++] = 0xF0 | (u >> 18);
      heap[outIdx++] = 0x80 | ((u >> 12) & 63);
      heap[outIdx++] = 0x80 | ((u >> 6) & 63);
      heap[outIdx++] = 0x80 | (u & 63);
    }
  }
  // Null-terminate the pointer to the buffer.
  heap[outIdx] = 0;
  return outIdx - startIdx;
}

// Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',
// null-terminated and encoded in UTF8 form. The copy will require at most str.length*4+1 bytes of space in the HEAP.
// Use the function lengthBytesUTF8 to compute the exact number of bytes (excluding null terminator) that this function will write.
// Returns the number of bytes written, EXCLUDING the null terminator.

function stringToUTF8(str, outPtr, maxBytesToWrite) {
  assert(typeof maxBytesToWrite == 'number', 'stringToUTF8(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!');
  return stringToUTF8Array(str, HEAPU8,outPtr, maxBytesToWrite);
}

// Returns the number of bytes the given Javascript string takes if encoded as a UTF8 byte array, EXCLUDING the null terminator byte.
function lengthBytesUTF8(str) {
  var len = 0;
  for (var i = 0; i < str.length; ++i) {
    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! So decode UTF16->UTF32->UTF8.
    // See http://unicode.org/faq/utf_bom.html#utf16-3
    var u = str.charCodeAt(i); // possibly a lead surrogate
    if (u >= 0xD800 && u <= 0xDFFF) u = 0x10000 + ((u & 0x3FF) << 10) | (str.charCodeAt(++i) & 0x3FF);
    if (u <= 0x7F) ++len;
    else if (u <= 0x7FF) len += 2;
    else if (u <= 0xFFFF) len += 3;
    else len += 4;
  }
  return len;
}



/**
 * @license
 * Copyright 2020 The Emscripten Authors
 * SPDX-License-Identifier: MIT
 */

// runtime_strings_extra.js: Strings related runtime functions that are available only in regular runtime.

// Given a pointer 'ptr' to a null-terminated ASCII-encoded string in the emscripten HEAP, returns
// a copy of that string as a Javascript String object.

function AsciiToString(ptr) {
  var str = '';
  while (1) {
    var ch = HEAPU8[((ptr++)>>0)];
    if (!ch) return str;
    str += String.fromCharCode(ch);
  }
}

// Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',
// null-terminated and encoded in ASCII form. The copy will require at most str.length+1 bytes of space in the HEAP.

function stringToAscii(str, outPtr) {
  return writeAsciiToMemory(str, outPtr, false);
}

// Given a pointer 'ptr' to a null-terminated UTF16LE-encoded string in the emscripten HEAP, returns
// a copy of that string as a Javascript String object.

var UTF16Decoder = typeof TextDecoder !== 'undefined' ? new TextDecoder('utf-16le') : undefined;

function UTF16ToString(ptr) {
  assert(ptr % 2 == 0, 'Pointer passed to UTF16ToString must be aligned to two bytes!');
  var endPtr = ptr;
  // TextDecoder needs to know the byte length in advance, it doesn't stop on null terminator by itself.
  // Also, use the length info to avoid running tiny strings through TextDecoder, since .subarray() allocates garbage.
  var idx = endPtr >> 1;
  while (HEAP16[idx]) ++idx;
  endPtr = idx << 1;

  if (endPtr - ptr > 32 && UTF16Decoder) {
    return UTF16Decoder.decode(HEAPU8.subarray(ptr, endPtr));
  } else {
    var i = 0;

    var str = '';
    while (1) {
      var codeUnit = HEAP16[(((ptr)+(i*2))>>1)];
      if (codeUnit == 0) return str;
      ++i;
      // fromCharCode constructs a character from a UTF-16 code unit, so we can pass the UTF16 string right through.
      str += String.fromCharCode(codeUnit);
    }
  }
}

// Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',
// null-terminated and encoded in UTF16 form. The copy will require at most str.length*4+2 bytes of space in the HEAP.
// Use the function lengthBytesUTF16() to compute the exact number of bytes (excluding null terminator) that this function will write.
// Parameters:
//   str: the Javascript string to copy.
//   outPtr: Byte address in Emscripten HEAP where to write the string to.
//   maxBytesToWrite: The maximum number of bytes this function can write to the array. This count should include the null
//                    terminator, i.e. if maxBytesToWrite=2, only the null terminator will be written and nothing else.
//                    maxBytesToWrite<2 does not write any bytes to the output, not even the null terminator.
// Returns the number of bytes written, EXCLUDING the null terminator.

function stringToUTF16(str, outPtr, maxBytesToWrite) {
  assert(outPtr % 2 == 0, 'Pointer passed to stringToUTF16 must be aligned to two bytes!');
  assert(typeof maxBytesToWrite == 'number', 'stringToUTF16(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!');
  // Backwards compatibility: if max bytes is not specified, assume unsafe unbounded write is allowed.
  if (maxBytesToWrite === undefined) {
    maxBytesToWrite = 0x7FFFFFFF;
  }
  if (maxBytesToWrite < 2) return 0;
  maxBytesToWrite -= 2; // Null terminator.
  var startPtr = outPtr;
  var numCharsToWrite = (maxBytesToWrite < str.length*2) ? (maxBytesToWrite / 2) : str.length;
  for (var i = 0; i < numCharsToWrite; ++i) {
    // charCodeAt returns a UTF-16 encoded code unit, so it can be directly written to the HEAP.
    var codeUnit = str.charCodeAt(i); // possibly a lead surrogate
    HEAP16[((outPtr)>>1)]=codeUnit;
    outPtr += 2;
  }
  // Null-terminate the pointer to the HEAP.
  HEAP16[((outPtr)>>1)]=0;
  return outPtr - startPtr;
}

// Returns the number of bytes the given Javascript string takes if encoded as a UTF16 byte array, EXCLUDING the null terminator byte.

function lengthBytesUTF16(str) {
  return str.length*2;
}

function UTF32ToString(ptr) {
  assert(ptr % 4 == 0, 'Pointer passed to UTF32ToString must be aligned to four bytes!');
  var i = 0;

  var str = '';
  while (1) {
    var utf32 = HEAP32[(((ptr)+(i*4))>>2)];
    if (utf32 == 0) return str;
    ++i;
    // Gotcha: fromCharCode constructs a character from a UTF-16 encoded code (pair), not from a Unicode code point! So encode the code point to UTF-16 for constructing.
    // See http://unicode.org/faq/utf_bom.html#utf16-3
    if (utf32 >= 0x10000) {
      var ch = utf32 - 0x10000;
      str += String.fromCharCode(0xD800 | (ch >> 10), 0xDC00 | (ch & 0x3FF));
    } else {
      str += String.fromCharCode(utf32);
    }
  }
}

// Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',
// null-terminated and encoded in UTF32 form. The copy will require at most str.length*4+4 bytes of space in the HEAP.
// Use the function lengthBytesUTF32() to compute the exact number of bytes (excluding null terminator) that this function will write.
// Parameters:
//   str: the Javascript string to copy.
//   outPtr: Byte address in Emscripten HEAP where to write the string to.
//   maxBytesToWrite: The maximum number of bytes this function can write to the array. This count should include the null
//                    terminator, i.e. if maxBytesToWrite=4, only the null terminator will be written and nothing else.
//                    maxBytesToWrite<4 does not write any bytes to the output, not even the null terminator.
// Returns the number of bytes written, EXCLUDING the null terminator.

function stringToUTF32(str, outPtr, maxBytesToWrite) {
  assert(outPtr % 4 == 0, 'Pointer passed to stringToUTF32 must be aligned to four bytes!');
  assert(typeof maxBytesToWrite == 'number', 'stringToUTF32(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!');
  // Backwards compatibility: if max bytes is not specified, assume unsafe unbounded write is allowed.
  if (maxBytesToWrite === undefined) {
    maxBytesToWrite = 0x7FFFFFFF;
  }
  if (maxBytesToWrite < 4) return 0;
  var startPtr = outPtr;
  var endPtr = startPtr + maxBytesToWrite - 4;
  for (var i = 0; i < str.length; ++i) {
    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! We must decode the string to UTF-32 to the heap.
    // See http://unicode.org/faq/utf_bom.html#utf16-3
    var codeUnit = str.charCodeAt(i); // possibly a lead surrogate
    if (codeUnit >= 0xD800 && codeUnit <= 0xDFFF) {
      var trailSurrogate = str.charCodeAt(++i);
      codeUnit = 0x10000 + ((codeUnit & 0x3FF) << 10) | (trailSurrogate & 0x3FF);
    }
    HEAP32[((outPtr)>>2)]=codeUnit;
    outPtr += 4;
    if (outPtr + 4 > endPtr) break;
  }
  // Null-terminate the pointer to the HEAP.
  HEAP32[((outPtr)>>2)]=0;
  return outPtr - startPtr;
}

// Returns the number of bytes the given Javascript string takes if encoded as a UTF16 byte array, EXCLUDING the null terminator byte.

function lengthBytesUTF32(str) {
  var len = 0;
  for (var i = 0; i < str.length; ++i) {
    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! We must decode the string to UTF-32 to the heap.
    // See http://unicode.org/faq/utf_bom.html#utf16-3
    var codeUnit = str.charCodeAt(i);
    if (codeUnit >= 0xD800 && codeUnit <= 0xDFFF) ++i; // possibly a lead surrogate, so skip over the tail surrogate.
    len += 4;
  }

  return len;
}

// Allocate heap space for a JS string, and write it there.
// It is the responsibility of the caller to free() that memory.
function allocateUTF8(str) {
  var size = lengthBytesUTF8(str) + 1;
  var ret = _malloc(size);
  if (ret) stringToUTF8Array(str, HEAP8, ret, size);
  return ret;
}

// Allocate stack space for a JS string, and write it there.
function allocateUTF8OnStack(str) {
  var size = lengthBytesUTF8(str) + 1;
  var ret = stackAlloc(size);
  stringToUTF8Array(str, HEAP8, ret, size);
  return ret;
}

// Deprecated: This function should not be called because it is unsafe and does not provide
// a maximum length limit of how many bytes it is allowed to write. Prefer calling the
// function stringToUTF8Array() instead, which takes in a maximum length that can be used
// to be secure from out of bounds writes.
/** @deprecated
    @param {boolean=} dontAddNull */
function writeStringToMemory(string, buffer, dontAddNull) {
  warnOnce('writeStringToMemory is deprecated and should not be called! Use stringToUTF8() instead!');

  var /** @type {number} */ lastChar, /** @type {number} */ end;
  if (dontAddNull) {
    // stringToUTF8Array always appends null. If we don't want to do that, remember the
    // character that existed at the location where the null will be placed, and restore
    // that after the write (below).
    end = buffer + lengthBytesUTF8(string);
    lastChar = HEAP8[end];
  }
  stringToUTF8(string, buffer, Infinity);
  if (dontAddNull) HEAP8[end] = lastChar; // Restore the value under the null character.
}

function writeArrayToMemory(array, buffer) {
  assert(array.length >= 0, 'writeArrayToMemory array must have a length (should be an array or typed array)')
  HEAP8.set(array, buffer);
}

/** @param {boolean=} dontAddNull */
function writeAsciiToMemory(str, buffer, dontAddNull) {
  for (var i = 0; i < str.length; ++i) {
    assert(str.charCodeAt(i) === str.charCodeAt(i)&0xff);
    HEAP8[((buffer++)>>0)]=str.charCodeAt(i);
  }
  // Null-terminate the pointer to the HEAP.
  if (!dontAddNull) HEAP8[((buffer)>>0)]=0;
}



// Memory management

var PAGE_SIZE = 16384;
var WASM_PAGE_SIZE = 65536;
var ASMJS_PAGE_SIZE = 16777216;

function alignUp(x, multiple) {
  if (x % multiple > 0) {
    x += multiple - (x % multiple);
  }
  return x;
}

var HEAP,
/** @type {ArrayBuffer} */
  buffer,
/** @type {Int8Array} */
  HEAP8,
/** @type {Uint8Array} */
  HEAPU8,
/** @type {Int16Array} */
  HEAP16,
/** @type {Uint16Array} */
  HEAPU16,
/** @type {Int32Array} */
  HEAP32,
/** @type {Uint32Array} */
  HEAPU32,
/** @type {Float32Array} */
  HEAPF32,
/** @type {Float64Array} */
  HEAPF64;

function updateGlobalBufferAndViews(buf) {
  buffer = buf;
  Module['HEAP8'] = HEAP8 = new Int8Array(buf);
  Module['HEAP16'] = HEAP16 = new Int16Array(buf);
  Module['HEAP32'] = HEAP32 = new Int32Array(buf);
  Module['HEAPU8'] = HEAPU8 = new Uint8Array(buf);
  Module['HEAPU16'] = HEAPU16 = new Uint16Array(buf);
  Module['HEAPU32'] = HEAPU32 = new Uint32Array(buf);
  Module['HEAPF32'] = HEAPF32 = new Float32Array(buf);
  Module['HEAPF64'] = HEAPF64 = new Float64Array(buf);
}

var STATIC_BASE = 1024,
    STACK_BASE = 5313648,
    STACKTOP = STACK_BASE,
    STACK_MAX = 70768,
    DYNAMIC_BASE = 5313648,
    DYNAMICTOP_PTR = 70608;

assert(STACK_BASE % 16 === 0, 'stack must start aligned');
assert(DYNAMIC_BASE % 16 === 0, 'heap must start aligned');



var TOTAL_STACK = 5242880;
if (Module['TOTAL_STACK']) assert(TOTAL_STACK === Module['TOTAL_STACK'], 'the stack size can no longer be determined at runtime')

var INITIAL_INITIAL_MEMORY = Module['INITIAL_MEMORY'] || 16777216;if (!Object.getOwnPropertyDescriptor(Module, 'INITIAL_MEMORY')) Object.defineProperty(Module, 'INITIAL_MEMORY', { configurable: true, get: function() { abort('Module.INITIAL_MEMORY has been replaced with plain INITIAL_INITIAL_MEMORY') } });

assert(INITIAL_INITIAL_MEMORY >= TOTAL_STACK, 'INITIAL_MEMORY should be larger than TOTAL_STACK, was ' + INITIAL_INITIAL_MEMORY + '! (TOTAL_STACK=' + TOTAL_STACK + ')');

// check for full engine support (use string 'subarray' to avoid closure compiler confusion)
assert(typeof Int32Array !== 'undefined' && typeof Float64Array !== 'undefined' && Int32Array.prototype.subarray !== undefined && Int32Array.prototype.set !== undefined,
       'JS engine does not provide full typed array support');



/**
 * @license
 * Copyright 2019 The Emscripten Authors
 * SPDX-License-Identifier: MIT
 */




// In standalone mode, the wasm creates the memory, and the user can't provide it.
// In non-standalone/normal mode, we create the memory here.

/**
 * @license
 * Copyright 2019 The Emscripten Authors
 * SPDX-License-Identifier: MIT
 */

// Create the main memory. (Note: this isn't used in STANDALONE_WASM mode since the wasm
// memory is created in the wasm, not in JS.)

  if (Module['wasmMemory']) {
    wasmMemory = Module['wasmMemory'];
  } else
  {
    wasmMemory = new WebAssembly.Memory({
      'initial': INITIAL_INITIAL_MEMORY / WASM_PAGE_SIZE
      ,
      'maximum': 2147483648 / WASM_PAGE_SIZE
    });
  }


if (wasmMemory) {
  buffer = wasmMemory.buffer;
}

// If the user provides an incorrect length, just use that length instead rather than providing the user to
// specifically provide the memory length with Module['INITIAL_MEMORY'].
INITIAL_INITIAL_MEMORY = buffer.byteLength;
assert(INITIAL_INITIAL_MEMORY % WASM_PAGE_SIZE === 0);
assert(65536 % WASM_PAGE_SIZE === 0);
updateGlobalBufferAndViews(buffer);

HEAP32[DYNAMICTOP_PTR>>2] = DYNAMIC_BASE;




/**
 * @license
 * Copyright 2019 The Emscripten Authors
 * SPDX-License-Identifier: MIT
 */

// Initializes the stack cookie. Called at the startup of main and at the startup of each thread in pthreads mode.
function writeStackCookie() {
  assert((STACK_MAX & 3) == 0);
  // The stack grows downwards
  HEAPU32[(STACK_MAX >> 2)+1] = 0x2135467;
  HEAPU32[(STACK_MAX >> 2)+2] = 0x89BACDFE;
  // Also test the global address 0 for integrity.
  // We don't do this with ASan because ASan does its own checks for this.
  HEAP32[0] = 0x63736d65; /* 'emsc' */
}

function checkStackCookie() {
  var cookie1 = HEAPU32[(STACK_MAX >> 2)+1];
  var cookie2 = HEAPU32[(STACK_MAX >> 2)+2];
  if (cookie1 != 0x2135467 || cookie2 != 0x89BACDFE) {
    abort('Stack overflow! Stack cookie has been overwritten, expected hex dwords 0x89BACDFE and 0x2135467, but received 0x' + cookie2.toString(16) + ' ' + cookie1.toString(16));
  }
  // Also test the global address 0 for integrity.
  // We don't do this with ASan because ASan does its own checks for this.
  if (HEAP32[0] !== 0x63736d65 /* 'emsc' */) abort('Runtime error: The application has corrupted its heap memory area (address zero)!');
}

function abortStackOverflow(allocSize) {
  abort('Stack overflow! Attempted to allocate ' + allocSize + ' bytes on the stack, but stack has only ' + (STACK_MAX - stackSave() + allocSize) + ' bytes available!');
}




/**
 * @license
 * Copyright 2019 The Emscripten Authors
 * SPDX-License-Identifier: MIT
 */

// Endianness check (note: assumes compiler arch was little-endian)
(function() {
  var h16 = new Int16Array(1);
  var h8 = new Int8Array(h16.buffer);
  h16[0] = 0x6373;
  if (h8[0] !== 0x73 || h8[1] !== 0x63) throw 'Runtime error: expected the system to be little-endian!';
})();

function abortFnPtrError(ptr, sig) {
	var possibleSig = '';
	for(var x in debug_tables) {
		var tbl = debug_tables[x];
		if (tbl[ptr]) {
			possibleSig += 'as sig "' + x + '" pointing to function ' + tbl[ptr] + ', ';
		}
	}
	abort("Invalid function pointer " + ptr + " called with signature '" + sig + "'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this). This pointer might make sense in another type signature: " + possibleSig);
}



function callRuntimeCallbacks(callbacks) {
  while(callbacks.length > 0) {
    var callback = callbacks.shift();
    if (typeof callback == 'function') {
      callback(Module); // Pass the module as the first argument.
      continue;
    }
    var func = callback.func;
    if (typeof func === 'number') {
      if (callback.arg === undefined) {
        Module['dynCall_v'](func);
      } else {
        Module['dynCall_vi'](func, callback.arg);
      }
    } else {
      func(callback.arg === undefined ? null : callback.arg);
    }
  }
}

var __ATPRERUN__  = []; // functions called before the runtime is initialized
var __ATINIT__    = []; // functions called during startup
var __ATMAIN__    = []; // functions called when main() is to be run
var __ATEXIT__    = []; // functions called during shutdown
var __ATPOSTRUN__ = []; // functions called after the main() is called

var runtimeInitialized = false;
var runtimeExited = false;


function preRun() {

  if (Module['preRun']) {
    if (typeof Module['preRun'] == 'function') Module['preRun'] = [Module['preRun']];
    while (Module['preRun'].length) {
      addOnPreRun(Module['preRun'].shift());
    }
  }

  callRuntimeCallbacks(__ATPRERUN__);
}

function initRuntime() {
  checkStackCookie();
  assert(!runtimeInitialized);
  runtimeInitialized = true;
  if (!Module["noFSInit"] && !FS.init.initialized) FS.init();
TTY.init();
  callRuntimeCallbacks(__ATINIT__);
}

function preMain() {
  checkStackCookie();
  FS.ignorePermissions = false;
  callRuntimeCallbacks(__ATMAIN__);
}

function exitRuntime() {
  checkStackCookie();
  runtimeExited = true;
}

function postRun() {
  checkStackCookie();

  if (Module['postRun']) {
    if (typeof Module['postRun'] == 'function') Module['postRun'] = [Module['postRun']];
    while (Module['postRun'].length) {
      addOnPostRun(Module['postRun'].shift());
    }
  }

  callRuntimeCallbacks(__ATPOSTRUN__);
}

function addOnPreRun(cb) {
  __ATPRERUN__.unshift(cb);
}

function addOnInit(cb) {
  __ATINIT__.unshift(cb);
}

function addOnPreMain(cb) {
  __ATMAIN__.unshift(cb);
}

function addOnExit(cb) {
}

function addOnPostRun(cb) {
  __ATPOSTRUN__.unshift(cb);
}

/** @param {number|boolean=} ignore */
function unSign(value, bits, ignore) {
  if (value >= 0) {
    return value;
  }
  return bits <= 32 ? 2*Math.abs(1 << (bits-1)) + value // Need some trickery, since if bits == 32, we are right at the limit of the bits JS uses in bitshifts
                    : Math.pow(2, bits)         + value;
}
/** @param {number|boolean=} ignore */
function reSign(value, bits, ignore) {
  if (value <= 0) {
    return value;
  }
  var half = bits <= 32 ? Math.abs(1 << (bits-1)) // abs is needed if bits == 32
                        : Math.pow(2, bits-1);
  if (value >= half && (bits <= 32 || value > half)) { // for huge values, we can hit the precision limit and always get true here. so don't do that
                                                       // but, in general there is no perfect solution here. With 64-bit ints, we get rounding and errors
                                                       // TODO: In i64 mode 1, resign the two parts separately and safely
    value = -2*half + value; // Cannot bitshift half, as it may be at the limit of the bits JS uses in bitshifts
  }
  return value;
}


/**
 * @license
 * Copyright 2019 The Emscripten Authors
 * SPDX-License-Identifier: MIT
 */

// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/imul

// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/fround

// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/clz32

// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/trunc

assert(Math.imul, 'This browser does not support Math.imul(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill');
assert(Math.fround, 'This browser does not support Math.fround(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill');
assert(Math.clz32, 'This browser does not support Math.clz32(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill');
assert(Math.trunc, 'This browser does not support Math.trunc(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill');

var Math_abs = Math.abs;
var Math_cos = Math.cos;
var Math_sin = Math.sin;
var Math_tan = Math.tan;
var Math_acos = Math.acos;
var Math_asin = Math.asin;
var Math_atan = Math.atan;
var Math_atan2 = Math.atan2;
var Math_exp = Math.exp;
var Math_log = Math.log;
var Math_sqrt = Math.sqrt;
var Math_ceil = Math.ceil;
var Math_floor = Math.floor;
var Math_pow = Math.pow;
var Math_imul = Math.imul;
var Math_fround = Math.fround;
var Math_round = Math.round;
var Math_min = Math.min;
var Math_max = Math.max;
var Math_clz32 = Math.clz32;
var Math_trunc = Math.trunc;



// A counter of dependencies for calling run(). If we need to
// do asynchronous work before running, increment this and
// decrement it. Incrementing must happen in a place like
// Module.preRun (used by emcc to add file preloading).
// Note that you can add dependencies in preRun, even though
// it happens right before run - run will be postponed until
// the dependencies are met.
var runDependencies = 0;
var runDependencyWatcher = null;
var dependenciesFulfilled = null; // overridden to take different actions when all run dependencies are fulfilled
var runDependencyTracking = {};

function getUniqueRunDependency(id) {
  var orig = id;
  while (1) {
    if (!runDependencyTracking[id]) return id;
    id = orig + Math.random();
  }
}

function addRunDependency(id) {
  runDependencies++;

  if (Module['monitorRunDependencies']) {
    Module['monitorRunDependencies'](runDependencies);
  }

  if (id) {
    assert(!runDependencyTracking[id]);
    runDependencyTracking[id] = 1;
    if (runDependencyWatcher === null && typeof setInterval !== 'undefined') {
      // Check for missing dependencies every few seconds
      runDependencyWatcher = setInterval(function() {
        if (ABORT) {
          clearInterval(runDependencyWatcher);
          runDependencyWatcher = null;
          return;
        }
        var shown = false;
        for (var dep in runDependencyTracking) {
          if (!shown) {
            shown = true;
            err('still waiting on run dependencies:');
          }
          err('dependency: ' + dep);
        }
        if (shown) {
          err('(end of list)');
        }
      }, 10000);
    }
  } else {
    err('warning: run dependency added without ID');
  }
}

function removeRunDependency(id) {
  runDependencies--;

  if (Module['monitorRunDependencies']) {
    Module['monitorRunDependencies'](runDependencies);
  }

  if (id) {
    assert(runDependencyTracking[id]);
    delete runDependencyTracking[id];
  } else {
    err('warning: run dependency removed without ID');
  }
  if (runDependencies == 0) {
    if (runDependencyWatcher !== null) {
      clearInterval(runDependencyWatcher);
      runDependencyWatcher = null;
    }
    if (dependenciesFulfilled) {
      var callback = dependenciesFulfilled;
      dependenciesFulfilled = null;
      callback(); // can add another dependenciesFulfilled
    }
  }
}

Module["preloadedImages"] = {}; // maps url to image data
Module["preloadedAudios"] = {}; // maps url to audio data


/** @param {string|number=} what */
function abort(what) {
  if (Module['onAbort']) {
    Module['onAbort'](what);
  }

  what += '';
  out(what);
  err(what);

  ABORT = true;
  EXITSTATUS = 1;

  var output = 'abort(' + what + ') at ' + stackTrace();
  what = output;

  // Throw a wasm runtime error, because a JS error might be seen as a foreign
  // exception, which means we'd run destructors on it. We need the error to
  // simply make the program stop.
  throw new WebAssembly.RuntimeError(what);
}


var memoryInitializer = null;


/**
 * @license
 * Copyright 2015 The Emscripten Authors
 * SPDX-License-Identifier: MIT
 */







/**
 * @license
 * Copyright 2017 The Emscripten Authors
 * SPDX-License-Identifier: MIT
 */

function hasPrefix(str, prefix) {
  return String.prototype.startsWith ?
      str.startsWith(prefix) :
      str.indexOf(prefix) === 0;
}

// Prefix of data URIs emitted by SINGLE_FILE and related options.
var dataURIPrefix = 'data:application/octet-stream;base64,';

// Indicates whether filename is a base64 data URI.
function isDataURI(filename) {
  return hasPrefix(filename, dataURIPrefix);
}

var fileURIPrefix = "file://";

// Indicates whether filename is delivered via file protocol (as opposed to http/https)
function isFileURI(filename) {
  return hasPrefix(filename, fileURIPrefix);
}



var wasmBinaryFile = 'data:application/octet-stream;base64,AGFzbQEAAAABtwM2YAJ/fwF/YAF/AX9gA39/fwF/YAJ/fwBgAAF/YAF/AGAEf39/fwF/YAV/f39/fwF/YAN/f38AYAR/f39/AGAAAGAGf39/f39/AGAGf39/f39/AX9gBX9/f39/AGACf34Bf2AGf35+f39/AX9gB39/f39/f38Bf2ADf35/AX5gCX9/f39/f39/fwF/YAd/f39/f39/AGADf35/AGAEf35/fwF/YAN/fn4Bf2AGf3x/f39/AX9gAn9+AGAEf35+fwBgCH9/f39/f39/AX9gCn9/f39/f39/f38Bf2AHf39+f39/fwF/YAN/fn8Bf2AGf35/f39/AX9gAn5/AX9gAX8BfmABfwF8YAh/f39/f39/fwBgCn9/f39/f39/f38AYA1/f39/f39/f39/f39/AGAEf39+fwBgA39/fABgC39/f39/f39/f39/AX9gBn9/f39/fgF/YAN/f34Bf2AEf39+fgF/YAd/f35+f39/AX9gB39/fH9/f38Bf2AFf35/f38Bf2AFf35+f38Bf2ADfn9/AX9gAn9/AX5gBH9/fn8BfmACf34BfmABfAF+YAJ+fgF8YAJ8fwF8ApYIKANlbnYFcmFpc2UAAQNlbnYEZXhpdAAFA2VudhFfZW12YWxfbmV3X29iamVjdAAEA2VudhNfZW12YWxfc2V0X3Byb3BlcnR5AAgDZW52El9lbXZhbF9uZXdfY3N0cmluZwABA2Vudg1fZW12YWxfZGVjcmVmAAUDZW52Fl9lbWJpbmRfcmVnaXN0ZXJfY2xhc3MAJANlbnYfX2VtYmluZF9yZWdpc3Rlcl9jbGFzc19wcm9wZXJ0eQAjA2VudhlfZW1iaW5kX3JlZ2lzdGVyX2Z1bmN0aW9uAAsDZW52GV9lbWJpbmRfcmVnaXN0ZXJfY29uc3RhbnQAJgNlbnYRX2VtdmFsX3Rha2VfdmFsdWUAAANlbnYiX2VtYmluZF9yZWdpc3Rlcl9jbGFzc19jb25zdHJ1Y3RvcgALA2Vudh9fZW1iaW5kX3JlZ2lzdGVyX2NsYXNzX2Z1bmN0aW9uACIDZW52DV9lbXZhbF9pbmNyZWYABQNlbnYKX19zeXNfb3BlbgACA2VudgtfX3N5c19tbWFwMgAMA2VudgxfX3N5c19tdW5tYXAAAANlbnYNX19zeXNfZnN0YXQ2NAAAA2VudgxfX3N5c19zdGF0NjQAABZ3YXNpX3NuYXBzaG90X3ByZXZpZXcxCGZkX3dyaXRlAAYWd2FzaV9zbmFwc2hvdF9wcmV2aWV3MQhmZF9jbG9zZQABA2VudhFfX3N5c19mdHJ1bmNhdGU2NAAGA2VudgpfX3N5c19yZWFkAAIWd2FzaV9zbmFwc2hvdF9wcmV2aWV3MQ1mZF9mZHN0YXRfZ2V0AAADZW52BWFib3J0AAoDZW52FV9lbWJpbmRfcmVnaXN0ZXJfdm9pZAADA2VudhVfZW1iaW5kX3JlZ2lzdGVyX2Jvb2wADQNlbnYbX2VtYmluZF9yZWdpc3Rlcl9zdGRfc3RyaW5nAAMDZW52HF9lbWJpbmRfcmVnaXN0ZXJfc3RkX3dzdHJpbmcACANlbnYWX2VtYmluZF9yZWdpc3Rlcl9lbXZhbAADA2VudhhfZW1iaW5kX3JlZ2lzdGVyX2ludGVnZXIADQNlbnYWX2VtYmluZF9yZWdpc3Rlcl9mbG9hdAAIA2VudhxfZW1iaW5kX3JlZ2lzdGVyX21lbW9yeV92aWV3AAgDZW52FmVtc2NyaXB0ZW5fcmVzaXplX2hlYXAAAQNlbnYVZW1zY3JpcHRlbl9tZW1jcHlfYmlnAAIDZW52F19faGFuZGxlX3N0YWNrX292ZXJmbG93AAoDZW52C3NldFRlbXBSZXQwAAUWd2FzaV9zbmFwc2hvdF9wcmV2aWV3MQdmZF9zZWVrAAcDZW52Bm1lbW9yeQIBgAKAgAIDZW52BXRhYmxlAXAAvAMDtg+0DwQKCAECAwAEAQECAwAEAQAFCQEAAAUABQAFAgABAAAAAQEAAgICAgACAwMGAAIGAwIBAAICAgICAAAAAwICBgYCAAAAAAAGAgACAgIGAgMCAgIAAAICAQAGBgIAAgcBAQMCAAIHBgACAgADBAUCBwYHDAEGBwMMAQAFAAAAAQABAAABAQACAgEAAgICAgICAgAGAAICAgYCAgAAAgUGAAkEBQABAAEFDgUAAAYPASUPBQ8OBQ8BBgYGAA4AAAIFBQAADgYGBQUGAgUFBgIFHQEBHQMBAQICAAEAAwgABwYCAwICBQUJBQkDCAgaAQEABQAAAAAMAwIAAAEJBgwACAYBAAEFBQMMBRsFAwADAAMAAwADBQAFBQUFCAYCBgsAAhInBQwNCQ0TAwMFAQUGAgMAAQUBAgABAQwCAhIMBwsGCwYLBgYCCAsGBhALCwsLFgMABgYGBgYGBgIGAAEyMC4ALQYFAAUGAAIGCAYABgUAAQEBAQEBARwICAoAAAEgAAgIAhUBAQACAiABAAAeAQAAAAEBAR4IFQUFAAIHBwcHAAYBBgIBAgIABgAGAAYBAgEBAgYBAQIGBgECAgAAAgYHAgIBBxICAgIGBgYGBgYCBgAGAAcaGwUAAQECBwACAAAFBhwGAQAGAAcAAQEAAAYDBwABAQEGAQEBAQEGAQEBAwACAQMDBQAIAQgICAgIAAAAAAAAAAYGBgcGCgEKAQQEBQQEBAQEBAQBBQEDAwMKAQQEBQQEBAQFAQMBAwoBBAQFBAQEAQUBAwMDCgEEBAUEBAQEBAUKAQQEBQQEBAQFAQMIAAAEBQEKBAQEBAQFBAQBBAEEAwMDAwMDAwMDAwMDAwMDCAAAAQEBAAEBBwEBBAIBAQQCAQECAQECAQEHAQEHAQEHAQEMAQEEBwEBBAEhBAEhAgEABAEBAwMFBAEBAAEBAwQBAQEBAQEBAQEBAQEBAQEBAQEABAEEAQABAwQBAQQEBAEAAAEBAQEEAQABAQEBBAABAQEBAQQBBAQEAQEBAQQAAQEBAQEEAAEBAQEEAQEEBAQAAAEBAQQAAQEBAQQAAQEBAQQBAQEEBAQBAQEBAQQBAQEEBAQBAQEBAQQAAQEBAQQBBAQEAQEBAQQBBAABAQEBBAQBBAMBBAECBAEEBAQEBAQBBAQECgEBBAIBCigAAwABARECAQECAgAECgIBEQEEAgQANQcQCAEJDR8vHwIXAzMCAgYCBgIJDQMTAwEIAgIBAQAAAAAAAAIBDhECAgUFAQEZGTQBAQUGBQUBAQgBAQEDAQEBAAMDAwECAwAAAQEBCAgBAQEBAgQEAgQEAQgIAwUBAQEBAAMKAQQFCgQBCgEFBQUFBQUFAgIAAQIGCQkJCQkCAgAADQkNCw0NDQsLCwEBCgQEBQUFBQUFBQUFBQUEBAQEBAUFBQUFBQUFBQUFBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQECgEEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQKAQUAAAAAAAMBAgICAQACBgEFAQEGAgEBAgMDAQEBAgAAAQEAAgIBAAgBAgEIAwEBAQEBAQEBAQEBAQEBAQEFAAEBAAAAAQEBAwgAARACAQECAAAAAAAAAAAAAQAAAQADAAEBAAEBAQACAAABAAIBAQEBAQICAgEAAAIAAAAAAAAAAAABAAAAAAEAAQADAQEAAwABAQkDEAECAQIBAgECAQICAQIBAgECAQIBAgACAAUHAAAAAAMDAwMFBQIDBQEAAQUCAAAAAgAABQMFAAMBAwABAwACAAMBAAIAAAMBAgAGAgABAAAAAwMFAgIDAwUBAQADAQMBAAEAAAIAAQAAAAAAAwMFAQgICAgBAQEAAgEGAgACAQIAAgYGAgICAAAAAAACAQICAQEGAAABAQEAAAIAAwcGAgEGAgICAQEGAQYBAQIBAAEGBgIGBgECAgwMBgYBBgYABgAGAAIBAAAAAgEAAAAAAAEAAAIAAAEBBQYAAQEAAgICAwEIBQADBQAAAwMFAwMDAQAAAwUAAAMFAAMFAAECAAACAgAGAwEAAAMFAgIAAgIAAQIDAgMDBRgYBQEDCAgAAwMFAgMDBQIDAwMFAwADAwUGAwMFAAMFAgMFAAADAQUHBwMFBQADAAEFAQYGAwAFAgIDBQYDBQIDBQICAAICAwUGAwUCAQABAAACAwMFAAAAAAADBQAAAAAAAAEAAAADBQADBQADAwUGAwUCAwUGBgYDBQYDBQIDBQIDBQwMDAMFBgMFBgMFAAMFAAMFAAMFAAMFAAEGAAMDBQYDBQICAwUAAAMFAgIDBQAAAwMFAQUDAAAAAQEAAAABAQEAAwEAAAAAAwMFAAMBBQIDAwUAAAMDBQEAAAMFAAMFEAAAAwMFAgMFAAAMAgECAgIAAAABAAAAAgICAgIAAgICAAAMAAMFAAMFDAAAAwMFAQICAgIDBQIDBQIAAAADAwMFAAACAgADBQIDBQICAAADAwUCAgADAwUCAgMFAAADAQMFAwIAAwgDBQgAAgAAAgMFBQQBBQEABgIBAwcMECkrCAkTKjEsBQsNBhIMBxUGFQN/AUHwqMQCC38AQdCnBAt/AUEACwfCBCMRX193YXNtX2NhbGxfY3RvcnMAJwZtYWxsb2MAugkEZnJlZQC7CQZtZW1zZXQAxAkQX19lcnJub19sb2NhdGlvbgCUBwZmZmx1c2gAnAcOX19jeGFfZGVtYW5nbGUAzgkNX19nZXRUeXBlTmFtZQC+CCpfX2VtYmluZF9yZWdpc3Rlcl9uYXRpdmVfYW5kX2J1aWx0aW5fdHlwZXMAvwgIbWVtYWxpZ24AvwkKX19kYXRhX2VuZAMBEV9fc2V0X3N0YWNrX2xpbWl0AL0PCXN0YWNrU2F2ZQC+DwpzdGFja0FsbG9jAL8PDHN0YWNrUmVzdG9yZQDADxBfX2dyb3dXYXNtTWVtb3J5AMEPCmR5bkNhbGxfaWkAwg8MZHluQ2FsbF9paWlpAMMPC2R5bkNhbGxfaWlpAMQPCWR5bkNhbGxfaQDFDwpkeW5DYWxsX3ZpAMYPDWR5bkNhbGxfaWlpaWkAxw8OZHluQ2FsbF9paWlpaWkAyA8PZHluQ2FsbF9paWlpaWlpAMkPC2R5bkNhbGxfaWlqANUPD2R5bkNhbGxfaWlqamlpaQDWDwtkeW5DYWxsX3ZpaQDMDwxkeW5DYWxsX3ZpaWkAzQ8PZHluQ2FsbF92aWlpaWlpAM4PDGR5bkNhbGxfaWlqagDXDwxkeW5DYWxsX2ppamkA2A8PZHluQ2FsbF9paWRpaWlpANEPCWR5bkNhbGxfdgDSDw5keW5DYWxsX3ZpaWlpaQDTDw1keW5DYWxsX3ZpaWlpANQPCfMGAQBBAQu7AykqLC0vMDIzgAGCAXp7hwGJAZ0BngGfAaABoQGiAaMBpAGlAaYBpwGoAakBqgGrAawBrQGuAa8BsAGxAbIBswG0AbUBtgG3AbgBuQG6AbsBvAG9Ab4BvwHAAcEBwgHDAcQBlAGWAZUBkwGXAZoBnAHNAc4BzwHQAdEB0gHVAdYB1wHYAdkB2gHlAeYB5wHoAekB6gHjAckB7AHtAe4B8AHxAfIB5AHrAe8B8wGhA6IDhQKGApYClwKZAqYCqAKnAq0CsQKyArMCtAK1ArYCtwK4AsEC1ALVAusC7ALoAvEC8gLkAuYC7QLzAvQC9QL2AvcC+gLlAukC5wL7AvwC/QLvAvcD+QOTBMIExATHBM8E0QTTBNYE2QTdBN8E4QTkBOcE6wTtBO8E8gT1BPoE/QSABYQFhgXABL8EvgS9BLwEuwS6BLkEuASiBKEEoASfBMYBqwSIBYkFigWqBKYEiwWMBY0FjQaUBpoGpQaqBrEGvQbCBsgGzwbQBtUG2wbcBuEG5gbwBvcGrQWwBbMFtwW7Bb4FwQXEBccF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QCAAKAIcIgNBP0sNACAAIANBAWo2AhwgACAAKQMAIANBA3StfDcDACAAQSBqIgQgA2pBgAE6AAACQAJAAkAgACgCHCICQTlJDQACQCACQT9LDQADQCAAIAJBAWo2AhwgACACakEgakEAOgAAIAAoAhwiAkHAAEkNAAsLIAAgBBAxQQAhAiAAQQA2AhwMAQsgAkE4Rg0BCwNAIAAgAkEBajYCHCAAIAJqQSBqQQA6AAAgACgCHCICQThJDQALCyAAQdgAaiAAKQMAIgVCOIYgBUIohkKAgICAgIDA/wCDhCAFQhiGQoCAgICA4D+DIAVCCIZCgICAgPAfg4SEIAVCCIhCgICA+A+DIAVCGIhCgID8B4OEIAVCKIhCgP4DgyAFQjiIhISENwAAIAAgBBAxIAEgAEELai0AADoAACABIABBCmovAQA6AAEgASAAKAIIQQh2OgACIAEgACgCCDoAAyABIABBD2otAAA6AAQgASAAQQ5qLwEAOgAFIAEgAEEMaiICKAIAQQh2OgAGIAEgAigCADoAByABIABBE2otAAA6AAggASAAQRJqLwEAOgAJIAEgAEEQaiICKAIAQQh2OgAKIAEgAigCADoACyABIABBF2otAAA6AAwgASAAQRZqLwEAOgANIAEgAEEUaiICKAIAQQh2OgAOIAEgAigCADoADyABIABBG2otAAA6ABAgASAAQRpqLwEAOgARIAEgAEEYaiIAKAIAQQh2OgASIAEgACgCADoAE0EAIQILIAIL8gEBBH8CQCMAQYABayIAIgIjAkkEQBAjCyACJAALIABBGGpC8MPLngw3AwAgAEEQakL+uevF6Y6VmRA3AwAgAEKBxpS6lvHq5m83AwggAEIANwMAIABB0BBBAxAwGiAAIABB4ABqEDIaQQUhAQJAIABB4ABqQaQQQRQQywcNACAAQvDDy54MNwMYIABC/rnrxemOlZkQNwMQIABCgcaUupbx6uZvNwMIIABCADcDACAAQdQQQTgQMBogACAAQeAAahAyGkEFQQAgAEHgAGpBvBBBFBDLBxshAQsCQCAAQYABaiIDIwJJBEAQIwsgAyQACyABCwcAIAAQugkLCQAgACABELwJCwcAIAAQuwkLDQAgACABIAIgAxDDBws7AQF/IABBgAEQugkiATYCDAJAIAENAEF+DwsgAUEAQYABEMQJGiAA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ACgCDCEHQQAhCCAFIQNBACEJA0AgAyAHKAIAIgpBAXRB/v///wBxIAhyNgIAIANBBGohAyAHQQRqIQcgCkEbdiEIIAlBAWoiCSAGRw0ACyAIRQ0AIANBATYCACABIAJBAWoiAjYCAAsCQCAEIAJMDQAgBSACQQJ0akEAIAQgAmtBAnQQxAkaCyABIAAoAgg2AghBACEDCyADC9ABAQh/AkACQCABKAIEIAAoAgAiAk4NACABIAIQOSIDDQEgACgCACECCyABKAIAIQQgASACNgIAIAEoAgwgAkECdCIDaiEFAkAgAkEBSA0AIAAoAgwgA2ohBkEAIQcgBSEIIAIhAwNAIAhBfGoiCCAGQXxqIgYoAgAiCUEBdiAHQRt0cjYCACAJQQFxIQcgA0EBSiEJIANBf2ohAyAJDQALCwJAIAQgAkwNACAFQQAgBCACa0ECdBDECRoLIAEgACgCCDYCCCABED9BACEDCyADC2ABA38CQCMAQRBrIgIiAyMCSQRAECMLIAMkAAsgAiABNgIMAkAgAEUNAANAIAAQOyACIAIoAgwiAEEEajYCDCAAKAIAIgANAAsLAkAgAkEQaiIEIwJJBEAQIwsgBCQACwvTDQEGfwJAIwBB0AJrIgMiByMCSQRAECMLIAckAAsgA0HwAGpBADYCACADQdAAaiADQdABajYCACADQdQAaiADQcABajYCACADQdgAaiADQbABajYCACADQcAAakEcaiADQaABajYCACADQeAAaiADQZABajYCACADQeQAaiADQYABajYCACADQegAaiADQfABajYCACADQewAaiADQeABajYCACADIANBsAJqNgJAIAMgA0GgAmo2AkQgAyADQZACajYCSCADIANBgAJqNgJMAkAgA0HAAmogA0HAAGoQXiIEDQACQCAAIAAoAgAiBCABKAIAIgUgBCAFSBtBA20iBUEcbCIGIANB0AFqEE4iBA0AIAAgA0HAAWoQOiIEDQAgA0HAAWogBRBPIANBwAFqIAYgA0HAAWoQThogACADQbABahA6IgQNACADQbABaiAFQQF0IgAQTyABIAYgA0GgAWoQTiIEDQAgASADQZABahA6IgQNACADQZABaiAFEE8gA0GQAWogBiADQZABahBOGiABIANBgAFqEDoiBA0AIANBgAFqIAAQTyADQdABaiADQaABaiADQcACahBmIgQNACADQbABaiADQYABaiADQYACahBmIgQNACADQdABaiADQfABahBfIgQNACADQfABaiADQcABaiADQfABahBcIgQNACADQfABaiADQfABahBfIgQNACADQfABaiADQbABaiADQfABahBcIgQNACADQaABaiADQeABahBfIgQNACADQeABaiADQZABaiADQeABahBcIgQNACADQeABaiADQeABahBfIgQNACADQeABaiADQYABaiADQeABahBcIgQNACADQfABaiADQeABaiADQbACahBmIgQNACADQbABaiADQfABahBfIgQNACADQfABaiADQcABaiADQfABahBcIgQNACADQfABaiADQfABahBfIgQNACADQfABaiADQdABaiADQfABahBcIgQNACADQYABaiADQeABahBfIgQNACADQeABaiADQZABaiADQeABahBcIgQNACADQeABaiADQeABahBfIgQNACADQeABaiADQaABaiADQeABahBcIgQNACADQfABaiADQeABaiADQZACahBmIgQNACADQbABaiADQcABaiADQfABahBcIgQNACADQfABaiADQdABaiADQfABahBcIgQNACADQYABaiADQZABaiADQeABahBcIgQNACADQeABaiADQaABaiADQeABahBcIgQNACADQfABaiADQeABaiADQaACahBmIgQNACADQbACaiADQYACaiADQbACahBdIgQNACADQZACaiADQcACaiADQZACahBdIgQNACADQbACaiADQbACahBgIgQNACADQZACaiADQZACahBgIgQNACADQaACaiADQcACaiADQaACahBdIgQNACADQaACaiADQYACaiADQaACahBdIgQNACADQbACaiADQaACaiADQbACahBdIgQNACADQZACaiADQaACaiADQZACahBdIgQNACADQcACakEDIANB8AFqEEAiBA0AIANBsAJqIANB8AFqIANBsAJqEF0iBA0AIANBgAJqQQMgA0HwAWoQQCIEDQAgA0GQAmogA0HwAWogA0GQAmoQXSIEDQAgA0GgAmpBAyADQaACahBJIgQNACADQaACaiADQbACaiADQaACahBdIgQNACADQaACaiADQZACaiADQaACahBdIgQNACADQbACaiADQaACaiADQbACahBdIgQNACADQZACaiADQaACaiADQZACahBdIgQNACADQbACaiADQbACakEAEFMiBA0AIANBkAJqIANBkAJqQQAQUyIEDQAgA0GwAmogBRA+IgQNACADQaACaiAAED4iBA0AIANBkAJqIAVBA2wQPiIEDQAgA0GAAmogBUECdBA+IgQNACADQcACaiADQbACaiACEFwiBA0AIANBoAJqIANBkAJqIANB8AFqEFwiBA0AIANBgAJqIANB8AFqIANB8AFqEFwiBA0AIANB8AFqIAIgAhBcIQQLIANBMGpBADYCACADQSxqIANB4AFqNgIAIANBKGogA0HwAWo2AgAgA0EkaiADQYABajYCACADQSBqIANBkAFqNgIAIANBHGogA0GgAWo2AgAgA0EYaiADQbABajYCACADQRRqIANBwAFqNgIAIANBEGogA0HQAWo2AgAgAyADQYACajYCDCADIANBkAJqNgIIIAMgA0GgAmo2AgQgAyADQbACajYCACADQcACaiADEGELAkAgA0HQAmoiCCMCSQRAECMLIAgkAAsgBAuABgELfwJAIwBB8ABrIgMiDCMCSQRAECMLIAwkAAtBfiEEAkAgA0HgAGogACgCACIFIAEoAgAiBiAFIAZIGyIGQQF1IgUQUg0AQX4hBAJAIANB0ABqIAAoAgAgBWsQUg0AQX4hBAJAIANBwABqIAUQUg0AQX4hBAJAIANBMGogASgCACAFaxBSDQBBfiEEAkAgA0EgaiAGQX5xIgcQUg0AQX4hBAJAIANBEGogBxBSDQBBfiEEAkAgAyAHEFINACADIAU2AmAgAyAFNgJAIAMgACgCACIIIAVrNgJQIAMgASgCACIJIAVrNgIwIAEoAgwhBCAAKAIMIQACQCAGQQJIDQAgBUEBIAVBAUobIQpBACELIAMoAmwhASADKAJMIQYDQCABIAAoAgA2AgAgBiAEKAIANgIAIAZBBGohBiAEQQRqIQQgAUEEaiEBIABBBGohACALQQFqIgsgCkcNAAsLAkAgCCAFTA0AIAMoAlwhASAFIQYDQCABIAAoAgA2AgAgAUEEaiEBIABBBGohACAGQQFqIgYgCEcNAAsLAkAgCSAFTA0AIAMoAjwhACAFIQEDQCAAIAQoAgA2AgAgAEEEaiEAIARBBGohBCABQQFqIgEgCUcNAAsLIANB4ABqED8gA0HAAGoQP0F+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ACACEFQLJgACQAJAIAAgAUYNACAAIAEQOiIADQELQQAhACABQQA2AggLIAAL+AIBBX8CQCMAQSBrIgMiBiMCSQRAECMLIAYkAAsCQAJAIAAoAgANACABIAIQbiEADAELAkAgASgCAA0AIAAgAhBuIQAMAQsgA0EQaiAAEE0iAA0AAkAgAyABEE0iAA0AIANBADYCGCADQQA2AggCQAJAIANBEGoQRyIBIAMQRyIEIAEgBEgbIgVBAUgNACADQRBqIAUgA0EQakEAEFEiAA0BIAMgBSADQQAQUSIADQELAkAgASAETA0AIANBEGogASAFayADQRBqQQAQUSIADQELAkAgASAETg0AIAMgBCAFayADQQAQUSIADQELAkADQCADKAIARQ0BAkAgA0EQaiADEENBAUcNACADQRBqIAMQUAsgAyADQRBqIAMQWyIADQIgAyADEEcgA0EAEFEiAEUNAAwCAAsACyADQRBqIAUgAhBAIgANAEEAIQAgAkEANgIICyADQRBqEDsLIAMQOwsCQCADQSBqIgcjAkkEQBAjCyAHJAALIAAL3AEBBH8CQCMAQcAAayIDIgUjAkkEQBAjCyAFJAALIANBADYCFCADIANBIGo2AhACQCADQTBqIANBEGoQXiIEDQACQCAAIAEgA0EwahBvIgQNAAJAAkAgACABEENBf0cNACAAIANBMGogA0EgakEAEGwiBEUNAQwCCyABIANBMGogA0EgakEAEGwhBCAAIQEgBA0BCyABIANBIGogAhBmIQQgAkEANgIICyADQQA2AgQgAyADQSBqNgIAIANBMGogAxBhCwJAIANBwABqIgYjAkkEQBAjCyAGJAALIAQLegEEfwJAIwBBEGsiAyIFIwJJBEAQIwsgBSQACwJAIAMQOCIEDQACQCAAIAFBACADEGwiBA0AAkAgAygCCCABKAIIRg0AIAEgAyACEFwhBAwBCyADIAIQUEEAIQQLIAMQOwsCQCADQRBqIgYjAkkEQBAjCyAGJAALIAQLXAEEfwJAIwBBEGsiBCIGIwJJBEAQIwsgBiQACwJAIAQQOCIFDQACQCAAIAEgBBBmIgUNACAEIAIgAxBxIQULIAQQOwsCQCAEQRBqIgcjAkkEQBAjCyAHJAALIAULWgEEfwJAIwBBEGsiAyIFIwJJBEAQIwsgBSQACwJAIAMQOCIEDQACQCAAIAMQayIEDQAgAyABIAIQcSEECyADEDsLAkAgA0EQaiIGIwJJBEAQIwsgBiQACyAECyMAIAAQPSAAKAIMIAFB/////wBxIgE2AgAgACABQQBHNgIAC5IGAQR/AkAjAEGgAWsiAyIFIwJJBEAQIwsgBSQACwJAAkAgASgCAEEBSA0AQX0hBCABKAIMLQAAQQFxRQ0BCyADQTRqQQA2AgAgA0EwaiADQcAAajYCACADIANB0ABqNgIsIAMgA0HgAGo2AiggAyADQfAAajYCJCADIANBgAFqNgIgIANBkAFqIANBIGoQXiIEDQACQCABIANBkAFqEDoiBA0AIAAgASADQYABahBxIgQNACADQZABaiADQfAAahA6IgQNACADQYABaiADQeAAahA6IgQNACADQcAAakEBEHQDQAJAIAMoAnBBAEwNACADKAJ8LQAAQQFxDQAgA0HwAGogA0HwAGoQYCIEDQICQCADKAJQQQFIDQAgAygCXC0AAEEBcUUNACADQdAAaiADQZABaiADQdAAahBdIgQNAwsgA0HQAGogA0HQAGoQYCIERQ0BDAILAkADQCADKAJgQQFIDQEgAygCbC0AAEEBcQ0BIANB4ABqIANB4ABqEGAiBA0DAkAgAygCQEEBSA0AIAMoAkwtAABBAXFFDQAgA0HAAGogA0GQAWogA0HAAGoQXSIEDQQLIANBwABqIANBwABqEGAiBEUNAAwDAAsACwJAAkAgA0HwAGogA0HgAGoQREF/Rg0AIANB8ABqIANB4ABqIANB8ABqEF0iBA0DIANB0ABqIANBwABqIANB0ABqEF0iBEUNAQwDCyADQeAAaiADQfAAaiADQeAAahBdIgQNAiADQcAAaiADQdAAaiADQcAAahBdIgQNAgsgAygCcA0AC0F9IQQgA0HgAGpBARBFDQAgACgCCCEAAkADQCADKAJIQQFHDQEgA0HAAGogASADQcAAahBcIgRFDQAMAgALAAsgA0HAAGogAhBQIAIgADYCCEEAIQQLIANBFGpBADYCACADQRBqIANBwABqNgIAIAMgA0HQAGo2AgwgAyADQeAAajYCCCADIANB8ABqNgIEIAMgA0GAAWo2AgAgA0GQAWogAxBhCwJAIANBoAFqIgYjAkkEQBAjCyAGJAALIAQL6wgBBH8CQCMAQcABayIDIgUjAkkEQBAjCyAFJAALQX0hBAJAIAEoAghBAUYNACABKAIARQ0AIANBPGpBADYCACADQThqIANBwABqNgIAIANBNGogA0HQAGo2AgAgA0EwaiADQeAAajYCACADIANB8ABqNgIsIAMgA0GAAWo2AiggAyADQZABajYCJCADIANBoAFqNgIgIANBsAFqIANBIGoQXiIEDQACQCAAIAEgA0GwAWoQcSIEDQAgASADQaABahA6IgQNAAJAIAMoArABQQFIDQAgAygCvAEtAABBAXENACADKAKgAUEBSA0AQX0hBCADKAKsAS0AAEEBcUUNAQsgA0GwAWogA0GQAWoQOiIEDQAgA0GgAWogA0GAAWoQOiIEDQAgA0HwAGpBARB0IANBwABqQQEQdANAAkAgAygCkAFBAEwNACADKAKcAS0AAEEBcQ0AIANBkAFqIANBkAFqEGAiBA0CAkACQAJAIAMoAnBBAUgNACADKAJ8LQAAQQFxDQELIAMoAmBBAUgNASADKAJsLQAAQQFxRQ0BCyADQfAAaiADQaABaiADQfAAahBcIgQNAyADQeAAaiADQbABaiADQeAAahBdIgQNAwsgA0HwAGogA0HwAGoQYCIEDQIgA0HgAGogA0HgAGoQYCIERQ0BDAILAkADQCADKAKAAUEBSA0BIAMoAowBLQAAQQFxDQEgA0GAAWogA0GAAWoQYCIEDQMCQAJAAkAgAygCUEEBSA0AIAMoAlwtAABBAXENAQsgAygCQEEBSA0BIAMoAkwtAABBAXFFDQELIANB0ABqIANBoAFqIANB0ABqEFwiBA0EIANBwABqIANBsAFqIANBwABqEF0iBA0ECyADQdAAaiADQdAAahBgIgQNAyADQcAAaiADQcAAahBgIgRFDQAMAwALAAsCQAJAIANBkAFqIANBgAFqEERBf0YNACADQZABaiADQYABaiADQZABahBdIgQNAyADQfAAaiADQdAAaiADQfAAahBdIgQNAyADQeAAaiADQcAAaiADQeAAahBdIgRFDQEMAwsgA0GAAWogA0GQAWogA0GAAWoQXSIEDQIgA0HQAGogA0HwAGogA0HQAGoQXSIEDQIgA0HAAGogA0HgAGogA0HAAGoQXSIEDQILIAMoApABDQALQX0hBCADQYABakEBEEUNAANAAkAgA0HQAGpBABBFQX9GDQACQANAIANB0ABqIAEQQ0F/Rg0BIANB0ABqIAEgA0HQAGoQXSIERQ0ADAQACwALIANB0ABqIAIQUEEAIQQMAgsgA0HQAGogASADQdAAahBcIgRFDQALCyADQRxqQQA2AgAgA0EYaiADQcAAajYCACADQRRqIANB0ABqNgIAIANBEGogA0HgAGo2AgAgAyADQfAAajYCDCADIANBgAFqNgIIIAMgA0GQAWo2AgQgAyADQaABajYCACADQbABaiADEGELAkAgA0HAAWoiBiMCSQRAECMLIAYkAAsgBAtMAQJ/QX0hAwJAIAEoAghBAUYNACABKAIAIgRFDQACQCAEQQFIDQAgASgCDC0AAEEBcUUNACAAIAEgAhB1DwsgACABIAIQdiEDCyADC1wBAX9BfSECAkAgACgCDCgCACIAQQFxRQ0AIAFBAkECIABBAXRBBGpBCHEgAGoiAiAAbGsgAmwiAiAAbGsgAmwiAiAAbEF+aiACbEH/////AHE2AgBBACECCyACC4gBAQJ/IAEQRkEcbyECAkACQAJAIAEoAgAiA0ECSA0AIAAgAiADQRxsakFjahBIIgNFDQEMAgtBASECIABBARB0CyACQX9qIQIDQCAAIAAQXyIDDQECQCAAIAEQQ0F/Rg0AIAAgASAAEFsiAw0CCyACQRtIIQMgAkEBaiECIAMNAAtBACEDCyADC4kFAg1/A34CQCMAQYAgayIDIg4jAkkEQBAjCyAOJAALIAAoAgAiBCEFAkACQCAAKAIEIAEoAgAiBkoNACAAIAZBAWoQOSIGDQEgACgCACEFC0EAIQcgACgCDCEIIAMhBgJAIAVBAEwNACAIIQkDQCAGIAk1AgA3AwAgBkEIaiEGIAlBBGohCSAHQQFqIgcgBUcNAAsgBSEHCwJAIAEoAgAiBUEBdEEBciIKIAdMDQAgBkEAIAogB2tBA3QQxAkaCwJAAkAgBUEBTg0AQQAhBiADIQsMAQsgASgCDCIMNQIAIRBBACENIAMhCwNAIAsgECALKQMAIhGnIAJsQf////8Aca0iEn4gEXw3AwBBASEHIAshBiAMIQkCQCAFQQFGDQADQCAGIAk1AgQgEn4gBikDCHw3AwggCUEEaiEJIAZBCGohBiAHQQFqIgcgBUcNAAsLIAspAwAhEiADIA1BAWoiDUEDdGoiCyALKQMAIBJCHIh8NwMAIA0gBUcNAAsgBSEGCwJAIAYgCk4NACADIAZBAWoiCUEDdGohBgNAIAYgBikDACALKQMAQhyIfDcDACAGQQhqIQYgC0EIaiELIAkgCkchByAJQQFqIQkgBw0ACwtBACELAkAgBUEASA0AIAVBAWohCyADIAVBA3RqIQZBACEJA0AgCCAGKAIAQf////8AcTYCACAIQQRqIQggBkEIaiEGIAkgBUYhByAJQQFqIQkgB0UNAAsLAkAgBCALTA0AIAhBACAEIAtrQQJ0EMQJGgsgACAFQQFqNgIAIAAQPwJAIAAgARBDQX9HDQBBACEGDAELIAAgASAAEFshBgsCQCADQYAgaiIPIwJJBEAQIwsgDyQACyAGC4ADAgd/An4gASgCACIDQQF0QQFyIQQCQCADQf8BSg0AIARB/wNKDQAgACABIAIQeg8LAkACQCAAKAIEIARODQAgACAEEDkiAw0BCyAAIAQ2AgACQCABKAIAIgVBAUgNACABKAIMIQYgACgCDCEHQQAhCANAIAcgCEECdGoiBCAGNQIAIAQoAgAiAyACbEH/////AHGtIgp+IAOtfCILp0H/////AHE2AgAgC0IciCELIARBBGohBEEBIQkgBiEDAkAgBUEBRg0AA0AgBCADNQIEIAp+IAtC/////w+DfCAENQIAfCILp0H/////AHE2AgAgC0IciCELIARBBGohBCADQQRqIQMgCUEBaiIJIAVHDQALCwJAIAunIgNFDQADQCAEIAQoAgAgA2oiA0H/////AHE2AgAgBEEEaiEEIANBHHYiAw0ACwsgCEEBaiIIIAVHDQALCyAAED8gACABKAIAEE8CQCAAIAEQQ0F/Rw0AQQAPCyAAIAEgABBbIQMLIAMLcwEDfwJAAkAgACgCACIBQQFLDQAgASECAkAgAQ4CAgACC0EBDwtBACECIAFBAkgNACAAKAIMIQNBACECQQAhAANAIAIgAyAAQQJ0aigCAEH/////AEZqIQIgAEEBaiIAIAFHDQALIAIgAUECbU4hAgsgAgslAQF/AkAgACABKAIAQThsEEgiAg0AIAAgASAAQQAQbCECCyACC74DAgx/AX4CQCMAQYAQayIEIg4jAkkEQBAjCyAOJAALAkACQCACKAIEIAEoAgAiBSAAKAIAIgZqIgdODQAgAiAHEDkiCA0BIAEoAgAiBSAAKAIAIgZqIQcLAkAC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QCADQeAAaiIHIwJJBEAQIwsgByQACyAECzgAIABB1QA2AjwgAEHLADYCOCAAQcwANgI0IABB1gA2AiggAEHXADYCJCAAIAAoAnxBgAJyNgJ8CwIACw4AQQBBigE2AuDyA0EACw4AQQBBigE2AuDyA0EACwIAC9EDAQd/AkAjAEGgAWsiAyIIIwJJBEAQIwsgCCQAC0HsByEEAkAgAUL/////D1YNACACQYCAIHENACADQZABakEIakEANgIAIANBgAFqQQhqQgA3AwAgA0IANwOQASADQgA3A4ABIANBAEH8ABDECSECIAAoAlRBzaDF0gFHDQAgAEHYAGooAgBBIEcNACAAQdwAajUCACABUg0AIABB8ABqLwEAQf//A3ENACAALwFyQf//A3FBA0cNACAAQegAaigCACEEIABB5ABqKAIAIQUgAEHgAGooAgAhBiAAIABB7ABqKAIAIgc2AnAgACAENgJsIAAgBTYCaCAAIAY2AmQgAEGAgAw2AmAgAELNoMXSgQQ3AlQgAEH0AGogAikDkAE3AgAgAEH8AGogAkGQAWpBCGooAgA2AgAgAEGAAWogATcCACAAQYgBaiACKQOAATcCACAAQZABaiACQYABakEIaikDADcCACAAQaABaiAHQQR0rTcCACAAQZgBaiAEQQR0rTcCACAAQagBaiACQfwAEMMJGiAAQdwANgJAIABBATYC0AIgACAAKALMAkEBcjYCzAJBACEECwJAIANBoAFqIgkjAkkEQBAjCyAJJAALIAQLsQICCX8BfgJAIwBBEGsiASIIIwJJBEAQIwsgCCQACyAAKAIwIgI1ABAhCgJAAkAgAigAGEEEdCIDELoJIgRFDQAgASAAKQMQIAp8NwMIAkAgACgCACABQQhqIAQgAxDdAUUNACAEIANB8O68nXwQpwMgBCACKAAYQQR0aiIFIARNDQJBACEGIAQhAANAAkAgACgCBCIDQX9GDQAgA0H/////AHEhBwJAAkAgACgCAEEBakECTw0AQewHIAYgAigAHCAHTRsgBiADQX5HGyEGDAELQewHIQYLIAApAgghCiAAIAc2AgwgACAKNwIAIABBADoACiAAQQA7AQgLIAUgAEEQaiIASw0ACyAGRQ0CCyAEELsJC0EAIQQLAkAgAUEQaiIJIwJJBEAQIwsgCSQACyAEC+0BAgd/AX4C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ACABLQAMaiIAaiAAIAEtAA1qIgBqIAAgAS0ADmoiAGogACABLQAPaiIDaiEEIAFBEGohASACQXBqIgJBD0sNAAsgAkUNAQsDQCADIAEtAABqIgMgBGohBCABQQFqIQEgAkF/aiICDQALCyAEQfH/A3AhBCADQfH/A3AhAwsgBEEQdCADcg8LAkAgAkUNAANAIAMgAS0AAGoiAyAEaiEEIAFBAWohASACQX9qIgINAAsLIARB8f8DcEEQdCADQY+AfGogAyADQfD/A0sbciEACyAAC2oAIABBADYCvC0gAEEAOwG4LSAAQQg2ArQtIABBuBZqQeyqAzYCACAAIABB/BRqNgKwFiAAQawWakHYqgM2AgAgACAAQYgTajYCpBYgAEGgFmpBxKoDNgIAIAAgAEGUAWo2ApgWIAAQigIL4QQBAX9BACEBA0AgACABQQJ0akGUAWpBADsBACABQQFqIgFBngJHDQALIABBADsB/BQgAEEAOwGIEyAAQcQVakEAOwEAIABBwBVqQQA7AQAgAEG8FWpBADsBACAAQbgVakEAOwEAIABBtBVqQQA7AQAgAEGwFWpBADsBACAAQawVakEAOwEAIABBqBVqQQA7AQAgAEGkFWpBADsBACAAQaAVakEAOwEAIABBnBVqQQA7AQAgAEGYFWpBADsBACAAQZQVakEAOwEAIABBkBVqQQA7AQAgAEGMFWpBADsBACAAQYgVakEAOwEAIABBhBVqQQA7AQAgAEGAFWpBADsBACAAQfwTakEAOwEAIABB+BNqQQA7AQAgAEH0E2pBADsBACAAQfATakEAOwEAIABB7BNqQQA7AQAgAEHoE2pBADsBACAAQeQTakEAOwEAIABB4BNqQQA7AQAgAEHcE2pBADsBACAAQdgTakEAOwEAIABB1BNqQQA7AQAgAEHQE2pBADsBACAAQcwTakEAOwEAIABByBNqQQA7AQAgAEHEE2pBADsBACAAQcATakEAOwEAIABBvBNqQQA7AQAgAEG4E2pBADsBACAAQbQTakEAOwEAIABBsBNqQQA7AQAgAEGsE2pBADsBACAAQagTakEAOwEAIABBpBNqQQA7AQAgAEGgE2pBADsBACAAQZwTakEAOwEAIABBmBNqQQA7AQAgAEGUE2pBADsBACAAQZATakEAOwEAIABBjBNqQQA7AQAgAEIANwKs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fCIPNwMQIAEpAwghDgJAIA9QDQADQCAIIA5CIIinQX9qOgAAIAEgCEEBaiIINgIYAkAgCCABKAIcRw0AIAEoAjANACAIIAEoAiAiDGshBgJAIAYgASgCJCIIIAwgBiAIKAIAEQIARg0AIAFBCTYCMAsgASABKAIgIgg2AhggASABKQMoIAatfDcDKAsgASABKQMQQn98Ig83AxAgASkDCCEOIA9CAFINAAsLIAEgDqdBGHY6AARCASEPCyABIA83AxAgASAOQgiGQoD+//8PgzcDCAsgDSALciEIIAcNAAwCAAsACyABIAYgCGsiBjYCACABIAEpAwggCK18Ig43AwggACAHIAdBBXZrOwEAAkAgBkH///8HSw0AIAEgBkEIdCIGNgIAAkACQCAOQv////8PVg0AIA6nQYCAgHhJDQAgASkDEEIBfCEPDAELIAEoAhgiCCABLQAEIA5CIIinajoAACABIAhBAWoiCDYCGAJAIAggASgCHEcNACABKAIwDQAgCCABKAIgIgZrIQcCQCAHIAEoAiQiCCAGIAcgCCgCABECAEYNACABQQk2AjALIAEgASgCICIINgIYIAEgASkDKCAHrXw3AygLIAEgASkDEEJ/fCIPNwMQIAEpAwghDgJAIA9QDQADQCAIIA5CIIinQX9qOgAAIAEgCEEBaiIINgIYAkAgCCABKAIcRw0AIAEoAjANACAIIAEoAiAiBmshBwJAIAcgASgCJCIIIAYgByAIKAIAEQIARg0AIAFBCTYCMAsgASABKAIgIgg2AhggASABKQMoIAetfDcDKAsgASABKQMQQn98Ig83AxAgASkDCCEOIA9CAFINAAsLIAEgDqdBGHY6AAQgASgCACEGQgEhDwsgASAPNwMQIAEgDkIIhkKA/v//D4MiDjcDCAsgBkELdiAALwECIgdsIQgCQCACQQ9LDQAgASAINgIAIAAgB0GAECAHa0EFdmo7AQICQCAIQf///wdLDQAgASAIQQh0NgIAAkACQCAOQv////8PVg0AIA6nQYCAgHhJDQAgASkDEEIBfCEPDAELIAEoAhgiCCABLQAEIA5CIIinajoAACABIAhBAWoiCDYCGAJAIAggASgCHEcNACABKAIwDQAgCCABKAIgIgZrIQcCQCAHIAEoAiQiCCAGIAcgCCgCABECAEYNACABQQk2AjALIAEgASgCICIINgIYIAEgASkDKCAHrXw3AygLIAEgASkDEEJ/fCIPNwMQIAEpAwghDgJAIA9QDQADQCAIIA5CIIinQX9qOgAAIAEgCEEBaiIINgIYAkAgCCABKAIcRw0AIAEoAjANACAIIAEoAiAiBmshBwJAIAcgASgCJCIIIAYgByAIKAIAEQIARg0AIAFBCTYCMAsgASABKAIgIgg2AhggASABKQMoIAetfDcDKAsgASABKQMQQn98Ig83AxAgASkDCCEOIA9CAFINAAsLIAEgDqdBGHY6AARCASEPCyABIA83AxAgASAOQgiGQoD+//8PgyIONwMICyACQXhqIQIgACADQQR0akGEAmohCUEDIQdBASEIA0AgASgCACIKQQt2IAkgCEEBdCILaiIMLwEAIgZsIQgCQAJAIAIgB0F/aiIHdkEBcSINDQAgASAINgIAQYAQIAZrQQV2IAZqIQYMAQsgASAKIAhrIgo2AgAgASAOIAitfCIONwMIIAYgBkEFdmshBiAKIQgLIAwgBjsBAAJAIAhB////B0sNACABIAhBCHQ2AgACQAJAIA5C/////w9WDQAgDqdBgICAeEkNACABKQMQQgF8IQ8MAQsgASgCGCIIIAEtAAQgDkIgiKdqOgAAIAEgCEEBaiIINgIYAkAgCCABKAIcRw0AIAEoAjANACAIIAEoAiAiDGshBgJAIAYgASgCJCIIIAwgBiAIKAIAEQIARg0AIAFBCTYCMAsgASABKAIgIgg2AhggASABKQMoIAatfDcDKAsgASABKQMQQn98Ig83AxAgASkDCCEOAkAgD1ANAANAIAggDkIgiKdBf2o6AAAgASAIQQFqIgg2AhgCQCAIIAEoAhxHDQAgASgCMA0AIAggASgCICIMayEGAkAgBiABKAIkIgggDCAGIAgoAgARAgBGDQAgAUEJNgIwCyABIAEoAiAiCDYCGCABIAEpAyggBq18NwMoCyABIAEpAxBCf3wiDzcDECABKQMIIQ4gD0IAUg0ACwsgASAOp0EYdjoABEIBIQ8LIAEgDzcDECABIA5CCIZCgP7//w+DIg43AwgLIA0gC3IhCCAHDQAMAgALAAsgASAGIAhrIgY2AgAgASAOIAitfCIONwMIIAAgByAHQQV2azsBAgJAIAZB////B0sNACABIAZBCHQ2AgACQAJAIA5C/////w9W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lwEgVCgCBCGYASBWKAIEIZkBIFgoAgQhmgEgWigCBCGbASBcKAIEIZwBIF4oAgQhnQEgYCgCBCGeASBiKAIEIZ8BIGQoAgQhoAEgZigCBCGhASBoKAIEIaIBIGooAgQhowEgbCgCBCGkASBuKAIEIaUBIHAoAgQhpgEgcigCBCGnASB0KAIEIagBIHYoAgQhqQEgAygCBCGqASABIAMoAgggdigCCGogdCgCCGogcigCCGogcCgCCGogbigCCGogbCgCCGogaigCCGogaCgCCGogZigCCGogZCgCCGogYigCCGogYCgCCGogXigCCGogXCgCCGogWigCCGogWCgCCGogVigCCGogVCgCCGogUigCCGogUCgCCGogTigCCGogTCgCCGogSigCCGogSCgCCGogRigCCGogRCgCCGogQigCCGogQCgCCGogPigCCGogPCgCCGogOigCCGogOCgCCGogNigCCGogNCgCCGogMigCCGogMCgCCGogLigCCGogLCgCCGogKigCCGogKCgCCGogJigCCGogJCgCCGogIigCCGogICgCCGogHigCCGogDSgCCGogDCgCCGogECgCCGogBCgCCGoiAzsBzAEgASADQRB2OwHOASABIHkgeiB7IHwgfSB+IH8ggAEggQEgggEggwEghAEghQEghgEghwEgiAEgiQEgigEgiwEgjAEgjQEgjgEgjwEgkAEgkQEgkgEgkwEglAEglQEglgEglwEgmAEgmQEgmgEgmwEgnAEgnQEgngEgnwEgoAEgoQEgogEgowEgpAEgpQEgpgEgpwEgqAEgqgEgqQFqampqampqampqampqampqampqampqampqampqampqampqampqampqampqampqampqIgM7AcgBIAEgA0EQdjsBygEgASAaIBsgHCAdIB8gISAjICUgJyApICsgLSAvIDEgMyA1IDcgOSA7ID0gPyBBIEMgRSBHIEkgSyBNIE8gUSBTIFUgVyBZIFsgXSBfIGEgYyBlIGcgaSBrIG0gbyBxIHMgdSB4IHdqampqampqampqampqampqampqampqampqampqampqampqampqampqampqampqampqIgM7AcQBIAEgA0EQdjsBxgELQf+T69wDIQRBfyEQQQAhAwNAIAFBxAFqIANBAXRqLwEAIgwgBCAEIAxKIgwbIQQg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ECAla0EFdmo7AQAMAQsgIyAlICVBBXZrOwEAIBggB2shGCAnIAdrIQcgJEEBciEkCwJAICRBQGoiKUEESQ0AIClBAXFBAnIhJSApQQF2IScCQCApQQ1LDQBBASEkIClBAXQhIyAMICUgJ0F/aiIidCIpQQF0aiAjayEmQQEhJwNAICYgJ0EBdCInaiIoLwEAISUCQAJAIAdB////B00NACAHISMMAQsgB0EIdCEjIBhBCHQgGS0AAHIhGCAZQQFqIRkLAkACQCAYICNBC3YgJWwiB08NACAoICVBgBAgJWtBBXZqOwEADAELICggJSAlQQV2azsBACAkIClyISkgGCAHayEYICMgB2shByAnQQFyIScLICRBAXQhJCAiQX9qIiINAAwCAAsACyAnQXtqIScDQAJAAkAgB0H///8HTQ0AIAchJAwBCyAHQQh0ISQgGEEIdCAZLQAAciEYIBlBAWohGQsgGCAkQQF2IgdrIhhBH3UiIyAlQQF0QQFyaiElICMgB3EgGGohGCAnQX9qIicNAAsgCi8BxgwhJwJAAkAgJEH///8PTQ0AIBkhJAwBCyAZQQFqISQgB0EIdCEHIBhBCHQgGS0AAHIhGAsgJUEEdCEpAkACQCAYIAdBC3YgJ2wiJU8NACAKICdBgBAgJ2tBBXZqOwHGDEECIQcMAQsgCiAnICdBBXZrOwHGDCApQQFyISkgGCAlayEYIAcgJWshJUEDIQcLIA0gB0EBdCIZaiIiLwEAIScCQAJAICVB////B00NACAkISMMAQsgJEEBaiEjICVBCHQhJSAYQQh0ICQtAAByIRgLAkACQCAYICVBC3YgJ2wiB08NACAiICdBgBAgJ2tBBXZqOwEADAELICIgJyAnQQV2azsBACApQQJyISkgGCAHayEYICUgB2shByAZQQFyIRkLIA0gGUEBdCIZaiIiLwEAIScCQAJAIAdB////B00NACAjISQMAQsgI0EBaiEkIAdBCHQhByAYQQh0ICMtAAByIRgLAkACQCAYIAdBC3YgJ2wiJU8NACAiICdBgBAgJ2tBBXZqOwEADAELICIgJyAnQQV2azsBACApQQRyISkgGCAlayEYIAcgJWshJSAZQQFyIRkLIA0gGUEBdGoiIy8BACEnAkACQCAlQf///wdNDQAgJCEZDAELICRBAWohGSAlQQh0ISUgGEEI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IQUgBEEANgIMAkAgACABQX0gBEEMahCAA0UNACAEKAIMIgYoAgwiASgCICEFAkACQCAAKAI0RQ0AIAYoAggiBkUNASAGQn83AgAgBkEIakL/////bzcCAAsCQCABKAI4IgJFDQAgAhC7CQtBACECIAFBADYCOCABQgA3AwAgASABKAIgQf////8HcTYCICAAIAAoAswCIANyNgLMAiAAIAAoArQCQQFqNgK0AgsgBEEMahC+AwsgACAAKALMAiACcjYCzAICQCAEQRBqIggjAkkEQBAjCyAIJAALIAULmwEBAX8CQCAAKALMAiIBQcAAcQ0AAkAgAUGADHENACAAIABB0swBQYAEQYAIEJMDNgK8AiAAKALMAiEBCwJAIAFBgDBxDQAgACAAQd3MAUGAEEGAIBCTAzYCwAIgACgCzAIhAQsCQCABQYDAAXENACAAIABB6swBQYDAAEGAgAEQkwM2AsQCIAAoAswCIQELIAAgAUECcjYCzAILC+wBAgd/AX4CQCMAQRBrIgIiByMCSQRAECMLIAckAAsgACgCMCEDQQAhBCACQQA6AA8CQCADKAAcIgVFDQAgACgC0AIiBkECSw0AAkACQAJAIAYOAwABAgALIAAgACkDECADMwAqQiCGIAM1ABSEfCIJIAlC/////w+DIAMvAAwbIAMoAEwgBUEEdEGj547kfiACQQ9qELMDIgNFDQICQCACLQAPDQAgAyEEDAMLIAAgACgCzAJBFHI2AswCIAMhBAwCCyAAEPYBIQQMAQsgABD6ASEECwJAIAJBEGoiCCMCSQRAECMLIAgkAAsgBAuiAQICfwJ+QQAhAQJAIAAoAjAiAikAPCIDUA0AIAIpAFwiBFANACAAIAMgBKdByIrR0gFB8O68nXwQhwMiAEUNAEEAIQECQCAAKAIIIgJBIEkNACAAKAIMIAJHDQAgAEEQaigCACAAQRRqKAIAIAAoAhggAEEsahCIAyICRQ0AIAIgAEEgaigCADYCKCACIAAoAiQ2AiwgAiEBCyAAELsJCyABC7cEAgd/An5BACEBAkAgACgCMCICKQA0IghQDQAgAikAZCIJUA0AIAAgCCAJp0HCitHSAUGj547kfhCHAyIARQ0AQQAhAQJAIAAoAggiAkHMAEkNACAAKAIMIAJHDQAgAEEQaigCACECQcwAELoJIgNFDQAgAEHY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IQIgASAEhiEBCyAAIAE3AwAgACACNwMIC1MBAX4CQAJAIANBwABxRQ0AIAIgA0FAaq2IIQFCACECDAELIANFDQAgAkHAACADa62GIAEgA60iBIiEIQEgAiAEiCECCyAAIAE3AwAgACACNwMIC4gEAgR/An4CQCMAQSBrIgIiBCMCSQRAECMLIAQkAAsCQAJAIAFC////////////AIMiBkKAgICAgIDA/0N8IAZCgICAgICAwIC8f3xaDQAgAEI8iCABQgSGhCEGAkAgAEL//////////w+DIgBCgYCAgICAgIAIVA0AIAZCgYCAgICAgIDAAHwhBwwCCyAGQoCAgICAgICAwAB8IQcgAEKAgICAgICAgAiFQgBSDQEgB0IBgyAHfCEHDAELAkAgAFAgBkKAgICAgIDA//8AVCAGQoCAgICAgMD//wBRGw0AIABCPIggAUIEhoRC/////////wODQoCAgICAgID8/wCEIQcMAQtCgICAgICAgPj/ACEHIAZC////////v//DAFYNAEIAIQcgBkIwiKciA0GR9wBJDQAgAkEQaiAAIAFC////////P4NCgICAgICAwACEIgYgA0H/iH9qEN4HIAIgACAGQYH4ACADaxDfByACKQMAIgZCPIggAkEIaikDAEIEhoQhBwJAIAZC//////////8PgyACKQMQIAJBEGpBCGopAwCEQgBSrYQiBkKBgICAgICAgAhUDQAgB0IBfCEHDAELIAZCgICAgICAgIAIhUIAUg0AIAdCAYMgB3whBwsCQCACQSBqIgUjAkkEQBAjCyAFJAALIAcgAUKAgICAgICAgIB/g4S/CzMBAX8gAEEBIAAbIQECQANAIAEQugkiAA0BAkAQmQgiAEUNACAAEQoADAELCxAYAAsgAAsHACAAEOEHCwcAIAAQuwkLSAEDfwJAIwBBEGsiBCIFIwJJBEAQIwsgBSQACyAEIAM2AgwgACABIAIgAxC/ByEDAkAgBEEQaiIGIwJJBEAQIwsgBiQACyADCwoAQZiuAhDmBwALBQAQGAALBwAgABDqBwsHACAAEOsHC68BAQV/AkAjAEEQayIDIgYjAkkEQBAjCyAGJAALAkAgABDsByACSQ0AAkACQCACQQpLDQAgACACEO0HIAAQ7gchBAwBCyACEO8HIQQgACAAEPAHIARBAWoiBRDxByIE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IAIgASgCODYCOCACIAEoAjw2AjwgAUHAAGohASACQcAAaiICIAVNDQALCyACIARPDQEDQCACIAEoAgA2AgAgAUEEaiEBIAJBBGoiAiAESQ0ADAIACwALAkAgA0EETw0AIAAhAgwBCwJAIANBfGoiBCAATw0AIAAhAgwBCyAAIQIDQCACIAEtAAA6AAAgAiABLQABOgABIAIgAS0AAjoAAiACIAEtAAM6AAMgAUEEaiEBIAJBBGoiAiAETQ0ACwsCQCACIANPDQADQCACIAEtAAA6AAAgAUEBaiEBIAJBAWoiAiADRw0ACwsgAAvzAgIDfwF+AkAgAkUNACACIABqIgNBf2ogAToAACAAIAE6AAAgAkEDSQ0AIANBfmogAToAACAAIAE6AAEgA0F9aiABOgAAIAAgAToAAiACQQdJDQAgA0F8aiABOgAAIAAgAToAAyACQQlJDQAgAEEAIABrQQNxIgRqIgMgAUH/AXFBgYKECGwiATYCACADIAIgBGtBfHEiBGoiAkF8aiABNgIAIARBCUkNACADIAE2AgggAyABNgIEIAJBeGogATYCACACQXRqIAE2AgAgBEEZSQ0AIAMgATYCGCADIAE2AhQgAyABNgIQIAMgATYCDCACQXBqIAE2AgAgAkFsaiABNgIAIAJBaGogATYCACACQWRqIAE2AgAgBCADQQRxQRhyIgVrIgJBIEkNACABrSIGQiCGIAaEIQYgAyAFaiEBA0AgASAGNwMYIAEgBjcDECABIAY3AwggASAGNwMAIAFBIGohASACQWBqIgJBH0sNAAsLIAAL/QIBAn8CQCAAIAFGDQACQAJAIAEgAmogAE0NACAAIAJqIgMgAUsNAQsgACABIAIQwwkPCyABIABzQQNxIQQCQAJAAkAgACABTw0AAkAgBEUNACAAIQQMAwsCQCAAQQNxDQAgACEEDAILIAAhBANAIAJFDQQgBCABLQAAOgAAIAFBAWohASACQX9qIQIgBEEBaiIEQQNxRQ0CDAAACwALAkAgBA0AAkAgA0EDcUUNAANAIAJFDQUgACACQX9qIgJqIgQgASACai0AADoAACAEQQNxDQALCyACQQNNDQADQCAAIAJBfGoiAmogASACaigCADYCACACQQNLDQALCyACRQ0CA0AgACACQX9qIgJqIAEgAmotAAA6AAAgAg0ADAMACwAL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IAEgAUGYAmpB+8sCENkJKQIANwMIQQAhAiAAIAFBCGoQ2glFDRUgAUEBNgKQASAAIAFBkAFqEOQLIQIMFQsgACAAKAIAQQFqNgIAIAAQ2wkhACABIAFBkAJqQf/LAhDZCSkCADcDGCAAIAFBGGoQ4wshAgwUCyAAIAAoAgBBAWo2AgAgABDbCSEAIAEgAUGIAmpBhMwCENkJKQIANwMgIAAgAUEgahDjCyECDBMLIAAgACgCAEEBajYCACAAENsJIQAgASABQYACakGQzAIQ2QkpAgA3AyggACABQShqEOMLIQIMEgsgACAAKAIAQQFqNgIAIAAQ2wkhACABIAFB+AFqQZ7MAhDZCSkCADcDMCAAIAFBMGoQ4wshAgwRCyAAIAAoAgBBAWo2AgAgABDbCSEAIAEgAUHwAWpBpMwCENkJKQIANwM4IAAgAUE4ahDjCyECDBALIAAgACgCAEEBajYCACAAENsJIQAgASABQegBakGzzAIQ2QkpAgA3A0AgACABQcAAahDjCyECDA8LIAAgACgCAEEBajYCACAAENsJIQAgASABQeABakG0zAIQ2QkpAgA3A0ggACABQcgAahDjCyECDA4LIAAgACgCAEEBajYCACAAENsJIQAgASABQdgBakG2zAIQ2QkpAgA3A1AgACABQdAAahDjCyECDA0LIAAgACgCAEEBajYCACAAENsJIQAgASABQdABakG4zAIQ2QkpAgA3A1ggACABQdgAahDjCyECDAwLIAAgACgCAEEBajYCACAAENsJIQAgASABQcgBakG7zAIQ2QkpAgA3A2AgACABQeAAahDjCyECDAsLIAAgACgCAEEBajYCACAAENsJIQAgASABQcABakG+zAIQ2QkpAgA3A2ggACABQegAahDjCyECDAoLIAAgACgCAEEBajYCACAAENsJIQAgASABQbgBakHCzAIQ2QkpAgA3A3AgACABQfAAahDjCyECDAkLIAAgACgCAEEBajYCACAAENsJIQAgASABQbABakHLzAIQ2QkpAgA3A3ggACABQfgAahDjCyECDAgLIAAgACgCAEEBajYCACAAENsJEOULIQIMBwsgACAAKAIAQQFqNgIAIAAQ2wkQ5gshAgwGCyAAIAAoAgBBAWo2AgAgABDbCRDnCyECDAULIAEgAUGoAWpBhMICENkJKQIANwOAAQJA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IAIQ9QsgAxD2CxD3CwsWACAAQaADakGmygIQ+AsgASACEPkLC2EBBH8CQCMAQRBrIgIiBCMCSQRAECMLIAQkAAsgAiAAENsJEMcKIgM2AgwCQAJAIAMNAEEAIQAMAQsgACABIAJBDGoQ7wshAAsCQCACQRBqIgUjAkkEQBAjCyAFJAALIAALDwAgAEGgA2ogASACEIIMC4IDAQV/AkAjAEEQayIBIgQjAkkEQBAjCyAEJAALAkACQAJAIABBABDdCUHkAEcNAAJAIABBARDdCSICQdgARg0AAkAgAkH4AEYNACACQekARw0CIAAgACgCAEECajYCACABIAAQ2wkiAxCdCyICNgIMIAJFDQMgASADEM4LIgI2AgggAkUNAyABQQA6AAQgACABQQxqIAFBCGogAUEEahCDDCEADAQLIAAgACgCAEECajYCACABIAAQ2wkiAxDHCiICNgIMIAJFDQIgASADEM4LIgI2AgggAkUNAiABQQE6AAQgACABQQxqIAFBCGogAUEEahCDDCEADAMLIAAgACgCAEECajYCACABIAAQ2wkiAxDHCiICNgIMIAJFDQEgASADEMcKIgI2AgggAkUNASABIAMQzgsiAjYCBCACRQ0BIAAgAUEMaiABQQhqIAFBBGoQhAwhAAwCCyAAENsJEMcKIQAMAQtBACEACwJAIAFBEGoiBSMCSQRAECMLIAUkAAsgAAsSACAAQaADaiABEIUMIAIQhgwLGwAgAEGgA2pB6MoCEPALIAFB/skCEOELEIoMCxIAIABBoANqIAEgAhD/CxCHDAsUACAAQaADaiABIAIQ/wsgAxCADAsRACAAQaADaiABIAIgAxCLDAsWACAAQaADakGKywIQjAwgASACEI0MCxYAIABBoANqQafLAhDRCiABIAIQjgwLGQAgAEGgA2ogARDTCiACQf7JAhDhCxCQDAsNACAAQaADaiABEJEMCxsAIABBoANqQbzLAhDRCiABQf7JAhDhCxCSDAsNACAAQaADaiABEJMMCw0AIABBoANqIAEQlwwLDQAgAEGgA2ogARCYDAsPACAAQaADaiABIAIQlAwL4AMBCH8CQCMAQfAAayIBIgcjAkkEQBAjCyAHJAALIAEgAUHgAGpBgMoCENkJKQIANwMgIAEgACABQSBqENoJOgBvIAEgAEEBEN0JQeEARjoAXyAB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IgE2AgQgACAAIANBDGoQtg8oAgA2AgAMAAALAAsLrQEBBH8CQCMAQSBrIgIiBCMCSQRAECMLIAQkAAsCQCAALQAQDQAgAkEYaiAAQRBqQQEQtAshAyACQRBqIAAgARCyDwJAAkAgAigCFCABELgLDQAgAigCFCABELoLRQ0BCyACIAJBCGpB/skCENkJKQIANwMAIAEgAhDwCgsgAigCFCIAIAEgACgCACgCFBEDACADELYLGgsCQCACQSBqIgUjAkkEQBAjCyAFJAALCwcAIAAQ4wcLDAAgACABIAIQtw8aCwkAIAAgARC4DwsYACAAIAEoAgA2AgAgACACKAIANgIEIAALDgAgASAAIAEgABC5DxsLDQAgACgCACABKAIASAssACAAQQVBAUEBQQEQ6goaIAAgATYCCCAAQYCWAzYCACAAIAIpAgA3AgwgAAtiAgR/AX4CQCMAQRBrIgIiBCMCSQRAECMLIAQkAAsgACgCCCIDIAEgAygCACgCEBEDACACIAApAgwiBjcDACACIAY3AwggASACEPAKAkAgAkEQaiIFIwJJBEAQIwsgBSQACwsHACAAEOMHCwYAIAAkAgsEACMACyEBAn8CQCMAIABrQXBxIgEiAiMCSQRAECMLIAIkAAsgAQsUAQF/IAAiASMCSQRAECMLIAEkAAsGACAAQAALCQAgASAAEQEACw0AIAEgAiADIAARAgALCwAgASACIAARAAALBwAgABEEAAsJACABIAARBQALDwAgASACIAMgBCAAEQYACxEAIAEgAiADIAQgBSAAEQcACxMAIAEgAiADIAQgBSAGIAARDAALCwAgASACIAARDgALEwAgASACIAMgBCAFIAYgABEPAAsLACABIAIgABEDAAsNACABIAIgAyAAEQgACxMAIAEgAiADIAQgBSAGIAARCwALDQAgASACIAMgABEWAAsNACABIAIgAyAAEREACxMAIAEgAiADIAQgBSAGIAARFwALBwAgABEKAAsRACABIAIgAyAEIAUgABENAAsPACABIAIgAyAEIAARCQALEwAgACABIAKtIAOtQiCGhBDKDwsjACAAIAEgAq0gA61CIIaEIAStIAWtQiCGhCAGIAcgCBDLDwsdACAAIAEgAq0gA61CIIaEIAStIAWtQiCGhBDPDwskAQF+IAAgASACrSADrUIghoQgBBDQ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IE5VTEwAUCAhPSBOVUxMAC9Vc2Vycy9taWNoYWVsL0RvY3VtZW50cy9Xb3JrYmVuY2gvV293c2VyL3JlcG9zL3N0b3JtanMvYnVpbGQvZGVidWcvU3Rvcm1MaWIvc3JjL2xpYnRvbWNyeXB0L3NyYy9way9lY2MvbHRjX2VjY19wcm9qZWN0aXZlX2RibF9wb2ludC5jAFIgIT0gTlVMTABtb2R1bHVzICE9IE5VTEwAbXAgIT0gTlVMTABQICE9IE5VTEwAL1VzZXJzL21pY2hhZWwvRG9jdW1lbnRzL1dvcmtiZW5jaC9Xb3dzZXIvcmVwb3Mvc3Rvcm1qcy9idWlsZC9kZWJ1Zy9TdG9ybUxpYi9zcmMvbGlidG9tY3J5cHQvc3JjL3BrL2VjYy9sdGNfZWNjX3Byb2plY3RpdmVfYWRkX3BvaW50LmMAUSAhPSBOVUxMAFIgIT0gTlVMTABtb2R1bHVzICE9IE5VTEwAbXAgIT0gTlVMTABBICE9IE5VTEwAL1VzZXJzL21pY2hhZWwvRG9jdW1lbnRzL1dvcmtiZW5jaC9Xb3dzZXIvcmVwb3Mvc3Rvcm1qcy9idWlsZC9kZWJ1Zy9TdG9ybUxpYi9zcmMvbGlidG9tY3J5cHQvc3JjL3BrL2VjYy9sdGNfZWNjX211bDJhZGQuYwBCICE9IE5VTEwAQyAhPSBOVUxMAGtBICE9IE5VTEwAa0IgIT0gTlVMTABtb2R1bHVzICE9IE5VTEwATiAhPSBOVUxMAC9Vc2Vycy9taWNoYWVsL0RvY3VtZW50cy9Xb3JrYmVuY2gvV293c2VyL3JlcG9zL3N0b3JtanMvYnVpbGQvZGVidWcvU3Rvcm1MaWIvc3JjL2xpYnRvbWNyeXB0L3NyYy9tYXRoL3JhbmRfcHJpbWUuYwBsdGNfbXAubmFtZSAhPSBOVUxMAC9Vc2Vycy9taWNoYWVsL0RvY3VtZW50cy9Xb3JrYmVuY2gvV293c2VyL3JlcG9zL3N0b3JtanMvYnVpbGQvZGVidWcvU3Rvcm1MaWIvc3JjL2xpYnRvbWNyeXB0L3NyYy9way9yc2EvcnNhX21ha2Vfa2V5LmMAa2V5ICE9IE5VTEwAb3V0ICE9ICgodm9pZCopMCkAL1VzZXJzL21pY2hhZWwvRG9jdW1lbnRzL1dvcmtiZW5jaC9Xb3dzZXIvcmVwb3Mvc3Rvcm1qcy9idWlsZC9kZWJ1Zy9TdG9ybUxpYi9zcmMvbGlidG9tY3J5cHQvc3JjL21pc2MvemVyb21lbS5jAGluICE9IE5VTEwAL1VzZXJzL21pY2hhZWwvRG9jdW1lbnRzL1dvcmtiZW5jaC9Xb3dzZXIvcmVwb3Mvc3Rvcm1qcy9idWlsZC9kZWJ1Zy9TdG9ybUxpYi9zcmMvbGlidG9tY3J5cHQvc3JjL3BrL3JzYS9yc2FfZXhwdG1vZC5jAG91dCAhPSBOVUxMAG91dGxlbiAhPSBOVUxMAGtleSAhPSBOVUxMAExpYlRvbU1hdGgAANQSAAAcAAAADwAAABAAAAARAAAAEgAAABMAAAAUAAAAFQAAABYAAAAXAAAAGAAAABkAAAAaAAAAGwAAABwAAAAdAAAAHgAAAB8AAAAgAAAAIQAAACIAAAAjAAAAJAAAACUAAAAmAAAAJwAAACgAAAApAAAAKgAAACsAAAAsAAAALQAAAC4AAAAvAAAAMAAAADEAAAAyAAAAMwAAADQAAAA1AAAANgAAADcAAAA4AAAAOQAAADoAAAA7AAAAPAAAAD0AAABhICE9IE5VTEwAL1VzZXJzL21pY2hhZWwvRG9jdW1lbnRzL1dvcmtiZW5jaC9Xb3dzZXIvcmVwb3Mvc3Rvcm1qcy9idWlsZC9kZWJ1Zy9TdG9ybUxpYi9zcmMvbGlidG9tY3J5cHQvc3JjL21hdGgvbHRtX2Rlc2MuYwAAAAAAAAAAAAD+////DQAAAP3///8QAAAAYSAhPSAoKHZvaWQqKTApAGIgIT0gTlVMTABjICE9IE5VTEwAZCAhPSBOVUxMAGZsYXQtAHBhcnQtAG1wcWUtAGJsazQtAGZpbGU6AG1hcDoAaHR0cDoAAFgAAABZAAAAWgAAAFsAAAAldQAAAAAAAAAAAAAAAAAAIBUAAEEVAABiFQAAgxUAAKQVAADFFQAA5hUAAAcWAAAoFgAASRYAAGoWAACLFgAArBYAAM0WAADuFgAADxcAADAXAABRFwAAchcAAJMXAAC0FwAA1RcAAPYXAAAXGAAAOBgAAFkYAAB6GAAAAAAAAFM0OEI2Q0RUTjVYRVFBS1FESk5ETEpCSjczRkRGTTNVAFVDTVhGNkVKWTM1MkVGSDRYRlJYQ0ZIMlhDOU1RUlpLAE1NS1ZIWTQ4UlA3V1hQNEdIWUJRN1NMOUo5VU5QSEJQADhNWExXSFE3VkdHTFRaOU1RWlFTRkRDTEpZRVQzQ1BQAEVKMlI1VE02WEZFMkdVTkc1UURHSEtROVVBS1BXWlNaAFBCR0ZCRTQyWjZMTks2NVVHSlEzV1pWTUNMUDRIUVFUAFg3U0VKSlM5VFNHQ1c1UDI4RUJTQzQ3QUpQRVk4VlUyADVLVkJRQThWWUU2WFJZM0RMR0M1WkRFNFhTNFA3WUEyADQ3OEpEMks1NkVWTlZWWTRYWDhURFdZVDVCOEtCMjU0ADhUUzRWTkZRUlpUTjZZV0hFOUNIVkRIOU5WV0Q0NzRBAExKNTJaMzJERjRMWjRaSkpYVktLM0FaUUE2R0FCTEpCAEs2QkRIWTJFQ1VFMjU0NVlLTkxCSlBWWVdIRTdYWUFHAE5EVlc4R1dMQVlDUlBHUk5ZOFJUN1paVVFVNjNWTFBSADZWV0NRVE44VjNaWk1SVUNaWFY4QThDR1VYMlRBQThIAFk0NU1EM0NBSzRLWFNTWEhZRDlWWTY0WjhFS0o0WEZYAEc4TU44VURHNk5BMkFOR1k2QTNETlk4MkhSR0YyOVpIAFc5UlJITEIyRkRVOVdXNUIzRUNFQkxSU0ZXWlNGN0hXADNESDVSRTVOVk01R1RGRDg1TFhHV1Q2Rks4NTlFVFI1ADhXTEtVQVhFOTRQRlFVNFkyNDlQQVoyNE40UjRYS1RRAEEzNERYWDNWSEdHWFNRQlJGRTVVRkZEWE1GOUc0RzU0AFpHN0o5SzkzOEhKRUZXUFFVQTc2OE1BMlBGRVI2RUFKAE5FN0NVTk5OVFZBUFhWN0UzRzJCU1ZCV0dWTVc4QkwyADNWOUUyRlRNQk05UVFXSzdVNk1BTVdBWldRREI4MzhGADJOU0ZCOE1FTFVMSjgzVTZZSEEzVVA2SzRNUUQ0OEw2AFFBMlRaOUVXWjRDVVU4Qk1CNVdYQ1RZNjVGOUNTVzRFAFZIQjM3OFc2NEJBVDlTSDdENjhWVjlOTFFESzlZRUdUAFUzTkZRSlY0TTZHQzdLQk45WFFKM0JSRE4zUExEOU5FAGV4cGFuZCAzMi1ieXRlIGswMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAJXMuJXUAAAAAAAAA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pgAIAGYACADmAAgAFgAIAJYACABWAAgA1gAIADYACAC2AAgAdgAIAPYACAAOAAgAjgAIAE4ACADOAAgALgAIAK4ACABuAAgA7gAIAB4ACACeAAgAXgAIAN4ACAA+AAgAvgAIAH4ACAD+AAgAAQAIAIEACABBAAgAwQAIACEACAChAAgAYQAIAOEACAARAAgAkQAIAFEACADRAAgAMQAIALEACABxAAgA8QAIAAkACACJAAgASQAIAMkACAApAAgAqQAIAGkACADpAAgAGQAIAJkACABZAAgA2QAIADkACAC5AAgAeQAIAPkACAAFAAgAhQAIAEUACADFAAgAJQAIAKUACABlAAgA5QAIABUACACVAAgAVQAIANUACAA1AAgAtQAIAHUACAD1AAgADQAIAI0ACABNAAgAzQAIAC0ACACtAAgAbQAIAO0ACAAdAAgAnQAIAF0ACADdAAgAPQAIAL0ACAB9AAgA/QAIABMACQATAQkAkwAJAJMBCQBTAAkAUwEJANMACQDTAQkAMwAJADMBCQCzAAkAswEJAHMACQBzAQkA8wAJAPMBCQALAAkACwEJAIsACQCLAQkASwAJAEsBCQDLAAkAywEJACsACQArAQkAqwAJAKsBCQBrAAkAawEJAOsACQDrAQkAGwAJABsBCQCbAAkAmwEJAFsACQBbAQkA2wAJANsBCQA7AAkAOwEJALsACQC7AQkAewAJAHsBCQD7AAkA+wEJAAcACQAHAQkAhwAJAIcBCQBHAAkARwEJAMcACQDHAQkAJwAJACcBCQCnAAkApwEJAGcACQBnAQkA5wAJAOcBCQAXAAkAFwEJAJcACQCXAQkAVwAJAFcBCQDXAAkA1wEJADcACQA3AQkAtwAJALcBCQB3AAkAdwEJAPcACQD3AQkADwAJAA8BCQCPAAkAjwEJAE8ACQBPAQkAzwAJAM8BCQAvAAkALwEJAK8ACQCvAQkAbwAJAG8BCQDvAAkA7wEJAB8ACQAfAQkAnwAJAJ8BCQBfAAkAXwEJAN8ACQDfAQkAPwAJAD8BCQC/AAkAvwEJAH8ACQB/AQkA/wAJAP8BCQAAAAcAQAAHACAABwBgAAcAEAAHAFAABwAwAAcAcAAHAAgABwBIAAcAKAAHAGgABwAYAAcAWAAHADgABwB4AAcABAAHAEQABwAkAAcAZAAHABQABwBUAAcANAAHAHQABwADAAgAgwAIAEMACADDAAgAIwAIAKMACABjAAgA4wAIAAAABQAQAAUACAAFABgABQAEAAUAFAAFAAwABQAcAAUAAgAFABIABQAKAAUAGgAFAAYABQAWAAUADgAFAB4ABQABAAUAEQAFAAkABQAZAAUABQAFABUABQANAAUAHQAFAAMABQATAAUACwAFABsABQAHAAUAFwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAQAAAAEAAAABAAAAAgAAAAIAAAACAAAAAgAAAAMAAAADAAAAAwAAAAMAAAAEAAAABAAAAAQAAAAEAAAABQAAAAUAAAAFAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAEAAAACAAAAAgAAAAMAAAADAAAABAAAAAQAAAAFAAAABQAAAAYAAAAGAAAABwAAAAcAAAAIAAAACAAAAAkAAAAJAAAACgAAAAoAAAALAAAACwAAAAwAAAAMAAAADQAAAA0AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAAAAAwAAAAcAAAAAAAAAEBESAAgHCQYKBQsEDAMNAg4BDwAAAAAAAAAAAAAAAAAAAAAAAQAAAAIAAAADAAAABAAAAAUAAAAGAAAABwAAAAgAAAAKAAAADAAAAA4AAAAQAAAAFAAAABgAAAAcAAAAIAAAACgAAAAwAAAAOAAAAEAAAABQAAAAYAAAAHAAAACAAAAAoAAAAMAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAgAAAAMAAAAEAAAABgAAAAgAAAAMAAAAEAAAABgAAAAgAAAAMAAAAEAAAABgAAAAgAAAAMAAAAAAAQAAgAEAAAACAAAAAwAAAAQAAAAGAAAACAAAAAwAAAAQAAAAGAAAACAAAAAwAAAAQAAAAGAAAAAAAAAAAAAAAAAAAAAAAABgAAAABAAEAAgABABhAAAABAAFABAACABhAAAABAAGACAAIABhAAAABAAEABAAEABiAAAACAAQACAAIABiAAAACAAQAIAAgABiAAAACAAgAIAAAAFiAAAAIACAAAIBAARiAAAAIAACAQIBABBiAAAAAAAAAAAAAAADAAQABQAGAAcACAAJAAoACwANAA8AEQATABcAGwAfACMAKwAzADsAQwBTAGMAcwCDAKMAwwDjAAIBAAAAAAAAEAAQABAAEAAQABAAEAAQABEAEQARABEAEgASABIAEgATABMAEwATABQAFAAUABQAFQAVABUAFQAQAEkAwwAAAAEAAgADAAQABQAHAAkADQARABkAIQAxAEEAYQCBAMEAAQGBAQECAQMBBAEGAQgBDAEQARgBIAEwAUABYAAAAAAQABAAEAAQABEAEQASABIAEwATABQAFAAVABUAFgAWABcAFwAYABgAGQAZABoAGgAbABsAHAAcAB0AHQBAAEAAaW52YWxpZCBkaXN0YW5jZSB0b28gZmFyIGJhY2sAaW52YWxpZCBkaXN0YW5jZSBjb2RlAGludmFsaWQgbGl0ZXJhbC9sZW5ndGggY29kZQAQABEAEgAAAAgABwAJAAYACgAFAAsABAAMAAMADQACAA4AAQAPAGluY29ycmVjdCBoZWFkZXIgY2hlY2sAdW5rbm93biBjb21wcmVzc2lvbiBtZXRob2QAaW52YWxpZCB3aW5kb3cgc2l6ZQB1bmtub3duIGhlYWRlciBmbGFncyBzZXQAaGVhZGVyIGNyYyBtaXNtYXRjaABpbnZhbGlkIGJsb2NrIHR5cGUAaW52YWxpZCBzdG9yZWQgYmxvY2sgbGVuZ3RocwB0b28gbWFueSBsZW5ndGggb3IgZGlzdGFuY2Ugc3ltYm9scwBpbnZhbGlkIGNvZGUgbGVuZ3RocyBzZXQAaW52YWxpZCBiaXQgbGVuZ3RoIHJlcGVhdABpbnZhbGlkIGNvZGUgLS0gbWlzc2luZyBlbmQtb2YtYmxvY2sAaW52YWxpZCBsaXRlcmFsL2xlbmd0aHMgc2V0AGludmFsaWQgZGlzdGFuY2VzIHNldABpbnZhbGlkIGxpdGVyYWwvbGVuZ3RoIGNvZGUAaW52YWxpZCBkaXN0YW5jZSBjb2RlAGludmFsaWQgZGlzdGFuY2UgdG9vIGZhciBiYWNrAGluY29ycmVjdCBkYXRhIGNoZWNrAGluY29ycmVjdCBsZW5ndGggY2hlY2sAAAAAAAAAAAAAAAAAAGAHAAAACFAAAAgQABQIcwASBx8AAAhwAAAIMAAACcAAEAcKAAAIYAAACCAAAAmgAAAIAAAACIAAAAhAAAAJ4AAQBwYAAAhYAAAIGAAACZAAEwc7AAAIeAAACDgAAAnQABEHEQAACGgAAAgoAAAJsAAACAgAAAiIAAAISAAACfAAEAcEAAAIVAAACBQAFQjjABMHKwAACHQAAAg0AAAJyAARBw0AAAhkAAAIJAAACagAAAgEAAAIhAAACEQAAAnoABAHCAAACFwAAAgcAAAJmAAUB1MAAAh8AAAIPAAACdgAEgcXAAAIbAAACCwAAAm4AAAIDAAACIwAAAhMAAAJ+AAQBwMAAAhSAAAIEgAVCKMAEwcjAAAIcgAACDIAAAnEABEHCwAACGIAAAgiAAAJpAAACAIAAAiCAAAIQgAACeQAEAcHAAAIWgAACBoAAAmUABQHQwAACHoAAAg6AAAJ1AASBxMAAAhqAAAIKgAACbQAAAgKAAAIigAACEoAAAn0ABAHBQAACFYAAAgWAEAIAAATBzMAAAh2AAAINgAACcwAEQcPAAAIZgAACCYAAAmsAAAIBgAACIYAAAhGAAAJ7AAQBwkAAAheAAAIHgAACZwAFAdjAAAIfgAACD4AAAncABIHGwAACG4AAAguAAAJvAAACA4AAAiOAAAITgAACfwAYAcAAAAIUQAACBEAFQiDABIHHwAACHEAAAgxAAAJwgAQBwoAAAhhAAAIIQAACaIAAAgBAAAIgQAACEEAAAniABAHBgAACFkAAAgZAAAJkgATBzsAAAh5AAAIOQAACdIAEQcRAAAIaQAACCkAAAmyAAAICQAACIkAAAhJAAAJ8gAQBwQAAAhVAAAIFQAQCAIBEwcrAAAIdQAACDUAAAnKABEHDQAACGUAAAglAAAJqgAACAUAAAiFAAAIRQAACeoAEAcIAAAIXQAACB0AAAmaABQHUwAACH0AAAg9AAAJ2gASBxcAAAhtAAAILQAACboAAAgNAAAIjQAACE0AAAn6ABAHAwAACFMAAAgTABUIwwATByMAAAhzAAAIMwAACcYAEQcLAAAIYwAACCMAAAmmAAAIAwAACIMAAAhDAAAJ5gAQBwcAAAhbAAAIGwAACZYAFAdDAAAIewAACDsAAAnWABIHEwAACGsAAAgrAAAJtgAACAsAAAiLAAAISwAACfYAEAcFAAAIVwAACBcAQAgAABMHMwAACHcAAAg3AAAJzgARBw8AAAhnAAAIJwAACa4AAAgHAAAIhwAACEcAAAnuABAHCQAACF8AAAgfAAAJngAUB2MAAAh/AAAIPwAACd4AEgcbAAAIbwAACC8AAAm+AAAIDwAACI8AAAhPAAAJ/gBgBwAAAAhQAAAIEAAUCHMAEgcfAAAIcAAACDAAAAnBABAHCgAACGAAAAggAAAJoQAACAAAAAiAAAAIQAAACeEAEAcGAAAIWAAACBgAAAmRABMHOwAACHgAAAg4AAAJ0QARBxEAAAhoAAAIKAAACbEAAAgIAAAIiAAACEgAAAnxABAHBAAACFQAAAgUABUI4wATBysAAAh0AAAINAAACckAEQcNAAAIZAAACCQAAAmpAAAIBAAACIQAAAhEAAAJ6QAQBwgAAAhcAAAIHAAACZkAFAdTAAAIfAAACDwAAAnZABIHFwAACGwAAAgsAAAJuQAACAwAAAiMAAAITAAACfkAEAcDAAAIUgAACBIAFQijABMHIwAACHIAAAgyAAAJxQARBwsAAAhiAAAIIgAACaUAAAgCAAAIggAACEIAAAnlABAHBwAACFoAAAgaAAAJlQAUB0MAAAh6AAAIOgAACdUAEgcTAAAIagAACCoAAAm1AAAICgAACIoAAAhKAAAJ9QAQBwUAAAhWAAAIFgBACAAAEwczAAAIdgAACDYAAAnNABEHDwAACGYAAAgmAAAJrQAACAYAAAiGAAAIRgAACe0AEAcJAAAIXgAACB4AAAmdABQHYwAACH4AAAg+AAAJ3QASBxsAAAhuAAAILgAACb0AAAgOAAAIjgAACE4AAAn9AGAHAAAACFEAAAgRABUIgwASBx8AAAhxAAAIMQAACcMAEAcKAAAIYQAACCEAAAmjAAAIAQAACIEAAAhBAAAJ4wAQBwYAAAhZAAAIGQAACZMAEwc7AAAIeQAACDkAAAnTABEHEQAACGkAAAgpAAAJswAACAkAAAiJAAAISQAACfMAEAcEAAAIVQAACBUAEAgCARMHKwAACHUAAAg1AAAJywARBw0AAAhlAAAIJQAACasAAAgFAAAIhQAACEUAAAnrABAHCAAACF0AAAgdAAAJmwAUB1MAAAh9AAAIPQAACdsAEgcXAAAIbQAACC0AAAm7AAAIDQAACI0AAAhNAAAJ+wAQBwMAAAhTAAAIEwAVCMMAEwcjAAAIcwAACDMAAAnHABEHCwAACGMAAAgjAAAJpwAACAMAAAiDAAAIQwAACecAEAcHAAAIWwAACBsAAAmXABQHQwAACHsAAAg7AAAJ1wASBxMAAAhrAAAIKwAACbcAAAgLAAAIiwAACEsAAAn3ABAHBQAACFcAAAgXAEAIAAATBzMAAAh3AAAINwAACc8AEQcPAAAIZwAACCcAAAmvAAAIBwAACIcAAAhHAAAJ7wAQBwkAAAhfAAAIHwAACZ8AFAdjAAAIfwAACD8AAAnfABIHGwAACG8AAAgvAAAJvwAACA8AAAiPAAAITwAACf8AEAUBABcFAQETBREAGwUBEBEFBQAZBQEEFQVBAB0FAUAQBQMAGAUBAhQFIQAcBQEgEgUJABoFAQgWBYEAQAUAABAFAgAXBYEBEwUZABsFARgRBQcAGQUBBhUFYQAdBQFgEAUEABgFAQMUBTEAHAUBMBIFDQAaBQEMFgXBAEAFAAALDAwMDAwMDAwIBwwMBwwMDAwMDAwMDAwMDA0MDAwMDAQKCAwKDAoIBwcICQcGBwgHBgcHBwcIBwcICAwLBwkLDAYHBgYFBwgIBgsJBgcGBgcLBgYGBwkICQkLCAsJDAgMBQYGBgUGBgYFCwcFBgUFBgoFBQUFCAcICAoLCwwMDA0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDA0MDQ0NDA0NDQwNDQ0NDA0NDQwMDA0NDQ0NDQ0NDQ0NkATgD+AH4AvgA+AN4AXgCeABuABiAOAO4AYiAOAK4ALgDOAE4AjgAGAPYAdgC2ADYA1gBUASYAlgAWAOYAZgCg8AUAI4AGACUABgDJAD2ABCAAIAWACwAXwAKQA8AJgAXAAJABwAbAAsAEwAGAAMAHQA6ABoAGAEkAA0ALAAEAdgCDEAVAARACEAFwAUAKgAKAABABADMAE+AGQAHgAuACQAEAUOADYAFgBEADAAyADQAdAAEAFIABAGUAFgAIgAoA8HACYABgA6ABsAGgAqAAoACwAQAgQAEwAyAAMAHQASAJABDQAVAAUAGQAIAHgA8ABwAJACEAQQAKAHoAugA0ACQBxADEAUQARAGEAIQBBAAIAfgA+AF4AHgBuAC4ATgAOAHYANgBWABYAZgAmAEYABgB6ADoAWgAaAGoAKgBKAAoAcgAyAFIAEgBiACIAQgAAAHwAPABcABwAbAAsAE6ANoAWgCaABoA6gBqAKoAKgDKAEoAigACAPIAcgCyADIA0gBSAJIAEgDiAGIAogAiAMIAQgCCAAwA/AB8ALwAPADcAFwAnAAcAOwAbACsACwAzABMAIwABAD0AHQAtAAwADQA0AHQANABVABQAFABkACUAJABEAAQAeAA5AAQAWAAYAGkAOQAZACgAKABIAAgAcAAwAFAAEABgACAAQAAAAAAAAAAAAAAECAwQFBgcIAwIDAwQEBAUFBQUGBgYHBwUDAQYKAgwUBBgIMBAgQAADDQUZCREBPh4uDjYWJgY6GioKMhIiQgJ8PFwcbCxMDHQ0VBRkJEQEeDhYGGgoSAjwcLAw0FCQEOBgoCDAQIAAAgQEBQUFBQYGBgYGBgYGBgYGBgYGBgcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHCAgICAgICAgICAgICAgICAsMDAwMDAwMDAgHDAwHDAwMDAwMDAwMDAwMDQwMDAwMBAoIDAoMCggHBwgJBwYHCAcGBwcHBwgHBwgIDAsHCQsMBgcGBgUHCAgGCwkGBwYGBwsGBgYHCQgJCQsICwkMCAwFBgYGBQYGBgULBwUGBQUGCgUFBQUIBwgICgsLDAwMDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDQwNDQ0MDQ0NDA0NDQ0MDQ0NDAwMDQ0NDQ0NDQ0NDQ0DAgMDBAQEBQUFBQYGBgcHBQMBBgoCDBQEGAgwECBAAAAAAAAAAAAAAQIDBAUGBwgAAAEAAgADAAQABQAGAAcACAAKAA4AFgAmAEYAhgAGAQIEBAUFBQUGBgYGBgYGBgYGBgYGBgYHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwgICAgICAgICAgICAgICAgDDQUZCREBPh4uDjYWJgY6GioKMhIiQgJ8PFwcbCxMDHQ0VBRkJEQEeDhYGGgoSAjwcLAw0FCQEOBgoCDAQIAAkATgD+AH4AvgA+AN4AXgCeABuABiAOAO4AYiAOAK4ALgDOAE4AjgAGAPYAdgC2ADYA1gBUASYAlgAWAOYAZgCg8AUAI4AGACUABgDJAD2ABCAAIAWACwAXwAKQA8AJgAXAAJABwAbAAsAEwAGAAMAHQA6ABoAGAEkAA0ALAAEAdgCDEAVAARACEAFwAUAKgAKAABABADMAE+AGQAHgAuACQAEAUOADYAFgBEADAAyADQAdAAEAFIABAGUAFgAIgAoA8HACYABgA6ABsAGgAqAAoACwAQAgQAEwAyAAMAHQASAJABDQAVAAUAGQAIAHgA8ABwAJACEAQQAKAHoAugA0ACQBxADEAUQARAGEAIQBBAAIAfgA+AF4AHgBuAC4ATgAOAHYANgBWABYAZgAmAEYABgB6ADoAWgAaAGoAKgBKAAoAcgAyAFIAEgBiACIAQgAAAHwAPABcABwAbAAsAE6ANoAWgCaABoA6gBqAKoAKgDKAEoAigACAPIAcgCyADIA0gBSAJIAEgDiAGIAogAiAMIAQgCCAAwA/AB8ALwAPADcAFwAnAAcAOwAbACsACwAzABMAIwABAD0AHQAtAAwADQA0AHQANABVABQAFABkACUAJABEAAQAeAA5AAQAWAAYAGkAOQAZACgAKABIAAgAcAAwAFAAEABgACAAQAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAIAAAADAAAABAAAAAUAAAAGAAAABAAAAAUAAAAJAAAACQAAAAkAAAAJAAAACQAAAAkAAAAJAAAACwAAAAsAAAALAAAACwAAAAsAAAAIAAAACAAAAAgAAAAIAAAACAAAAAgAAAAIAAAACwAAAAsAAAALAAAACwAAAAsAAAAHAAAABwAAAAcAAAAHAAAABwAAAAcAAAAHAAAACgAAAAoAAAAKAAAACgAAAAoAAAAgICAgICAlZCB3b3JrLCAlZCBibG9jaywgcmF0aW8gJTUuMmYKACAgICB0b28gcmVwZXRpdGl2ZTsgdXNpbmcgZmFsbGJhY2sgc29ydGluZyBhbGdvcml0aG0KACAgICAgICAgYnVja2V0IHNvcnRpbmcgLi4uCgAgICAgICAgIGRlcHRoICU2ZCBoYXMgACU2ZCB1bnJlc29sdmVkIHN0cmluZ3MKACAgICAgICAgcmVjb25zdHJ1Y3RpbmcgYmxvY2sgLi4uCgAgICAgICAgIG1haW4gc29ydCBpbml0aWFsaXNlIC4uLgoAICAgICAgICBxc29ydCBbMHgleCwgMHgleF0gICBkb25lICVkICAgdGhpcyAlZAoAICAgICAgICAlZCBwb2ludGVycywgJWQgc29ydGVkLCAlZCBzY2FubmVkCgAAAAAAAAAAAAABAAAABAAAAA0AAAAoAAAAeQAAAGwBAABFBAAA0AwAAHEmAABUcwAA/VkBAPgNBADpKQwAvH0kACAgICBibG9jayAlZDogY3JjID0gMHglMDh4LCBjb21iaW5lZCBDUkMgPSAweCUwOHgsIHNpemUgPSAlZAoAICAgIGZpbmFsIGNvbWJpbmVkIENSQyA9IDB4JTA4eAogICAAICAgICAgJWQgaW4gYmxvY2ssICVkIGFmdGVyIE1URiAmIDEtMiBjb2RpbmcsICVkKzIgc3ltcyBpbiB1c2UKACAgICAgIGluaXRpYWwgZ3JvdXAgJWQsIFslZCAuLiAlZF0sIGhhcyAlZCBzeW1zICglNC4xZiUlKQoAICAgICAgcGFzcyAlZDogc2l6ZSBpcyAlZCwgZ3JwIHVzZXMgYXJlIAAlZCAAICAgICAgYnl0ZXM6IG1hcHBpbmcgJWQsIABzZWxlY3RvcnMgJWQsIABjb2RlIGxlbmd0aHMgJWQsIABjb2RlcyAlZAoACiAgICBbJWQ6IGh1ZmYrbXRmIABydCtybGQACgpiemlwMi9saWJiemlwMjogaW50ZXJuYWwgZXJyb3IgbnVtYmVyICVkLgpUaGlzIGlzIGEgYnVnIGluIGJ6aXAyL2xpYmJ6aXAyLCAlcy4KUGxlYXNlIHJlcG9ydCBpdCB0byBtZSBhdDoganNld2FyZEBiemlwLm9yZy4gIElmIHRoaXMgaGFwcGVuZWQKd2hlbiB5b3Ugd2VyZSB1c2luZyBzb21lIHByb2dyYW0gd2hpY2ggdXNlcyBsaWJiemlwMiBhcyBhCmNvbXBvbmVudCwgeW91IHNob3VsZCBhbHNvIHJlcG9ydCB0aGlzIGJ1ZyB0byB0aGUgYXV0aG9yKHMpCm9mIHRoYXQgcHJvZ3JhbS4gIFBsZWFzZSBtYWtlIGFuIGVmZm9ydCB0byByZXBvcnQgdGhpcyBidWc7CnRpbWVseSBhbmQgYWNjdXJhdGUgYnVnIHJlcG9ydHMgZXZlbnR1YWxseSBsZWFkIHRvIGhpZ2hlcgpxdWFsaXR5IHNvZnR3YXJlLiAgVGhhbmtzLiAgSnVsaWFuIFNld2FyZCwgMTAgRGVjZW1iZXIgMjAwNy4KCgAKKioqIEEgc3BlY2lhbCBub3RlIGFib3V0IGludGVybmFsIGVycm9yIG51bWJlciAxMDA3ICoqKgoKRXhwZXJpZW5jZSBzdWdnZXN0cyB0aGF0IGEgY29tbW9uIGNhdXNlIG9mIGkuZS4gMTAwNwppcyB1bnJlbGlhYmxlIG1lbW9yeSBvciBvdGhlciBoYXJkd2FyZS4gIFRoZSAxMDA3IGFzc2VydGlvbgpqdXN0IGhhcHBlbnMgdG8gY3Jvc3MtY2hlY2sgdGhlIHJlc3VsdHMgb2YgaHVnZSBudW1iZXJzIG9mCm1lbW9yeSByZWFkcy93cml0ZXMsIGFuZCBzbyBhY3RzICh1bmludGVuZGVkbHkpIGFzIGEgc3RyZXNzCnRlc3Qgb2YgeW91ciBtZW1vcnkgc3lzdGVtLgoKSSBzdWdnZXN0IHRoZSBmb2xsb3dpbmc6IHRyeSBjb21wcmVzc2luZyB0aGUgZmlsZSBhZ2FpbiwKcG9zc2libHkgbW9uaXRvcmluZyBwcm9ncmVzcyBpbiBkZXRhaWwgd2l0aCB0aGUgLXZ2IGZsYWcuCgoqIElmIHRoZSBlcnJvciBjYW5ub3QgYmUgcmVwcm9kdWNlZCwgYW5kL29yIGhhcHBlbnMgYXQgZGlmZmVyZW50CiAgcG9pbnRzIGluIGNvbXByZXNzaW9uLCB5b3UgbWF5IGhhdmUgYSBmbGFreSBtZW1vcnkgc3lzdGVtLgogIFRyeSBhIG1lbW9yeS10ZXN0IHByb2dyYW0uICBJIGhhdmUgdXNlZCBNZW10ZXN0ODYKICAod3d3Lm1lbXRlc3Q4Ni5jb20pLiAgQXQgdGhlIHRpbWUgb2Ygd3JpdGluZyBpdCBpcyBmcmVlIChHUExkKS4KICBNZW10ZXN0ODYgdGVzdHMgbWVtb3J5IG11Y2ggbW9yZSB0aG9yb3VnbHkgdGhhbiB5b3VyIEJJT1NzCiAgcG93ZXItb24gdGVzdCwgYW5kIG1heSBmaW5kIGZhaWx1cmVzIHRoYXQgdGhlIEJJT1MgZG9lc24ndC4KCiogSWYgdGhlIGVycm9yIGNhbiBiZSByZXBlYXRhYmx5IHJlcHJvZHVjZWQsIHRoaXMgaXMgYSBidWcgaW4KICBiemlwMiwgYW5kIEkgd291bGQgdmVyeSBtdWNoIGxpa2UgdG8gaGVhciBhYm91dCBpdC4gIFBsZWFzZQogIGxldCBtZSBrbm93LCBhbmQsIGlkZWFsbHksIHNhdmUgYSBjb3B5IG9mIHRoZSBmaWxlIGNhdXNpbmcgdGhlCiAgcHJvYmxlbSAtLSB3aXRob3V0IHdoaWNoIEkgd2lsbCBiZSB1bmFibGUgdG8gaW52ZXN0aWdhdGUgaXQuCgoAIHsweCUwOHgsIDB4JTA4eH0ACiAgICBjb21iaW5lZCBDUkNzOiBzdG9yZWQgPSAweCUwOHgsIGNvbXB1dGVkID0gMHglMDh4ADEuMC41LCAxMC1EZWMtMjAwNwAAAAAAAAAHAAAACAAAAAkAAAAKAAAACwAAAAwAAAANAAAADgAAABAAAAARAAAAEwAAABUAAAAXAAAAGQAAABwAAAAfAAAAIgAAACUAAAApAAAALQAAADIAAAA3AAAAPAAAAEIAAABJAAAAUAAAAFgAAABhAAAAawAAAHYAAACCAAAAjwAAAJ0AAACtAAAAvgAAANEAAADmAAAA/QAAABcBAAAzAQAAUQEAAHMBAACYAQAAwQEAAO4BAAAgAgAAVgIAAJICAADUAgAAHAMAAGwDAADDAwAAJAQAAI4EAAACBQAAgwUAABAGAACrBgAAVgcAABIIAADgCAAAwwkAAL0KAADQCwAA/wwAAEwOAAC6DwAATBEAAAcTAADuFAAABhcAAFQZAADcGwAApR4AALYhAAAVJQAAyigAAN8sAABbMQAASzYAALk7AACyQQAAREgAAH5PAABxVwAAL2AAAM5pAABidAAA/38AAAAAAAAAAAAAAAAAAP////8AAAAA/////wQAAAD/////AgAAAP////8GAAAA/////wEAAAD/////BQAAAP////8DAAAA/////wcAAAD/////AQAAAP////8FAAAA/////wMAAAD/////BwAAAP////8CAAAA/////wQAAAD/////BgAAAP////8IAAAAMS4yLjUAAAAAAAAAAAAAABAAAACDAAAACAAAAIYAAAACAAAAggAAAAEAAACAAAAAgAAAAH8AAABAAAAAhQAAACAAAACBAAAAXQAAAAFPbGRXb3JsZFwAAAAAAAAAAAAAAAABAAMABwAPAB8APwB/AP8AKGxpc3RmaWxlKQAoYXR0cmlidXRlcykAKHNpZ25hdHVyZSkAKGxpc3RmaWxlKQAoYXR0cmlidXRlcykAKHNpZ25hdHVyZSkARmlsZQBuYW1lICE9IE5VTEwAL1VzZXJzL21pY2hhZWwvRG9jdW1lbnRzL1dvcmtiZW5jaC9Xb3dzZXIvcmVwb3Mvc3Rvcm1qcy9idWlsZC9kZWJ1Zy9TdG9ybUxpYi9zcmMvbGlidG9tY3J5cHQvc3JjL21pc2MvY3J5cHRfZmluZF9oYXNoLmMAaW4gIT0gTlVMTAAvVXNlcnMvbWljaGFlbC9Eb2N1bWVudHMvV29ya2JlbmNoL1dvd3Nlci9yZXBvcy9zdG9ybWpzL2J1aWxkL2RlYnVnL1N0b3JtTGliL3NyYy9saWJ0b21jcnlwdC9zcmMvbWlzYy9iYXNlNjRfZGVjb2RlLmMAb3V0ICE9IE5VTEwAb3V0bGVuICE9IE5VTEwA/////////////////////////////////////////////////////////z7///8/NDU2Nzg5Ojs8Pf////7///8AAQIDBAUGBwgJCgsMDQ4PEBESExQVFhcYGf///////xobHB0eHyAhIiMkJSYnKCkqKywtLi8wMTIz/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////2luICE9IE5VTEwAL1VzZXJzL21pY2hhZWwvRG9jdW1lbnRzL1dvcmtiZW5jaC9Xb3dzZXIvcmVwb3Mvc3Rvcm1qcy9idWlsZC9kZWJ1Zy9TdG9ybUxpYi9zcmMvbGlidG9tY3J5cHQvc3JjL3BrL2FzbjEvZGVyX2RlY29kZV9ib29sZWFuLmMAb3V0ICE9IE5VTEwAb3V0bGVuICE9IE5VTEwAL1VzZXJzL21pY2hhZWwvRG9jdW1lbnRzL1dvcmtiZW5jaC9Xb3dzZXIvcmVwb3Mvc3Rvcm1qcy9idWlsZC9kZWJ1Zy9TdG9ybUxpYi9zcmMvbGlidG9tY3J5cHQvc3JjL3BrL2FzbjEvZGVyX2xlbmd0aF9ib29sZWFuLmMAbnVtICE9IE5VTEwAL1VzZXJzL21pY2hhZWwvRG9jdW1lbnRzL1dvcmtiZW5jaC9Xb3dzZXIvcmVwb3Mvc3Rvcm1qcy9idWlsZC9kZWJ1Zy9TdG9ybUxpYi9zcmMvbGlidG9tY3J5cHQvc3JjL3BrL2FzbjEvZGVyX2RlY29kZV9pbnRlZ2VyLmMAaW4gIT0gTlVMTABudW0gIT0gTlVMTAAvVXNlcnMvbWljaGFlbC9Eb2N1bWVudHMvV29ya2JlbmNoL1dvd3Nlci9yZXBvcy9zdG9ybWpzL2J1aWxkL2RlYnVnL1N0b3JtTGliL3NyYy9saWJ0b21jcnlwdC9zcmMvcGsvYXNuMS9kZXJfZGVjb2RlX3Nob3J0X2ludGVnZXIuYwBpbiAhPSBOVUxMAG91dGxlbiAhPSBOVUxMAC9Vc2Vycy9taWNoYWVsL0RvY3VtZW50cy9Xb3JrYmVuY2gvV293c2VyL3JlcG9zL3N0b3JtanMvYnVpbGQvZGVidWcvU3Rvcm1MaWIvc3JjL2xpYnRvbWNyeXB0L3NyYy9way9hc24xL2Rlcl9sZW5ndGhfc2hvcnRfaW50ZWdlci5jAGluICE9IE5VTEwAL1VzZXJzL21pY2hhZWwvRG9jdW1lbnRzL1dvcmtiZW5jaC9Xb3dzZXIvcmVwb3Mvc3Rvcm1qcy9idWlsZC9kZWJ1Zy9TdG9ybUxpYi9zcmMvbGlidG9tY3J5cHQvc3JjL3BrL2FzbjEvZGVyX2RlY29kZV9iaXRfc3RyaW5nLmMAb3V0ICE9IE5VTEwAb3V0bGVuICE9IE5VTEwAb3V0bGVuICE9IE5VTEwAL1VzZXJzL21pY2hhZWwvRG9jdW1lbnRzL1dvcmtiZW5jaC9Xb3dzZXIvcmVwb3Mvc3Rvcm1qcy9idWlsZC9kZWJ1Zy9TdG9ybUxpYi9zcmMvbGlidG9tY3J5cHQvc3JjL3BrL2FzbjEvZGVyX2xlbmd0aF9iaXRfc3RyaW5nLmMAaW4gIT0gTlVMTAAvVXNlcnMvbWljaGFlbC9Eb2N1bWVudHMvV29ya2JlbmNoL1dvd3Nlci9yZXBvcy9zdG9ybWpzL2J1aWxkL2RlYnVnL1N0b3JtTGliL3NyYy9saWJ0b21jcnlwdC9zcmMvcGsvYXNuMS9kZXJfZGVjb2RlX29jdGV0X3N0cmluZy5jAG91dCAhPSBOVUxMAG91dGxlbiAhPSBOVUxMAG91dGxlbiAhPSBOVUxMAC9Vc2Vycy9taWNoYWVsL0RvY3VtZW50cy9Xb3JrYmVuY2gvV293c2VyL3JlcG9zL3N0b3JtanMvYnVpbGQvZGVidWcvU3Rvcm1MaWIvc3JjL2xpYnRvbWNyeXB0L3NyYy9way9hc24xL2Rlcl9sZW5ndGhfb2N0ZXRfc3RyaW5nLmMAaW4gIT0gTlVMTAAvVXNlcnMvbWljaGFlbC9Eb2N1bWVudHMvV29ya2JlbmNoL1dvd3Nlci9yZXBvcy9zdG9ybWpzL2J1aWxkL2RlYnVnL1N0b3JtTGliL3NyYy9saWJ0b21jcnlwdC9zcmMvcGsvYXNuMS9kZXJfZGVjb2RlX29iamVjdF9pZGVudGlmaWVyLmMAd29yZHMgIT0gTlVMTABvdXRsZW4gIT0gTlVMTAB3b3JkcyAhPSBOVUxMAC9Vc2Vycy9taWNoYWVsL0RvY3VtZW50cy9Xb3JrYmVuY2gvV293c2VyL3JlcG9zL3N0b3JtanMvYnVpbGQvZGVidWcvU3Rvcm1MaWIvc3JjL2xpYnRvbWNyeXB0L3NyYy9way9hc24xL2Rlcl9sZW5ndGhfb2JqZWN0X2lkZW50aWZpZXIuYwBvdXRsZW4gIT0gTlVMTAAAAAAAAAAAAAAAAAAHAAAABwAAAAgAAAAIAAAACQAAAAkAAAAKAAAACgAAAAwAAAAMAAAADQAAAA0AAAAgAAAAIAAAACEAAAAhAAAAIgAAACIAAAAjAAAAIwAAACQAAAAkAAAAJQAAACUAAAAmAAAAJgAAACcAAAAnAAAAKAAAACgAAAApAAAAKQAAACoAAAAqAAAAKwAAACsAAAAsAAAALAAAAC0AAAAtAAAALgAAAC4AAAAvAAAALwAAADAAAAAwAAAAMQAAADEAAAAyAAAAMgAAADMAAAAzAAAANAAAADQAAAA1AAAANQAAADYAAAA2AAAANwAAADcAAAA4AAAAOAAAADkAAAA5AAAAOgAAADoAAAA7AAAAOwAAADwAAAA8AAAAPQAAAD0AAAA+AAAAPgAAAD8AAAA/AAAAQAAAAEAAAABBAAAAQQAAAEIAAABCAAAAQwAAAEMAAABEAAAA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L2J1aWxkL2RlYnVnL1N0b3JtTGliL3NyYy9saWJ0b21jcnlwdC9zcmMvcGsvYXNuMS9kZXJfZGVjb2RlX3V0Zjhfc3RyaW5nLmMAb3V0ICE9IE5VTEwAb3V0bGVuICE9IE5VTEwAaW4gIT0gTlVMTAAvVXNlcnMvbWljaGFlbC9Eb2N1bWVudHMvV29ya2JlbmNoL1dvd3Nlci9yZXBvcy9zdG9ybWpzL2J1aWxkL2RlYnVnL1N0b3JtTGliL3NyYy9saWJ0b21jcnlwdC9zcmMvcGsvYXNuMS9kZXJfbGVuZ3RoX3V0Zjhfc3RyaW5nLmMAb3V0bGVuICE9IE5VTEwAaW4gIT0gTlVMTAAvVXNlcnMvbWljaGFlbC9Eb2N1bWVudHMvV29ya2JlbmNoL1dvd3Nlci9yZXBvcy9zdG9ybWpzL2J1aWxkL2RlYnVnL1N0b3JtTGliL3NyYy9saWJ0b21jcnlwdC9zcmMvcGsvYXNuMS9kZXJfZGVjb2RlX3V0Y3RpbWUuYwBpbmxlbiAhPSBOVUxMAG91dCAhPSBOVUxMAG51bSAhPSBOVUxMAC9Vc2Vycy9taWNoYWVsL0RvY3VtZW50cy9Xb3JrYmVuY2gvV293c2VyL3JlcG9zL3N0b3JtanMvYnVpbGQvZGVidWcvU3Rvcm1MaWIvc3JjL2xpYnRvbWNyeXB0L3NyYy9way9hc24xL2Rlcl9sZW5ndGhfaW50ZWdlci5jAG91dGxlbiAhPSBOVUxMAG91dGxlbiAhPSBOVUxMAC9Vc2Vycy9taWNoYWVsL0RvY3VtZW50cy9Xb3JrYmVuY2gvV293c2VyL3JlcG9zL3N0b3JtanMvYnVpbGQvZGVidWcvU3Rvcm1MaWIvc3JjL2xpYnRvbWNyeXB0L3NyYy9way9hc24xL2Rlcl9sZW5ndGhfdXRjdGltZS5jAHV0Y3RpbWUgIT0gTlVMTABsaXN0ICE9IE5VTEwAL1VzZXJzL21pY2hhZWwvRG9jdW1lbnRzL1dvcmtiZW5jaC9Xb3dzZXIvcmVwb3Mvc3Rvcm1qcy9idWlsZC9kZWJ1Zy9TdG9ybUxpYi9zcmMvbGlidG9tY3J5cHQvc3JjL3BrL2FzbjEvZGVyX2xlbmd0aF9zZXF1ZW5jZS5jAG91dGxlbiAhPSBOVUxMAGluICE9IE5VTEwAL1VzZXJzL21pY2hhZWwvRG9jdW1lbnRzL1dvcmtiZW5jaC9Xb3dzZXIvcmVwb3Mvc3Rvcm1qcy9idWlsZC9kZWJ1Zy9TdG9ybUxpYi9zcmMvbGlidG9tY3J5cHQvc3JjL3BrL2FzbjEvZGVyX2RlY29kZV9jaG9pY2UuYwBpbmxlbiAhPSBOVUxMAGxpc3QgIT0gTlVMTABpbiAhPSBOVUxMAC9Vc2Vycy9taWNoYWVsL0RvY3VtZW50cy9Xb3JrYmVuY2gvV293c2VyL3JlcG9zL3N0b3JtanMvYnVpbGQvZGVidWcvU3Rvcm1MaWIvc3JjL2xpYnRvbWNyeXB0L3NyYy9way9hc24xL2Rlcl9kZWNvZGVfc2VxdWVuY2VfZXguYwBsaXN0ICE9IE5VTEwAaW4gIT0gTlVMTAAvVXNlcnMvbWljaGFlbC9Eb2N1bWVudHMvV29ya2JlbmNoL1dvd3Nlci9yZXBvcy9zdG9ybWpzL2J1aWxkL2RlYnVnL1N0b3JtTGliL3NyYy9saWJ0b21jcnlwdC9zcmMvcGsvYXNuMS9kZXJfZGVjb2RlX3NlcXVlbmNlX211bHRpLmMAaW4gIT0gTlVMTAAvVXNlcnMvbWljaGFlbC9Eb2N1bWVudHMvV29ya2JlbmNoL1dvd3Nlci9yZXBvcy9zdG9ybWpzL2J1aWxkL2RlYnVnL1N0b3JtTGliL3NyYy9saWJ0b21jcnlwdC9zcmMvcGsvcnNhL3JzYV9pbXBvcnQuYwBrZXkgIT0gTlVMTABsdGNfbXAubmFtZSAhPSBOVUxMAHNlZWQgIT0gTlVMTAAvVXNlcnMvbWljaGFlbC9Eb2N1bWVudHMvV29ya2JlbmNoL1dvd3Nlci9yZXBvcy9zdG9ybWpzL2J1aWxkL2RlYnVnL1N0b3JtTGliL3NyYy9saWJ0b21jcnlwdC9zcmMvcGsvcGtjczEvcGtjc18xX21nZjEuYwBtYXNrICE9IE5VTEwAbXNnaGFzaCAhPSBOVUxMAC9Vc2Vycy9taWNoYWVsL0RvY3VtZW50cy9Xb3JrYmVuY2gvV293c2VyL3JlcG9zL3N0b3JtanMvYnVpbGQvZGVidWcvU3Rvcm1MaWIvc3JjL2xpYnRvbWNyeXB0L3NyYy9way9wa2NzMS9wa2NzXzFfcHNzX2VuY29kZS5jAG91dCAhPSBOVUxMAG91dGxlbiAhPSBOVUxMAG91dGxlbiAhPSBOVUxMAC9Vc2Vycy9taWNoYWVsL0RvY3VtZW50cy9Xb3JrYmVuY2gvV293c2VyL3JlcG9zL3N0b3JtanMvYnVpbGQvZGVidWcvU3Rvcm1MaWIvc3JjL2xpYnRvbWNyeXB0L3NyYy9way9hc24xL2Rlcl9lbmNvZGVfYm9vbGVhbi5jAG91dCAhPSBOVUxMAG51bSAhPSBOVUxMAC9Vc2Vycy9taWNoYWVsL0RvY3VtZW50cy9Xb3JrYmVuY2gvV293c2VyL3JlcG9zL3N0b3JtanMvYnVpbGQvZGVidWcvU3Rvcm1MaWIvc3JjL2xpYnRvbWNyeXB0L3NyYy9way9hc24xL2Rlcl9lbmNvZGVfaW50ZWdlci5jAG91dCAhPSBOVUxMAG91dGxlbiAhPSBOVUxMAG91dCAhPSBOVUxMAC9Vc2Vycy9taWNoYWVsL0RvY3VtZW50cy9Xb3JrYmVuY2gvV293c2VyL3JlcG9zL3N0b3JtanMvYnVpbGQvZGVidWcvU3Rvcm1MaWIvc3JjL2xpYnRvbWNyeXB0L3NyYy9way9hc24xL2Rlcl9lbmNvZGVfc2hvcnRfaW50ZWdlci5jAG91dGxlbiAhPSBOVUxMAGluICE9IE5VTEwAL1VzZXJzL21pY2hhZWwvRG9jdW1lbnRzL1dvcmtiZW5jaC9Xb3dzZXIvcmVwb3Mvc3Rvcm1qcy9idWlsZC9kZWJ1Zy9TdG9ybUxpYi9zcmMvbGlidG9tY3J5cHQvc3JjL3BrL2FzbjEvZGVyX2VuY29kZV9iaXRfc3RyaW5nLmMAb3V0ICE9IE5VTEwAb3V0bGVuICE9IE5VTEwAaW4gIT0gTlVMTAAvVXNlcnMvbWljaGFlbC9Eb2N1bWVudHMvV29ya2JlbmNoL1dvd3Nlci9yZXBvcy9zdG9ybWpzL2J1aWxkL2RlYnVnL1N0b3JtTGliL3NyYy9saWJ0b21jcnlwdC9zcmMvcGsvYXNuMS9kZXJfZW5jb2RlX29jdGV0X3N0cmluZy5jAG91dCAhPSBOVUxMAG91dGxlbiAhPSBOVUxMAHdvcmRzICE9IE5VTEwAL1VzZXJzL21pY2hhZWwvRG9jdW1lbnRzL1dvcmtiZW5jaC9Xb3dzZXIvcmVwb3Mvc3Rvcm1qcy9idWlsZC9kZWJ1Zy9TdG9ybUxpYi9zcmMvbGlidG9tY3J5cHQvc3JjL3BrL2FzbjEvZGVyX2VuY29kZV9vYmplY3RfaWRlbnRpZmllci5jAG91dCAhPSBOVUxMAG91dGxlbiAhPSBOVUxMAGluICE9IE5VTEwAL1VzZXJzL21pY2hhZWwvRG9jdW1lbnRzL1dvcmtiZW5jaC9Xb3dzZXIvcmVwb3Mvc3Rvcm1qcy9idWlsZC9kZWJ1Zy9TdG9ybUxpYi9zcmMvbGlidG9tY3J5cHQvc3JjL3BrL2FzbjEvZGVyX2VuY29kZV9pYTVfc3RyaW5nLmMAb3V0ICE9IE5VTEwAb3V0bGVuICE9IE5VTEwAaW4gIT0gTlVMTAAvVXNlcnMvbWljaGFlbC9Eb2N1bWVudHMvV29ya2JlbmNoL1dvd3Nlci9yZXBvcy9zdG9ybWpzL2J1aWxkL2RlYnVnL1N0b3JtTGliL3NyYy9saWJ0b21jcnlwdC9zcmMvcGsvYXNuMS9kZXJfZW5jb2RlX3ByaW50YWJsZV9zdHJpbmcuYwBvdXQgIT0gTlVMTABvdXRsZW4gIT0gTlVMTABpbiAhPSBOVUxMAC9Vc2Vycy9taWNoYWVsL0RvY3VtZW50cy9Xb3JrYmVuY2gvV293c2VyL3JlcG9zL3N0b3JtanMvYnVpbGQvZGVidWcvU3Rvcm1MaWIvc3JjL2xpYnRvbWNyeXB0L3NyYy9way9hc24xL2Rlcl9lbmNvZGVfdXRmOF9zdHJpbmcuYwBvdXQgIT0gTlVMTABvdXRsZW4gIT0gTlVMTAB1dGN0aW1lICE9IE5VTEwAL1VzZXJzL21pY2hhZWwvRG9jdW1lbnRzL1dvcmtiZW5jaC9Xb3dzZXIvcmVwb3Mvc3Rvcm1qcy9idWlsZC9kZWJ1Zy9TdG9ybUxpYi9zcmMvbGlidG9tY3J5cHQvc3JjL3BrL2FzbjEvZGVyX2VuY29kZV91dGN0aW1lLmMAb3V0ICE9IE5VTEwAb3V0bGVuICE9IE5VTEwAMDEyMzQ1Njc4OQABAAAAAgAAAAIAAAADAAAABAAAAAUAAAAGAAAAFgAAABMAAAAMAAAAFwAAAP////8wAAAAMQAAADEAAAD//////v////7////9/////P////v////6////6v///+3////0////6f///wEAAADQ////z////8////9saXN0ICE9IE5VTEwAL1VzZXJzL21pY2hhZWwvRG9jdW1lbnRzL1dvcmtiZW5jaC9Xb3dzZXIvcmVwb3Mvc3Rvcm1qcy9idWlsZC9kZWJ1Zy9TdG9ybUxpYi9zcmMvbGlidG9tY3J5cHQvc3JjL3BrL2FzbjEvZGVyX2VuY29kZV9zZXF1ZW5jZV9leC5jAG91dCAhPSBOVUxMAG91dGxlbiAhPSBOVUxMAGluICE9IE5VTEwAL1VzZXJzL21pY2hhZWwvRG9jdW1lbnRzL1dvcmtiZW5jaC9Xb3dzZXIvcmVwb3Mvc3Rvcm1qcy9idWlsZC9kZWJ1Zy9TdG9ybUxpYi9zcmMvbGlidG9tY3J5cHQvc3JjL3BrL3JzYS9yc2Ffc2lnbl9oYXNoLmMAb3V0ICE9IE5VTEwAb3V0bGVuICE9IE5VTEwAa2V5ICE9IE5VTEwAa2V5ICE9ICgodm9pZCopMCkAL1VzZXJzL21pY2hhZWwvRG9jdW1lbnRzL1dvcmtiZW5jaC9Xb3dzZXIvcmVwb3Mvc3Rvcm1qcy9idWlsZC9kZWJ1Zy9TdG9ybUxpYi9zcmMvbGlidG9tY3J5cHQvc3JjL3BrL3JzYS9yc2FfZnJlZS5jAChzaWduYXR1cmUpAG1kNQAtLS0tLUJFR0lOIFBSSVZBVEUgS0VZLS0tLS1NSUlCT1FJQkFBSkJBSkppZHdTL3VJTE1CU081RExHc0JGa25JWFdXalFKZTJrZmRmRWszRy9qNjZ3NEtraFoxVjYxUnQ0ekxhTVZDWXBEdW43Rkx3UmprTURTZXBPMXEyRGNDQXdFQUFRSkFOdGl6dFZETUpoMmhFMWhqUERLeVVtRUo5VS9hTjNnb211S09qYlFiUS9iV1djTS9XZmhTVkhtUHF0cWgvYlFJMlVYRnIwcm5YbmdldGVaSExyL2I4UUloQU11V3JpU0tHTUFDdzE4L3JWVmZVclRoczkxNW9kS0JIMUFscjN2TVZWelpBaUVBdUJIUFNRa2d3Y2I2TDRNV2FpS3VPenEwOG1TeU5xUGVOOG9TeTE4cTg0OENJSGVNbiszcytlT211N3N1MVVZUWw2eUg3T3JkQmQxcTNVeGZGTkVKaUFiaEFpQXF4ZEN5T3hIR2xiTTdhUzNET2czY3E1YXlvTjJjdnRWN2gxUjR0OE9tVndJZ0YrNXovNnZrekJVc1poZDhOd3lpcytNZVFZSDBycEZwTUtkVGxxbVBGMlE9LS0tLS1FTkQgUFJJVkFURSBLRVktLS0tLQAAAE1aAAD//wAAAAAAAAAAAACYiwAABgAAAP////8BAAAA/////5yLAABNUFEa/////wAAAAAAAAAAoIsAAFJJRkb/////AAAAAAAAAACkiwAAU01LMv////8AAAAAAAAAAKiLAABCSUtp/////wAAAAAAAAAArIsAAAoFAQj/////AAAAAAAAAACwiwAARk9OVP////8AAAAAAAAAALSLAAA8aHRt/////wAAAAAAAAAAuIsAADxIVE3/////AAAAAAAAAAC4iwAAV29vIf////8AAAAAAAAAAL2LAABCTFAx/////wAAAAAAAAAAwYsAAEJMUDL/////AAAAAAAAAADBiwAATURMWP////8AAAAAAAAAAMWLAABUWVBF/////wAAAAAAAAAAyYsAAEdJRjj/////AAAAAAAAAADNiwAATUQyMP////8AAAAAAAAAANGLAABXREJD/////wAAAAAAAAAA1IsAAFNQWEf/////AAAAAAAAAADYiwAA/9j/4P////8AAAAAAAAAANyLAABJRDtQ/////1dYTDv/////4IsAAAAAAAAAAAAAAAAAAAAAAADkiwAAAAAAAAAAAAAAAAAAAAAAAAAAAABGaWxlJTA4dS4lcwBleGUAZGM2AG1wcQB3YXYAc21rAGJpawBwY3gAZm50AGh0bWwAdGJsAGJscABtZHgAcHVkAGdpZgBtMgBkYmMAYmxzAGpwZwBzbGsAeHh4AGJhc2VcKHBhdGNoX21ldGFkYXRhKQBTdHJlYW1pbmdCdWNrZXRzLnR4dAAAAAAAAAAAAAAAAAAA34wAABIAAAAWAAAA9owAABIAAAAWAAAADY0AABIAAAAWAAAAJI0AABIAAAAWAAAAO40AABIAAAAWAAAAUo0AABIAAAAWAAAAaY0AAAcAAAALAAAAdY0AAAcAAAALAAAAAAAAAAAAAAAAAAAAQmFzZQAtbWQ1LmxzdABiYXNldGVlbmVuVVNlbkdCZW5DTmVuVFdkZURFZXNFU2VzTVhmckZSaXRJVGtvS1JwdEJScHRQVHJ1UlV6aENOemhUVwBleHBhbnNpb24xLWxvY2FsZS0jIyMjAGV4cGFuc2lvbjEtc3BlZWNoLSMjIyMAZXhwYW5zaW9uMi1sb2NhbGUtIyMjIwBleHBhbnNpb24yLXNwZWVjaC0jIyMjAGV4cGFuc2lvbjMtbG9jYWxlLSMjIyMAZXhwYW5zaW9uMy1zcGVlY2gtIyMjIwBsb2NhbGUtIyMjIwBzcGVlY2gtIyMjIwBCYXR0bGUubmV0AENhbXBhaWducwBNb2RzAFwocGF0Y2hfbWV0YWRhdGEpAC1QQVRDSABQYXRjaFByZWZpeAAocGF0Y2hfbWV0YWRhdGEpAEZpbGUlMDh1Lnh4eAAobGlzdGZpbGUpAChzaWduYXR1cmUpAChhdHRyaWJ1dGVzKQAoYXR0cmlidXRlcykAKGxpc3RmaWxlKQAoYXR0cmlidXRlcykAKHNpZ25hdHVyZSkAZmlsZU5hbWUAcGxhaW5OYW1lAGhhc2hJbmRleABibG9ja0luZGV4AGZpbGVTaXplAGNvbXBTaXplAGZpbGVUaW1lTG8AZmlsZVRpbWVIaQBsb2NhbGUAQnVmAGdldFNpemUAdG9KUwBQdHIAZ2V0QWRkcgBpc051bGwAU3RyAFZvaWRQdHIAVWludDMyUHRyAFNGaWxlRmluZERhdGEAR2V0TGFzdEVycm9yAFNGaWxlQ2xvc2VBcmNoaXZlAFNGaWxlQ2xvc2VGaWxlAFNGaWxlRmluZENsb3NlAFNGaWxlRmluZEZpcnN0RmlsZQBTRmlsZUZpbmROZXh0RmlsZQBTRmlsZUdldEZpbGVOYW1lAFNGaWxlR2V0RmlsZVNpemUAU0ZpbGVIYXNGaWxlAFNGaWxlT3BlbkFyY2hpdmUAU0ZpbGVPcGVuUGF0Y2hBcmNoaXZlAFNGaWxlT3BlbkZpbGVFeABTRmlsZVJlYWRGaWxlAFNGaWxlU2V0RmlsZVBvaW50ZXIARVJST1JfRklMRV9OT1RfRk9VTkQARVJST1JfTk9fTU9SRV9GSUxFUwBGSUxFX0JFR0lOAE1BWF9QQVRIAFNGSUxFX0lOVkFMSURfU0laRQBTVFJFQU1fRkxBR19SRUFEX09OTFkATjEwZW1zY3JpcHRlbjExbWVtb3J5X3ZpZXdJaEVFAAAAAACaAAAikAAATlN0M19fMjEyYmFzaWNfc3RyaW5nSWNOU18xMWNoYXJfdHJh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bABjaGFyAHNpZ25lZCBjaGFyAHVuc2lnbmVkIGNoYXIAc2hvcnQAdW5zaWduZWQgc2hvcnQAaW50AHVuc2lnbmVkIGludABsb25nAHVuc2lnbmVkIGxvbmcAZmxvYXQAZG91YmxlAHN0ZDo6c3RyaW5nAHN0ZDo6YmFzaWNfc3RyaW5nPHVuc2lnbmVkIGNoYXI+AHN0ZDo6d3N0cmluZwBzdGQ6OnUxNnN0cmluZwBzdGQ6OnUzMnN0cmluZwBlbXNjcmlwdGVuOjp2YWwAZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8Y2hhcj4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8c2lnbmVkIGNoYXI+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHVuc2lnbmVkIGNoYXI+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHNob3J0PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzx1bnNpZ25lZCBzaG9ydD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8aW50PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzx1bnNpZ25lZCBpbnQ+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PGxvbmc+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHVuc2lnbmVkIGxvbmc+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PGludDhfdD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8dWludDhfdD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8aW50MTZfdD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8dWludDE2X3Q+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PGludDMyX3Q+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHVpbnQzMl90PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxmbG9hdD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8ZG91YmxlPgBOU3QzX18yMTJiYXNpY19zdHJpbmdJaE5TXzExY2hhcl90cmFpdHNJaEVFTlNfOWFsbG9jYXRvckloRUVFRQAAAACEmgAACp4AAAAAAAABAAAAtJAAAAAAAABOU3QzX18yMTJiYXNpY19zdHJpbmdJd05TXzExY2hhcl90cmFpdHNJd0VFTlNfOWFsbG9jYXRvckl3RUVFRQAAhJoAAGSeAAAAAAAAAQAAALSQAAAAAAAATlN0M19fMjEyYmFzaWNfc3RyaW5nSURzTlNfMTFjaGFyX3RyYWl0c0lEc0VFTlNfOWFsbG9jYXRvcklEc0VFRUUAAACEmgAAvJ4AAAAAAAABAAAAtJAAAAAAAABOU3QzX18yMTJiYXNpY19zdHJpbmdJRGlOU18xMWNoYXJfdHJhaXRzSURpRUVOU185YWxsb2NhdG9ySURpRUVFRQAAAISaAAAYnwAAAAAAAAEAAAC0kAAAAAAAAE4xMGVtc2NyaXB0ZW4xMW1lbW9yeV92aWV3SWNFRQAAAJoAAHSfAABOMTBlbXNjcmlwdGVuMTFtZW1vcnlfdmlld0lhRUUAAACaAACcnwAATjEwZW1zY3JpcHRlbjExbWVtb3J5X3ZpZXdJc0VFAAAAmgAAxJ8AAE4xMGVtc2NyaXB0ZW4xMW1lbW9yeV92aWV3SXRFRQAAAJoAAOyfAABOMTBlbXNjcmlwdGVuMTFtZW1vcnlfdmlld0lpRUUAAACaAAAUoAAATjEwZW1zY3JpcHRlbjExbWVtb3J5X3ZpZXdJakVFAAAAmgAAPKAAAE4xMGVtc2NyaXB0ZW4xMW1lbW9yeV92aWV3SWxFRQAAAJoAAGSgAABOMTBlbXNjcmlwdGVuMTFtZW1vcnlfdmlld0ltRUUAAACaAACMoAAATjEwZW1zY3JpcHRlbjExbWVtb3J5X3ZpZXdJZkVFAAAAmgAAtKAAAE4xMGVtc2NyaXB0ZW4xMW1lbW9yeV92aWV3SWRFRQAAAJoAANygAABfWgBfX1oAX19fWgBfX19fWgBfYmxvY2tfaW52b2tlAGludm9jYXRpb24gZnVuY3Rpb24gZm9yIGJsb2NrIGluIABVYTllbmFibGVfaWZJAHZ0YWJsZSBmb3IgAFZUVCBmb3IgAHR5cGVpbmZvIGZvciAAdHlwZWluZm8gbmFtZSBmb3IgAGNvdmFyaWFudCByZXR1cm4gdGh1bmsgdG8gAHRocmVhZC1sb2NhbCB3cmFwcGVyIHJvdXRpbmUgZm9yIAB0aHJlYWQtbG9jYWwgaW5pdGlhbGl6YXRpb24gcm91dGluZSBmb3IgAHZpcnR1YWwgdGh1bmsgdG8gAG5vbi12aXJ0dWFsIHRodW5rIHRvIABndWFyZCB2YXJpYWJsZSBmb3IgAHJlZmVyZW5jZSB0ZW1wb3JhcnkgZm9yIAAAAAAAAAAA1KIAAPQAAAD1AAAA9gAAAPcAAAD4AAAA+QAAAPoAAAD7AAAA/AAAAE4xMl9HTE9CQUxfX05fMTE2aXRhbml1bV9kZW1hbmdsZTExU3BlY2lhbE5hbWVFAE4xMl9HTE9CQUxfX05fMTE2aXRhbml1bV9kZW1hbmdsZTROb2RlRQAAmgAApKIAACiaAAB0ogAAzKIAAAAAAADMogAA9AAAAPUAAAD2AAAA9wAAAP0AAAD5AAAA+gAAAPsAAAD+AAAAAAAAAHSjAAD0AAAA9QAAAPYAAAD3AAAA/wAAAPkAAAD6AAAA+wAAAAABAABOMTJfR0xPQkFMX19OXzExNml0YW5pdW1fZGVtYW5nbGUyMUN0b3JWdGFibGVTcGVjaWFsTmFtZUUAAAAomgAAOKMAAMyiAABjb25zdHJ1Y3Rpb24gdnRhYmxlIGZvciAALWluLQBTdABzdGQAAAAAAAAAAACkAAD0AAAA9QAAAPYAAAD3AAAAAQEAAPkAAAACAQAA+wAAAAMBAABOMTJfR0xPQkFMX19OXzExNml0YW5pdW1fZGVtYW5nbGU4TmFtZVR5cGVFACiaAADUowAAzKIAAAAAAABopAAA9AAAAPUAAAD2AAAA9wAAAAQBAAD5AAAABQEAAPsAAAAGAQAATjEyX0dMT0JBTF9fTl8xMTZpdGFuaXVtX2RlbWFuZ2xlMTBOZXN0ZWROYW1lRQAAKJoAADikAADMogAAOjoAYXV0bwAAAAAA6KQAAAcBAAAIAQAACQEAAAoBAAALAQAADAEAAPoAAAD7AAAADQEAAE4xMl9HTE9CQUxfX05fMTE2aXRhbml1bV9kZW1hbmdsZTI0Rm9yd2FyZFRlbXBsYXRlUmVmZXJlbmNlRQAAAAAomgAAqKQAAMyiAABkZWNsdHlwZSgAKQBncwAmJgAmACY9AD0AYWxpZ25vZiAoAGNvbnN0X2Nhc3QALAB+AGR5bmFtaWNfY2FzdAAqAC4qAC4ALwAvPQBeAF49AD09AD49AD4APD0APDwAPDw9ADwALQAtPQAqPQAtLQAhPQAhAG5vZXhjZXB0ICgAfHwAfAB8PQAtPioAKwArPQArKwAtPgByZWludGVycHJldF9jYXN0ACUAJT0APj4APj49AHN0YXRpY19jYXN0AHNpemVvZiAoAHNpemVvZi4uLiAoAHR5cGVpZCAoAHRocm93AHU4X191dWlkb2Z0AHU4X191dWlkb2Z6AHdjaGFyX3QAYjBFAGIxRQBjaGFyAHNpZ25lZCBjaGFyAHVuc2lnbmVkIGNoYXIAc2hvcnQAdW5zaWduZWQgc2hvcnQAAHUAbAB1bABsbAB1bGwAX19pbnQxMjgAdW5zaWduZWQgX19pbnQxMjgARG5FAG51bGxwdHIAAAAAAAAAAMymAAD0AAAA9QAAAPYAAAD3AAAADgEAAPkAAAD6AAAA+wAAAA8BAABOMTJfR0xPQkFMX19OXzExNml0YW5pdW1fZGVtYW5nbGUxNEludGVnZXJMaXRlcmFsRQAAKJoAAJimAADMogAAKAAAAAAAAAA0pwAA9AAAAPUAAAD2AAAA9wAAABABAAD5AAAA+gAAAPsAAAARAQAATjEyX0dMT0JBTF9fTl8xMTZpdGFuaXVtX2RlbWFuZ2xlOEJvb2xFeHByRQAomgAACKcAAMyiAAB0cnVlAGZhbHNlAAAAAAAAsKcAAPQAAAD1AAAA9gAAAPcAAAASAQAA+QAAAPoAAAD7AAAAEwEAAE4xMl9HTE9CQUxfX05fMTE2aXRhbml1bV9kZW1hbmdsZTE2RmxvYXRMaXRlcmFsSW1wbElmRUUAKJoAAHinAADMogAAJWFmAAAAAAAkqAAA9AAAAPUAAAD2AAAA9wAAABQBAAD5AAAA+gAAAPsAAAAVAQAATjEyX0dMT0JBTF9fTl8xMTZpdGFuaXVtX2RlbWFuZ2xlMTZGbG9hdExpdGVyYWxJbXBsSWRFRQAomgAA7KcAAMyiAAAlYQAAAAAAAJioAAD0AAAA9QAAAPYAAAD3AAAAFgEAAPkAAAD6AAAA+wAAABcBAABOMTJfR0xPQkFMX19OXzExNml0YW5pdW1fZGVtYW5nbGUxNkZsb2F0TGl0ZXJhbEltcGxJZUVFACiaAABgqAAAzKIAACVMYUwAAAAAAAAAAAypAAD0AAAA9QAAAPYAAAD3AAAAGAEAAPkAAAD6AAAA+wAAABkBAABOMTJfR0xPQkFMX19OXzExNml0YW5pdW1fZGVtYW5nbGUxM1N0cmluZ0xpdGVyYWxFAAAAKJoAANioAADMogAAIjwAPiIAVXQAVWwAeXB0bgB2RQBVYgAnYmxvY2stbGl0ZXJhbCcAAAAAAACgqQAA9AAAAPUAAAD2AAAA9wAAABoBAAD5AAAA+gAAAPsAAAAbAQAATjEyX0dMT0JBTF9fTl8xMTZpdGFuaXVtX2RlbWFuZ2xlMTVVbm5hbWVkVHlwZU5hbWVFACiaAABsqQAAzKIAACd1bm5hbWVkACcAVHkAVG4AVHQARQBUcAAAAAAAAAAANKoAAPQAAAD1AAAA9gAAAPcAAAAcAQAA+QAAAPoAAAD7AAAAHQEAAE4xMl9HTE9CQUxfX05fMTE2aXRhbml1bV9kZW1hbmdsZTI2U3ludGhldGljVGVtcGxhdGVQYXJhbU5hbWVFAAAomgAA9KkAAMyiAAAkVAAkTgAkVFQAAAAAAAAAtKoAAPQAAAD1AAAA9gAAAPcAAAAeAQAAHwEAAPoAAAD7AAAAIAEAAE4xMl9HTE9CQUxfX05fMTE2aXRhbml1bV9kZW1hbmdsZTIxVHlwZVRlbXBsYXRlUGFyYW1EZWNsRQAAACiaAAB4qgAAzKIAAHR5cGVuYW1lIAAAAAAAAAA4qwAA9AAAAPUAAAD2AAAA9wAAACEBAAAiAQAA+gAAAPsAAAAjAQAATjEyX0dMT0JBTF9fTl8xMTZpdGFuaXVtX2RlbWFuZ2xlMjROb25UeXBlVGVtcGxhdGVQYXJhbURlY2xFAAAAACiaAAD4qgAAzKIAACAAAAAAAAAAtKsAAPQAAAD1AAAA9gAAAPcAAAAkAQAAJQEAAPoAAAD7AAAAJgEAAE4xMl9HTE9CQUxfX05fMTE2aXRhbml1bV9kZW1hbmdsZTI1VGVtcGxhdGVUZW1wbGF0ZVBhcmFtRGVjbEUAAAAomgAAdKsAAMyiAAB0ZW1wbGF0ZTwAPiB0eXBlbmFtZSAALCAAAAAAAAAAAESsAAD0AAAA9QAAAPYAAAD3AAAAJwEAACgBAAD6AAAA+wAAACkBAABOMTJfR0xPQkFMX19OXzExNml0YW5pdW1fZGVtYW5nbGUyMVRlbXBsYXRlUGFyYW1QYWNrRGVjbEUAAAAomgAACKwAAMyiAAAuLi4AAAAAALSsAAD0AAAA9QAAAPYAAAD3AAAAKgEAAPkAAAD6AAAA+wAAACsBAABOMTJfR0xPQkFMX19OXzExNml0YW5pdW1fZGVtYW5nbGUxNUNsb3N1cmVUeXBlTmFtZUUAKJoAAICsAADMogAAJ2xhbWJkYQAAAAAAJK0AAPQAAAD1AAAA9gAAAPcAAAAsAQAA+QAAAPoAAAD7AAAALQEAAE4xMl9HTE9CQUxfX05fMTE2aXRhbml1bV9kZW1hbmdsZTEwTGFtYmRhRXhwckUAACiaAAD0rAAAzKIAAFtdAHsuLi59AAAAAAAAAACcrQAA9AAAAPUAAAD2AAAA9wAAAC4BAAD5AAAA+gAAAPsAAAAvAQAATjEyX0dMT0JBTF9fTl8xMTZpdGFuaXVtX2RlbWFuZ2xlMTVJbnRlZ2VyQ2FzdEV4cHJFACiaAABorQAAzKIAAGZwAGZMAAAAAAAAABCuAAD0AAAA9QAAAPYAAAD3AAAAMAEAAPkAAAD6AAAA+wAAADEBAABOMTJfR0xPQkFMX19OXzExNml0YW5pdW1fZGVtYW5nbGUxM0Z1bmN0aW9uUGFyYW1FAAAAKJoAANytAADMogAAYWEAYW4AYU4AYVMAY20AZHMAZHYAZFYAZW8AZU8AZXEAZ2UAZ3QAbGUAbHMAbFMAbHQAbWkAbUkAbWwAbUwAbmUAb28Ab3IAb1IAcGwAcEwAcm0Ack0AcnMAclMAAAAAAAAAANSuAAD0AAAA9QAAAPYAAAD3AAAAMgEAAPkAAAD6AAAA+wAAADMBAABOMTJfR0xPQkFMX19OXzExNml0YW5pdW1fZGVtYW5nbGU4Rm9sZEV4cHJFACiaAACorgAAzKIAAC4uLiAAIC4uLgAAAAAAAABUrwAA9AAAAPUAAAD2AAAA9wAAADQBAAD5AAAA+gAAAPsAAAA1AQAATjEyX0dMT0JBTF9fTl8xMTZpdGFuaXVtX2RlbWFuZ2xlMjJQYXJhbWV0ZXJQYWNrRXhwYW5zaW9uRQAAKJoAABivAADMogAAAAAAALyvAAD0AAAA9QAAAPYAAAD3AAAANgEAAPkAAAD6AAAA+wAAADcBAABOMTJfR0xPQkFMX19OXzExNml0YW5pdW1fZGVtYW5nbGUxMEJpbmFyeUV4cHJFAAAomgAAjK8AAMyiAAApIAAgKAAAAAAAAAAssAAA9AAAAPUAAAD2AAAA9wAAADgBAAD5AAAA+gAAAPsAAAA5AQAATjEyX0dMT0JBTF9fTl8xMTZpdGFuaXVtX2RlbWFuZ2xlMTBQcmVmaXhFeHByRQAAKJoAAPyvAADMogAAAAAAAJCwAAD0AAAA9QAAAPYAAAD3AAAAOgEAAPkAAAD6AAAA+wAAADsBAABOMTJfR0xPQkFMX19OXzExNml0YW5pdW1fZGVtYW5nbGU4Q2FzdEV4cHJFACiaAABksAAAzKIAAD4oAAAAAAAA+LAAAPQAAAD1AAAA9gAAAPcAAAA8AQAA+QAAAPoAAAD7AAAAPQEAAE4xMl9HTE9CQUxfX05fMTE2aXRhbml1bV9kZW1hbmdsZThDYWxsRXhwckUAKJoAAMywAADMogAAY3YAAAAAAABosQAA9AAAAPUAAAD2AAAA9wAAAD4BAAD5AAAA+gAAAPsAAAA/AQAATjEyX0dMT0JBTF9fTl8xMTZpdGFuaXVtX2RlbWFuZ2xlMTRDb252ZXJzaW9uRXhwckUAACiaAAA0sQAAzKIAACkoAAAAAAAA1LEAAPQAAAD1AAAA9gAAAPcAAABAAQAA+QAAAPoAAAD7AAAAQQEAAE4xMl9HTE9CQUxfX05fMTE2aXRhbml1bV9kZW1hbmdsZTEwRGVsZXRlRXhwckUAACiaAACksQAAzKIAAGRlbGV0ZQBbXSAAc3JOAHNyAF9HTE9CQUxfX04AKGFub255bW91cyBuYW1lc3BhY2UpAAAAAAAAdLIAAPQAAAD1AAAA9gAAAPcAAABCAQAA+QAAAEMBAAD7AAAARAEAAE4xMl9HTE9CQUxfX05fMTE2aXRhbml1bV9kZW1hbmdsZTEzUXVhbGlmaWVkTmFtZUUAAAAomgAAQLIAAMyiAABkbgBvbgAAAAAAAADgsgAA9AAAAPUAAAD2AAAA9wAAAEUBAAD5AAAA+gAAAPsAAABGAQAATjEyX0dMT0JBTF9fTl8xMTZpdGFuaXVtX2RlbWFuZ2xlOER0b3JOYW1lRQAomgAAtLIAAMyiAABvcGVyYXRvciYmAG9wZXJhdG9yJgBvcGVyYXRvciY9AG9wZXJhdG9yPQBvcGVyYXRvcigpAG9wZXJhdG9yLABvcGVyYXRvcn4Ab3BlcmF0b3IgZGVsZXRlW10Ab3BlcmF0b3IqAG9wZXJhdG9yIGRlbGV0ZQBvcGVyYXRvci8Ab3BlcmF0b3IvPQBvcGVyYXRvcl4Ab3BlcmF0b3JePQBvcGVyYXRvcj09AG9wZXJhdG9yPj0Ab3BlcmF0b3I+AG9wZXJhdG9yW10Ab3BlcmF0b3I8PQBvcGVyYXRvcjw8AG9wZXJhdG9yPDw9AG9wZXJhdG9yPABvcGVyYXRvci0Ab3BlcmF0b3ItPQBvcGVyYXRvcio9AG9wZXJhdG9yLS0Ab3BlcmF0b3IgbmV3W10Ab3BlcmF0b3IhPQBvcGVyYXRvciEAb3BlcmF0b3IgbmV3AG9wZXJhdG9yfHwAb3BlcmF0b3J8AG9wZXJhdG9yfD0Ab3BlcmF0b3ItPioAb3BlcmF0b3IrAG9wZXJhdG9yKz0Ab3BlcmF0b3IrKwBvcGVyYXRvci0+AG9wZXJhdG9yPwBvcGVyYXRvciUAb3BlcmF0b3IlPQBvcGVyYXRvcj4+AG9wZXJhdG9yPj49AG9wZXJhdG9yPD0+AAAAAAAAQLUAAPQAAAD1AAAA9gAAAPcAAABHAQAA+QAAAPoAAAD7AAAASAEAAE4xMl9HTE9CQUxfX05fMTE2aXRhbml1bV9kZW1hbmdsZTIyQ29udmVyc2lvbk9wZXJhdG9yVHlwZUUAACiaAAAEtQAAzKIAAG9wZXJhdG9yIAAAAAAAAAC4tQAA9AAAAPUAAAD2AAAA9wAAAEkBAAD5AAAA+gAAAPsAAABKAQAATjEyX0dMT0JBTF9fTl8xMTZpdGFuaXVtX2RlbWFuZ2xlMTVMaXRlcmFsT3BlcmF0b3JFACiaAACEtQAAzKIAAG9wZXJhdG9yIiIgAAAAAAA0tgAA9AAAAPUAAAD2AAAA9wAAAEsBAAD5AAAATAEAAPsAAABNAQAATjEyX0dMT0JBTF9fTl8xMTZpdGFuaXVtX2RlbWFuZ2xlMTlHbG9iYWxRdWFsaWZpZWROYW1lRQAomgAA/LUAAMyiAAAAAAAAnLYAAPQAAAD1AAAA9gAAAPcAAABOAQAA+QAAAPoAAAD7AAAATwEAAE4xMl9HTE9CQUxfX05fMTE2aXRhbml1bV9kZW1hbmdsZTEwTWVtYmVyRXhwckUAACiaAABstgAAzKIAAAAAAAAMtwAA9AAAAPUAAAD2AAAA9wAAAFABAAD5AAAA+gAAAPsAAABRAQAATjEyX0dMT0JBTF9fTl8xMTZpdGFuaXVtX2RlbWFuZ2xlMThBcnJheVN1YnNjcmlwdEV4cHJFAAAomgAA1LYAAMyiAAApWwBdAAAAAAAAAAB8twAA9AAAAPUAAAD2AAAA9wAAAFIBAAD5AAAA+gAAAPsAAABTAQAATjEyX0dMT0JBTF9fTl8xMTZpdGFuaXVtX2RlbWFuZ2xlMTBCcmFjZWRFeHByRQAAKJoAAEy3AADMogAAID0gAAAAAADstwAA9AAAAPUAAAD2AAAA9wAAAFQBAAD5AAAA+gAAAPsAAABVAQAATjEyX0dMT0JBTF9fTl8xMTZpdGFuaXVtX2RlbWFuZ2xlMTVCcmFjZWRSYW5nZUV4cHJFACiaAAC4twAAzKIAACAuLi4gAAAAAAAAAGC4AAD0AAAA9QAAAPYAAAD3AAAAVgEAAPkAAAD6AAAA+wAAAFcBAABOMTJfR0xPQkFMX19OXzExNml0YW5pdW1fZGVtYW5nbGUxMkluaXRMaXN0RXhwckUAAAAAKJoAACy4AADMogAAAAAAAMi4AAD0AAAA9QAAAPYAAAD3AAAAWAEAAPkAAAD6AAAA+wAAAFkBAABOMTJfR0xPQkFMX19OXzExNml0YW5pdW1fZGVtYW5nbGUxMVBvc3RmaXhFeHByRQAomgAAmLgAAMyiAABudwBuYQBwaQAAAAAAAAAAOLkAAPQAAAD1AAAA9gAAAPcAAABaAQAA+QAAAPoAAAD7AAAAWwEAAE4xMl9HTE9CQUxfX05fMTE2aXRhbml1bV9kZW1hbmdsZTdOZXdFeHByRQAAKJoAAAy5AADMogAAOjpvcGVyYXRvciAAbmV3AAAAAAC0uQAA9AAAAPUAAAD2AAAA9wAAAFwBAAD5AAAA+gAAAPsAAABdAQAATjEyX0dMT0JBTF9fTl8xMTZpdGFuaXVtX2RlbWFuZ2xlMTNFbmNsb3NpbmdFeHByRQAAACiaAACAuQAAzKIAAAAAAAAgugAA9AAAAPUAAAD2AAAA9wAAAF4BAAD5AAAA+gAAAPsAAABfAQAATjEyX0dMT0JBTF9fTl8xMTZpdGFuaXVtX2RlbWFuZ2xlMTVDb25kaXRpb25hbEV4cHJFACiaAADsuQAAzKIAACkgPyAoACkgOiAoAAAAAACcugAA9AAAAPUAAAD2AAAA9wAAAGABAAD5AAAA+gAAAPsAAABhAQAATjEyX0dMT0JBTF9fTl8xMTZpdGFuaXVtX2RlbWFuZ2xlMTlTaXplb2ZQYXJhbVBhY2tFeHByRQAomgAAZLoAAMyiAABzaXplb2YuLi4oAAAAAAAAFLsAAPQAAAD1AAAA9gAAAPcAAABiAQAA+QAAAPoAAAD7AAAAYwEAAE4xMl9HTE9CQUxfX05fMTE2aXRhbml1bV9kZW1hbmdsZTEzTm9kZUFycmF5Tm9kZUUAAAAomgAA4LoAAMyiAAAAAAAAfLsAAPQAAAD1AAAA9gAAAPcAAABkAQAA+QAAAPoAAAD7AAAAZQEAAE4xMl9HTE9CQUxfX05fMTE2aXRhbml1bV9kZW1hbmdsZTlUaHJvd0V4cHJFAAAAACiaAABMuwAAzKIAAHRocm93IAAAAAAAAOy7AAD0AAAA9QAAAPYAAAD3AAAAZgEAAPkAAAD6AAAA+wAAAGcBAABOMTJfR0xPQkFMX19OXzExNml0YW5pdW1fZGVtYW5nbGUxMFVVSURPZkV4cHJFAAAomgAAvLsAAMyiAABfX3V1aWRvZigAAAAAAAAAcLwAAPQAAAD1AAAA9gAAAPcAAABoAQAA+QAAAGkBAAD7AAAAagEAAE4xMl9HTE9CQUxfX05fMTE2aXRhbml1bV9kZW1hbmdsZTI3RXhwYW5kZWRTcGVjaWFsU3Vic3RpdHV0aW9uRQAomgAAMLwAAMyiAABzdGQ6OmFsbG9jYXRvcgBzdGQ6OmJhc2ljX3N0cmluZwBzdGQ6OmJhc2ljX3N0cmluZzxjaGFyLCBzdGQ6OmNoYXJfdHJhaXRzPGNoYXI+LCBzdGQ6OmFsbG9jYXRvcjxjaGFyPiA+AHN0ZDo6YmFzaWNfaXN0cmVhbTxjaGFyLCBzdGQ6OmNoYXJfdHJhaXRzPGNoYXI+ID4Ac3RkOjpiYXNpY19vc3RyZWFtPGNoYXIsIHN0ZDo6Y2hhcl90cmFpdHM8Y2hhcj4gPgBzdGQ6OmJhc2ljX2lvc3RyZWFtPGNoYXIsIHN0ZDo6Y2hhcl90cmFpdHM8Y2hhcj4gPgBhbGxvY2F0b3IAYmFzaWNfc3RyaW5nAGJhc2ljX2lzdHJlYW0AYmFzaWNfb3N0cmVhbQBiYXNpY19pb3N0cmVhbQAAAAAAAAAAIL4AAPQAAAD1AAAA9gAAAPcAAABrAQAA+QAAAPoAAAD7AAAAbAEAAE4xMl9HTE9CQUxfX05fMTE2aXRhbml1bV9kZW1hbmdsZTEyQ3RvckR0b3JOYW1lRQAAAAAomgAA7L0AAMyiAAAAAAAAiL4AAPQAAAD1AAAA9gAAAPcAAABtAQAA+QAAAPoAAAD7AAAAbgEAAE4xMl9HTE9CQUxfX05fMTE2aXRhbml1bV9kZW1hbmdsZTEwQWJpVGFnQXR0ckUAACiaAABYvgAAzKIAAFthYmk6AERDAAAAAAAAAAAIvwAA9AAAAPUAAAD2AAAA9wAAAG8BAAD5AAAA+gAAAPsAAABwAQAATjEyX0dMT0JBTF9fTl8xMTZpdGFuaXVtX2RlbWFuZ2xlMjFTdHJ1Y3R1cmVkQmluZGluZ05hbWVFAAAAKJoAAMy+AADMogAAc3RyaW5nIGxpdGVyYWwAAAAAAACAvwAA9AAAAPUAAAD2AAAA9wAAAHEBAAD5AAAA+gAAAPsAAAByAQAATjEyX0dMT0JBTF9fTl8xMTZpdGFuaXVtX2RlbWFuZ2xlOUxvY2FsTmFtZUUAAAAAKJoAAFC/AADMogAAAAAAAPC/AAD0AAAA9QAAAPYAAAD3AAAAcwEAAPkAAAB0AQAA+wAAAHUBAABOMTJfR0xPQkFMX19OXzExNml0YW5pdW1fZGVtYW5nbGUxOVNwZWNpYWxTdWJzdGl0dXRpb25FACiaAAC4vwAAzKIAAHN0ZDo6c3RyaW5nAHN0ZDo6aXN0cmVhbQBzdGQ6Om9zdHJlYW0Ac3RkOjppb3N0cmVhbQBzdHJpbmcAaXN0cmVhbQBvc3RyZWFtAGlvc3RyZWFtAAAAAACwwAAAdgEAAHcBAAB4AQAAeQEAAHoBAAB7AQAA+gAAAPsAAAB8AQAATjEyX0dMT0JBTF9fTl8xMTZpdGFuaXVtX2RlbWFuZ2xlMTNQYXJhbWV0ZXJQYWNrRQAAACiaAAB8wAAAzKIAAAAAAAAcwQAA9AAAAPUAAAD2AAAA9wAAAH0BAAD5AAAA+gAAAPsAAAB+AQAATjEyX0dMT0JBTF9fTl8xMTZpdGFuaXVtX2RlbWFuZ2xlMTJUZW1wbGF0ZUFyZ3NFAAAAACiaAADowAAAzKIAAAAAAACQwQAA9AAAAPUAAAD2AAAA9wAAAH8BAAD5AAAAgAEAAPsAAACBAQAATjEyX0dMT0JBTF9fTl8xMTZpdGFuaXVtX2RlbWFuZ2xlMjBOYW1lV2l0aFRlbXBsYXRlQXJnc0UAAAAAKJoAAFTBAADMogAAU3RMAAAAAAAEwgAA9AAAAPUAAAD2AAAA9wAAAIIBAAD5AAAAgwEAAPsAAACEAQAATjEyX0dMT0JBTF9fTl8xMTZpdGFuaXVtX2RlbWFuZ2xlMTZTdGRRdWFsaWZpZWROYW1lRQAAAAAomgAAzMEAAMyiAABzdGQ6OgAAAAAAAACAwgAA9AAAAPUAAAD2AAAA9wAAAIUBAAD5AAAA+gAAAPsAAACGAQAATjEyX0dMT0JBTF9fTl8xMTZpdGFuaXVtX2RlbWFuZ2xlMjBUZW1wbGF0ZUFyZ3VtZW50UGFja0UAAAAAKJoAAETCAADMogAAAAAAAOzCAAD0AAAA9QAAAPYAAAD3AAAAhwEAAPkAAAD6AAAA+wAAAIgBAABOMTJfR0xPQkFMX19OXzExNml0YW5pdW1fZGVtYW5nbGUxMkVuYWJsZUlmQXR0ckUAAAAAKJoAALjCAADMogAAIFtlbmFibGVfaWY6AAAAAAAAAABswwAAiQEAAPUAAACKAQAA9wAAAIsBAACMAQAA+gAAAPsAAACNAQAATjEyX0dMT0JBTF9fTl8xMTZpdGFuaXVtX2RlbWFuZ2xlMTZGdW5jdGlvbkVuY29kaW5nRQAAAAAomgAANMMAAMyiAAAgY29uc3QAIHZvbGF0aWxlACByZXN0cmljdAAgJgAgJiYAAAAAAAAA+MMAAPQAAAD1AAAA9gAAAPcAAACOAQAA+QAAAPoAAAD7AAAAjwEAAE4xMl9HTE9CQUxfX05fMTE2aXRhbml1bV9kZW1hbmdsZTlEb3RTdWZmaXhFAAAAACiaAADIwwAAzKIAAHZvaWQAYm9vbABpbnQAdW5zaWduZWQgaW50AGxvbmcAdW5zaWduZWQgbG9uZwBsb25nIGxvbmcAdW5zaWduZWQgbG9uZyBsb25nAGZsb2F0AGRvdWJsZQBsb25nIGRvdWJsZQBfX2Zsb2F0MTI4AGRlY2ltYWw2NABkZWNpbWFsMTI4AGRlY2ltYWwzMgBkZWNpbWFsMTYAY2hhcjMyX3QAY2hhcjE2X3QAY2hhcjhfdABkZWNsdHlwZShhdXRvKQBzdGQ6Om51bGxwdHJfdAAgY29tcGxleAAgaW1hZ2luYXJ5AERvAG5vZXhjZXB0AERPAER3AER4AFJFAE9FAAAAAAAAZMUAAPQAAAD1AAAA9gAAAPcAAACQAQAA+QAAAPoAAAD7AAAA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AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAAAAAAAAAAAAAAAAAAAAAFQWFg0MCAYFBgUGAwQEAwUOCxQTEwkLBgUEAwIDAgICDQcJBgYEAwIEAwMDAwMCAgkGBAQEBAMCAwICAgIDAgQIAwQHCQUDAwMDAgICAwICAwICAgICAgICAQEBAgECAgYKCAgGBwQDBAQCAgQCAwMEAwcHCQYEAwMCAQICAgICCgICAwICAQECAgIGAwUCAwIBAQEBAQEBAQEBAgMBAQECAQEBAQEBAgQEBAcJCAwCAQEBAQEBAQEBAQEBAgEBAwQBAgQFAQEBAQEBAQIBAQEEAQEBAQECAQEBAQEBAQEBAgEBAQEBAQEDAQEBAQEBAQIBAQEBAQECAgEBAgICBksAAAAAAAAAAAAAAAAAAAAA/wsHBQsCAgIGAgIBBAIBAwkBAQEDBAEBAgEBAQIBAQEFAQEBDQEBAQEBAQEBAQEBAgEBAwEBAQEBAQECAQEBAQoEAgEGAwIBAQEBAQMBAQEFAgMEAwMDAgEBAQIBAgMDAQMBAQIFAQEEAwUBAwEDAwIBBAMKBgEBAQEBAQEBAQECAgEKAgUBAQIHAhcBBQEBDgEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBBgIBBAUBAQIBAQEBAgEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQcBAQIBAQEBAgEBAQEBAQECAQEBAQEBEQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADJwAAIwAAAAAAAAAAAAAAAAAAAAAAAP8BAQEBAQEBAgIBAQYOEAQGCAUEBAMDAgIDAwEBAgEBAQQCBAICAgEBBAEBAgMDAgMBAwYEAQEBAQEBAgECAQEBKQcWEkAKChElAQMXECYqEAEjIy8QBgcCCQEBAQEBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA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/////wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAADZAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADXAAAA2gAAANgNAQAABAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAK/////wAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQ5QAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACgDQEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAN4AAAAAQZDNAwvAWgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/JcPBG5hbWUB85cP2g8ABXJhaXNlAQRleGl0AhFfZW12YWxfbmV3X29iamVjdAMTX2VtdmFsX3NldF9wcm9wZXJ0eQQSX2VtdmFsX25ld19jc3RyaW5nBQ1fZW12YWxfZGVjcmVmBhZfZW1iaW5kX3JlZ2lzdGVyX2NsYXNzBx9fZW1iaW5kX3JlZ2lzdGVyX2NsYXNzX3Byb3BlcnR5CBlfZW1iaW5kX3JlZ2lzdGVyX2Z1bmN0aW9uCRlfZW1iaW5kX3JlZ2lzdGVyX2NvbnN0YW50ChFfZW12YWxfdGFrZV92YWx1ZQsiX2VtYmluZF9yZWdpc3Rlcl9jbGFzc19jb25zdHJ1Y3RvcgwfX2VtYmluZF9yZWdpc3Rlcl9jbGFzc19mdW5jdGlvbg0NX2VtdmFsX2luY3JlZg4KX19zeXNjYWxsNQ8MX19zeXNjYWxsMTkyEAtfX3N5c2NhbGw5MREMX19zeXNjYWxsMTk3EgxfX3N5c2NhbGwxOTUTD19fd2FzaV9mZF93cml0ZRQPX193YXNpX2ZkX2Nsb3NlFQxfX3N5c2NhbGwxOTQWCl9fc3lzY2FsbDMXFF9fd2FzaV9mZF9mZHN0YXRfZ2V0GAVhYm9ydBkVX2VtYmluZF9yZWdpc3Rlcl92b2lkGhVfZW1iaW5kX3JlZ2lzdGVyX2Jvb2wbG19lbWJpbmRfcmVnaXN0ZXJfc3RkX3N0cmluZxwcX2VtYmluZF9yZWdpc3Rlcl9zdGRfd3N0cmluZx0WX2VtYmluZF9yZWdpc3Rlcl9lbXZhbB4YX2VtYmluZF9yZWdpc3Rlcl9pbnRlZ2VyHxZfZW1iaW5kX3JlZ2lzdGVyX2Zsb2F0IBxfZW1iaW5kX3JlZ2lzdGVyX21lbW9yeV92aWV3IRZlbXNjcmlwdGVuX3Jlc2l6ZV9oZWFwIhVlbXNjcmlwdGVuX21lbWNweV9iaWcjF19faGFuZGxlX3N0YWNrX292ZXJmbG93JAtzZXRUZW1wUmV0MCUabGVnYWxpbXBvcnQkX193YXNpX2ZkX3NlZWsmF2Vtc2NyaXB0ZW5fZ2V0X3NicmtfcHRyJxFfX3dhc21fY2FsbF9jdG9ycygMY3J5cHRfYXJnY2hrKQhtZDVfaW5pdCoLbWQ1X3Byb2Nlc3MrDG1kNV9jb21wcmVzcywIbWQ1X2RvbmUtCG1kNV90ZXN0Lg1yZWdpc3Rlcl9oYXNoLwlzaGExX2luaXQwDHNoYTFfcHJvY2VzczENc2hhMV9jb21wcmVzczIJc2hhMV9kb25lMwlzaGExX3Rlc3Q0DExpYlRvbU1hbGxvYzUMTGliVG9tQ2FsbG9jNgpMaWJUb21GcmVlNwtMaWJUb21Rc29ydDgHbXBfaW5pdDkHbXBfZ3JvdzoHbXBfY29weTsIbXBfY2xlYXI8Bm1wX25lZz0HbXBfemVybz4HbXBfbHNoZD8IbXBfY2xhbXBACW1wX211bF8yZEEKbXBfc2V0X2ludEIKbXBfZ2V0X2ludEMKbXBfY21wX21hZ0QGbXBfY21wRQhtcF9jbXBfZEYNbXBfY291bnRfYml0c0cKbXBfY250X2xzYkgIbXBfMmV4cHRJCG1wX211bF9kSghtcF9zdWJfZEsIbXBfYWRkX2RMDW1wX3JlYWRfcmFkaXhNDG1wX2luaXRfY29weU4JbXBfbW9kXzJkTwdtcF9yc2hkUAdtcF9leGNoUQltcF9kaXZfMmRSDG1wX2luaXRfc2l6ZVMIbXBfZGl2XzNUCG1wX2Rpdl9kVQpibl9yZXZlcnNlVgptcF90b3JhZGl4VxRtcF91bnNpZ25lZF9iaW5fc2l6ZVgSbXBfdG9fdW5zaWduZWRfYmluWRRtcF9yZWFkX3Vuc2lnbmVkX2JpbloIc19tcF9hZGRbCHNfbXBfc3ViXAZtcF9hZGRdBm1wX3N1Yl4NbXBfaW5pdF9tdWx0aV8IbXBfbXVsXzJgCG1wX2Rpdl8yYQ5tcF9jbGVhcl9tdWx0aWILbXBfdG9vbV9tdWxjEG1wX2thcmF0c3ViYV9tdWxkEmZhc3Rfc19tcF9tdWxfZGlnc2UNc19tcF9tdWxfZGlnc2YGbXBfbXVsZwttcF90b29tX3NxcmgQbXBfa2FyYXRzdWJhX3NxcmkNZmFzdF9zX21wX3NxcmoIc19tcF9zcXJrBm1wX3NxcmwGbXBfZGl2bQhtcF9tb2RfZG4GbXBfYWJzbwZtcF9nY2RwBm1wX2xjbXEGbXBfbW9kcgltcF9tdWxtb2RzCW1wX3Nxcm1vZHQGbXBfc2V0dQ5mYXN0X21wX2ludm1vZHYObXBfaW52bW9kX3Nsb3d3CW1wX2ludm1vZHgTbXBfbW9udGdvbWVyeV9zZXR1cHkgbXBfbW9udGdvbWVyeV9jYWxjX25vcm1hbGl6YXRpb256GWZhc3RfbXBfbW9udGdvbWVyeV9yZWR1Y2V7FG1wX21vbnRnb21lcnlfcmVkdWNlfBFtcF9yZWR1Y2VfaXNfMmtfbH0PbXBfcmVkdWNlX3NldHVwfhdmYXN0X3NfbXBfbXVsX2hpZ2hfZGlnc38Sc19tcF9tdWxfaGlnaF9kaWdzgAEJbXBfcmVkdWNlgQEUbXBfcmVkdWNlXzJrX3NldHVwX2yCAQ5tcF9yZWR1Y2VfMmtfbIMBDHNfbXBfZXhwdG1vZIQBEG1wX2RyX2lzX21vZHVsdXOFAQ9tcF9yZWR1Y2VfaXNfMmuGAQttcF9kcl9zZXR1cIcBDG1wX2RyX3JlZHVjZYgBEm1wX3JlZHVjZV8ya19zZXR1cIkBDG1wX3JlZHVjZV8ya4oBD21wX2V4cHRtb2RfZmFzdIsBCm1wX2V4cHRtb2SMARVtcF9wcmltZV9pc19kaXZpc2libGWNARVtcF9wcmltZV9taWxsZXJfcmFiaW6OARFtcF9wcmltZV9pc19wcmltZY8BDmx0Y19pbml0X211bHRpkAEQbHRjX2RlaW5pdF9tdWx0aZEBEWx0Y19lY2NfbmV3X3BvaW50kgERbHRjX2VjY19kZWxfcG9pbnSTAQtsdGNfZWNjX21hcJQBDmx0Y19lY2NfbXVsbW9klQEcbHRjX2VjY19wcm9qZWN0aXZlX2RibF9wb2ludJYBHGx0Y19lY2NfcHJvamVjdGl2ZV9hZGRfcG9pbnSXAQ9sdGNfZWNjX211bDJhZGSYAQ1wcm5nX2lzX3ZhbGlkmQEKcmFuZF9wcmltZZoBDHJzYV9tYWtlX2tleZsBB3plcm9tZW2cAQtyc2FfZXhwdG1vZJ0BBGluaXSeAQlpbml0X2NvcHmfAQZkZWluaXSgAQNuZWehAQRjb3B5ogEHc2V0X2ludKMBB2dldF9pbnSkAQlnZXRfZGlnaXSlAQ9nZXRfZGlnaXRfY291bnSmAQdjb21wYXJlpwEJY29tcGFyZV9kqAEKY291bnRfYml0c6kBDmNvdW50X2xzYl9iaXRzqgEHdHdvZXhwdKsBCnJlYWRfcmFkaXisAQt3cml0ZV9yYWRpeK0BDXVuc2lnbmVkX3NpemWuAQ51bnNpZ25lZF93cml0Za8BDXVuc2lnbmVkX3JlYWSwAQNhZGSxAQRhZGRpsgEDc3ViswEEc3ViabQBA211bLUBBG11bGm2AQNzcXK3AQZkaXZpZGW4AQVkaXZfMrkBBG1vZGm6AQNnY2S7AQNsY228AQZtdWxtb2S9AQZzcXJtb2S+AQZpbnZtb2S/ARBtb250Z29tZXJ5X3NldHVwwAEYbW9udGdvbWVyeV9ub3JtYWxpemF0aW9uwQERbW9udGdvbWVyeV9yZWR1Y2XCARFtb250Z29tZXJ5X2RlaW5pdMMBB2V4cHRtb2TEAQdpc3ByaW1lxQELaGFzaGxpdHRsZTLGAQxHZXRMYXN0RXJyb3LHAQxTZXRMYXN0RXJyb3LIARNGaWxlU3RyZWFtX09wZW5GaWxlyQEdQmFzZUZpbGVfQ3JlYXRlKFRGaWxlU3RyZWFtKinKARFGaWxlU3RyZWFtX1ByZWZpeMsBJEZsYXRTdHJlYW1fTG9hZEJpdG1hcChUQmxvY2tTdHJlYW0qKcwBEEZpbGVTdHJlYW1fQ2xvc2XNAThGbGF0U3RyZWFtX0Jsb2NrQ2hlY2soVEJsb2NrU3RyZWFtKiwgdW5zaWduZWQgbG9uZyBsb25nKc4BH0ZsYXRTdHJlYW1fQ2xvc2UoVEJsb2NrU3RyZWFtKinPATVCbG9ja1N0cmVhbV9HZXRQb3MoVEZpbGVTdHJlYW0qLCB1bnNpZ25lZCBsb25nIGxvbmcqKdABNkJsb2NrU3RyZWFtX0dldFNpemUoVEZpbGVTdHJlYW0qLCB1bnNpZ25lZCBsb25nIGxvbmcqKdEBSUJsb2NrU3RyZWFtX1JlYWQoVEJsb2NrU3RyZWFtKiwgdW5zaWduZWQgbG9uZyBsb25nKiwgdm9pZCosIHVuc2lnbmVkIGludCnSAW9GbGF0U3RyZWFtX0Jsb2NrUmVhZChUQmxvY2tTdHJlYW0qLCB1bnNpZ25lZCBsb25nIGxvbmcsIHVuc2lnbmVkIGxvbmcgbG9uZywgdW5zaWduZWQgY2hhciosIHVuc2lnbmVkIGludCwgYm9vbCnTASRQYXJ0U3RyZWFtX0xvYWRCaXRtYXAoVEJsb2NrU3RyZWFtKinUAVFEZWNyeXB0RmlsZUNodW5rKHVuc2lnbmVkIGludCosIHVuc2lnbmVkIGNoYXIqLCB1bnNpZ25lZCBsb25nIGxvbmcsIHVuc2lnbmVkIGludCnVAXFCbG9jazRTdHJlYW1fQmxvY2tSZWFkKFRCbG9ja1N0cmVhbSosIHVuc2lnbmVkIGxvbmcgbG9uZywgdW5zaWduZWQgbG9uZyBsb25nLCB1bnNpZ25lZCBjaGFyKiwgdW5zaWduZWQgaW50LCBib29sKdYBIUJsb2NrNFN0cmVhbV9DbG9zZShUQmxvY2tTdHJlYW0qKdcBc01wcWVTdHJlYW1fQmxvY2tSZWFkKFRFbmNyeXB0ZWRTdHJlYW0qLCB1bnNpZ25lZCBsb25nIGxvbmcsIHVuc2lnbmVkIGxvbmcgbG9uZywgdW5zaWduZWQgY2hhciosIHVuc2lnbmVkIGludCwgYm9vbCnYAThQYXJ0U3RyZWFtX0Jsb2NrQ2hlY2soVEJsb2NrU3RyZWFtKiwgdW5zaWduZWQgbG9uZyBsb25nKdkBH1BhcnRTdHJlYW1fQ2xvc2UoVEJsb2NrU3RyZWFtKinaAW9QYXJ0U3RyZWFtX0Jsb2NrUmVhZChUQmxvY2tTdHJlYW0qLCB1bnNpZ25lZCBsb25nIGxvbmcsIHVuc2lnbmVkIGxvbmcgbG9uZywgdW5zaWduZWQgY2hhciosIHVuc2lnbmVkIGludCwgYm9vbCnbARZGaWxlU3RyZWFtX0dldEZpbGVOYW1l3AEURmlsZVN0cmVhbV9HZXRCaXRtYXDdAQ9GaWxlU3RyZWFtX1JlYWTeARBGaWxlU3RyZWFtX1dyaXRl3wESRmlsZVN0cmVhbV9HZXRTaXpl4AESRmlsZVN0cmVhbV9TZXRTaXpl4QERRmlsZVN0cmVhbV9HZXRQb3PiARNGaWxlU3RyZWFtX0dldEZsYWdz4wE2QmFzZUZpbGVfT3BlbihURmlsZVN0cmVhbSosIGNoYXIgY29uc3QqLCB1bnNpZ25lZCBpbnQp5AEbQmFzZUZpbGVfSW5pdChURmlsZVN0cmVhbSop5QEcQmFzZUZpbGVfQ2xvc2UoVEZpbGVTdHJlYW0qKeYBMkJhc2VGaWxlX0dldFBvcyhURmlsZVN0cmVhbSosIHVuc2lnbmVkIGxvbmcgbG9uZyop5wEzQmFzZUZpbGVfR2V0U2l6ZShURmlsZVN0cmVhbSosIHVuc2lnbmVkIGxvbmcgbG9uZyop6AExQmFzZUZpbGVfUmVzaXplKFRGaWxlU3RyZWFtKiwgdW5zaWduZWQgbG9uZyBsb25nKekBTEJhc2VGaWxlX1dyaXRlKFRGaWxlU3RyZWFtKiwgdW5zaWduZWQgbG9uZyBsb25nKiwgdm9pZCBjb25zdCosIHVuc2lnbmVkIGludCnqAUVCYXNlRmlsZV9SZWFkKFRGaWxlU3RyZWFtKiwgdW5zaWduZWQgbG9uZyBsb25nKiwgdm9pZCosIHVuc2lnbmVkIGludCnrARpCYXNlTWFwX0luaXQoVEZpbGVTdHJlYW0qKewBG0Jhc2VNYXBfQ2xvc2UoVEZpbGVTdHJlYW0qKe0BREJhc2VNYXBfUmVhZChURmlsZVN0cmVhbSosIHVuc2lnbmVkIGxvbmcgbG9uZyosIHZvaWQqLCB1bnNpZ25lZCBpbnQp7gE1QmFzZU1hcF9PcGVuKFRGaWxlU3RyZWFtKiwgY2hhciBjb25zdCosIHVuc2lnbmVkIGludCnvARtCYXNlSHR0cF9Jbml0KFRGaWxlU3RyZWFtKinwARxCYXNlSHR0cF9DbG9zZShURmlsZVN0cmVhbSop8QFFQmFzZUh0dHBfUmVhZChURmlsZVN0cmVhbSosIHVuc2lnbmVkIGxvbmcgbG9uZyosIHZvaWQqLCB1bnNpZ25lZCBpbnQp8gE2QmFzZUh0dHBfT3BlbihURmlsZVN0cmVhbSosIGNoYXIgY29uc3QqLCB1bnNpZ25lZCBpbnQp8wEbQmFzZU5vbmVfSW5pdChURmlsZVN0cmVhbSop9AFKQ29udmVydFNxcEhlYWRlclRvRm9ybWF0NChfVE1QUUFyY2hpdmUqLCB1bnNpZ25lZCBsb25nIGxvbmcsIHVuc2lnbmVkIGludCn1AR9Mb2FkU3FwSGFzaFRhYmxlKF9UTVBRQXJjaGl2ZSop9gEgTG9hZFNxcEJsb2NrVGFibGUoX1RNUFFBcmNoaXZlKin3AUpDb252ZXJ0TXBrSGVhZGVyVG9Gb3JtYXQ0KF9UTVBRQXJjaGl2ZSosIHVuc2lnbmVkIGxvbmcgbG9uZywgdW5zaWduZWQgaW50KfgBJURlY3J5cHRNcGtUYWJsZSh2b2lkKiwgdW5zaWduZWQgbG9uZyn5AR9Mb2FkTXBrSGFzaFRhYmxlKF9UTVBRQXJjaGl2ZSop+gEgTG9hZE1wa0Jsb2NrVGFibGUoX1RNUFFBcmNoaXZlKin7ATBUSW5wdXRTdHJlYW06OlRJbnB1dFN0cmVhbSh2b2lkKiwgdW5zaWduZWQgbG9uZyn8ATJUT3V0cHV0U3RyZWFtOjpUT3V0cHV0U3RyZWFtKHZvaWQqLCB1bnNpZ25lZCBsb25nKf0BIlRIdWZmbWFublRyZWU6OlRIdWZmbWFublRyZWUoYm9vbCn+AR9USHVmZm1hbm5UcmVlOjp+VEh1ZmZtYW5uVHJlZSgp/wEmVEh1ZmZtYW5uVHJlZTo6QnVpbGRUcmVlKHVuc2lnbmVkIGludCmAAjJUSHVmZm1hbm5UcmVlOjpJbmNXZWlnaHRzQW5kUmViYWxhbmNlKFRIVHJlZUl0ZW0qKYECRlRIdWZmbWFublRyZWU6Okluc2VydE5ld0JyYW5jaEFuZFJlYmFsYW5jZSh1bnNpZ25lZCBpbnQsIHVuc2lnbmVkIGludCmCAitUSHVmZm1hbm5UcmVlOjpEZWNvZGVPbmVCeXRlKFRJbnB1dFN0cmVhbSopgwI4VEh1ZmZtYW5uVHJlZTo6Q29tcHJlc3MoVE91dHB1dFN0cmVhbSosIHZvaWQqLCBpbnQsIGludCmEAj1USHVmZm1hbm5UcmVlOjpEZWNvbXByZXNzKHZvaWQqLCB1bnNpZ25lZCBpbnQsIFRJbnB1dFN0cmVhbSophQIHemNhbGxvY4YCBnpjZnJlZYcCBWNyYzMyiAIHYWRsZXIzMokCCF90cl9pbml0igIKaW5pdF9ibG9ja4sCEF90cl9zdG9yZWRfYmxvY2uMAglfdHJfYWxpZ26NAg9fdHJfZmx1c2hfYmxvY2uOAgpidWlsZF90cmVljwIOY29tcHJlc3NfYmxvY2uQAglzZW5kX3RyZWWRAg1kZWZsYXRlSW5pdDJfkgIKZGVmbGF0ZUVuZJMCDGRlZmxhdGVSZXNldJQCB2RlZmxhdGWVAgtmaWxsX3dpbmRvd5YCDmRlZmxhdGVfc3RvcmVklwIMZGVmbGF0ZV9mYXN0mAINbG9uZ2VzdF9tYXRjaJkCDGRlZmxhdGVfc2xvd5oCDWluZmxhdGVfdGFibGWbAgxpbmZsYXRlX2Zhc3ScAgxpbmZsYXRlSW5pdF+dAgdpbmZsYXRlngIMdXBkYXRld2luZG93nwIKaW5mbGF0ZUVuZKACJ0NvbXByZXNzU3BhcnNlKHZvaWQqLCBpbnQqLCB2b2lkKiwgaW50KaECKURlY29tcHJlc3NTcGFyc2Uodm9pZCosIGludCosIHZvaWQqLCBpbnQpogIHaW1wbG9kZaMCB0ZpbmRSZXCkAgpPdXRwdXRCaXRzpQIHZXhwbG9kZaYCIk1hdGNoRmluZGVyX0dldFBvaW50ZXJUb0N1cnJlbnRQb3OnAhhNYXRjaEZpbmRlcl9HZXRJbmRleEJ5dGWoAiBNYXRjaEZpbmRlcl9HZXROdW1BdmFpbGFibGVCeXRlc6kCFU1hdGNoRmluZGVyX1JlYWRCbG9ja6oCFU1hdGNoRmluZGVyX0NvbnN0cnVjdKsCEE1hdGNoRmluZGVyX0ZyZWWsAhJNYXRjaEZpbmRlcl9DcmVhdGWtAhBNYXRjaEZpbmRlcl9Jbml0rgIPR2V0TWF0Y2hlc1NwZWMxrwIXTWF0Y2hGaW5kZXJfQ2hlY2tMaW1pdHOwAhhNYXRjaEZpbmRlcl9DcmVhdGVWVGFibGWxAhpIYzRfTWF0Y2hGaW5kZXJfR2V0TWF0Y2hlc7ICFEhjNF9NYXRjaEZpbmRlcl9Ta2lwswIaQnQyX01hdGNoRmluZGVyX0dldE1hdGNoZXO0AhRCdDJfTWF0Y2hGaW5kZXJfU2tpcLUCGkJ0M19NYXRjaEZpbmRlcl9HZXRNYXRjaGVztgIUQnQzX01hdGNoRmluZGVyX1NraXC3AhpCdDRfTWF0Y2hGaW5kZXJfR2V0TWF0Y2hlc7gCFEJ0NF9NYXRjaEZpbmRlcl9Ta2lwuQIRTHptYUVuY1Byb3BzX0luaXS6AhBMem1hRW5jX1NldFByb3BzuwIRTHptYUVuY19Db25zdHJ1Y3S8AgxMem1hRW5jX0luaXS9AhNGaWxsRGlzdGFuY2VzUHJpY2VzvgIPRmlsbEFsaWduUHJpY2VzvwIXTGVuUHJpY2VFbmNfVXBkYXRlVGFibGXAAhRMem1hRW5jX0FsbG9jQW5kSW5pdMECB015V3JpdGXCAhRMem1hRW5jX0NvZGVPbmVCbG9ja8MCDkxlbkVuY19FbmNvZGUyxAIFRmx1c2jFAhdMem1hRW5jX1dyaXRlUHJvcGVydGllc8YCEUx6bWFFbmNfTWVtRW5jb2RlxwIKTHptYUVuY29kZcgCDUJaMl9ibG9ja1NvcnTJAgdtYWluR3RVygIMZmFsbGJhY2tTb3J0ywIVQloyX2hiTWFrZUNvZGVMZW5ndGhzzAIRQloyX2hiQXNzaWduQ29kZXPNAhhCWjJfaGJDcmVhdGVEZWNvZGVUYWJsZXPOAhFCWjJfY29tcHJlc3NCbG9ja88CC2JzUHV0VUludDMy0AINc2VuZE1URlZhbHVlc9ECDkJaMl9kZWNvbXByZXNz0gIVQloyX2J6X19Bc3NlcnRIX19mYWls0wISQloyX2J6Q29tcHJlc3NJbml01AIPZGVmYXVsdF9iemFsbG9j1QIOZGVmYXVsdF9iemZyZWXWAg5CWjJfYnpDb21wcmVzc9cCD2hhbmRsZV9jb21wcmVzc9gCEWFkZF9wYWlyX3RvX2Jsb2Nr2QIRQloyX2J6Q29tcHJlc3NFbmTaAhRCWjJfYnpEZWNvbXByZXNzSW5pdNsCDkJaMl9pbmRleEludG9G3AIQQloyX2J6RGVjb21wcmVzc90CE0JaMl9iekRlY29tcHJlc3NFbmTeAhNMem1hRGVjX0RlY29kZVRvRGlj3wIQTHptYURlY19UcnlEdW1teeACE0x6bWFEZWNfRGVjb2RlUmVhbDLhAgpMem1hRGVjb2Rl4gIvQ29tcHJlc3NBRFBDTSh2b2lkKiwgaW50LCB2b2lkKiwgaW50LCBpbnQsIGludCnjAixEZWNvbXByZXNzQURQQ00odm9pZCosIGludCwgdm9pZCosIGludCwgaW50KeQCMUNvbXByZXNzX2h1ZmYodm9pZCosIGludCosIHZvaWQqLCBpbnQsIGludCosIGludCnlAihEZWNvbXByZXNzX2h1ZmYodm9pZCosIGludCosIHZvaWQqLCBpbnQp5gIxQ29tcHJlc3NfWkxJQih2b2lkKiwgaW50Kiwgdm9pZCosIGludCwgaW50KiwgaW50KecCKERlY29tcHJlc3NfWkxJQih2b2lkKiwgaW50Kiwgdm9pZCosIGludCnoAjNDb21wcmVzc19TUEFSU0Uodm9pZCosIGludCosIHZvaWQqLCBpbnQsIGludCosIGludCnpAipEZWNvbXByZXNzX1NQQVJTRSh2b2lkKiwgaW50Kiwgdm9pZCosIGludCnqAgxTQ29tcEltcGxvZGXrAipSZWFkSW5wdXREYXRhKGNoYXIqLCB1bnNpZ25lZCBpbnQqLCB2b2lkKinsAixXcml0ZU91dHB1dERhdGEoY2hhciosIHVuc2lnbmVkIGludCosIHZvaWQqKe0CMkNvbXByZXNzX1BLTElCKHZvaWQqLCBpbnQqLCB2b2lkKiwgaW50LCBpbnQqLCBpbnQp7gIMU0NvbXBFeHBsb2Rl7wIpRGVjb21wcmVzc19QS0xJQih2b2lkKiwgaW50Kiwgdm9pZCosIGludCnwAg1TQ29tcENvbXByZXNz8QI3Q29tcHJlc3NfQURQQ01fbW9ubyh2b2lkKiwgaW50Kiwgdm9pZCosIGludCwgaW50KiwgaW50KfICOUNvbXByZXNzX0FEUENNX3N0ZXJlbyh2b2lkKiwgaW50Kiwgdm9pZCosIGludCwgaW50KiwgaW50KfMCMkNvbXByZXNzX0JaSVAyKHZvaWQqLCBpbnQqLCB2b2lkKiwgaW50LCBpbnQqLCBpbnQp9AIxQ29tcHJlc3NfTFpNQSh2b2lkKiwgaW50Kiwgdm9pZCosIGludCwgaW50KiwgaW50KfUCRUxaTUFfQ2FsbGJhY2tfUHJvZ3Jlc3Modm9pZCosIHVuc2lnbmVkIGxvbmcgbG9uZywgdW5zaWduZWQgbG9uZyBsb25nKfYCIExaTUFfQ2FsbGJhY2tfRnJlZSh2b2lkKiwgdm9pZCop9wIpTFpNQV9DYWxsYmFja19BbGxvYyh2b2lkKiwgdW5zaWduZWQgbG9uZyn4Ag9TQ29tcERlY29tcHJlc3P5AhBTQ29tcERlY29tcHJlc3My+gIwRGVjb21wcmVzc19BRFBDTV9zdGVyZW8odm9pZCosIGludCosIHZvaWQqLCBpbnQp+wIpRGVjb21wcmVzc19CWklQMih2b2lkKiwgaW50Kiwgdm9pZCosIGludCn8AihEZWNvbXByZXNzX0xaTUEodm9pZCosIGludCosIHZvaWQqLCBpbnQp/QIuRGVjb21wcmVzc19BRFBDTV9tb25vKHZvaWQqLCBpbnQqLCB2b2lkKiwgaW50Kf4CK1NDb21wRGVjb21wcmVzc01wayh2b2lkKiwgaW50Kiwgdm9pZCosIGludCn/AitPcGVuUGF0Y2hlZEZpbGUodm9pZCosIGNoYXIgY29uc3QqLCB2b2lkKiopgAMPU0ZpbGVPcGVuRmlsZUV4gQMMU0ZpbGVIYXNGaWxlggMOU0ZpbGVDbG9zZUZpbGWDAzpGaWxlT2Zmc2V0RnJvbU1wcU9mZnNldChfVE1QUUFyY2hpdmUqLCB1bnNpZ25lZCBsb25nIGxvbmcphAMyQ2FsY3VsYXRlUmF3U2VjdG9yT2Zmc2V0KF9UTVBRRmlsZSosIHVuc2lnbmVkIGludCmFA2RDb252ZXJ0TXBxSGVhZGVyVG9Gb3JtYXQ0KF9UTVBRQXJjaGl2ZSosIHVuc2lnbmVkIGxvbmcgbG9uZywgdW5zaWduZWQgbG9uZyBsb25nLCB1bnNpZ25lZCBpbnQsIGJvb2wphgMrSXNWYWxpZEhhc2hFbnRyeShfVE1QUUFyY2hpdmUqLCBfVE1QUUhhc2gqKYcDWkxvYWRFeHRUYWJsZShfVE1QUUFyY2hpdmUqLCB1bnNpZ25lZCBsb25nIGxvbmcsIHVuc2lnbmVkIGxvbmcsIHVuc2lnbmVkIGludCwgdW5zaWduZWQgaW50KYgDSENyZWF0ZUhldFRhYmxlKHVuc2lnbmVkIGludCwgdW5zaWduZWQgaW50LCB1bnNpZ25lZCBpbnQsIHVuc2lnbmVkIGNoYXIqKYkDHEZyZWVIZXRUYWJsZShfVE1QUUhldFRhYmxlKimKAzVUcmFuc2xhdGVCZXRUYWJsZShfVE1QUUFyY2hpdmUqLCB1bnNpZ25lZCBsb25nIGxvbmcqKYsDHEZyZWVCZXRUYWJsZShfVE1QUUJldFRhYmxlKimMA0xHZXRGaWxlRW50cnlMb2NhbGUyKF9UTVBRQXJjaGl2ZSosIGNoYXIgY29uc3QqLCB1bnNpZ25lZCBpbnQsIHVuc2lnbmVkIGludCopjQMsR2V0RmlsZUluZGV4X0hldChfVE1QUUFyY2hpdmUqLCBjaGFyIGNvbnN0KimOAzxHZXRGaWxlRW50cnlMb2NhbGUoX1RNUFFBcmNoaXZlKiwgY2hhciBjb25zdCosIHVuc2lnbmVkIGludCmPA0pHZXRGaWxlRW50cnlFeGFjdChfVE1QUUFyY2hpdmUqLCBjaGFyIGNvbnN0KiwgdW5zaWduZWQgaW50LCB1bnNpZ25lZCBpbnQqKZADOkFsbG9jYXRlRmlsZU5hbWUoX1RNUFFBcmNoaXZlKiwgX1RGaWxlRW50cnkqLCBjaGFyIGNvbnN0KimRA0pBbGxvY2F0ZUZpbGVFbnRyeShfVE1QUUFyY2hpdmUqLCBjaGFyIGNvbnN0KiwgdW5zaWduZWQgaW50LCB1bnNpZ25lZCBpbnQqKZIDKkRlbGV0ZUZpbGVFbnRyeShfVE1QUUFyY2hpdmUqLCBfVE1QUUZpbGUqKZMDTkludmFsaWRhdGVJbnRlcm5hbEZpbGUoX1RNUFFBcmNoaXZlKiwgY2hhciBjb25zdCosIHVuc2lnbmVkIGludCwgdW5zaWduZWQgaW50KZQDJkludmFsaWRhdGVJbnRlcm5hbEZpbGVzKF9UTVBRQXJjaGl2ZSoplQMjTG9hZEJsb2NrVGFibGUoX1RNUFFBcmNoaXZlKiwgYm9vbCmWAxtMb2FkSGV0VGFibGUoX1RNUFFBcmNoaXZlKimXAxtMb2FkQmV0VGFibGUoX1RNUFFBcmNoaXZlKimYAx9Mb2FkQW55SGFzaFRhYmxlKF9UTVBRQXJjaGl2ZSopmQMdQnVpbGRGaWxlVGFibGUoX1RNUFFBcmNoaXZlKimaAyJEZWZyYWdtZW50RmlsZVRhYmxlKF9UTVBRQXJjaGl2ZSopmwMeUmVidWlsZEhldFRhYmxlKF9UTVBRQXJjaGl2ZSopnAMcU2F2ZU1QUVRhYmxlcyhfVE1QUUFyY2hpdmUqKZ0DgQFTYXZlRXh0VGFibGUoX1RNUFFBcmNoaXZlKiwgX1RNUFFFeHRIZWFkZXIqLCB1bnNpZ25lZCBsb25nIGxvbmcsIHVuc2lnbmVkIGludCwgdW5zaWduZWQgY2hhciosIHVuc2lnbmVkIGludCwgYm9vbCwgdW5zaWduZWQgaW50KimeAy1TdHJpbmdDb3B5KGNoYXIqLCB1bnNpZ25lZCBsb25nLCBjaGFyIGNvbnN0KimfAyxTdHJpbmdDYXQoY2hhciosIHVuc2lnbmVkIGxvbmcsIGNoYXIgY29uc3QqKaADG0luaXRpYWxpemVNcHFDcnlwdG9ncmFwaHkoKaEDKkhhc2hTdHJpbmdTbGFzaChjaGFyIGNvbnN0KiwgdW5zaWduZWQgaW50KaIDKkhhc2hTdHJpbmdMb3dlcihjaGFyIGNvbnN0KiwgdW5zaWduZWQgaW50KaMDIkdldE5lYXJlc3RQb3dlck9mVHdvKHVuc2lnbmVkIGludCmkAx5IYXNoU3RyaW5nSmVua2lucyhjaGFyIGNvbnN0KimlAzhHZXREZWZhdWx0U3BlY2lhbEZpbGVGbGFncyh1bnNpZ25lZCBpbnQsIHVuc2lnbmVkIHNob3J0KaYDMkVuY3J5cHRNcHFCbG9jayh2b2lkKiwgdW5zaWduZWQgaW50LCB1bnNpZ25lZCBpbnQppwMyRGVjcnlwdE1wcUJsb2NrKHZvaWQqLCB1bnNpZ25lZCBpbnQsIHVuc2lnbmVkIGludCmoAzlEZXRlY3RGaWxlS2V5QnlDb250ZW50KHZvaWQqLCB1bnNpZ25lZCBpbnQsIHVuc2lnbmVkIGludCmpA0tEZWNyeXB0RmlsZUtleShjaGFyIGNvbnN0KiwgdW5zaWduZWQgbG9uZyBsb25nLCB1bnNpZ25lZCBpbnQsIHVuc2lnbmVkIGludCmqAxdJc1ZhbGlkTXBxSGFuZGxlKHZvaWQqKasDGElzVmFsaWRGaWxlSGFuZGxlKHZvaWQqKawDLUdldEZpcnN0SGFzaEVudHJ5KF9UTVBRQXJjaGl2ZSosIGNoYXIgY29uc3QqKa0DN0dldE5leHRIYXNoRW50cnkoX1RNUFFBcmNoaXZlKiwgX1RNUFFIYXNoKiwgX1RNUFFIYXNoKimuAzxBbGxvY2F0ZUhhc2hFbnRyeShfVE1QUUFyY2hpdmUqLCBfVEZpbGVFbnRyeSosIHVuc2lnbmVkIGludCmvAx9GaW5kRnJlZU1wcVNwYWNlKF9UTVBRQXJjaGl2ZSopsAMiSXNJbnRlcm5hbE1wcUZpbGVOYW1lKGNoYXIgY29uc3QqKbEDLUNyZWF0ZUZpbGVIYW5kbGUoX1RNUFFBcmNoaXZlKiwgX1RGaWxlRW50cnkqKbIDMUNyZWF0ZVdyaXRhYmxlSGFuZGxlKF9UTVBRQXJjaGl2ZSosIHVuc2lnbmVkIGludCmzA2BMb2FkTXBxVGFibGUoX1RNUFFBcmNoaXZlKiwgdW5zaWduZWQgbG9uZyBsb25nLCB1bnNpZ25lZCBpbnQsIHVuc2lnbmVkIGludCwgdW5zaWduZWQgaW50LCBib29sKim0AyBBbGxvY2F0ZVNlY3RvckJ1ZmZlcihfVE1QUUZpbGUqKbUDI0FsbG9jYXRlUGF0Y2hJbmZvKF9UTVBRRmlsZSosIGJvb2wptgMnQWxsb2NhdGVTZWN0b3JPZmZzZXRzKF9UTVBRRmlsZSosIGJvb2wptwMpQWxsb2NhdGVTZWN0b3JDaGVja3N1bXMoX1RNUFFGaWxlKiwgYm9vbCm4AxpXcml0ZVBhdGNoSW5mbyhfVE1QUUZpbGUqKbkDHldyaXRlU2VjdG9yT2Zmc2V0cyhfVE1QUUZpbGUqKboDIFdyaXRlU2VjdG9yQ2hlY2tzdW1zKF9UTVBRRmlsZSopuwNjV3JpdGVNZW1EYXRhTUQ1KFRGaWxlU3RyZWFtKiwgdW5zaWduZWQgbG9uZyBsb25nLCB2b2lkKiwgdW5zaWduZWQgaW50LCB1bnNpZ25lZCBpbnQsIHVuc2lnbmVkIGludCopvAM7Q2FsY3VsYXRlRGF0YUJsb2NrSGFzaCh2b2lkKiwgdW5zaWduZWQgaW50LCB1bnNpZ25lZCBjaGFyKim9A01Xcml0ZU1wcURhdGFNRDUoVEZpbGVTdHJlYW0qLCB1bnNpZ25lZCBsb25nIGxvbmcsIHVuc2lnbmVkIGludCwgdW5zaWduZWQgaW50Kb4DG0ZyZWVGaWxlSGFuZGxlKF9UTVBRRmlsZSomKb8DIUZyZWVBcmNoaXZlSGFuZGxlKF9UTVBRQXJjaGl2ZSomKcADLElzUHNldWRvRmlsZU5hbWUoY2hhciBjb25zdCosIHVuc2lnbmVkIGludCopwQM4VmVyaWZ5RGF0YUJsb2NrSGFzaCh2b2lkKiwgdW5zaWduZWQgaW50LCB1bnNpZ25lZCBjaGFyKinCAw1TRmlsZVJlYWRGaWxlwwNTUmVhZE1wcUZpbGVTaW5nbGVVbml0KF9UTVBRRmlsZSosIHZvaWQqLCB1bnNpZ25lZCBpbnQsIHVuc2lnbmVkIGludCwgdW5zaWduZWQgaW50KinEA1NSZWFkTXBxRmlsZVNlY3RvckZpbGUoX1RNUFFGaWxlKiwgdm9pZCosIHVuc2lnbmVkIGludCwgdW5zaWduZWQgaW50LCB1bnNpZ25lZCBpbnQqKcUDVVJlYWRNcHFTZWN0b3JzKF9UTVBRRmlsZSosIHVuc2lnbmVkIGNoYXIqLCB1bnNpZ25lZCBpbnQsIHVuc2lnbmVkIGludCwgdW5zaWduZWQgaW50KinGAxBTRmlsZUdldEZpbGVTaXplxwMTU0ZpbGVTZXRGaWxlUG9pbnRlcsgDCWZpbmRfaGFzaMkDDWJhc2U2NF9kZWNvZGXKAxJkZXJfZGVjb2RlX2Jvb2xlYW7LAxJkZXJfbGVuZ3RoX2Jvb2xlYW7MAxJkZXJfZGVjb2RlX2ludGVnZXLNAxhkZXJfZGVjb2RlX3Nob3J0X2ludGVnZXLOAxhkZXJfbGVuZ3RoX3Nob3J0X2ludGVnZXLPAxVkZXJfZGVjb2RlX2JpdF9zdHJpbmfQAxVkZXJfbGVuZ3RoX2JpdF9zdHJpbmfRAxdkZXJfZGVjb2RlX29jdGV0X3N0cmluZ9IDF2Rlcl9sZW5ndGhfb2N0ZXRfc3RyaW5n0wMcZGVyX2RlY29kZV9vYmplY3RfaWRlbnRpZmllctQDGmRlcl9vYmplY3RfaWRlbnRpZmllcl9iaXRz1QMcZGVyX2xlbmd0aF9vYmplY3RfaWRlbnRpZmllctYDE2Rlcl9pYTVfY2hhcl9lbmNvZGXXAxRkZXJfaWE1X3ZhbHVlX2RlY29kZdgDFWRlcl9sZW5ndGhfaWE1X3N0cmluZ9kDFWRlcl9kZWNvZGVfaWE1X3N0cmluZ9oDGWRlcl9wcmludGFibGVfY2hhcl9lbmNvZGXbAxpkZXJfcHJpbnRhYmxlX3ZhbHVlX2RlY29kZdwDG2Rlcl9sZW5ndGhfcHJpbnRhYmxlX3N0cmluZ90DG2Rlcl9kZWNvZGVfcHJpbnRhYmxlX3N0cmluZ94DFmRlcl9kZWNvZGVfdXRmOF9zdHJpbmffAxFkZXJfdXRmOF9jaGFyc2l6ZeADFmRlcl9sZW5ndGhfdXRmOF9zdHJpbmfhAxJkZXJfZGVjb2RlX3V0Y3RpbWXiAxJkZXJfbGVuZ3RoX2ludGVnZXLjAxJkZXJfbGVuZ3RoX3V0Y3RpbWXkAxNkZXJfbGVuZ3RoX3NlcXVlbmNl5QMRZGVyX2RlY29kZV9jaG9pY2XmAxZkZXJfZGVjb2RlX3NlcXVlbmNlX2V45wMZZGVyX2RlY29kZV9zZXF1ZW5jZV9tdWx0aegDCnJzYV9pbXBvcnTpAw1oYXNoX2lzX3ZhbGlk6gMLcGtjc18xX21nZjHrAxFwa2NzXzFfcHNzX2VuY29kZewDEmRlcl9lbmNvZGVfYm9vbGVhbu0DEmRlcl9lbmNvZGVfaW50ZWdlcu4DGGRlcl9lbmNvZGVfc2hvcnRfaW50ZWdlcu8DFWRlcl9lbmNvZGVfYml0X3N0cmluZ/ADF2Rlcl9lbmNvZGVfb2N0ZXRfc3RyaW5n8QMcZGVyX2VuY29kZV9vYmplY3RfaWRlbnRpZmllcvIDFWRlcl9lbmNvZGVfaWE1X3N0cmluZ/MDG2Rlcl9lbmNvZGVfcHJpbnRhYmxlX3N0cmluZ/QDFmRlcl9lbmNvZGVfdXRmOF9zdHJpbmf1AxJkZXJfZW5jb2RlX3V0Y3RpbWX2Aw5kZXJfZW5jb2RlX3NldPcDDHFzb3J0X2hlbHBlcvgDEGRlcl9lbmNvZGVfc2V0b2b5Aw5xc29ydF9oZWxwZXIuMfoDFmRlcl9lbmNvZGVfc2VxdWVuY2VfZXj7AxJwa2NzXzFfdjFfNV9lbmNvZGX8AxByc2Ffc2lnbl9oYXNoX2V4/QMIcnNhX2ZyZWX+AzpRdWVyeU1wcVNpZ25hdHVyZUluZm8oX1RNUFFBcmNoaXZlKiwgX01QUV9TSUdOQVRVUkVfSU5GTyop/wMeU1NpZ25GaWxlQ3JlYXRlKF9UTVBRQXJjaGl2ZSopgAQeU1NpZ25GaWxlRmluaXNoKF9UTVBRQXJjaGl2ZSopgQRIQ2FsY3VsYXRlTXBxSGFzaE1kNShfVE1QUUFyY2hpdmUqLCBfTVBRX1NJR05BVFVSRV9JTkZPKiwgdW5zaWduZWQgY2hhciopggQQU0ZpbGVHZXRGaWxlSW5mb4MEEFNGaWxlR2V0RmlsZU5hbWWEBEBJc0luY3JlbWVudGFsUGF0Y2hGaWxlKHZvaWQgY29uc3QqLCB1bnNpZ25lZCBpbnQsIHVuc2lnbmVkIGludCophQQsUGF0Y2hfSW5pdFBhdGNoZXIoX1RNUFFQYXRjaGVyKiwgX1RNUFFGaWxlKimGBChQYXRjaF9Qcm9jZXNzKF9UTVBRUGF0Y2hlciosIF9UTVBRRmlsZSophwQdUGF0Y2hfRmluYWxpemUoX1RNUFFQYXRjaGVyKimIBBVTRmlsZU9wZW5QYXRjaEFyY2hpdmWJBHhTRmlsZUFkZEZpbGVfSW5pdChfVE1QUUFyY2hpdmUqLCBjaGFyIGNvbnN0KiwgdW5zaWduZWQgbG9uZyBsb25nLCB1bnNpZ25lZCBpbnQsIHVuc2lnbmVkIGludCwgdW5zaWduZWQgaW50LCBfVE1QUUZpbGUqKimKBEdTRmlsZUFkZEZpbGVfV3JpdGUoX1RNUFFGaWxlKiwgdm9pZCBjb25zdCosIHVuc2lnbmVkIGludCwgdW5zaWduZWQgaW50KYsEH1NGaWxlQWRkRmlsZV9GaW5pc2goX1RNUFFGaWxlKimMBCdDaGVja1dpbGRDYXJkKGNoYXIgY29uc3QqLCBjaGFyIGNvbnN0KimNBBJTRmlsZUZpbmRGaXJzdEZpbGWOBCtEb01QUVNlYXJjaChUTVBRU2VhcmNoKiwgX1NGSUxFX0ZJTkRfREFUQSopjwReRG9NUFFTZWFyY2hfRmlsZUVudHJ5KFRNUFFTZWFyY2gqLCBfU0ZJTEVfRklORF9EQVRBKiwgX1RNUFFBcmNoaXZlKiwgX1RNUFFIYXNoKiwgX1RGaWxlRW50cnkqKZAEEVNGaWxlRmluZE5leHRGaWxlkQQOU0ZpbGVGaW5kQ2xvc2WSBCFTTGlzdEZpbGVTYXZlVG9NcHEoX1RNUFFBcmNoaXZlKimTBCpDb21wYXJlRmlsZU5vZGVzKHZvaWQgY29uc3QqLCB2b2lkIGNvbnN0KimUBBBTRmlsZUFkZExpc3RGaWxllQRKU0ZpbGVBZGRBcmJpdHJhcnlMaXN0RmlsZShfVE1QUUFyY2hpdmUqLCB2b2lkKiwgY2hhciBjb25zdCosIHVuc2lnbmVkIGludCmWBDxTTGlzdEZpbGVDcmVhdGVOb2RlRm9yQWxsTG9jYWxlcyhfVE1QUUFyY2hpdmUqLCBjaGFyIGNvbnN0KimXBFBDcmVhdGVMaXN0RmlsZUNhY2hlKHZvaWQqLCBjaGFyIGNvbnN0KiwgY2hhciBjb25zdCosIHVuc2lnbmVkIGludCwgdW5zaWduZWQgaW50KZgEMVJlYWRMaXN0RmlsZUxpbmUoVExpc3RGaWxlQ2FjaGUqLCB1bnNpZ25lZCBsb25nKimZBCJTQXR0ckxvYWRBdHRyaWJ1dGVzKF9UTVBRQXJjaGl2ZSopmgQhU0F0dHJGaWxlU2F2ZVRvTXBxKF9UTVBRQXJjaGl2ZSopmwQOU0ZpbGVTZXRMb2NhbGWcBBBTRmlsZU9wZW5BcmNoaXZlnQQRU0ZpbGVGbHVzaEFyY2hpdmWeBBFTRmlsZUNsb3NlQXJjaGl2ZZ8EG0VtU0ZpbGVDbG9zZUFyY2hpdmUoRW1QdHImKaAEGEVtU0ZpbGVDbG9zZUZpbGUoRW1QdHImKaEEGEVtU0ZpbGVGaW5kQ2xvc2UoRW1QdHImKaIE6wFFbVNGaWxlRmluZEZpcnN0RmlsZShFbVB0ciYsIHN0ZDo6X18yOjpiYXNpY19zdHJpbmc8Y2hhciwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPGNoYXI+LCBzdGQ6Ol9fMjo6YWxsb2NhdG9yPGNoYXI+ID4gY29uc3QmLCBfU0ZJTEVfRklORF9EQVRBJiwgc3RkOjpfXzI6OmJhc2ljX3N0cmluZzxjaGFyLCBzdGQ6Ol9fMjo6Y2hhcl90cmFpdHM8Y2hhcj4sIHN0ZDo6X18yOjphbGxvY2F0b3I8Y2hhcj4gPiBjb25zdCYpowQORW1QdHI6OkVtUHRyKCmkBGRzdGQ6Ol9fMjo6YmFzaWNfc3RyaW5nPGNoYXIsIHN0ZDo6X18yOjpjaGFyX3RyYWl0czxjaGFyPiwgc3RkOjpfXzI6OmFsbG9jYXRvcjxjaGFyPiA+OjpjX3N0cigpIGNvbnN0pQRjc3RkOjpfXzI6OmJhc2ljX3N0cmluZzxjaGFyLCBzdGQ6Ol9fMjo6Y2hhcl90cmFpdHM8Y2hhcj4sIHN0ZDo6X18yOjphbGxvY2F0b3I8Y2hhcj4gPjo6ZGF0YSgpIGNvbnN0pgQzRW1TRmlsZUZpbmREYXRhR2V0RmlsZU5hbWUoX1NGSUxFX0ZJTkRfREFUQSBjb25zdCYppwSAAXN0ZDo6X18yOjpiYXNpY19zdHJpbmc8Y2hhciwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPGNoYXI+LCBzdGQ6Ol9fMjo6YWxsb2NhdG9yPGNoYXI+ID46OmJhc2ljX3N0cmluZzxzdGQ6Om51bGxwdHJfdD4oY2hhciBjb25zdCopqASkAnN0ZDo6X18yOjpfX2NvbXByZXNzZWRfcGFpcjxzdGQ6Ol9fMjo6YmFzaWNfc3RyaW5nPGNoYXIsIHN0ZDo6X18yOjpjaGFyX3RyYWl0czxjaGFyPiwgc3RkOjpfXzI6OmFsbG9jYXRvcjxjaGFyPiA+OjpfX3JlcCwgc3RkOjpfXzI6OmFsbG9jYXRvcjxjaGFyPiA+OjpfX2NvbXByZXNzZWRfcGFpcjxzdGQ6Ol9fMjo6X19kZWZhdWx0X2luaXRfdGFnLCBzdGQ6Ol9fMjo6X19kZWZhdWx0X2luaXRfdGFnPihzdGQ6Ol9fMjo6X19kZWZhdWx0X2luaXRfdGFnJiYsIHN0ZDo6X18yOjpfX2RlZmF1bHRfaW5pdF90YWcmJimpBDBzdGQ6Ol9fMjo6Y2hhcl90cmFpdHM8Y2hhcj46Omxlbmd0aChjaGFyIGNvbnN0KimqBDRFbVNGaWxlRmluZERhdGFHZXRQbGFpbk5hbWUoX1NGSUxFX0ZJTkRfREFUQSBjb25zdCYpqwQsRW1TRmlsZUZpbmREYXRhVG9KUyhfU0ZJTEVfRklORF9EQVRBIGNvbnN0JimsBBllbXNjcmlwdGVuOjp2YWw6Om9iamVjdCgprQQhZW1zY3JpcHRlbjo6dmFsOjp2YWwoY2hhciBjb25zdCoprgRPdm9pZCBlbXNjcmlwdGVuOjp2YWw6OnNldDxjaGFyIFs5XT4oY2hhciBjb25zdCAoJikgWzldLCBlbXNjcmlwdGVuOjp2YWwgY29uc3QmKa8EF2Vtc2NyaXB0ZW46OnZhbDo6fnZhbCgpsATvAXZvaWQgZW1zY3JpcHRlbjo6dmFsOjpzZXQ8Y2hhciBbMTBdLCBzdGQ6Ol9fMjo6YmFzaWNfc3RyaW5nPGNoYXIsIHN0ZDo6X18yOjpjaGFyX3RyYWl0czxjaGFyPiwgc3RkOjpfXzI6OmFsbG9jYXRvcjxjaGFyPiA+ID4oY2hhciBjb25zdCAoJikgWzEwXSwgc3RkOjpfXzI6OmJhc2ljX3N0cmluZzxjaGFyLCBzdGQ6Ol9fMjo6Y2hhcl90cmFpdHM8Y2hhcj4sIHN0ZDo6X18yOjphbGxvY2F0b3I8Y2hhcj4gPiBjb25zdCYpsQRcdm9pZCBlbXNjcmlwdGVuOjp2YWw6OnNldDxjaGFyIFsxMF0sIHVuc2lnbmVkIGludD4oY2hhciBjb25zdCAoJikgWzEwXSwgdW5zaWduZWQgaW50IGNvbnN0JimyBFx2b2lkIGVtc2NyaXB0ZW46OnZhbDo6c2V0PGNoYXIgWzExXSwgdW5zaWduZWQgaW50PihjaGFyIGNvbnN0ICgmKSBbMTFdLCB1bnNpZ25lZCBpbnQgY29uc3QmKbMEWnZvaWQgZW1zY3JpcHRlbjo6dmFsOjpzZXQ8Y2hhciBbOV0sIHVuc2lnbmVkIGludD4oY2hhciBjb25zdCAoJikgWzldLCB1bnNpZ25lZCBpbnQgY29uc3QmKbQEWnZvaWQgZW1zY3JpcHRlbjo6dmFsOjpzZXQ8Y2hhciBbN10sIHVuc2lnbmVkIGludD4oY2hhciBjb25zdCAoJikgWzddLCB1bnNpZ25lZCBpbnQgY29uc3QmKbUENGVtc2NyaXB0ZW46OnZhbDo6dmFsKGVtc2NyaXB0ZW46OmludGVybmFsOjpfRU1fVkFMKim2BNABZW1zY3JpcHRlbjo6dmFsOjp2YWw8c3RkOjpfXzI6OmJhc2ljX3N0cmluZzxjaGFyLCBzdGQ6Ol9fMjo6Y2hhcl90cmFpdHM8Y2hhcj4sIHN0ZDo6X18yOjphbGxvY2F0b3I8Y2hhcj4gPiBjb25zdCY+KHN0ZDo6X18yOjpiYXNpY19zdHJpbmc8Y2hhciwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPGNoYXI+LCBzdGQ6Ol9fMjo6YWxsb2NhdG9yPGNoYXI+ID4gY29uc3QmKbcEPmVtc2NyaXB0ZW46OnZhbDo6dmFsPHVuc2lnbmVkIGludCBjb25zdCY+KHVuc2lnbmVkIGludCBjb25zdCYpuAQuRW1TRmlsZUZpbmROZXh0RmlsZShFbVB0ciYsIF9TRklMRV9GSU5EX0RBVEEmKbkEIkVtU0ZpbGVHZXRGaWxlTmFtZShFbVB0ciYsIEVtU3RyJim6BCJFbVNGaWxlR2V0RmlsZVNpemUoRW1QdHImLCBFbVB0ciYpuwR0RW1TRmlsZUhhc0ZpbGUoRW1QdHImLCBzdGQ6Ol9fMjo6YmFzaWNfc3RyaW5nPGNoYXIsIHN0ZDo6X18yOjpjaGFyX3RyYWl0czxjaGFyPiwgc3RkOjpfXzI6OmFsbG9jYXRvcjxjaGFyPiA+IGNvbnN0Jim8BJQBRW1TRmlsZU9wZW5BcmNoaXZlKHN0ZDo6X18yOjpiYXNpY19zdHJpbmc8Y2hhciwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPGNoYXI+LCBzdGQ6Ol9fMjo6YWxsb2NhdG9yPGNoYXI+ID4gY29uc3QmLCB1bnNpZ25lZCBpbnQsIHVuc2lnbmVkIGludCwgRW1QdHImKb0E6QFFbVNGaWxlT3BlblBhdGNoQXJjaGl2ZShFbVB0ciYsIHN0ZDo6X18yOjpiYXNpY19zdHJpbmc8Y2hhciwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPGNoYXI+LCBzdGQ6Ol9fMjo6YWxsb2NhdG9yPGNoYXI+ID4gY29uc3QmLCBzdGQ6Ol9fMjo6YmFzaWNfc3RyaW5nPGNoYXIsIHN0ZDo6X18yOjpjaGFyX3RyYWl0czxjaGFyPiwgc3RkOjpfXzI6OmFsbG9jYXRvcjxjaGFyPiA+IGNvbnN0JiwgdW5zaWduZWQgaW50Kb4EjQFFbVNGaWxlT3BlbkZpbGVFeChFbVB0ciYsIHN0ZDo6X18yOjpiYXNpY19zdHJpbmc8Y2hhciwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPGNoYXI+LCBzdGQ6Ol9fMjo6YWxsb2NhdG9yPGNoYXI+ID4gY29uc3QmLCB1bnNpZ25lZCBpbnQsIEVtUHRyJim/BD1FbVNGaWxlUmVhZEZpbGUoRW1QdHImLCBFbUJ1ZiYsIHVuc2lnbmVkIGludCwgRW1QdHImLCBFbVB0ciYpwARBRW1TRmlsZVNldEZpbGVQb2ludGVyKEVtUHRyJiwgdW5zaWduZWQgaW50LCBFbVB0ciYsIHVuc2lnbmVkIGludCnBBBVfX2N4eF9nbG9iYWxfdmFyX2luaXTCBFJFbXNjcmlwdGVuQmluZGluZ0luaXRpYWxpemVyX0VtU3Rvcm1MaWI6OkVtc2NyaXB0ZW5CaW5kaW5nSW5pdGlhbGl6ZXJfRW1TdG9ybUxpYigpwwQ3dm9pZCBlbXNjcmlwdGVuOjppbnRlcm5hbDo6Tm9CYXNlQ2xhc3M6OnZlcmlmeTxFbUJ1Zj4oKcQEPnZvaWQgY29uc3QqIGVtc2NyaXB0ZW46OmludGVybmFsOjpnZXRBY3R1YWxUeXBlPEVtQnVmPihFbUJ1ZiopxQRBdm9pZCAoKmVtc2NyaXB0ZW46OmludGVybmFsOjpOb0Jhc2VDbGFzczo6Z2V0VXBjYXN0ZXI8RW1CdWY+KCkpKCnGBEN2b2lkICgqZW1zY3JpcHRlbjo6aW50ZXJuYWw6Ok5vQmFzZUNsYXNzOjpnZXREb3duY2FzdGVyPEVtQnVmPigpKSgpxwQ4dm9pZCBlbXNjcmlwdGVuOjppbnRlcm5hbDo6cmF3X2Rlc3RydWN0b3I8RW1CdWY+KEVtQnVmKinIBDBlbXNjcmlwdGVuOjppbnRlcm5hbDo6VHlwZUlEPEVtQnVmLCB2b2lkPjo6Z2V0KCnJBFllbXNjcmlwdGVuOjppbnRlcm5hbDo6VHlwZUlEPGVtc2NyaXB0ZW46OmludGVybmFsOjpBbGxvd2VkUmF3UG9pbnRlcjxFbUJ1Zj4sIHZvaWQ+OjpnZXQoKcoEX2Vtc2NyaXB0ZW46OmludGVybmFsOjpUeXBlSUQ8ZW1zY3JpcHRlbjo6aW50ZXJuYWw6OkFsbG93ZWRSYXdQb2ludGVyPEVtQnVmIGNvbnN0Piwgdm9pZD46OmdldCgpywQoZW1zY3JpcHRlbjo6aW50ZXJuYWw6Ok5vQmFzZUNsYXNzOjpnZXQoKcwEQWNoYXIgY29uc3QqIGVtc2NyaXB0ZW46OmludGVybmFsOjpnZXRHZW5lcmljU2lnbmF0dXJlPGludCwgaW50PigpzQQ9Y2hhciBjb25zdCogZW1zY3JpcHRlbjo6aW50ZXJuYWw6OmdldEdlbmVyaWNTaWduYXR1cmU8dm9pZD4oKc4EQmNoYXIgY29uc3QqIGVtc2NyaXB0ZW46OmludGVybmFsOjpnZXRHZW5lcmljU2lnbmF0dXJlPHZvaWQsIGludD4oKc8ETkVtQnVmKiBlbXNjcmlwdGVuOjppbnRlcm5hbDo6b3BlcmF0b3JfbmV3PEVtQnVmLCB1bnNpZ25lZCBpbnQ+KHVuc2lnbmVkIGludCYmKdAEenZvaWQgZW1zY3JpcHRlbjo6aW50ZXJuYWw6OlJlZ2lzdGVyQ2xhc3NDb25zdHJ1Y3RvcjxFbUJ1ZiogKCopKHVuc2lnbmVkIGludCYmKT46Omludm9rZTxFbUJ1Zj4oRW1CdWYqICgqKSh1bnNpZ25lZCBpbnQmJikp0QQWRW1CdWY6OmdldFNpemUoKSBjb25zdNIEjAF2b2lkIGVtc2NyaXB0ZW46OmludGVybmFsOjpSZWdpc3RlckNsYXNzTWV0aG9kPHVuc2lnbmVkIGludCAoRW1CdWY6OiopKCkgY29uc3Q+OjppbnZva2U8RW1CdWY+KGNoYXIgY29uc3QqLCB1bnNpZ25lZCBpbnQgKEVtQnVmOjoqKSgpIGNvbnN0KdMEDUVtQnVmOjp0b0pTKCnUBIYBdm9pZCBlbXNjcmlwdGVuOjppbnRlcm5hbDo6UmVnaXN0ZXJDbGFzc01ldGhvZDxlbXNjcmlwdGVuOjp2YWwgKEVtQnVmOjoqKSgpPjo6aW52b2tlPEVtQnVmPihjaGFyIGNvbnN0KiwgZW1zY3JpcHRlbjo6dmFsIChFbUJ1Zjo6KikoKSnVBDd2b2lkIGVtc2NyaXB0ZW46OmludGVybmFsOjpOb0Jhc2VDbGFzczo6dmVyaWZ5PEVtUHRyPigp1gQ+dm9pZCBjb25zdCogZW1zY3JpcHRlbjo6aW50ZXJuYWw6OmdldEFjdHVhbFR5cGU8RW1QdHI+KEVtUHRyKinXBEF2b2lkICgqZW1zY3JpcHRlbjo6aW50ZXJuYWw6Ok5vQmFzZUNsYXNzOjpnZXRVcGNhc3RlcjxFbVB0cj4oKSkoKdgEQ3ZvaWQgKCplbXNjcmlwdGVuOjppbnRlcm5hbDo6Tm9CYXNlQ2xhc3M6OmdldERvd25jYXN0ZXI8RW1QdHI+KCkpKCnZBDh2b2lkIGVtc2NyaXB0ZW46OmludGVybmFsOjpyYXdfZGVzdHJ1Y3RvcjxFbVB0cj4oRW1QdHIqKdoEMGVtc2NyaXB0ZW46OmludGVybmFsOjpUeXBlSUQ8RW1QdHIsIHZvaWQ+OjpnZXQoKdsEWWVtc2NyaXB0ZW46OmludGVybmFsOjpUeXBlSUQ8ZW1zY3JpcHRlbjo6aW50ZXJuYWw6OkFsbG93ZWRSYXdQb2ludGVyPEVtUHRyPiwgdm9pZD46OmdldCgp3ARfZW1zY3JpcHRlbjo6aW50ZXJuYWw6OlR5cGVJRDxlbXNjcmlwdGVuOjppbnRlcm5hbDo6QWxsb3dlZFJhd1BvaW50ZXI8RW1QdHIgY29uc3Q+LCB2b2lkPjo6Z2V0KCndBDJFbVB0ciogZW1zY3JpcHRlbjo6aW50ZXJuYWw6Om9wZXJhdG9yX25ldzxFbVB0cj4oKd4EXnZvaWQgZW1zY3JpcHRlbjo6aW50ZXJuYWw6OlJlZ2lzdGVyQ2xhc3NDb25zdHJ1Y3RvcjxFbVB0ciogKCopKCk+OjppbnZva2U8RW1QdHI+KEVtUHRyKiAoKikoKSnfBBZFbVB0cjo6Z2V0QWRkcigpIGNvbnN04ASOAXZvaWQgZW1zY3JpcHRlbjo6aW50ZXJuYWw6OlJlZ2lzdGVyQ2xhc3NNZXRob2Q8dW5zaWduZWQgbG9uZyAoRW1QdHI6OiopKCkgY29uc3Q+OjppbnZva2U8RW1QdHI+KGNoYXIgY29uc3QqLCB1bnNpZ25lZCBsb25nIChFbVB0cjo6KikoKSBjb25zdCnhBBVFbVB0cjo6aXNOdWxsKCkgY29uc3TiBHx2b2lkIGVtc2NyaXB0ZW46OmludGVybmFsOjpSZWdpc3RlckNsYXNzTWV0aG9kPGJvb2wgKEVtUHRyOjoqKSgpIGNvbnN0Pjo6aW52b2tlPEVtUHRyPihjaGFyIGNvbnN0KiwgYm9vbCAoRW1QdHI6OiopKCkgY29uc3Qp4wQ3dm9pZCBlbXNjcmlwdGVuOjppbnRlcm5hbDo6Tm9CYXNlQ2xhc3M6OnZlcmlmeTxFbVN0cj4oKeQEPnZvaWQgY29uc3QqIGVtc2NyaXB0ZW46OmludGVybmFsOjpnZXRBY3R1YWxUeXBlPEVtU3RyPihFbVN0ciop5QRBdm9pZCAoKmVtc2NyaXB0ZW46OmludGVybmFsOjpOb0Jhc2VDbGFzczo6Z2V0VXBjYXN0ZXI8RW1TdHI+KCkpKCnmBEN2b2lkICgqZW1zY3JpcHRlbjo6aW50ZXJuYWw6Ok5vQmFzZUNsYXNzOjpnZXREb3duY2FzdGVyPEVtU3RyPigpKSgp5wQ4dm9pZCBlbXNjcmlwdGVuOjppbnRlcm5hbDo6cmF3X2Rlc3RydWN0b3I8RW1TdHI+KEVtU3RyKinoBDBlbXNjcmlwdGVuOjppbnRlcm5hbDo6VHlwZUlEPEVtU3RyLCB2b2lkPjo6Z2V0KCnpBFllbXNjcmlwdGVuOjppbnRlcm5hbDo6VHlwZUlEPGVtc2NyaXB0ZW46OmludGVybmFsOjpBbGxvd2VkUmF3UG9pbnRlcjxFbVN0cj4sIHZvaWQ+OjpnZXQoKeoEX2Vtc2NyaXB0ZW46OmludGVybmFsOjpUeXBlSUQ8ZW1zY3JpcHRlbjo6aW50ZXJuYWw6OkFsbG93ZWRSYXdQb2ludGVyPEVtU3RyIGNvbnN0Piwgdm9pZD46OmdldCgp6wRORW1TdHIqIGVtc2NyaXB0ZW46OmludGVybmFsOjpvcGVyYXRvcl9uZXc8RW1TdHIsIHVuc2lnbmVkIGludD4odW5zaWduZWQgaW50JiYp7AR6dm9pZCBlbXNjcmlwdGVuOjppbnRlcm5hbDo6UmVnaXN0ZXJDbGFzc0NvbnN0cnVjdG9yPEVtU3RyKiAoKikodW5zaWduZWQgaW50JiYpPjo6aW52b2tlPEVtU3RyPihFbVN0ciogKCopKHVuc2lnbmVkIGludCYmKSntBBZFbVN0cjo6Z2V0U2l6ZSgpIGNvbnN07gSMAXZvaWQgZW1zY3JpcHRlbjo6aW50ZXJuYWw6OlJlZ2lzdGVyQ2xhc3NNZXRob2Q8dW5zaWduZWQgaW50IChFbVN0cjo6KikoKSBjb25zdD46Omludm9rZTxFbVN0cj4oY2hhciBjb25zdCosIHVuc2lnbmVkIGludCAoRW1TdHI6OiopKCkgY29uc3Qp7wQNRW1TdHI6OnRvSlMoKfAEhgF2b2lkIGVtc2NyaXB0ZW46OmludGVybmFsOjpSZWdpc3RlckNsYXNzTWV0aG9kPGVtc2NyaXB0ZW46OnZhbCAoRW1TdHI6OiopKCk+OjppbnZva2U8RW1TdHI+KGNoYXIgY29uc3QqLCBlbXNjcmlwdGVuOjp2YWwgKEVtU3RyOjoqKSgpKfEEMXZvaWQgZW1zY3JpcHRlbjo6YmFzZTxFbVB0cj46OnZlcmlmeTxFbVZvaWRQdHI+KCnyBEZ2b2lkIGNvbnN0KiBlbXNjcmlwdGVuOjppbnRlcm5hbDo6Z2V0QWN0dWFsVHlwZTxFbVZvaWRQdHI+KEVtVm9pZFB0ciop8wRHRW1QdHIqICgqZW1zY3JpcHRlbjo6YmFzZTxFbVB0cj46OmdldFVwY2FzdGVyPEVtVm9pZFB0cj4oKSkoRW1Wb2lkUHRyKin0BElFbVZvaWRQdHIqICgqZW1zY3JpcHRlbjo6YmFzZTxFbVB0cj46OmdldERvd25jYXN0ZXI8RW1Wb2lkUHRyPigpKShFbVB0ciop9QRAdm9pZCBlbXNjcmlwdGVuOjppbnRlcm5hbDo6cmF3X2Rlc3RydWN0b3I8RW1Wb2lkUHRyPihFbVZvaWRQdHIqKfYENGVtc2NyaXB0ZW46OmludGVybmFsOjpUeXBlSUQ8RW1Wb2lkUHRyLCB2b2lkPjo6Z2V0KCn3BF1lbXNjcmlwdGVuOjppbnRlcm5hbDo6VHlwZUlEPGVtc2NyaXB0ZW46OmludGVybmFsOjpBbGxvd2VkUmF3UG9pbnRlcjxFbVZvaWRQdHI+LCB2b2lkPjo6Z2V0KCn4BGNlbXNjcmlwdGVuOjppbnRlcm5hbDo6VHlwZUlEPGVtc2NyaXB0ZW46OmludGVybmFsOjpBbGxvd2VkUmF3UG9pbnRlcjxFbVZvaWRQdHIgY29uc3Q+LCB2b2lkPjo6Z2V0KCn5BB5lbXNjcmlwdGVuOjpiYXNlPEVtUHRyPjo6Z2V0KCn6BDpFbVZvaWRQdHIqIGVtc2NyaXB0ZW46OmludGVybmFsOjpvcGVyYXRvcl9uZXc8RW1Wb2lkUHRyPigp+wRqdm9pZCBlbXNjcmlwdGVuOjppbnRlcm5hbDo6UmVnaXN0ZXJDbGFzc0NvbnN0cnVjdG9yPEVtVm9pZFB0ciogKCopKCk+OjppbnZva2U8RW1Wb2lkUHRyPihFbVZvaWRQdHIqICgqKSgpKfwEM3ZvaWQgZW1zY3JpcHRlbjo6YmFzZTxFbVB0cj46OnZlcmlmeTxFbVVpbnQzMlB0cj4oKf0ESnZvaWQgY29uc3QqIGVtc2NyaXB0ZW46OmludGVybmFsOjpnZXRBY3R1YWxUeXBlPEVtVWludDMyUHRyPihFbVVpbnQzMlB0ciop/gRLRW1QdHIqICgqZW1zY3JpcHRlbjo6YmFzZTxFbVB0cj46OmdldFVwY2FzdGVyPEVtVWludDMyUHRyPigpKShFbVVpbnQzMlB0ciop/wRNRW1VaW50MzJQdHIqICgqZW1zY3JpcHRlbjo6YmFzZTxFbVB0cj46OmdldERvd25jYXN0ZXI8RW1VaW50MzJQdHI+KCkpKEVtUHRyKimABUR2b2lkIGVtc2NyaXB0ZW46OmludGVybmFsOjpyYXdfZGVzdHJ1Y3RvcjxFbVVpbnQzMlB0cj4oRW1VaW50MzJQdHIqKYEFNmVtc2NyaXB0ZW46OmludGVybmFsOjpUeXBlSUQ8RW1VaW50MzJQdHIsIHZvaWQ+OjpnZXQoKYIFX2Vtc2NyaXB0ZW46OmludGVybmFsOjpUeXBlSUQ8ZW1zY3JpcHRlbjo6aW50ZXJuYWw6OkFsbG93ZWRSYXdQb2ludGVyPEVtVWludDMyUHRyPiwgdm9pZD46OmdldCgpgwVlZW1zY3JpcHRlbjo6aW50ZXJuYWw6OlR5cGVJRDxlbXNjcmlwdGVuOjppbnRlcm5hbDo6QWxsb3dlZFJhd1BvaW50ZXI8RW1VaW50MzJQdHIgY29uc3Q+LCB2b2lkPjo6Z2V0KCmEBT5FbVVpbnQzMlB0ciogZW1zY3JpcHRlbjo6aW50ZXJuYWw6Om9wZXJhdG9yX25ldzxFbVVpbnQzMlB0cj4oKYUFcHZvaWQgZW1zY3JpcHRlbjo6aW50ZXJuYWw6OlJlZ2lzdGVyQ2xhc3NDb25zdHJ1Y3RvcjxFbVVpbnQzMlB0ciogKCopKCk+OjppbnZva2U8RW1VaW50MzJQdHI+KEVtVWludDMyUHRyKiAoKikoKSmGBRlFbVVpbnQzMlB0cjo6dG9KUygpIGNvbnN0hwWeAXZvaWQgZW1zY3JpcHRlbjo6aW50ZXJuYWw6OlJlZ2lzdGVyQ2xhc3NNZXRob2Q8dW5zaWduZWQgaW50IChFbVVpbnQzMlB0cjo6KikoKSBjb25zdD46Omludm9rZTxFbVVpbnQzMlB0cj4oY2hhciBjb25zdCosIHVuc2lnbmVkIGludCAoRW1VaW50MzJQdHI6OiopKCkgY29uc3QpiAWsAXZvaWQgZW1zY3JpcHRlbjo6aW50ZXJuYWw6Ok1lbWJlckFjY2VzczxfU0ZJTEVfRklORF9EQVRBLCB1bnNpZ25lZCBpbnQ+OjpzZXRXaXJlPF9TRklMRV9GSU5EX0RBVEE+KHVuc2lnbmVkIGludCBfU0ZJTEVfRklORF9EQVRBOjoqIGNvbnN0JiwgX1NGSUxFX0ZJTkRfREFUQSYsIHVuc2lnbmVkIGludCmJBawBdW5zaWduZWQgaW50IGVtc2NyaXB0ZW46OmludGVybmFsOjpNZW1iZXJBY2Nlc3M8X1NGSUxFX0ZJTkRfREFUQSwgdW5zaWduZWQgaW50Pjo6Z2V0V2lyZTxfU0ZJTEVfRklORF9EQVRBPih1bnNpZ25lZCBpbnQgX1NGSUxFX0ZJTkRfREFUQTo6KiBjb25zdCYsIF9TRklMRV9GSU5EX0RBVEEgY29uc3QmKYoFzANlbXNjcmlwdGVuOjppbnRlcm5hbDo6QmluZGluZ1R5cGU8c3RkOjpfXzI6OmJhc2ljX3N0cmluZzxjaGFyLCBzdGQ6Ol9fMjo6Y2hhcl90cmFpdHM8Y2hhcj4sIHN0ZDo6X18yOjphbGxvY2F0b3I8Y2hhcj4gPiwgdm9pZD46Oid1bm5hbWVkJyogZW1zY3JpcHRlbjo6aW50ZXJuYWw6OkdldHRlclBvbGljeTxzdGQ6Ol9fMjo6YmFzaWNfc3RyaW5nPGNoYXIsIHN0ZDo6X18yOjpjaGFyX3RyYWl0czxjaGFyPiwgc3RkOjpfXzI6OmFsbG9jYXRvcjxjaGFyPiA+ICgqKShfU0ZJTEVfRklORF9EQVRBIGNvbnN0Jik+OjpnZXQ8X1NGSUxFX0ZJTkRfREFUQT4oc3RkOjpfXzI6OmJhc2ljX3N0cmluZzxjaGFyLCBzdGQ6Ol9fMjo6Y2hhcl90cmFpdHM8Y2hhcj4sIHN0ZDo6X18yOjphbGxvY2F0b3I8Y2hhcj4gPiAoKiBjb25zdCYpKF9TRklMRV9GSU5EX0RBVEEgY29uc3QmKSwgX1NGSUxFX0ZJTkRfREFUQSBjb25zdCYpiwVIX1NGSUxFX0ZJTkRfREFUQSogZW1zY3JpcHRlbjo6aW50ZXJuYWw6Om9wZXJhdG9yX25ldzxfU0ZJTEVfRklORF9EQVRBPigpjAVOdm9pZCBlbXNjcmlwdGVuOjppbnRlcm5hbDo6cmF3X2Rlc3RydWN0b3I8X1NGSUxFX0ZJTkRfREFUQT4oX1NGSUxFX0ZJTkRfREFUQSopjQVUdm9pZCBjb25zdCogZW1zY3JpcHRlbjo6aW50ZXJuYWw6OmdldEFjdHVhbFR5cGU8X1NGSUxFX0ZJTkRfREFUQT4oX1NGSUxFX0ZJTkRfREFUQSopjgVCdm9pZCBlbXNjcmlwdGVuOjppbnRlcm5hbDo6Tm9CYXNlQ2xhc3M6OnZlcmlmeTxfU0ZJTEVfRklORF9EQVRBPigpjwVMdm9pZCAoKmVtc2NyaXB0ZW46OmludGVybmFsOjpOb0Jhc2VDbGFzczo6Z2V0VXBjYXN0ZXI8X1NGSUxFX0ZJTkRfREFUQT4oKSkoKZAFTnZvaWQgKCplbXNjcmlwdGVuOjppbnRlcm5hbDo6Tm9CYXNlQ2xhc3M6OmdldERvd25jYXN0ZXI8X1NGSUxFX0ZJTkRfREFUQT4oKSkoKZEFO2Vtc2NyaXB0ZW46OmludGVybmFsOjpUeXBlSUQ8X1NGSUxFX0ZJTkRfREFUQSwgdm9pZD46OmdldCgpkgVkZW1zY3JpcHRlbjo6aW50ZXJuYWw6OlR5cGVJRDxlbXNjcmlwdGVuOjppbnRlcm5hbDo6QWxsb3dlZFJhd1BvaW50ZXI8X1NGSUxFX0ZJTkRfREFUQT4sIHZvaWQ+OjpnZXQoKZMFamVtc2NyaXB0ZW46OmludGVybmFsOjpUeXBlSUQ8ZW1zY3JpcHRlbjo6aW50ZXJuYWw6OkFsbG93ZWRSYXdQb2ludGVyPF9TRklMRV9GSU5EX0RBVEEgY29uc3Q+LCB2b2lkPjo6Z2V0KCmUBX92b2lkIGVtc2NyaXB0ZW46OmludGVybmFsOjpSZWdpc3RlckNsYXNzQ29uc3RydWN0b3I8X1NGSUxFX0ZJTkRfREFUQSogKCopKCk+OjppbnZva2U8X1NGSUxFX0ZJTkRfREFUQT4oX1NGSUxFX0ZJTkRfREFUQSogKCopKCkplQWAAWVtc2NyaXB0ZW46OmludGVybmFsOjpUeXBlSUQ8c3RkOjpfXzI6OmJhc2ljX3N0cmluZzxjaGFyLCBzdGQ6Ol9fMjo6Y2hhcl90cmFpdHM8Y2hhcj4sIHN0ZDo6X18yOjphbGxvY2F0b3I8Y2hhcj4gPiwgdm9pZD46OmdldCgplgVGY2hhciBjb25zdCogZW1zY3JpcHRlbjo6aW50ZXJuYWw6OmdldEdlbmVyaWNTaWduYXR1cmU8aW50LCBpbnQsIGludD4oKZcFlgJlbXNjcmlwdGVuOjppbnRlcm5hbDo6R2V0dGVyUG9saWN5PHN0ZDo6X18yOjpiYXNpY19zdHJpbmc8Y2hhciwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPGNoYXI+LCBzdGQ6Ol9fMjo6YWxsb2NhdG9yPGNoYXI+ID4gKCopKF9TRklMRV9GSU5EX0RBVEEgY29uc3QmKT46OmdldENvbnRleHQoc3RkOjpfXzI6OmJhc2ljX3N0cmluZzxjaGFyLCBzdGQ6Ol9fMjo6Y2hhcl90cmFpdHM8Y2hhcj4sIHN0ZDo6X18yOjphbGxvY2F0b3I8Y2hhcj4gPiAoKikoX1NGSUxFX0ZJTkRfREFUQSBjb25zdCYpKZgFN2Vtc2NyaXB0ZW46OmludGVybmFsOjpUeXBlSUQ8dW5zaWduZWQgaW50LCB2b2lkPjo6Z2V0KCmZBY0BdW5zaWduZWQgaW50IF9TRklMRV9GSU5EX0RBVEE6OioqIGVtc2NyaXB0ZW46OmludGVybmFsOjpnZXRDb250ZXh0PHVuc2lnbmVkIGludCBfU0ZJTEVfRklORF9EQVRBOjoqPih1bnNpZ25lZCBpbnQgX1NGSUxFX0ZJTkRfREFUQTo6KiBjb25zdCYpmgVMY2hhciBjb25zdCogZW1zY3JpcHRlbjo6aW50ZXJuYWw6OmdldEdlbmVyaWNTaWduYXR1cmU8dm9pZCwgaW50LCBpbnQsIGludD4oKZsFsQF2b2lkIGVtc2NyaXB0ZW46OmludGVybmFsOjpSZWdpc3RlckNsYXNzTWV0aG9kPGVtc2NyaXB0ZW46OnZhbCAoKikoX1NGSUxFX0ZJTkRfREFUQSBjb25zdCYpPjo6aW52b2tlPF9TRklMRV9GSU5EX0RBVEE+KGNoYXIgY29uc3QqLCBlbXNjcmlwdGVuOjp2YWwgKCopKF9TRklMRV9GSU5EX0RBVEEgY29uc3QmKSmcBUh2b2lkIGVtc2NyaXB0ZW46OmZ1bmN0aW9uPHVuc2lnbmVkIGludD4oY2hhciBjb25zdCosIHVuc2lnbmVkIGludCAoKikoKSmdBUZ2b2lkIGVtc2NyaXB0ZW46OmZ1bmN0aW9uPGJvb2wsIEVtUHRyJj4oY2hhciBjb25zdCosIGJvb2wgKCopKEVtUHRyJikpngXmA3ZvaWQgZW1zY3JpcHRlbjo6ZnVuY3Rpb248RW1QdHIsIEVtUHRyJiwgc3RkOjpfXzI6OmJhc2ljX3N0cmluZzxjaGFyLCBzdGQ6Ol9fMjo6Y2hhcl90cmFpdHM8Y2hhcj4sIHN0ZDo6X18yOjphbGxvY2F0b3I8Y2hhcj4gPiBjb25zdCYsIF9TRklMRV9GSU5EX0RBVEEmLCBzdGQ6Ol9fMjo6YmFzaWNfc3RyaW5nPGNoYXIsIHN0ZDo6X18yOjpjaGFyX3RyYWl0czxjaGFyPiwgc3RkOjpfXzI6OmFsbG9jYXRvcjxjaGFyPiA+IGNvbnN0Jj4oY2hhciBjb25zdCosIEVtUHRyICgqKShFbVB0ciYsIHN0ZDo6X18yOjpiYXNpY19zdHJpbmc8Y2hhciwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPGNoYXI+LCBzdGQ6Ol9fMjo6YWxsb2NhdG9yPGNoYXI+ID4gY29uc3QmLCBfU0ZJTEVfRklORF9EQVRBJiwgc3RkOjpfXzI6OmJhc2ljX3N0cmluZzxjaGFyLCBzdGQ6Ol9fMjo6Y2hhcl90cmFpdHM8Y2hhcj4sIHN0ZDo6X18yOjphbGxvY2F0b3I8Y2hhcj4gPiBjb25zdCYpKZ8FbHZvaWQgZW1zY3JpcHRlbjo6ZnVuY3Rpb248Ym9vbCwgRW1QdHImLCBfU0ZJTEVfRklORF9EQVRBJj4oY2hhciBjb25zdCosIGJvb2wgKCopKEVtUHRyJiwgX1NGSUxFX0ZJTkRfREFUQSYpKaAFVnZvaWQgZW1zY3JpcHRlbjo6ZnVuY3Rpb248Ym9vbCwgRW1QdHImLCBFbVN0ciY+KGNoYXIgY29uc3QqLCBib29sICgqKShFbVB0ciYsIEVtU3RyJikpoQVmdm9pZCBlbXNjcmlwdGVuOjpmdW5jdGlvbjx1bnNpZ25lZCBpbnQsIEVtUHRyJiwgRW1QdHImPihjaGFyIGNvbnN0KiwgdW5zaWduZWQgaW50ICgqKShFbVB0ciYsIEVtUHRyJikpogWCAnZvaWQgZW1zY3JpcHRlbjo6ZnVuY3Rpb248Ym9vbCwgRW1QdHImLCBzdGQ6Ol9fMjo6YmFzaWNfc3RyaW5nPGNoYXIsIHN0ZDo6X18yOjpjaGFyX3RyYWl0czxjaGFyPiwgc3RkOjpfXzI6OmFsbG9jYXRvcjxjaGFyPiA+IGNvbnN0Jj4oY2hhciBjb25zdCosIGJvb2wgKCopKEVtUHRyJiwgc3RkOjpfXzI6OmJhc2ljX3N0cmluZzxjaGFyLCBzdGQ6Ol9fMjo6Y2hhcl90cmFpdHM8Y2hhcj4sIHN0ZDo6X18yOjphbGxvY2F0b3I8Y2hhcj4gPiBjb25zdCYpKaMFugJ2b2lkIGVtc2NyaXB0ZW46OmZ1bmN0aW9uPGJvb2wsIHN0ZDo6X18yOjpiYXNpY19zdHJpbmc8Y2hhciwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPGNoYXI+LCBzdGQ6Ol9fMjo6YWxsb2NhdG9yPGNoYXI+ID4gY29uc3QmLCB1bnNpZ25lZCBpbnQsIHVuc2lnbmVkIGludCwgRW1QdHImPihjaGFyIGNvbnN0KiwgYm9vbCAoKikoc3RkOjpfXzI6OmJhc2ljX3N0cmluZzxjaGFyLCBzdGQ6Ol9fMjo6Y2hhcl90cmFpdHM8Y2hhcj4sIHN0ZDo6X18yOjphbGxvY2F0b3I8Y2hhcj4gPiBjb25zdCYsIHVuc2lnbmVkIGludCwgdW5zaWduZWQgaW50LCBFbVB0ciYpKaQF2gN2b2lkIGVtc2NyaXB0ZW46OmZ1bmN0aW9uPGJvb2wsIEVtUHRyJiwgc3RkOjpfXzI6OmJhc2ljX3N0cmluZzxjaGFyLCBzdGQ6Ol9fMjo6Y2hhcl90cmFpdHM8Y2hhcj4sIHN0ZDo6X18yOjphbGxvY2F0b3I8Y2hhcj4gPiBjb25zdCYsIHN0ZDo6X18yOjpiYXNpY19zdHJpbmc8Y2hhciwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPGNoYXI+LCBzdGQ6Ol9fMjo6YWxsb2NhdG9yPGNoYXI+ID4gY29uc3QmLCB1bnNpZ25lZCBpbnQ+KGNoYXIgY29uc3QqLCBib29sICgqKShFbVB0ciYsIHN0ZDo6X18yOjpiYXNpY19zdHJpbmc8Y2hhciwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPGNoYXI+LCBzdGQ6Ol9fMjo6YWxsb2NhdG9yPGNoYXI+ID4gY29uc3QmLCBzdGQ6Ol9fMjo6YmFzaWNfc3RyaW5nPGNoYXIsIHN0ZDo6X18yOjpjaGFyX3RyYWl0czxjaGFyPiwgc3RkOjpfXzI6OmFsbG9jYXRvcjxjaGFyPiA+IGNvbnN0JiwgdW5zaWduZWQgaW50KSmlBa4Cdm9pZCBlbXNjcmlwdGVuOjpmdW5jdGlvbjxib29sLCBFbVB0ciYsIHN0ZDo6X18yOjpiYXNpY19zdHJpbmc8Y2hhciwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPGNoYXI+LCBzdGQ6Ol9fMjo6YWxsb2NhdG9yPGNoYXI+ID4gY29uc3QmLCB1bnNpZ25lZCBpbnQsIEVtUHRyJj4oY2hhciBjb25zdCosIGJvb2wgKCopKEVtUHRyJiwgc3RkOjpfXzI6OmJhc2ljX3N0cmluZzxjaGFyLCBzdGQ6Ol9fMjo6Y2hhcl90cmFpdHM8Y2hhcj4sIHN0ZDo6X18yOjphbGxvY2F0b3I8Y2hhcj4gPiBjb25zdCYsIHVuc2lnbmVkIGludCwgRW1QdHImKSmmBZIBdm9pZCBlbXNjcmlwdGVuOjpmdW5jdGlvbjxib29sLCBFbVB0ciYsIEVtQnVmJiwgdW5zaWduZWQgaW50LCBFbVB0ciYsIEVtUHRyJj4oY2hhciBjb25zdCosIGJvb2wgKCopKEVtUHRyJiwgRW1CdWYmLCB1bnNpZ25lZCBpbnQsIEVtUHRyJiwgRW1QdHImKSmnBZ4Bdm9pZCBlbXNjcmlwdGVuOjpmdW5jdGlvbjx1bnNpZ25lZCBpbnQsIEVtUHRyJiwgdW5zaWduZWQgaW50LCBFbVB0ciYsIHVuc2lnbmVkIGludD4oY2hhciBjb25zdCosIHVuc2lnbmVkIGludCAoKikoRW1QdHImLCB1bnNpZ25lZCBpbnQsIEVtUHRyJiwgdW5zaWduZWQgaW50KSmoBTd2b2lkIGVtc2NyaXB0ZW46OmNvbnN0YW50PGludD4oY2hhciBjb25zdCosIGludCBjb25zdCYpqQVJdm9pZCBlbXNjcmlwdGVuOjpjb25zdGFudDx1bnNpZ25lZCBpbnQ+KGNoYXIgY29uc3QqLCB1bnNpZ25lZCBpbnQgY29uc3QmKaoFeGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHVuc2lnbmVkIGNoYXI+IGVtc2NyaXB0ZW46OnR5cGVkX21lbW9yeV92aWV3PHVuc2lnbmVkIGNoYXI+KHVuc2lnbmVkIGxvbmcsIHVuc2lnbmVkIGNoYXIgY29uc3QqKasFZ2Vtc2NyaXB0ZW46OnZhbDo6dmFsPGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHVuc2lnbmVkIGNoYXI+ID4oZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8dW5zaWduZWQgY2hhcj4mJimsBcUBZW1zY3JpcHRlbjo6dmFsOjp2YWw8c3RkOjpfXzI6OmJhc2ljX3N0cmluZzxjaGFyLCBzdGQ6Ol9fMjo6Y2hhcl90cmFpdHM8Y2hhcj4sIHN0ZDo6X18yOjphbGxvY2F0b3I8Y2hhcj4gPiA+KHN0ZDo6X18yOjpiYXNpY19zdHJpbmc8Y2hhciwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPGNoYXI+LCBzdGQ6Ol9fMjo6YWxsb2NhdG9yPGNoYXI+ID4mJimtBUdlbXNjcmlwdGVuOjppbnRlcm5hbDo6SW52b2tlcjx1bnNpZ25lZCBpbnQ+OjppbnZva2UodW5zaWduZWQgaW50ICgqKSgpKa4FUWVtc2NyaXB0ZW46OmludGVybmFsOjpXaXRoUG9saWNpZXM8Pjo6QXJnVHlwZUxpc3Q8dW5zaWduZWQgaW50Pjo6Z2V0Q291bnQoKSBjb25zdK8FUWVtc2NyaXB0ZW46OmludGVybmFsOjpXaXRoUG9saWNpZXM8Pjo6QXJnVHlwZUxpc3Q8dW5zaWduZWQgaW50Pjo6Z2V0VHlwZXMoKSBjb25zdLAFTWVtc2NyaXB0ZW46OmludGVybmFsOjpJbnZva2VyPGJvb2wsIEVtUHRyJj46Omludm9rZShib29sICgqKShFbVB0ciYpLCBFbVB0ciopsQVRZW1zY3JpcHRlbjo6aW50ZXJuYWw6OldpdGhQb2xpY2llczw+OjpBcmdUeXBlTGlzdDxib29sLCBFbVB0ciY+OjpnZXRDb3VudCgpIGNvbnN0sgVRZW1zY3JpcHRlbjo6aW50ZXJuYWw6OldpdGhQb2xpY2llczw+OjpBcmdUeXBlTGlzdDxib29sLCBFbVB0ciY+OjpnZXRUeXBlcygpIGNvbnN0swWYBmVtc2NyaXB0ZW46OmludGVybmFsOjpJbnZva2VyPEVtUHRyLCBFbVB0ciYsIHN0ZDo6X18yOjpiYXNpY19zdHJpbmc8Y2hhciwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPGNoYXI+LCBzdGQ6Ol9fMjo6YWxsb2NhdG9yPGNoYXI+ID4gY29uc3QmLCBfU0ZJTEVfRklORF9EQVRBJiwgc3RkOjpfXzI6OmJhc2ljX3N0cmluZzxjaGFyLCBzdGQ6Ol9fMjo6Y2hhcl90cmFpdHM8Y2hhcj4sIHN0ZDo6X18yOjphbGxvY2F0b3I8Y2hhcj4gPiBjb25zdCY+OjppbnZva2UoRW1QdHIgKCopKEVtUHRyJiwgc3RkOjpfXzI6OmJhc2ljX3N0cmluZzxjaGFyLCBzdGQ6Ol9fMjo6Y2hhcl90cmFpdHM8Y2hhcj4sIHN0ZDo6X18yOjphbGxvY2F0b3I8Y2hhcj4gPiBjb25zdCYsIF9TRklMRV9GSU5EX0RBVEEmLCBzdGQ6Ol9fMjo6YmFzaWNfc3RyaW5nPGNoYXIsIHN0ZDo6X18yOjpjaGFyX3RyYWl0czxjaGFyPiwgc3RkOjpfXzI6OmFsbG9jYXRvcjxjaGFyPiA+IGNvbnN0JiksIEVtUHRyKiwgZW1zY3JpcHRlbjo6aW50ZXJuYWw6OkJpbmRpbmdUeXBlPHN0ZDo6X18yOjpiYXNpY19zdHJpbmc8Y2hhciwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPGNoYXI+LCBzdGQ6Ol9fMjo6YWxsb2NhdG9yPGNoYXI+ID4sIHZvaWQ+OjondW5uYW1lZCcqLCBfU0ZJTEVfRklORF9EQVRBKiwgZW1zY3JpcHRlbjo6aW50ZXJuYWw6OkJpbmRpbmdUeXBlPHN0ZDo6X18yOjpiYXNpY19zdHJpbmc8Y2hhciwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPGNoYXI+LCBzdGQ6Ol9fMjo6YWxsb2NhdG9yPGNoYXI+ID4sIHZvaWQ+OjondW5uYW1lZCcqKbQFoQJlbXNjcmlwdGVuOjppbnRlcm5hbDo6V2l0aFBvbGljaWVzPD46OkFyZ1R5cGVMaXN0PEVtUHRyLCBFbVB0ciYsIHN0ZDo6X18yOjpiYXNpY19zdHJpbmc8Y2hhciwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPGNoYXI+LCBzdGQ6Ol9fMjo6YWxsb2NhdG9yPGNoYXI+ID4gY29uc3QmLCBfU0ZJTEVfRklORF9EQVRBJiwgc3RkOjpfXzI6OmJhc2ljX3N0cmluZzxjaGFyLCBzdGQ6Ol9fMjo6Y2hhcl90cmFpdHM8Y2hhcj4sIHN0ZDo6X18yOjphbGxvY2F0b3I8Y2hhcj4gPiBjb25zdCY+OjpnZXRDb3VudCgpIGNvbnN0tQWhAmVtc2NyaXB0ZW46OmludGVybmFsOjpXaXRoUG9saWNpZXM8Pjo6QXJnVHlwZUxpc3Q8RW1QdHIsIEVtUHRyJiwgc3RkOjpfXzI6OmJhc2ljX3N0cmluZzxjaGFyLCBzdGQ6Ol9fMjo6Y2hhcl90cmFpdHM8Y2hhcj4sIHN0ZDo6X18yOjphbGxvY2F0b3I8Y2hhcj4gPiBjb25zdCYsIF9TRklMRV9GSU5EX0RBVEEmLCBzdGQ6Ol9fMjo6YmFzaWNfc3RyaW5nPGNoYXIsIHN0ZDo6X18yOjpjaGFyX3RyYWl0czxjaGFyPiwgc3RkOjpfXzI6OmFsbG9jYXRvcjxjaGFyPiA+IGNvbnN0Jj46OmdldFR5cGVzKCkgY29uc3S2BVVjaGFyIGNvbnN0KiBlbXNjcmlwdGVuOjppbnRlcm5hbDo6Z2V0R2VuZXJpY1NpZ25hdHVyZTxpbnQsIGludCwgaW50LCBpbnQsIGludCwgaW50PigptwWGAWVtc2NyaXB0ZW46OmludGVybmFsOjpJbnZva2VyPGJvb2wsIEVtUHRyJiwgX1NGSUxFX0ZJTkRfREFUQSY+OjppbnZva2UoYm9vbCAoKikoRW1QdHImLCBfU0ZJTEVfRklORF9EQVRBJiksIEVtUHRyKiwgX1NGSUxFX0ZJTkRfREFUQSopuAVkZW1zY3JpcHRlbjo6aW50ZXJuYWw6OldpdGhQb2xpY2llczw+OjpBcmdUeXBlTGlzdDxib29sLCBFbVB0ciYsIF9TRklMRV9GSU5EX0RBVEEmPjo6Z2V0Q291bnQoKSBjb25zdLkFZGVtc2NyaXB0ZW46OmludGVybmFsOjpXaXRoUG9saWNpZXM8Pjo6QXJnVHlwZUxpc3Q8Ym9vbCwgRW1QdHImLCBfU0ZJTEVfRklORF9EQVRBJj46OmdldFR5cGVzKCkgY29uc3S6BUtjaGFyIGNvbnN0KiBlbXNjcmlwdGVuOjppbnRlcm5hbDo6Z2V0R2VuZXJpY1NpZ25hdHVyZTxpbnQsIGludCwgaW50LCBpbnQ+KCm7BWVlbXNjcmlwdGVuOjppbnRlcm5hbDo6SW52b2tlcjxib29sLCBFbVB0ciYsIEVtU3RyJj46Omludm9rZShib29sICgqKShFbVB0ciYsIEVtU3RyJiksIEVtUHRyKiwgRW1TdHIqKbwFWWVtc2NyaXB0ZW46OmludGVybmFsOjpXaXRoUG9saWNpZXM8Pjo6QXJnVHlwZUxpc3Q8Ym9vbCwgRW1QdHImLCBFbVN0ciY+OjpnZXRDb3VudCgpIGNvbnN0vQVZZW1zY3JpcHRlbjo6aW50ZXJuYWw6OldpdGhQb2xpY2llczw+OjpBcmdUeXBlTGlzdDxib29sLCBFbVB0ciYsIEVtU3RyJj46OmdldFR5cGVzKCkgY29uc3S+BXVlbXNjcmlwdGVuOjppbnRlcm5hbDo6SW52b2tlcjx1bnNpZ25lZCBpbnQsIEVtUHRyJiwgRW1QdHImPjo6aW52b2tlKHVuc2lnbmVkIGludCAoKikoRW1QdHImLCBFbVB0ciYpLCBFbVB0ciosIEVtUHRyKim/BWFlbXNjcmlwdGVuOjppbnRlcm5hbDo6V2l0aFBvbGljaWVzPD46OkFyZ1R5cGVMaXN0PHVuc2lnbmVkIGludCwgRW1QdHImLCBFbVB0ciY+OjpnZXRDb3VudCgpIGNvbnN0wAVhZW1zY3JpcHRlbjo6aW50ZXJuYWw6OldpdGhQb2xpY2llczw+OjpBcmdUeXBlTGlzdDx1bnNpZ25lZCBpbnQsIEVtUHRyJiwgRW1QdHImPjo6Z2V0VHlwZXMoKSBjb25zdMEFlQNlbXNjcmlwdGVuOjppbnRlcm5hbDo6SW52b2tlcjxib29sLCBFbVB0ciYsIHN0ZDo6X18yOjpiYXNpY19zdHJpbmc8Y2hhciwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPGNoYXI+LCBzdGQ6Ol9fMjo6YWxsb2NhdG9yPGNoYXI+ID4gY29uc3QmPjo6aW52b2tlKGJvb2wgKCopKEVtUHRyJiwgc3RkOjpfXzI6OmJhc2ljX3N0cmluZzxjaGFyLCBzdGQ6Ol9fMjo6Y2hhcl90cmFpdHM8Y2hhcj4sIHN0ZDo6X18yOjphbGxvY2F0b3I8Y2hhcj4gPiBjb25zdCYpLCBFbVB0ciosIGVtc2NyaXB0ZW46OmludGVybmFsOjpCaW5kaW5nVHlwZTxzdGQ6Ol9fMjo6YmFzaWNfc3RyaW5nPGNoYXIsIHN0ZDo6X18yOjpjaGFyX3RyYWl0czxjaGFyPiwgc3RkOjpfXzI6OmFsbG9jYXRvcjxjaGFyPiA+LCB2b2lkPjo6J3VubmFtZWQnKinCBa8BZW1zY3JpcHRlbjo6aW50ZXJuYWw6OldpdGhQb2xpY2llczw+OjpBcmdUeXBlTGlzdDxib29sLCBFbVB0ciYsIHN0ZDo6X18yOjpiYXNpY19zdHJpbmc8Y2hhciwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPGNoYXI+LCBzdGQ6Ol9fMjo6YWxsb2NhdG9yPGNoYXI+ID4gY29uc3QmPjo6Z2V0Q291bnQoKSBjb25zdMMFrwFlbXNjcmlwdGVuOjppbnRlcm5hbDo6V2l0aFBvbGljaWVzPD46OkFyZ1R5cGVMaXN0PGJvb2wsIEVtUHRyJiwgc3RkOjpfXzI6OmJhc2ljX3N0cmluZzxjaGFyLCBzdGQ6Ol9fMjo6Y2hhcl90cmFpdHM8Y2hhcj4sIHN0ZDo6X18yOjphbGxvY2F0b3I8Y2hhcj4gPiBjb25zdCY+OjpnZXRUeXBlcygpIGNvbnN0xAXpA2Vtc2NyaXB0ZW46OmludGVybmFsOjpJbnZva2VyPGJvb2wsIHN0ZDo6X18yOjpiYXNpY19zdHJpbmc8Y2hhciwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPGNoYXI+LCBzdGQ6Ol9fMjo6YWxsb2NhdG9yPGNoYXI+ID4gY29uc3QmLCB1bnNpZ25lZCBpbnQsIHVuc2lnbmVkIGludCwgRW1QdHImPjo6aW52b2tlKGJvb2wgKCopKHN0ZDo6X18yOjpiYXNpY19zdHJpbmc8Y2hhciwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPGNoYXI+LCBzdGQ6Ol9fMjo6YWxsb2NhdG9yPGNoYXI+ID4gY29uc3QmLCB1bnNpZ25lZCBpbnQsIHVuc2lnbmVkIGludCwgRW1QdHImKSwgZW1zY3JpcHRlbjo6aW50ZXJuYWw6OkJpbmRpbmdUeXBlPHN0ZDo6X18yOjpiYXNpY19zdHJpbmc8Y2hhciwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPGNoYXI+LCBzdGQ6Ol9fMjo6YWxsb2NhdG9yPGNoYXI+ID4sIHZvaWQ+OjondW5uYW1lZCcqLCB1bnNpZ25lZCBpbnQsIHVuc2lnbmVkIGludCwgRW1QdHIqKcUFywFlbXNjcmlwdGVuOjppbnRlcm5hbDo6V2l0aFBvbGljaWVzPD46OkFyZ1R5cGVMaXN0PGJvb2wsIHN0ZDo6X18yOjpiYXNpY19zdHJpbmc8Y2hhciwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPGNoYXI+LCBzdGQ6Ol9fMjo6YWxsb2NhdG9yPGNoYXI+ID4gY29uc3QmLCB1bnNpZ25lZCBpbnQsIHVuc2lnbmVkIGludCwgRW1QdHImPjo6Z2V0Q291bnQoKSBjb25zdMYFywFlbXNjcmlwdGVuOjppbnRlcm5hbDo6V2l0aFBvbGljaWVzPD46OkFyZ1R5cGVMaXN0PGJvb2wsIHN0ZDo6X18yOjpiYXNpY19zdHJpbmc8Y2hhciwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPGNoYXI+LCBzdGQ6Ol9fMjo6YWxsb2NhdG9yPGNoYXI+ID4gY29uc3QmLCB1bnNpZ25lZCBpbnQsIHVuc2lnbmVkIGludCwgRW1QdHImPjo6Z2V0VHlwZXMoKSBjb25zdMcFhwZlbXNjcmlwdGVuOjppbnRlcm5hbDo6SW52b2tlcjxib29sLCBFbVB0ciYsIHN0ZDo6X18yOjpiYXNpY19zdHJpbmc8Y2hhciwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPGNoYXI+LCBzdGQ6Ol9fMjo6YWxsb2NhdG9yPGNoYXI+ID4gY29uc3QmLCBzdGQ6Ol9fMjo6YmFzaWNfc3RyaW5nPGNoYXIsIHN0ZDo6X18yOjpjaGFyX3RyYWl0czxjaGFyPiwgc3RkOjpfXzI6OmFsbG9jYXRvcjxjaGFyPiA+IGNvbnN0JiwgdW5zaWduZWQgaW50Pjo6aW52b2tlKGJvb2wgKCopKEVtUHRyJiwgc3RkOjpfXzI6OmJhc2ljX3N0cmluZzxjaGFyLCBzdGQ6Ol9fMjo6Y2hhcl90cmFpdHM8Y2hhcj4sIHN0ZDo6X18yOjphbGxvY2F0b3I8Y2hhcj4gPiBjb25zdCYsIHN0ZDo6X18yOjpiYXNpY19zdHJpbmc8Y2hhciwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPGNoYXI+LCBzdGQ6Ol9fMjo6YWxsb2NhdG9yPGNoYXI+ID4gY29uc3QmLCB1bnNpZ25lZCBpbnQpLCBFbVB0ciosIGVtc2NyaXB0ZW46OmludGVybmFsOjpCaW5kaW5nVHlwZTxzdGQ6Ol9fMjo6YmFzaWNfc3RyaW5nPGNoYXIsIHN0ZDo6X18yOjpjaGFyX3RyYWl0czxjaGFyPiwgc3RkOjpfXzI6OmFsbG9jYXRvcjxjaGFyPiA+LCB2b2lkPjo6J3VubmFtZWQnKiwgZW1zY3JpcHRlbjo6aW50ZXJuYWw6OkJpbmRpbmdUeXBlPHN0ZDo6X18yOjpiYXNpY19zdHJpbmc8Y2hhciwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPGNoYXI+LCBzdGQ6Ol9fMjo6YWxsb2NhdG9yPGNoYXI+ID4sIHZvaWQ+OjondW5uYW1lZCcqLCB1bnNpZ25lZCBpbnQpyAWbAmVtc2NyaXB0ZW46OmludGVybmFsOjpXaXRoUG9saWNpZXM8Pjo6QXJnVHlwZUxpc3Q8Ym9vbCwgRW1QdHImLCBzdGQ6Ol9fMjo6YmFzaWNfc3RyaW5nPGNoYXIsIHN0ZDo6X18yOjpjaGFyX3RyYWl0czxjaGFyPiwgc3RkOjpfXzI6OmFsbG9jYXRvcjxjaGFyPiA+IGNvbnN0Jiwgc3RkOjpfXzI6OmJhc2ljX3N0cmluZzxjaGFyLCBzdGQ6Ol9fMjo6Y2hhcl90cmFpdHM8Y2hhcj4sIHN0ZDo6X18yOjphbGxvY2F0b3I8Y2hhcj4gPiBjb25zdCYsIHVuc2lnbmVkIGludD46OmdldENvdW50KCkgY29uc3TJBZsCZW1zY3JpcHRlbjo6aW50ZXJuYWw6OldpdGhQb2xpY2llczw+OjpBcmdUeXBlTGlzdDxib29sLCBFbVB0ciYsIHN0ZDo6X18yOjpiYXNpY19zdHJpbmc8Y2hhciwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPGNoYXI+LCBzdGQ6Ol9fMjo6YWxsb2NhdG9yPGNoYXI+ID4gY29uc3QmLCBzdGQ6Ol9fMjo6YmFzaWNfc3RyaW5nPGNoYXIsIHN0ZDo6X18yOjpjaGFyX3RyYWl0czxjaGFyPiwgc3RkOjpfXzI6OmFsbG9jYXRvcjxjaGFyPiA+IGNvbnN0JiwgdW5zaWduZWQgaW50Pjo6Z2V0VHlwZXMoKSBjb25zdMoF1wNlbXNjcmlwdGVuOjppbnRlcm5hbDo6SW52b2tlcjxib29sLCBFbVB0ciYsIHN0ZDo6X18yOjpiYXNpY19zdHJpbmc8Y2hhciwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPGNoYXI+LCBzdGQ6Ol9fMjo6YWxsb2NhdG9yPGNoYXI+ID4gY29uc3QmLCB1bnNpZ25lZCBpbnQsIEVtUHRyJj46Omludm9rZShib29sICgqKShFbVB0ciYsIHN0ZDo6X18yOjpiYXNpY19zdHJpbmc8Y2hhciwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPGNoYXI+LCBzdGQ6Ol9fMjo6YWxsb2NhdG9yPGNoYXI+ID4gY29uc3QmLCB1bnNpZ25lZCBpbnQsIEVtUHRyJiksIEVtUHRyKiwgZW1zY3JpcHRlbjo6aW50ZXJuYWw6OkJpbmRpbmdUeXBlPHN0ZDo6X18yOjpiYXNpY19zdHJpbmc8Y2hhciwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPGNoYXI+LCBzdGQ6Ol9fMjo6YWxsb2NhdG9yPGNoYXI+ID4sIHZvaWQ+OjondW5uYW1lZCcqLCB1bnNpZ25lZCBpbnQsIEVtUHRyKinLBcUBZW1zY3JpcHRlbjo6aW50ZXJuYWw6OldpdGhQb2xpY2llczw+OjpBcmdUeXBlTGlzdDxib29sLCBFbVB0ciYsIHN0ZDo6X18yOjpiYXNpY19zdHJpbmc8Y2hhciwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPGNoYXI+LCBzdGQ6Ol9fMjo6YWxsb2NhdG9yPGNoYXI+ID4gY29uc3QmLCB1bnNpZ25lZCBpbnQsIEVtUHRyJj46OmdldENvdW50KCkgY29uc3TMBcUBZW1zY3JpcHRlbjo6aW50ZXJuYWw6OldpdGhQb2xpY2llczw+OjpBcmdUeXBlTGlzdDxib29sLCBFbVB0ciYsIHN0ZDo6X18yOjpiYXNpY19zdHJpbmc8Y2hhciwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPGNoYXI+LCBzdGQ6Ol9fMjo6YWxsb2NhdG9yPGNoYXI+ID4gY29uc3QmLCB1bnNpZ25lZCBpbnQsIEVtUHRyJj46OmdldFR5cGVzKCkgY29uc3TNBb8BZW1zY3JpcHRlbjo6aW50ZXJuYWw6Okludm9rZXI8Ym9vbCwgRW1QdHImLCBFbUJ1ZiYsIHVuc2lnbmVkIGludCwgRW1QdHImLCBFbVB0ciY+OjppbnZva2UoYm9vbCAoKikoRW1QdHImLCBFbUJ1ZiYsIHVuc2lnbmVkIGludCwgRW1QdHImLCBFbVB0ciYpLCBFbVB0ciosIEVtQnVmKiwgdW5zaWduZWQgaW50LCBFbVB0ciosIEVtUHRyKinOBXdlbXNjcmlwdGVuOjppbnRlcm5hbDo6V2l0aFBvbGljaWVzPD46OkFyZ1R5cGVMaXN0PGJvb2wsIEVtUHRyJiwgRW1CdWYmLCB1bnNpZ25lZCBpbnQsIEVtUHRyJiwgRW1QdHImPjo6Z2V0Q291bnQoKSBjb25zdM8Fd2Vtc2NyaXB0ZW46OmludGVybmFsOjpXaXRoUG9saWNpZXM8Pjo6QXJnVHlwZUxpc3Q8Ym9vbCwgRW1QdHImLCBFbUJ1ZiYsIHVuc2lnbmVkIGludCwgRW1QdHImLCBFbVB0ciY+OjpnZXRUeXBlcygpIGNvbnN00AVaY2hhciBjb25zdCogZW1zY3JpcHRlbjo6aW50ZXJuYWw6OmdldEdlbmVyaWNTaWduYXR1cmU8aW50LCBpbnQsIGludCwgaW50LCBpbnQsIGludCwgaW50Pigp0QXJAWVtc2NyaXB0ZW46OmludGVybmFsOjpJbnZva2VyPHVuc2lnbmVkIGludCwgRW1QdHImLCB1bnNpZ25lZCBpbnQsIEVtUHRyJiwgdW5zaWduZWQgaW50Pjo6aW52b2tlKHVuc2lnbmVkIGludCAoKikoRW1QdHImLCB1bnNpZ25lZCBpbnQsIEVtUHRyJiwgdW5zaWduZWQgaW50KSwgRW1QdHIqLCB1bnNpZ25lZCBpbnQsIEVtUHRyKiwgdW5zaWduZWQgaW50KdIFfWVtc2NyaXB0ZW46OmludGVybmFsOjpXaXRoUG9saWNpZXM8Pjo6QXJnVHlwZUxpc3Q8dW5zaWduZWQgaW50LCBFbVB0ciYsIHVuc2lnbmVkIGludCwgRW1QdHImLCB1bnNpZ25lZCBpbnQ+OjpnZXRDb3VudCgpIGNvbnN00wV9ZW1zY3JpcHRlbjo6aW50ZXJuYWw6OldpdGhQb2xpY2llczw+OjpBcmdUeXBlTGlzdDx1bnNpZ25lZCBpbnQsIEVtUHRyJiwgdW5zaWduZWQgaW50LCBFbVB0ciYsIHVuc2lnbmVkIGludD46OmdldFR5cGVzKCkgY29uc3TUBTVlbXNjcmlwdGVuOjppbnRlcm5hbDo6VHlwZUlEPGludCBjb25zdCYsIHZvaWQ+OjpnZXQoKdUFRGVtc2NyaXB0ZW46OmludGVybmFsOjpCaW5kaW5nVHlwZTxpbnQsIHZvaWQ+Ojp0b1dpcmVUeXBlKGludCBjb25zdCYp1gU1ZG91YmxlIGVtc2NyaXB0ZW46OmludGVybmFsOjphc0dlbmVyaWNWYWx1ZTxpbnQ+KGludCnXBT5lbXNjcmlwdGVuOjppbnRlcm5hbDo6VHlwZUlEPHVuc2lnbmVkIGludCBjb25zdCYsIHZvaWQ+OjpnZXQoKdgFVmVtc2NyaXB0ZW46OmludGVybmFsOjpCaW5kaW5nVHlwZTx1bnNpZ25lZCBpbnQsIHZvaWQ+Ojp0b1dpcmVUeXBlKHVuc2lnbmVkIGludCBjb25zdCYp2QVHZG91YmxlIGVtc2NyaXB0ZW46OmludGVybmFsOjphc0dlbmVyaWNWYWx1ZTx1bnNpZ25lZCBpbnQ+KHVuc2lnbmVkIGludCnaBVhlbXNjcmlwdGVuOjptZW1vcnlfdmlldzx1bnNpZ25lZCBjaGFyPjo6bWVtb3J5X3ZpZXcodW5zaWduZWQgbG9uZywgdW5zaWduZWQgY2hhciBjb25zdCop2wWvAWVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHVuc2lnbmVkIGNoYXI+JiYgc3RkOjpfXzI6OmZvcndhcmQ8ZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8dW5zaWduZWQgY2hhcj4gPihzdGQ6Ol9fMjo6cmVtb3ZlX3JlZmVyZW5jZTxlbXNjcmlwdGVuOjptZW1vcnlfdmlldzx1bnNpZ25lZCBjaGFyPiA+Ojp0eXBlJincBYMBZW1zY3JpcHRlbjo6aW50ZXJuYWw6OldpcmVUeXBlUGFjazxlbXNjcmlwdGVuOjptZW1vcnlfdmlldzx1bnNpZ25lZCBjaGFyPiA+OjpXaXJlVHlwZVBhY2soZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8dW5zaWduZWQgY2hhcj4mJindBVFlbXNjcmlwdGVuOjppbnRlcm5hbDo6VHlwZUlEPGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHVuc2lnbmVkIGNoYXI+LCB2b2lkPjo6Z2V0KCneBWllbXNjcmlwdGVuOjppbnRlcm5hbDo6V2lyZVR5cGVQYWNrPGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHVuc2lnbmVkIGNoYXI+ID46Om9wZXJhdG9yIHZvaWQgY29uc3QqKCkgY29uc3TfBUNzdGQ6Ol9fMjo6YXJyYXk8ZW1zY3JpcHRlbjo6aW50ZXJuYWw6OkdlbmVyaWNXaXJlVHlwZSwgMXVsPjo6ZGF0YSgp4AWKAWVtc2NyaXB0ZW46OmludGVybmFsOjpCaW5kaW5nVHlwZTxlbXNjcmlwdGVuOjptZW1vcnlfdmlldzx1bnNpZ25lZCBjaGFyPiwgdm9pZD46OnRvV2lyZVR5cGUoZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8dW5zaWduZWQgY2hhcj4gY29uc3QmKeEFlgF2b2lkIGVtc2NyaXB0ZW46OmludGVybmFsOjp3cml0ZUdlbmVyaWNXaXJlVHlwZTx1bnNpZ25lZCBjaGFyPihlbXNjcmlwdGVuOjppbnRlcm5hbDo6R2VuZXJpY1dpcmVUeXBlKiYsIGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHVuc2lnbmVkIGNoYXI+IGNvbnN0JiniBVRlbXNjcmlwdGVuOjppbnRlcm5hbDo6d3JpdGVHZW5lcmljV2lyZVR5cGVzKGVtc2NyaXB0ZW46OmludGVybmFsOjpHZW5lcmljV2lyZVR5cGUqJinjBVFlbXNjcmlwdGVuOjppbnRlcm5hbDo6TGlnaHRUeXBlSUQ8ZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8dW5zaWduZWQgY2hhcj4gPjo6Z2V0KCnkBUlzdGQ6Ol9fMjo6YXJyYXk8ZW1zY3JpcHRlbjo6aW50ZXJuYWw6OkdlbmVyaWNXaXJlVHlwZSwgMXVsPjo6ZGF0YSgpIGNvbnN05QW8AnN0ZDo6X18yOjpiYXNpY19zdHJpbmc8Y2hhciwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPGNoYXI+LCBzdGQ6Ol9fMjo6YWxsb2NhdG9yPGNoYXI+ID4mJiBzdGQ6Ol9fMjo6Zm9yd2FyZDxzdGQ6Ol9fMjo6YmFzaWNfc3RyaW5nPGNoYXIsIHN0ZDo6X18yOjpjaGFyX3RyYWl0czxjaGFyPiwgc3RkOjpfXzI6OmFsbG9jYXRvcjxjaGFyPiA+ID4oc3RkOjpfXzI6OnJlbW92ZV9yZWZlcmVuY2U8c3RkOjpfXzI6OmJhc2ljX3N0cmluZzxjaGFyLCBzdGQ6Ol9fMjo6Y2hhcl90cmFpdHM8Y2hhcj4sIHN0ZDo6X18yOjphbGxvY2F0b3I8Y2hhcj4gPiA+Ojp0eXBlJinmBeEBZW1zY3JpcHRlbjo6aW50ZXJuYWw6OldpcmVUeXBlUGFjazxzdGQ6Ol9fMjo6YmFzaWNfc3RyaW5nPGNoYXIsIHN0ZDo6X18yOjpjaGFyX3RyYWl0czxjaGFyPiwgc3RkOjpfXzI6OmFsbG9jYXRvcjxjaGFyPiA+ID46OldpcmVUeXBlUGFjayhzdGQ6Ol9fMjo6YmFzaWNfc3RyaW5nPGNoYXIsIHN0ZDo6X18yOjpjaGFyX3RyYWl0czxjaGFyPiwgc3RkOjpfXzI6OmFsbG9jYXRvcjxjaGFyPiA+JiYp5wWYAWVtc2NyaXB0ZW46OmludGVybmFsOjpXaXJlVHlwZVBhY2s8c3RkOjpfXzI6OmJhc2ljX3N0cmluZzxjaGFyLCBzdGQ6Ol9fMjo6Y2hhcl90cmFpdHM8Y2hhcj4sIHN0ZDo6X18yOjphbGxvY2F0b3I8Y2hhcj4gPiA+OjpvcGVyYXRvciB2b2lkIGNvbnN0KigpIGNvbnN06AXoAWVtc2NyaXB0ZW46OmludGVybmFsOjpCaW5kaW5nVHlwZTxzdGQ6Ol9fMjo6YmFzaWNfc3RyaW5nPGNoYXIsIHN0ZDo6X18yOjpjaGFyX3RyYWl0czxjaGFyPiwgc3RkOjpfXzI6OmFsbG9jYXRvcjxjaGFyPiA+LCB2b2lkPjo6dG9XaXJlVHlwZShzdGQ6Ol9fMjo6YmFzaWNfc3RyaW5nPGNoYXIsIHN0ZDo6X18yOjpjaGFyX3RyYWl0czxjaGFyPiwgc3RkOjpfXzI6OmFsbG9jYXRvcjxjaGFyPiA+IGNvbnN0JinpBe8Cdm9pZCBlbXNjcmlwdGVuOjppbnRlcm5hbDo6d3JpdGVHZW5lcmljV2lyZVR5cGU8ZW1zY3JpcHRlbjo6aW50ZXJuYWw6OkJpbmRpbmdUeXBlPHN0ZDo6X18yOjpiYXNpY19zdHJpbmc8Y2hhciwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPGNoYXI+LCBzdGQ6Ol9fMjo6YWxsb2NhdG9yPGNoYXI+ID4sIHZvaWQ+OjondW5uYW1lZCc+KGVtc2NyaXB0ZW46OmludGVybmFsOjpHZW5lcmljV2lyZVR5cGUqJiwgZW1zY3JpcHRlbjo6aW50ZXJuYWw6OkJpbmRpbmdUeXBlPHN0ZDo6X18yOjpiYXNpY19zdHJpbmc8Y2hhciwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPGNoYXI+LCBzdGQ6Ol9fMjo6YWxsb2NhdG9yPGNoYXI+ID4sIHZvaWQ+OjondW5uYW1lZCcqKeoFgAFlbXNjcmlwdGVuOjppbnRlcm5hbDo6TGlnaHRUeXBlSUQ8c3RkOjpfXzI6OmJhc2ljX3N0cmluZzxjaGFyLCBzdGQ6Ol9fMjo6Y2hhcl90cmFpdHM8Y2hhcj4sIHN0ZDo6X18yOjphbGxvY2F0b3I8Y2hhcj4gPiA+OjpnZXQoKesFZXN0ZDo6X18yOjpiYXNpY19zdHJpbmc8Y2hhciwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPGNoYXI+LCBzdGQ6Ol9fMjo6YWxsb2NhdG9yPGNoYXI+ID46Omxlbmd0aCgpIGNvbnN07AVjc3RkOjpfXzI6OmJhc2ljX3N0cmluZzxjaGFyLCBzdGQ6Ol9fMjo6Y2hhcl90cmFpdHM8Y2hhcj4sIHN0ZDo6X18yOjphbGxvY2F0b3I8Y2hhcj4gPjo6c2l6ZSgpIGNvbnN07QVsc3RkOjpfXzI6OmJhc2ljX3N0cmluZzxjaGFyLCBzdGQ6Ol9fMjo6Y2hhcl90cmFpdHM8Y2hhcj4sIHN0ZDo6X18yOjphbGxvY2F0b3I8Y2hhcj4gPjo6X19nZXRfcG9pbnRlcigpIGNvbnN07gU7Y2hhciBjb25zdCogc3RkOjpfXzI6Ol9fdG9fYWRkcmVzczxjaGFyIGNvbnN0PihjaGFyIGNvbnN0KinvBWhzdGQ6Ol9fMjo6YmFzaWNfc3RyaW5nPGNoYXIsIHN0ZDo6X18yOjpjaGFyX3RyYWl0czxjaGFyPiwgc3RkOjpfXzI6OmFsbG9jYXRvcjxjaGFyPiA+OjpfX2lzX2xvbmcoKSBjb25zdPAFbnN0ZDo6X18yOjpiYXNpY19zdHJpbmc8Y2hhciwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPGNoYXI+LCBzdGQ6Ol9fMjo6YWxsb2NhdG9yPGNoYXI+ID46Ol9fZ2V0X2xvbmdfc2l6ZSgpIGNvbnN08QVvc3RkOjpfXzI6OmJhc2ljX3N0cmluZzxjaGFyLCBzdGQ6Ol9fMjo6Y2hhcl90cmFpdHM8Y2hhcj4sIHN0ZDo6X18yOjphbGxvY2F0b3I8Y2hhcj4gPjo6X19nZXRfc2hvcnRfc2l6ZSgpIGNvbnN08gWkAXN0ZDo6X18yOjpfX2NvbXByZXNzZWRfcGFpcjxzdGQ6Ol9fMjo6YmFzaWNfc3RyaW5nPGNoYXIsIHN0ZDo6X18yOjpjaGFyX3RyYWl0czxjaGFyPiwgc3RkOjpfXzI6OmFsbG9jYXRvcjxjaGFyPiA+OjpfX3JlcCwgc3RkOjpfXzI6OmFsbG9jYXRvcjxjaGFyPiA+OjpmaXJzdCgpIGNvbnN08wWXAXN0ZDo6X18yOjpfX2NvbXByZXNzZWRfcGFpcl9lbGVtPHN0ZDo6X18yOjpiYXNpY19zdHJpbmc8Y2hhciwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPGNoYXI+LCBzdGQ6Ol9fMjo6YWxsb2NhdG9yPGNoYXI+ID46Ol9fcmVwLCAwLCBmYWxzZT46Ol9fZ2V0KCkgY29uc3T0BXFzdGQ6Ol9fMjo6YmFzaWNfc3RyaW5nPGNoYXIsIHN0ZDo6X18yOjpjaGFyX3RyYWl0czxjaGFyPiwgc3RkOjpfXzI6OmFsbG9jYXRvcjxjaGFyPiA+OjpfX2dldF9sb25nX3BvaW50ZXIoKSBjb25zdPUFcnN0ZDo6X18yOjpiYXNpY19zdHJpbmc8Y2hhciwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPGNoYXI+LCBzdGQ6Ol9fMjo6YWxsb2NhdG9yPGNoYXI+ID46Ol9fZ2V0X3Nob3J0X3BvaW50ZXIoKSBjb25zdPYFPnN0ZDo6X18yOjpwb2ludGVyX3RyYWl0czxjaGFyIGNvbnN0Kj46OnBvaW50ZXJfdG8oY2hhciBjb25zdCYp9wU4Y2hhciBjb25zdCogc3RkOjpfXzI6OmFkZHJlc3NvZjxjaGFyIGNvbnN0PihjaGFyIGNvbnN0Jin4BY8Bc3RkOjpfXzI6Ol9fZGVmYXVsdF9pbml0X3RhZyYmIHN0ZDo6X18yOjpmb3J3YXJkPHN0ZDo6X18yOjpfX2RlZmF1bHRfaW5pdF90YWc+KHN0ZDo6X18yOjpyZW1vdmVfcmVmZXJlbmNlPHN0ZDo6X18yOjpfX2RlZmF1bHRfaW5pdF90YWc+Ojp0eXBlJin5Bb4Bc3RkOjpfXzI6Ol9fY29tcHJlc3NlZF9wYWlyX2VsZW08c3RkOjpfXzI6OmJhc2ljX3N0cmluZzxjaGFyLCBzdGQ6Ol9fMjo6Y2hhcl90cmFpdHM8Y2hhcj4sIHN0ZDo6X18yOjphbGxvY2F0b3I8Y2hhcj4gPjo6X19yZXAsIDAsIGZhbHNlPjo6X19jb21wcmVzc2VkX3BhaXJfZWxlbShzdGQ6Ol9fMjo6X19kZWZhdWx0X2luaXRfdGFnKfoFenN0ZDo6X18yOjpfX2NvbXByZXNzZWRfcGFpcl9lbGVtPHN0ZDo6X18yOjphbGxvY2F0b3I8Y2hhcj4sIDEsIHRydWU+OjpfX2NvbXByZXNzZWRfcGFpcl9lbGVtKHN0ZDo6X18yOjpfX2RlZmF1bHRfaW5pdF90YWcp+wUmc3RkOjpfXzI6OmFsbG9jYXRvcjxjaGFyPjo6YWxsb2NhdG9yKCn8Bc0Cc3RkOjpfXzI6OmJhc2ljX3N0cmluZzxjaGFyLCBzdGQ6Ol9fMjo6Y2hhcl90cmFpdHM8Y2hhcj4sIHN0ZDo6X18yOjphbGxvY2F0b3I8Y2hhcj4gPiBjb25zdCYgc3RkOjpfXzI6OmZvcndhcmQ8c3RkOjpfXzI6OmJhc2ljX3N0cmluZzxjaGFyLCBzdGQ6Ol9fMjo6Y2hhcl90cmFpdHM8Y2hhcj4sIHN0ZDo6X18yOjphbGxvY2F0b3I8Y2hhcj4gPiBjb25zdCY+KHN0ZDo6X18yOjpyZW1vdmVfcmVmZXJlbmNlPHN0ZDo6X18yOjpiYXNpY19zdHJpbmc8Y2hhciwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPGNoYXI+LCBzdGQ6Ol9fMjo6YWxsb2NhdG9yPGNoYXI+ID4gY29uc3QmPjo6dHlwZSYp/QXsAWVtc2NyaXB0ZW46OmludGVybmFsOjpXaXJlVHlwZVBhY2s8c3RkOjpfXzI6OmJhc2ljX3N0cmluZzxjaGFyLCBzdGQ6Ol9fMjo6Y2hhcl90cmFpdHM8Y2hhcj4sIHN0ZDo6X18yOjphbGxvY2F0b3I8Y2hhcj4gPiBjb25zdCY+OjpXaXJlVHlwZVBhY2soc3RkOjpfXzI6OmJhc2ljX3N0cmluZzxjaGFyLCBzdGQ6Ol9fMjo6Y2hhcl90cmFpdHM8Y2hhcj4sIHN0ZDo6X18yOjphbGxvY2F0b3I8Y2hhcj4gPiBjb25zdCYp/gWHAWVtc2NyaXB0ZW46OmludGVybmFsOjpUeXBlSUQ8c3RkOjpfXzI6OmJhc2ljX3N0cmluZzxjaGFyLCBzdGQ6Ol9fMjo6Y2hhcl90cmFpdHM8Y2hhcj4sIHN0ZDo6X18yOjphbGxvY2F0b3I8Y2hhcj4gPiBjb25zdCYsIHZvaWQ+OjpnZXQoKf8FngFlbXNjcmlwdGVuOjppbnRlcm5hbDo6V2lyZVR5cGVQYWNrPHN0ZDo6X18yOjpiYXNpY19zdHJpbmc8Y2hhciwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPGNoYXI+LCBzdGQ6Ol9fMjo6YWxsb2NhdG9yPGNoYXI+ID4gY29uc3QmPjo6b3BlcmF0b3Igdm9pZCBjb25zdCooKSBjb25zdIAGhgFlbXNjcmlwdGVuOjppbnRlcm5hbDo6TGlnaHRUeXBlSUQ8c3RkOjpfXzI6OmJhc2ljX3N0cmluZzxjaGFyLCBzdGQ6Ol9fMjo6Y2hhcl90cmFpdHM8Y2hhcj4sIHN0ZDo6X18yOjphbGxvY2F0b3I8Y2hhcj4gPiBjb25zdCY+OjpnZXQoKYEGcnVuc2lnbmVkIGludCBjb25zdCYgc3RkOjpfXzI6OmZvcndhcmQ8dW5zaWduZWQgaW50IGNvbnN0Jj4oc3RkOjpfXzI6OnJlbW92ZV9yZWZlcmVuY2U8dW5zaWduZWQgaW50IGNvbnN0Jj46OnR5cGUmKYIGWmVtc2NyaXB0ZW46OmludGVybmFsOjpXaXJlVHlwZVBhY2s8dW5zaWduZWQgaW50IGNvbnN0Jj46OldpcmVUeXBlUGFjayh1bnNpZ25lZCBpbnQgY29uc3QmKYMGVWVtc2NyaXB0ZW46OmludGVybmFsOjpXaXJlVHlwZVBhY2s8dW5zaWduZWQgaW50IGNvbnN0Jj46Om9wZXJhdG9yIHZvaWQgY29uc3QqKCkgY29uc3SEBnR2b2lkIGVtc2NyaXB0ZW46OmludGVybmFsOjp3cml0ZUdlbmVyaWNXaXJlVHlwZTx1bnNpZ25lZCBpbnQ+KGVtc2NyaXB0ZW46OmludGVybmFsOjpHZW5lcmljV2lyZVR5cGUqJiwgdW5zaWduZWQgaW50KYUGPWVtc2NyaXB0ZW46OmludGVybmFsOjpMaWdodFR5cGVJRDx1bnNpZ25lZCBpbnQgY29uc3QmPjo6Z2V0KCmGBkV2b2lkIGNvbnN0KiBlbXNjcmlwdGVuOjppbnRlcm5hbDo6Z2V0TGlnaHRUeXBlSUQ8RW1CdWY+KEVtQnVmIGNvbnN0JimHBg9FbUJ1Zjo6fkVtQnVmKCmIBi9lbXNjcmlwdGVuOjppbnRlcm5hbDo6TGlnaHRUeXBlSUQ8RW1CdWY+OjpnZXQoKYkGMGVtc2NyaXB0ZW46OmludGVybmFsOjpMaWdodFR5cGVJRDxFbUJ1Zio+OjpnZXQoKYoGNmVtc2NyaXB0ZW46OmludGVybmFsOjpMaWdodFR5cGVJRDxFbUJ1ZiBjb25zdCo+OjpnZXQoKYsGX3Vuc2lnbmVkIGludCYmIHN0ZDo6X18yOjpmb3J3YXJkPHVuc2lnbmVkIGludD4oc3RkOjpfXzI6OnJlbW92ZV9yZWZlcmVuY2U8dW5zaWduZWQgaW50Pjo6dHlwZSYpjAYaRW1CdWY6OkVtQnVmKHVuc2lnbmVkIGludCmNBmdlbXNjcmlwdGVuOjppbnRlcm5hbDo6SW52b2tlcjxFbUJ1ZiosIHVuc2lnbmVkIGludCYmPjo6aW52b2tlKEVtQnVmKiAoKikodW5zaWduZWQgaW50JiYpLCB1bnNpZ25lZCBpbnQpjgZ5ZW1zY3JpcHRlbjo6aW50ZXJuYWw6OldpdGhQb2xpY2llczxlbXNjcmlwdGVuOjphbGxvd19yYXdfcG9pbnRlcnM+OjpBcmdUeXBlTGlzdDxFbUJ1ZiosIHVuc2lnbmVkIGludCYmPjo6Z2V0Q291bnQoKSBjb25zdI8GeWVtc2NyaXB0ZW46OmludGVybmFsOjpXaXRoUG9saWNpZXM8ZW1zY3JpcHRlbjo6YWxsb3dfcmF3X3BvaW50ZXJzPjo6QXJnVHlwZUxpc3Q8RW1CdWYqLCB1bnNpZ25lZCBpbnQmJj46OmdldFR5cGVzKCkgY29uc3SQBlNlbXNjcmlwdGVuOjppbnRlcm5hbDo6QmluZGluZ1R5cGU8dW5zaWduZWQgaW50JiYsIHZvaWQ+Ojpmcm9tV2lyZVR5cGUodW5zaWduZWQgaW50KZEGQ2Vtc2NyaXB0ZW46OmludGVybmFsOjpCaW5kaW5nVHlwZTxFbUJ1ZiosIHZvaWQ+Ojp0b1dpcmVUeXBlKEVtQnVmKimSBowBZW1zY3JpcHRlbjo6aW50ZXJuYWw6OkFyZ0FycmF5R2V0dGVyPGVtc2NyaXB0ZW46OmludGVybmFsOjpUeXBlTGlzdDxlbXNjcmlwdGVuOjppbnRlcm5hbDo6QWxsb3dlZFJhd1BvaW50ZXI8RW1CdWY+LCB1bnNpZ25lZCBpbnQmJj4gPjo6Z2V0KCmTBlFlbXNjcmlwdGVuOjppbnRlcm5hbDo6QmluZGluZ1R5cGU8dW5zaWduZWQgaW50LCB2b2lkPjo6ZnJvbVdpcmVUeXBlKHVuc2lnbmVkIGludCmUBp4BZW1zY3JpcHRlbjo6aW50ZXJuYWw6Ok1ldGhvZEludm9rZXI8dW5zaWduZWQgaW50IChFbUJ1Zjo6KikoKSBjb25zdCwgdW5zaWduZWQgaW50LCBFbUJ1ZiBjb25zdCo+OjppbnZva2UodW5zaWduZWQgaW50IChFbUJ1Zjo6KiBjb25zdCYpKCkgY29uc3QsIEVtQnVmIGNvbnN0KimVBogBZW1zY3JpcHRlbjo6aW50ZXJuYWw6OldpdGhQb2xpY2llczw+OjpBcmdUeXBlTGlzdDx1bnNpZ25lZCBpbnQsIGVtc2NyaXB0ZW46OmludGVybmFsOjpBbGxvd2VkUmF3UG9pbnRlcjxFbUJ1ZiBjb25zdD4gPjo6Z2V0Q291bnQoKSBjb25zdJYGiAFlbXNjcmlwdGVuOjppbnRlcm5hbDo6V2l0aFBvbGljaWVzPD46OkFyZ1R5cGVMaXN0PHVuc2lnbmVkIGludCwgZW1zY3JpcHRlbjo6aW50ZXJuYWw6OkFsbG93ZWRSYXdQb2ludGVyPEVtQnVmIGNvbnN0PiA+OjpnZXRUeXBlcygpIGNvbnN0lwaJAXVuc2lnbmVkIGludCAoRW1CdWY6OioqZW1zY3JpcHRlbjo6aW50ZXJuYWw6OmdldENvbnRleHQ8dW5zaWduZWQgaW50IChFbUJ1Zjo6KikoKSBjb25zdD4odW5zaWduZWQgaW50IChFbUJ1Zjo6KiBjb25zdCYpKCkgY29uc3QpKSgpIGNvbnN0mAZRZW1zY3JpcHRlbjo6aW50ZXJuYWw6OkJpbmRpbmdUeXBlPEVtQnVmIGNvbnN0Kiwgdm9pZD46OmZyb21XaXJlVHlwZShFbUJ1ZiBjb25zdCopmQaRAWVtc2NyaXB0ZW46OmludGVybmFsOjpBcmdBcnJheUdldHRlcjxlbXNjcmlwdGVuOjppbnRlcm5hbDo6VHlwZUxpc3Q8dW5zaWduZWQgaW50LCBlbXNjcmlwdGVuOjppbnRlcm5hbDo6QWxsb3dlZFJhd1BvaW50ZXI8RW1CdWYgY29uc3Q+ID4gPjo6Z2V0KCmaBo8BZW1zY3JpcHRlbjo6aW50ZXJuYWw6Ok1ldGhvZEludm9rZXI8ZW1zY3JpcHRlbjo6dmFsIChFbUJ1Zjo6KikoKSwgZW1zY3JpcHRlbjo6dmFsLCBFbUJ1Zio+OjppbnZva2UoZW1zY3JpcHRlbjo6dmFsIChFbUJ1Zjo6KiBjb25zdCYpKCksIEVtQnVmKimbBoUBZW1zY3JpcHRlbjo6aW50ZXJuYWw6OldpdGhQb2xpY2llczw+OjpBcmdUeXBlTGlzdDxlbXNjcmlwdGVuOjp2YWwsIGVtc2NyaXB0ZW46OmludGVybmFsOjpBbGxvd2VkUmF3UG9pbnRlcjxFbUJ1Zj4gPjo6Z2V0Q291bnQoKSBjb25zdJwGhQFlbXNjcmlwdGVuOjppbnRlcm5hbDo6V2l0aFBvbGljaWVzPD46OkFyZ1R5cGVMaXN0PGVtc2NyaXB0ZW46OnZhbCwgZW1zY3JpcHRlbjo6aW50ZXJuYWw6OkFsbG93ZWRSYXdQb2ludGVyPEVtQnVmPiA+OjpnZXRUeXBlcygpIGNvbnN0nQaAAWVtc2NyaXB0ZW46OnZhbCAoRW1CdWY6OioqZW1zY3JpcHRlbjo6aW50ZXJuYWw6OmdldENvbnRleHQ8ZW1zY3JpcHRlbjo6dmFsIChFbUJ1Zjo6KikoKT4oZW1zY3JpcHRlbjo6dmFsIChFbUJ1Zjo6KiBjb25zdCYpKCkpKSgpngZFZW1zY3JpcHRlbjo6aW50ZXJuYWw6OkJpbmRpbmdUeXBlPEVtQnVmKiwgdm9pZD46OmZyb21XaXJlVHlwZShFbUJ1ZiopnwZcZW1zY3JpcHRlbjo6aW50ZXJuYWw6OkJpbmRpbmdUeXBlPGVtc2NyaXB0ZW46OnZhbCwgdm9pZD46OnRvV2lyZVR5cGUoZW1zY3JpcHRlbjo6dmFsIGNvbnN0JimgBo4BZW1zY3JpcHRlbjo6aW50ZXJuYWw6OkFyZ0FycmF5R2V0dGVyPGVtc2NyaXB0ZW46OmludGVybmFsOjpUeXBlTGlzdDxlbXNjcmlwdGVuOjp2YWwsIGVtc2NyaXB0ZW46OmludGVybmFsOjpBbGxvd2VkUmF3UG9pbnRlcjxFbUJ1Zj4gPiA+OjpnZXQoKaEGRXZvaWQgY29uc3QqIGVtc2NyaXB0ZW46OmludGVybmFsOjpnZXRMaWdodFR5cGVJRDxFbVB0cj4oRW1QdHIgY29uc3QmKaIGL2Vtc2NyaXB0ZW46OmludGVybmFsOjpMaWdodFR5cGVJRDxFbVB0cj46OmdldCgpowYwZW1zY3JpcHRlbjo6aW50ZXJuYWw6OkxpZ2h0VHlwZUlEPEVtUHRyKj46OmdldCgppAY2ZW1zY3JpcHRlbjo6aW50ZXJuYWw6OkxpZ2h0VHlwZUlEPEVtUHRyIGNvbnN0Kj46OmdldCgppQY7ZW1zY3JpcHRlbjo6aW50ZXJuYWw6Okludm9rZXI8RW1QdHIqPjo6aW52b2tlKEVtUHRyKiAoKikoKSmmBmllbXNjcmlwdGVuOjppbnRlcm5hbDo6V2l0aFBvbGljaWVzPGVtc2NyaXB0ZW46OmFsbG93X3Jhd19wb2ludGVycz46OkFyZ1R5cGVMaXN0PEVtUHRyKj46OmdldENvdW50KCkgY29uc3SnBmllbXNjcmlwdGVuOjppbnRlcm5hbDo6V2l0aFBvbGljaWVzPGVtc2NyaXB0ZW46OmFsbG93X3Jhd19wb2ludGVycz46OkFyZ1R5cGVMaXN0PEVtUHRyKj46OmdldFR5cGVzKCkgY29uc3SoBkNlbXNjcmlwdGVuOjppbnRlcm5hbDo6QmluZGluZ1R5cGU8RW1QdHIqLCB2b2lkPjo6dG9XaXJlVHlwZShFbVB0ciopqQZ9ZW1zY3JpcHRlbjo6aW50ZXJuYWw6OkFyZ0FycmF5R2V0dGVyPGVtc2NyaXB0ZW46OmludGVybmFsOjpUeXBlTGlzdDxlbXNjcmlwdGVuOjppbnRlcm5hbDo6QWxsb3dlZFJhd1BvaW50ZXI8RW1QdHI+ID4gPjo6Z2V0KCmqBqEBZW1zY3JpcHRlbjo6aW50ZXJuYWw6Ok1ldGhvZEludm9rZXI8dW5zaWduZWQgbG9uZyAoRW1QdHI6OiopKCkgY29uc3QsIHVuc2lnbmVkIGxvbmcsIEVtUHRyIGNvbnN0Kj46Omludm9rZSh1bnNpZ25lZCBsb25nIChFbVB0cjo6KiBjb25zdCYpKCkgY29uc3QsIEVtUHRyIGNvbnN0KimrBokBZW1zY3JpcHRlbjo6aW50ZXJuYWw6OldpdGhQb2xpY2llczw+OjpBcmdUeXBlTGlzdDx1bnNpZ25lZCBsb25nLCBlbXNjcmlwdGVuOjppbnRlcm5hbDo6QWxsb3dlZFJhd1BvaW50ZXI8RW1QdHIgY29uc3Q+ID46OmdldENvdW50KCkgY29uc3SsBokBZW1zY3JpcHRlbjo6aW50ZXJuYWw6OldpdGhQb2xpY2llczw+OjpBcmdUeXBlTGlzdDx1bnNpZ25lZCBsb25nLCBlbXNjcmlwdGVuOjppbnRlcm5hbDo6QWxsb3dlZFJhd1BvaW50ZXI8RW1QdHIgY29uc3Q+ID46OmdldFR5cGVzKCkgY29uc3StBowBdW5zaWduZWQgbG9uZyAoRW1QdHI6OioqZW1zY3JpcHRlbjo6aW50ZXJuYWw6OmdldENvbnRleHQ8dW5zaWduZWQgbG9uZyAoRW1QdHI6OiopKCkgY29uc3Q+KHVuc2lnbmVkIGxvbmcgKEVtUHRyOjoqIGNvbnN0JikoKSBjb25zdCkpKCkgY29uc3SuBlFlbXNjcmlwdGVuOjppbnRlcm5hbDo6QmluZGluZ1R5cGU8RW1QdHIgY29uc3QqLCB2b2lkPjo6ZnJvbVdpcmVUeXBlKEVtUHRyIGNvbnN0KimvBlhlbXNjcmlwdGVuOjppbnRlcm5hbDo6QmluZGluZ1R5cGU8dW5zaWduZWQgbG9uZywgdm9pZD46OnRvV2lyZVR5cGUodW5zaWduZWQgbG9uZyBjb25zdCYpsAaSAWVtc2NyaXB0ZW46OmludGVybmFsOjpBcmdBcnJheUdldHRlcjxlbXNjcmlwdGVuOjppbnRlcm5hbDo6VHlwZUxpc3Q8dW5zaWduZWQgbG9uZywgZW1zY3JpcHRlbjo6aW50ZXJuYWw6OkFsbG93ZWRSYXdQb2ludGVyPEVtUHRyIGNvbnN0PiA+ID46OmdldCgpsQaGAWVtc2NyaXB0ZW46OmludGVybmFsOjpNZXRob2RJbnZva2VyPGJvb2wgKEVtUHRyOjoqKSgpIGNvbnN0LCBib29sLCBFbVB0ciBjb25zdCo+OjppbnZva2UoYm9vbCAoRW1QdHI6OiogY29uc3QmKSgpIGNvbnN0LCBFbVB0ciBjb25zdCopsgaAAWVtc2NyaXB0ZW46OmludGVybmFsOjpXaXRoUG9saWNpZXM8Pjo6QXJnVHlwZUxpc3Q8Ym9vbCwgZW1zY3JpcHRlbjo6aW50ZXJuYWw6OkFsbG93ZWRSYXdQb2ludGVyPEVtUHRyIGNvbnN0PiA+OjpnZXRDb3VudCgpIGNvbnN0swaAAWVtc2NyaXB0ZW46OmludGVybmFsOjpXaXRoUG9saWNpZXM8Pjo6QXJnVHlwZUxpc3Q8Ym9vbCwgZW1zY3JpcHRlbjo6aW50ZXJuYWw6OkFsbG93ZWRSYXdQb2ludGVyPEVtUHRyIGNvbnN0PiA+OjpnZXRUeXBlcygpIGNvbnN0tAZxYm9vbCAoRW1QdHI6OioqZW1zY3JpcHRlbjo6aW50ZXJuYWw6OmdldENvbnRleHQ8Ym9vbCAoRW1QdHI6OiopKCkgY29uc3Q+KGJvb2wgKEVtUHRyOjoqIGNvbnN0JikoKSBjb25zdCkpKCkgY29uc3S1Bj9lbXNjcmlwdGVuOjppbnRlcm5hbDo6QmluZGluZ1R5cGU8Ym9vbCwgdm9pZD46OnRvV2lyZVR5cGUoYm9vbCm2BokBZW1zY3JpcHRlbjo6aW50ZXJuYWw6OkFyZ0FycmF5R2V0dGVyPGVtc2NyaXB0ZW46OmludGVybmFsOjpUeXBlTGlzdDxib29sLCBlbXNjcmlwdGVuOjppbnRlcm5hbDo6QWxsb3dlZFJhd1BvaW50ZXI8RW1QdHIgY29uc3Q+ID4gPjo6Z2V0KCm3BkV2b2lkIGNvbnN0KiBlbXNjcmlwdGVuOjppbnRlcm5hbDo6Z2V0TGlnaHRUeXBlSUQ8RW1TdHI+KEVtU3RyIGNvbnN0Jim4Bg9FbVN0cjo6fkVtU3RyKCm5Bi9lbXNjcmlwdGVuOjppbnRlcm5hbDo6TGlnaHRUeXBlSUQ8RW1TdHI+OjpnZXQoKboGMGVtc2NyaXB0ZW46OmludGVybmFsOjpMaWdodFR5cGVJRDxFbVN0cio+OjpnZXQoKbsGNmVtc2NyaXB0ZW46OmludGVybmFsOjpMaWdodFR5cGVJRDxFbVN0ciBjb25zdCo+OjpnZXQoKbwGGkVtU3RyOjpFbVN0cih1bnNpZ25lZCBpbnQpvQZnZW1zY3JpcHRlbjo6aW50ZXJuYWw6Okludm9rZXI8RW1TdHIqLCB1bnNpZ25lZCBpbnQmJj46Omludm9rZShFbVN0ciogKCopKHVuc2lnbmVkIGludCYmKSwgdW5zaWduZWQgaW50Kb4GeWVtc2NyaXB0ZW46OmludGVybmFsOjpXaXRoUG9saWNpZXM8ZW1zY3JpcHRlbjo6YWxsb3dfcmF3X3BvaW50ZXJzPjo6QXJnVHlwZUxpc3Q8RW1TdHIqLCB1bnNpZ25lZCBpbnQmJj46OmdldENvdW50KCkgY29uc3S/BnllbXNjcmlwdGVuOjppbnRlcm5hbDo6V2l0aFBvbGljaWVzPGVtc2NyaXB0ZW46OmFsbG93X3Jhd19wb2ludGVycz46OkFyZ1R5cGVMaXN0PEVtU3RyKiwgdW5zaWduZWQgaW50JiY+OjpnZXRUeXBlcygpIGNvbnN0wAZDZW1zY3JpcHRlbjo6aW50ZXJuYWw6OkJpbmRpbmdUeXBlPEVtU3RyKiwgdm9pZD46OnRvV2lyZVR5cGUoRW1TdHIqKcEGjAFlbXNjcmlwdGVuOjppbnRlcm5hbDo6QXJnQXJyYXlHZXR0ZXI8ZW1zY3JpcHRlbjo6aW50ZXJuYWw6OlR5cGVMaXN0PGVtc2NyaXB0ZW46OmludGVybmFsOjpBbGxvd2VkUmF3UG9pbnRlcjxFbVN0cj4sIHVuc2lnbmVkIGludCYmPiA+OjpnZXQoKcIGngFlbXNjcmlwdGVuOjppbnRlcm5hbDo6TWV0aG9kSW52b2tlcjx1bnNpZ25lZCBpbnQgKEVtU3RyOjoqKSgpIGNvbnN0LCB1bnNpZ25lZCBpbnQsIEVtU3RyIGNvbnN0Kj46Omludm9rZSh1bnNpZ25lZCBpbnQgKEVtU3RyOjoqIGNvbnN0JikoKSBjb25zdCwgRW1TdHIgY29uc3QqKcMGiAFlbXNjcmlwdGVuOjppbnRlcm5hbDo6V2l0aFBvbGljaWVzPD46OkFyZ1R5cGVMaXN0PHVuc2lnbmVkIGludCwgZW1zY3JpcHRlbjo6aW50ZXJuYWw6OkFsbG93ZWRSYXdQb2ludGVyPEVtU3RyIGNvbnN0PiA+OjpnZXRDb3VudCgpIGNvbnN0xAaIAWVtc2NyaXB0ZW46OmludGVybmFsOjpXaXRoUG9saWNpZXM8Pjo6QXJnVHlwZUxpc3Q8dW5zaWduZWQgaW50LCBlbXNjcmlwdGVuOjppbnRlcm5hbDo6QWxsb3dlZFJhd1BvaW50ZXI8RW1TdHIgY29uc3Q+ID46OmdldFR5cGVzKCkgY29uc3TFBokBdW5zaWduZWQgaW50IChFbVN0cjo6KiplbXNjcmlwdGVuOjppbnRlcm5hbDo6Z2V0Q29udGV4dDx1bnNpZ25lZCBpbnQgKEVtU3RyOjoqKSgpIGNvbnN0Pih1bnNpZ25lZCBpbnQgKEVtU3RyOjoqIGNvbnN0JikoKSBjb25zdCkpKCkgY29uc3TGBlFlbXNjcmlwdGVuOjppbnRlcm5hbDo6QmluZGluZ1R5cGU8RW1TdHIgY29uc3QqLCB2b2lkPjo6ZnJvbVdpcmVUeXBlKEVtU3RyIGNvbnN0KinHBpEBZW1zY3JpcHRlbjo6aW50ZXJuYWw6OkFyZ0FycmF5R2V0dGVyPGVtc2NyaXB0ZW46OmludGVybmFsOjpUeXBlTGlzdDx1bnNpZ25lZCBpbnQsIGVtc2NyaXB0ZW46OmludGVybmFsOjpBbGxvd2VkUmF3UG9pbnRlcjxFbVN0ciBjb25zdD4gPiA+OjpnZXQoKcgGjwFlbXNjcmlwdGVuOjppbnRlcm5hbDo6TWV0aG9kSW52b2tlcjxlbXNjcmlwdGVuOjp2YWwgKEVtU3RyOjoqKSgpLCBlbXNjcmlwdGVuOjp2YWwsIEVtU3RyKj46Omludm9rZShlbXNjcmlwdGVuOjp2YWwgKEVtU3RyOjoqIGNvbnN0JikoKSwgRW1TdHIqKckGhQFlbXNjcmlwdGVuOjppbnRlcm5hbDo6V2l0aFBvbGljaWVzPD46OkFyZ1R5cGVMaXN0PGVtc2NyaXB0ZW46OnZhbCwgZW1zY3JpcHRlbjo6aW50ZXJuYWw6OkFsbG93ZWRSYXdQb2ludGVyPEVtU3RyPiA+OjpnZXRDb3VudCgpIGNvbnN0ygaFAWVtc2NyaXB0ZW46OmludGVybmFsOjpXaXRoUG9saWNpZXM8Pjo6QXJnVHlwZUxpc3Q8ZW1zY3JpcHRlbjo6dmFsLCBlbXNjcmlwdGVuOjppbnRlcm5hbDo6QWxsb3dlZFJhd1BvaW50ZXI8RW1TdHI+ID46OmdldFR5cGVzKCkgY29uc3TLBoABZW1zY3JpcHRlbjo6dmFsIChFbVN0cjo6KiplbXNjcmlwdGVuOjppbnRlcm5hbDo6Z2V0Q29udGV4dDxlbXNjcmlwdGVuOjp2YWwgKEVtU3RyOjoqKSgpPihlbXNjcmlwdGVuOjp2YWwgKEVtU3RyOjoqIGNvbnN0JikoKSkpKCnMBkVlbXNjcmlwdGVuOjppbnRlcm5hbDo6QmluZGluZ1R5cGU8RW1TdHIqLCB2b2lkPjo6ZnJvbVdpcmVUeXBlKEVtU3RyKinNBo4BZW1zY3JpcHRlbjo6aW50ZXJuYWw6OkFyZ0FycmF5R2V0dGVyPGVtc2NyaXB0ZW46OmludGVybmFsOjpUeXBlTGlzdDxlbXNjcmlwdGVuOjp2YWwsIGVtc2NyaXB0ZW46OmludGVybmFsOjpBbGxvd2VkUmF3UG9pbnRlcjxFbVN0cj4gPiA+OjpnZXQoKc4GTXZvaWQgY29uc3QqIGVtc2NyaXB0ZW46OmludGVybmFsOjpnZXRMaWdodFR5cGVJRDxFbVZvaWRQdHI+KEVtVm9pZFB0ciBjb25zdCYpzwZMRW1QdHIqIGVtc2NyaXB0ZW46OmJhc2U8RW1QdHI+Ojpjb252ZXJ0UG9pbnRlcjxFbVZvaWRQdHIsIEVtUHRyPihFbVZvaWRQdHIqKdAGTEVtVm9pZFB0ciogZW1zY3JpcHRlbjo6YmFzZTxFbVB0cj46OmNvbnZlcnRQb2ludGVyPEVtUHRyLCBFbVZvaWRQdHI+KEVtUHRyKinRBjNlbXNjcmlwdGVuOjppbnRlcm5hbDo6TGlnaHRUeXBlSUQ8RW1Wb2lkUHRyPjo6Z2V0KCnSBjRlbXNjcmlwdGVuOjppbnRlcm5hbDo6TGlnaHRUeXBlSUQ8RW1Wb2lkUHRyKj46OmdldCgp0wY6ZW1zY3JpcHRlbjo6aW50ZXJuYWw6OkxpZ2h0VHlwZUlEPEVtVm9pZFB0ciBjb25zdCo+OjpnZXQoKdQGFkVtVm9pZFB0cjo6RW1Wb2lkUHRyKCnVBkNlbXNjcmlwdGVuOjppbnRlcm5hbDo6SW52b2tlcjxFbVZvaWRQdHIqPjo6aW52b2tlKEVtVm9pZFB0ciogKCopKCkp1gZtZW1zY3JpcHRlbjo6aW50ZXJuYWw6OldpdGhQb2xpY2llczxlbXNjcmlwdGVuOjphbGxvd19yYXdfcG9pbnRlcnM+OjpBcmdUeXBlTGlzdDxFbVZvaWRQdHIqPjo6Z2V0Q291bnQoKSBjb25zdNcGbWVtc2NyaXB0ZW46OmludGVybmFsOjpXaXRoUG9saWNpZXM8ZW1zY3JpcHRlbjo6YWxsb3dfcmF3X3BvaW50ZXJzPjo6QXJnVHlwZUxpc3Q8RW1Wb2lkUHRyKj46OmdldFR5cGVzKCkgY29uc3TYBktlbXNjcmlwdGVuOjppbnRlcm5hbDo6QmluZGluZ1R5cGU8RW1Wb2lkUHRyKiwgdm9pZD46OnRvV2lyZVR5cGUoRW1Wb2lkUHRyKinZBoEBZW1zY3JpcHRlbjo6aW50ZXJuYWw6OkFyZ0FycmF5R2V0dGVyPGVtc2NyaXB0ZW46OmludGVybmFsOjpUeXBlTGlzdDxlbXNjcmlwdGVuOjppbnRlcm5hbDo6QWxsb3dlZFJhd1BvaW50ZXI8RW1Wb2lkUHRyPiA+ID46OmdldCgp2gZRdm9pZCBjb25zdCogZW1zY3JpcHRlbjo6aW50ZXJuYWw6OmdldExpZ2h0VHlwZUlEPEVtVWludDMyUHRyPihFbVVpbnQzMlB0ciBjb25zdCYp2wZQRW1QdHIqIGVtc2NyaXB0ZW46OmJhc2U8RW1QdHI+Ojpjb252ZXJ0UG9pbnRlcjxFbVVpbnQzMlB0ciwgRW1QdHI+KEVtVWludDMyUHRyKincBlBFbVVpbnQzMlB0ciogZW1zY3JpcHRlbjo6YmFzZTxFbVB0cj46OmNvbnZlcnRQb2ludGVyPEVtUHRyLCBFbVVpbnQzMlB0cj4oRW1QdHIqKd0GNWVtc2NyaXB0ZW46OmludGVybmFsOjpMaWdodFR5cGVJRDxFbVVpbnQzMlB0cj46OmdldCgp3gY2ZW1zY3JpcHRlbjo6aW50ZXJuYWw6OkxpZ2h0VHlwZUlEPEVtVWludDMyUHRyKj46OmdldCgp3wY8ZW1zY3JpcHRlbjo6aW50ZXJuYWw6OkxpZ2h0VHlwZUlEPEVtVWludDMyUHRyIGNvbnN0Kj46OmdldCgp4AYaRW1VaW50MzJQdHI6OkVtVWludDMyUHRyKCnhBkdlbXNjcmlwdGVuOjppbnRlcm5hbDo6SW52b2tlcjxFbVVpbnQzMlB0cio+OjppbnZva2UoRW1VaW50MzJQdHIqICgqKSgpKeIGb2Vtc2NyaXB0ZW46OmludGVybmFsOjpXaXRoUG9saWNpZXM8ZW1zY3JpcHRlbjo6YWxsb3dfcmF3X3BvaW50ZXJzPjo6QXJnVHlwZUxpc3Q8RW1VaW50MzJQdHIqPjo6Z2V0Q291bnQoKSBjb25zdOMGb2Vtc2NyaXB0ZW46OmludGVybmFsOjpXaXRoUG9saWNpZXM8ZW1zY3JpcHRlbjo6YWxsb3dfcmF3X3BvaW50ZXJzPjo6QXJnVHlwZUxpc3Q8RW1VaW50MzJQdHIqPjo6Z2V0VHlwZXMoKSBjb25zdOQGT2Vtc2NyaXB0ZW46OmludGVybmFsOjpCaW5kaW5nVHlwZTxFbVVpbnQzMlB0ciosIHZvaWQ+Ojp0b1dpcmVUeXBlKEVtVWludDMyUHRyKinlBoMBZW1zY3JpcHRlbjo6aW50ZXJuYWw6OkFyZ0FycmF5R2V0dGVyPGVtc2NyaXB0ZW46OmludGVybmFsOjpUeXBlTGlzdDxlbXNjcmlwdGVuOjppbnRlcm5hbDo6QWxsb3dlZFJhd1BvaW50ZXI8RW1VaW50MzJQdHI+ID4gPjo6Z2V0KCnmBrYBZW1zY3JpcHRlbjo6aW50ZXJuYWw6Ok1ldGhvZEludm9rZXI8dW5zaWduZWQgaW50IChFbVVpbnQzMlB0cjo6KikoKSBjb25zdCwgdW5zaWduZWQgaW50LCBFbVVpbnQzMlB0ciBjb25zdCo+OjppbnZva2UodW5zaWduZWQgaW50IChFbVVpbnQzMlB0cjo6KiBjb25zdCYpKCkgY29uc3QsIEVtVWludDMyUHRyIGNvbnN0KinnBo4BZW1zY3JpcHRlbjo6aW50ZXJuYWw6OldpdGhQb2xpY2llczw+OjpBcmdUeXBlTGlzdDx1bnNpZ25lZCBpbnQsIGVtc2NyaXB0ZW46OmludGVybmFsOjpBbGxvd2VkUmF3UG9pbnRlcjxFbVVpbnQzMlB0ciBjb25zdD4gPjo6Z2V0Q291bnQoKSBjb25zdOgGjgFlbXNjcmlwdGVuOjppbnRlcm5hbDo6V2l0aFBvbGljaWVzPD46OkFyZ1R5cGVMaXN0PHVuc2lnbmVkIGludCwgZW1zY3JpcHRlbjo6aW50ZXJuYWw6OkFsbG93ZWRSYXdQb2ludGVyPEVtVWludDMyUHRyIGNvbnN0PiA+OjpnZXRUeXBlcygpIGNvbnN06QabAXVuc2lnbmVkIGludCAoRW1VaW50MzJQdHI6OioqZW1zY3JpcHRlbjo6aW50ZXJuYWw6OmdldENvbnRleHQ8dW5zaWduZWQgaW50IChFbVVpbnQzMlB0cjo6KikoKSBjb25zdD4odW5zaWduZWQgaW50IChFbVVpbnQzMlB0cjo6KiBjb25zdCYpKCkgY29uc3QpKSgpIGNvbnN06gZdZW1zY3JpcHRlbjo6aW50ZXJuYWw6OkJpbmRpbmdUeXBlPEVtVWludDMyUHRyIGNvbnN0Kiwgdm9pZD46OmZyb21XaXJlVHlwZShFbVVpbnQzMlB0ciBjb25zdCop6waXAWVtc2NyaXB0ZW46OmludGVybmFsOjpBcmdBcnJheUdldHRlcjxlbXNjcmlwdGVuOjppbnRlcm5hbDo6VHlwZUxpc3Q8dW5zaWduZWQgaW50LCBlbXNjcmlwdGVuOjppbnRlcm5hbDo6QWxsb3dlZFJhd1BvaW50ZXI8RW1VaW50MzJQdHIgY29uc3Q+ID4gPjo6Z2V0KCnsBlt2b2lkIGNvbnN0KiBlbXNjcmlwdGVuOjppbnRlcm5hbDo6Z2V0TGlnaHRUeXBlSUQ8X1NGSUxFX0ZJTkRfREFUQT4oX1NGSUxFX0ZJTkRfREFUQSBjb25zdCYp7QY6ZW1zY3JpcHRlbjo6aW50ZXJuYWw6OkxpZ2h0VHlwZUlEPF9TRklMRV9GSU5EX0RBVEE+OjpnZXQoKe4GO2Vtc2NyaXB0ZW46OmludGVybmFsOjpMaWdodFR5cGVJRDxfU0ZJTEVfRklORF9EQVRBKj46OmdldCgp7wZBZW1zY3JpcHRlbjo6aW50ZXJuYWw6OkxpZ2h0VHlwZUlEPF9TRklMRV9GSU5EX0RBVEEgY29uc3QqPjo6Z2V0KCnwBlFlbXNjcmlwdGVuOjppbnRlcm5hbDo6SW52b2tlcjxfU0ZJTEVfRklORF9EQVRBKj46Omludm9rZShfU0ZJTEVfRklORF9EQVRBKiAoKikoKSnxBnRlbXNjcmlwdGVuOjppbnRlcm5hbDo6V2l0aFBvbGljaWVzPGVtc2NyaXB0ZW46OmFsbG93X3Jhd19wb2ludGVycz46OkFyZ1R5cGVMaXN0PF9TRklMRV9GSU5EX0RBVEEqPjo6Z2V0Q291bnQoKSBjb25zdPIGdGVtc2NyaXB0ZW46OmludGVybmFsOjpXaXRoUG9saWNpZXM8ZW1zY3JpcHRlbjo6YWxsb3dfcmF3X3BvaW50ZXJzPjo6QXJnVHlwZUxpc3Q8X1NGSUxFX0ZJTkRfREFUQSo+OjpnZXRUeXBlcygpIGNvbnN08wZZZW1zY3JpcHRlbjo6aW50ZXJuYWw6OkJpbmRpbmdUeXBlPF9TRklMRV9GSU5EX0RBVEEqLCB2b2lkPjo6dG9XaXJlVHlwZShfU0ZJTEVfRklORF9EQVRBKin0BogBZW1zY3JpcHRlbjo6aW50ZXJuYWw6OkFyZ0FycmF5R2V0dGVyPGVtc2NyaXB0ZW46OmludGVybmFsOjpUeXBlTGlzdDxlbXNjcmlwdGVuOjppbnRlcm5hbDo6QWxsb3dlZFJhd1BvaW50ZXI8X1NGSUxFX0ZJTkRfREFUQT4gPiA+OjpnZXQoKfUGggNzdGQ6Ol9fMjo6YmFzaWNfc3RyaW5nPGNoYXIsIHN0ZDo6X18yOjpjaGFyX3RyYWl0czxjaGFyPiwgc3RkOjpfXzI6OmFsbG9jYXRvcjxjaGFyPiA+ICgqKmVtc2NyaXB0ZW46OmludGVybmFsOjpnZXRDb250ZXh0PHN0ZDo6X18yOjpiYXNpY19zdHJpbmc8Y2hhciwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPGNoYXI+LCBzdGQ6Ol9fMjo6YWxsb2NhdG9yPGNoYXI+ID4gKCopKF9TRklMRV9GSU5EX0RBVEEgY29uc3QmKT4oc3RkOjpfXzI6OmJhc2ljX3N0cmluZzxjaGFyLCBzdGQ6Ol9fMjo6Y2hhcl90cmFpdHM8Y2hhcj4sIHN0ZDo6X18yOjphbGxvY2F0b3I8Y2hhcj4gPiAoKiBjb25zdCYpKF9TRklMRV9GSU5EX0RBVEEgY29uc3QmKSkpKF9TRklMRV9GSU5EX0RBVEEgY29uc3QmKfYGNmVtc2NyaXB0ZW46OmludGVybmFsOjpMaWdodFR5cGVJRDx1bnNpZ25lZCBpbnQ+OjpnZXQoKfcGxwFlbXNjcmlwdGVuOjppbnRlcm5hbDo6RnVuY3Rpb25JbnZva2VyPGVtc2NyaXB0ZW46OnZhbCAoKikoX1NGSUxFX0ZJTkRfREFUQSBjb25zdCYpLCBlbXNjcmlwdGVuOjp2YWwsIF9TRklMRV9GSU5EX0RBVEEgY29uc3QmPjo6aW52b2tlKGVtc2NyaXB0ZW46OnZhbCAoKiopKF9TRklMRV9GSU5EX0RBVEEgY29uc3QmKSwgX1NGSUxFX0ZJTkRfREFUQSop+AZtZW1zY3JpcHRlbjo6aW50ZXJuYWw6OldpdGhQb2xpY2llczw+OjpBcmdUeXBlTGlzdDxlbXNjcmlwdGVuOjp2YWwsIF9TRklMRV9GSU5EX0RBVEEgY29uc3QmPjo6Z2V0Q291bnQoKSBjb25zdPkGbWVtc2NyaXB0ZW46OmludGVybmFsOjpXaXRoUG9saWNpZXM8Pjo6QXJnVHlwZUxpc3Q8ZW1zY3JpcHRlbjo6dmFsLCBfU0ZJTEVfRklORF9EQVRBIGNvbnN0Jj46OmdldFR5cGVzKCkgY29uc3T6BrABZW1zY3JpcHRlbjo6dmFsICgqKmVtc2NyaXB0ZW46OmludGVybmFsOjpnZXRDb250ZXh0PGVtc2NyaXB0ZW46OnZhbCAoKikoX1NGSUxFX0ZJTkRfREFUQSBjb25zdCYpPihlbXNjcmlwdGVuOjp2YWwgKCogY29uc3QmKShfU0ZJTEVfRklORF9EQVRBIGNvbnN0JikpKShfU0ZJTEVfRklORF9EQVRBIGNvbnN0Jin7BltlbXNjcmlwdGVuOjppbnRlcm5hbDo6R2VuZXJpY0JpbmRpbmdUeXBlPF9TRklMRV9GSU5EX0RBVEE+Ojpmcm9tV2lyZVR5cGUoX1NGSUxFX0ZJTkRfREFUQSop/AZ2ZW1zY3JpcHRlbjo6aW50ZXJuYWw6OkFyZ0FycmF5R2V0dGVyPGVtc2NyaXB0ZW46OmludGVybmFsOjpUeXBlTGlzdDxlbXNjcmlwdGVuOjp2YWwsIF9TRklMRV9GSU5EX0RBVEEgY29uc3QmPiA+OjpnZXQoKf0GWmVtc2NyaXB0ZW46OmludGVybmFsOjpBcmdBcnJheUdldHRlcjxlbXNjcmlwdGVuOjppbnRlcm5hbDo6VHlwZUxpc3Q8dW5zaWduZWQgaW50PiA+OjpnZXQoKf4GRWVtc2NyaXB0ZW46OmludGVybmFsOjpHZW5lcmljQmluZGluZ1R5cGU8RW1QdHI+Ojpmcm9tV2lyZVR5cGUoRW1QdHIqKf8GWmVtc2NyaXB0ZW46OmludGVybmFsOjpBcmdBcnJheUdldHRlcjxlbXNjcmlwdGVuOjppbnRlcm5hbDo6VHlwZUxpc3Q8Ym9vbCwgRW1QdHImPiA+OjpnZXQoKYAHmAJlbXNjcmlwdGVuOjppbnRlcm5hbDo6QmluZGluZ1R5cGU8c3RkOjpfXzI6OmJhc2ljX3N0cmluZzxjaGFyLCBzdGQ6Ol9fMjo6Y2hhcl90cmFpdHM8Y2hhcj4sIHN0ZDo6X18yOjphbGxvY2F0b3I8Y2hhcj4gPiwgdm9pZD46OmZyb21XaXJlVHlwZShlbXNjcmlwdGVuOjppbnRlcm5hbDo6QmluZGluZ1R5cGU8c3RkOjpfXzI6OmJhc2ljX3N0cmluZzxjaGFyLCBzdGQ6Ol9fMjo6Y2hhcl90cmFpdHM8Y2hhcj4sIHN0ZDo6X18yOjphbGxvY2F0b3I8Y2hhcj4gPiwgdm9pZD46Oid1bm5hbWVkJyopgQdEZW1zY3JpcHRlbjo6aW50ZXJuYWw6OkdlbmVyaWNCaW5kaW5nVHlwZTxFbVB0cj46OnRvV2lyZVR5cGUoRW1QdHImJimCB6oCZW1zY3JpcHRlbjo6aW50ZXJuYWw6OkFyZ0FycmF5R2V0dGVyPGVtc2NyaXB0ZW46OmludGVybmFsOjpUeXBlTGlzdDxFbVB0ciwgRW1QdHImLCBzdGQ6Ol9fMjo6YmFzaWNfc3RyaW5nPGNoYXIsIHN0ZDo6X18yOjpjaGFyX3RyYWl0czxjaGFyPiwgc3RkOjpfXzI6OmFsbG9jYXRvcjxjaGFyPiA+IGNvbnN0JiwgX1NGSUxFX0ZJTkRfREFUQSYsIHN0ZDo6X18yOjpiYXNpY19zdHJpbmc8Y2hhciwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPGNoYXI+LCBzdGQ6Ol9fMjo6YWxsb2NhdG9yPGNoYXI+ID4gY29uc3QmPiA+OjpnZXQoKYMHSkVtUHRyJiYgc3RkOjpfXzI6OmZvcndhcmQ8RW1QdHI+KHN0ZDo6X18yOjpyZW1vdmVfcmVmZXJlbmNlPEVtUHRyPjo6dHlwZSYphAd/c3RkOjpfXzI6OmJhc2ljX3N0cmluZzxjaGFyLCBzdGQ6Ol9fMjo6Y2hhcl90cmFpdHM8Y2hhcj4sIHN0ZDo6X18yOjphbGxvY2F0b3I8Y2hhcj4gPjo6YmFzaWNfc3RyaW5nKGNoYXIgY29uc3QqLCB1bnNpZ25lZCBsb25nKYUHbWVtc2NyaXB0ZW46OmludGVybmFsOjpBcmdBcnJheUdldHRlcjxlbXNjcmlwdGVuOjppbnRlcm5hbDo6VHlwZUxpc3Q8Ym9vbCwgRW1QdHImLCBfU0ZJTEVfRklORF9EQVRBJj4gPjo6Z2V0KCmGB0VlbXNjcmlwdGVuOjppbnRlcm5hbDo6R2VuZXJpY0JpbmRpbmdUeXBlPEVtU3RyPjo6ZnJvbVdpcmVUeXBlKEVtU3RyKimHB2JlbXNjcmlwdGVuOjppbnRlcm5hbDo6QXJnQXJyYXlHZXR0ZXI8ZW1zY3JpcHRlbjo6aW50ZXJuYWw6OlR5cGVMaXN0PGJvb2wsIEVtUHRyJiwgRW1TdHImPiA+OjpnZXQoKYgHamVtc2NyaXB0ZW46OmludGVybmFsOjpBcmdBcnJheUdldHRlcjxlbXNjcmlwdGVuOjppbnRlcm5hbDo6VHlwZUxpc3Q8dW5zaWduZWQgaW50LCBFbVB0ciYsIEVtUHRyJj4gPjo6Z2V0KCmJB7gBZW1zY3JpcHRlbjo6aW50ZXJuYWw6OkFyZ0FycmF5R2V0dGVyPGVtc2NyaXB0ZW46OmludGVybmFsOjpUeXBlTGlzdDxib29sLCBFbVB0ciYsIHN0ZDo6X18yOjpiYXNpY19zdHJpbmc8Y2hhciwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPGNoYXI+LCBzdGQ6Ol9fMjo6YWxsb2NhdG9yPGNoYXI+ID4gY29uc3QmPiA+OjpnZXQoKYoH1AFlbXNjcmlwdGVuOjppbnRlcm5hbDo6QXJnQXJyYXlHZXR0ZXI8ZW1zY3JpcHRlbjo6aW50ZXJuYWw6OlR5cGVMaXN0PGJvb2wsIHN0ZDo6X18yOjpiYXNpY19zdHJpbmc8Y2hhciwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPGNoYXI+LCBzdGQ6Ol9fMjo6YWxsb2NhdG9yPGNoYXI+ID4gY29uc3QmLCB1bnNpZ25lZCBpbnQsIHVuc2lnbmVkIGludCwgRW1QdHImPiA+OjpnZXQoKYsHpAJlbXNjcmlwdGVuOjppbnRlcm5hbDo6QXJnQXJyYXlHZXR0ZXI8ZW1zY3JpcHRlbjo6aW50ZXJuYWw6OlR5cGVMaXN0PGJvb2wsIEVtUHRyJiwgc3RkOjpfXzI6OmJhc2ljX3N0cmluZzxjaGFyLCBzdGQ6Ol9fMjo6Y2hhcl90cmFpdHM8Y2hhcj4sIHN0ZDo6X18yOjphbGxvY2F0b3I8Y2hhcj4gPiBjb25zdCYsIHN0ZDo6X18yOjpiYXNpY19zdHJpbmc8Y2hhciwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPGNoYXI+LCBzdGQ6Ol9fMjo6YWxsb2NhdG9yPGNoYXI+ID4gY29uc3QmLCB1bnNpZ25lZCBpbnQ+ID46OmdldCgpjAfOAWVtc2NyaXB0ZW46OmludGVybmFsOjpBcmdBcnJheUdldHRlcjxlbXNjcmlwdGVuOjppbnRlcm5hbDo6VHlwZUxpc3Q8Ym9vbCwgRW1QdHImLCBzdGQ6Ol9fMjo6YmFzaWNfc3RyaW5nPGNoYXIsIHN0ZDo6X18yOjpjaGFyX3RyYWl0czxjaGFyPiwgc3RkOjpfXzI6OmFsbG9jYXRvcjxjaGFyPiA+IGNvbnN0JiwgdW5zaWduZWQgaW50LCBFbVB0ciY+ID46OmdldCgpjQdFZW1zY3JpcHRlbjo6aW50ZXJuYWw6OkdlbmVyaWNCaW5kaW5nVHlwZTxFbUJ1Zj46OmZyb21XaXJlVHlwZShFbUJ1ZiopjgeAAWVtc2NyaXB0ZW46OmludGVybmFsOjpBcmdBcnJheUdldHRlcjxlbXNjcmlwdGVuOjppbnRlcm5hbDo6VHlwZUxpc3Q8Ym9vbCwgRW1QdHImLCBFbUJ1ZiYsIHVuc2lnbmVkIGludCwgRW1QdHImLCBFbVB0ciY+ID46OmdldCgpjweGAWVtc2NyaXB0ZW46OmludGVybmFsOjpBcmdBcnJheUdldHRlcjxlbXNjcmlwdGVuOjppbnRlcm5hbDo6VHlwZUxpc3Q8dW5zaWduZWQgaW50LCBFbVB0ciYsIHVuc2lnbmVkIGludCwgRW1QdHImLCB1bnNpZ25lZCBpbnQ+ID46OmdldCgpkAc0ZW1zY3JpcHRlbjo6aW50ZXJuYWw6OkxpZ2h0VHlwZUlEPGludCBjb25zdCY+OjpnZXQoKZEHHV9HTE9CQUxfX3N1Yl9JX0VtU3Rvcm1MaWIuY3BwkgcHaXNsb3dlcpMHB3RvdXBwZXKUBxBfX2Vycm5vX2xvY2F0aW9ulQcEb3BlbpYHDV9fc3lzY2FsbF9yZXSXBwVkdW1teZgHBl9fbW1hcJkHCF9fbXVubWFwmgcMX19wcm9jZmRuYW1lmwcFZnN0YXScBwZmZmx1c2idBxFfX2ZmbHVzaF91bmxvY2tlZJ4HDF9fc3RkaW9fc2Vla58HDV9fc3RkaW9fd3JpdGWgBwdkdW1teS4xoQcNX19zdGRpb19jbG9zZaIHCGZpcHJpbnRmowcPX19zbWFsbF9mcHJpbnRmpAcFZnB1dGOlBwpfX29mbF9sb2NrpgcMX19vZmxfdW5sb2NrpwcIc2lwcmludGaoBxlfX2Vtc2NyaXB0ZW5fc3Rkb3V0X2Nsb3NlqQcYX19lbXNjcmlwdGVuX3N0ZG91dF9zZWVrqgcHaXNkaWdpdKsHDHB0aHJlYWRfc2VsZqwHB3djcnRvbWKtBw5fX3B0aHJlYWRfc2VsZq4HBndjdG9tYq8HBWZyZXhwsAcTX192ZnByaW50Zl9pbnRlcm5hbLEHC3ByaW50Zl9jb3JlsgcDb3V0swcGZ2V0aW50tAcHcG9wX2FyZ7UHA3BhZLYHBWZtdF9vtwcFZm10X3i4BwVmbXRfdbkHCHZmcHJpbnRmugcGZm10X2ZwuwcTcG9wX2FyZ19sb25nX2RvdWJsZbwHDV9fRE9VQkxFX0JJVFO9Bwl2ZmlwcmludGa+BxBfX3NtYWxsX3ZmcHJpbnRmvwcJdnNucHJpbnRmwAcIc25fd3JpdGXBBwp2c25pcHJpbnRmwgcJdnNpcHJpbnRmwwcFcXNvcnTEBwRzaWZ0xQcDc2hyxgcHdHJpbmtsZccHA3NobMgHBHBudHrJBwVjeWNsZcoHBm1lbWNocssHBm1lbWNtcMwHB2lzdXBwZXLNBwd0b2xvd2VyzgcKc3RyY2FzZWNtcM8HBnN0cmNoctAHC19fc3RyY2hybnVs0QcGc3RyY21w0gcIX19zdHBjcHnTBwZzdHJjcHnUBwtzdHJuY2FzZWNtcNUHBWNsb3Nl1gcJZnRydW5jYXRl1wcFbHNlZWvYBwRyZWFk2QcFd3JpdGXaBwZfX2xvY2vbBwhfX3VubG9ja9wHEl9fd2FzaV9zeXNjYWxsX3JldN0HEl9fd2FzaV9mZF9pc192YWxpZN4HCV9fYXNobHRpM98HCV9fbHNocnRpM+AHDF9fdHJ1bmN0ZmRmMuEHG29wZXJhdG9yIG5ldyh1bnNpZ25lZCBsb25nKeIHHW9wZXJhdG9yIG5ld1tdKHVuc2lnbmVkIGxvbmcp4wcWb3BlcmF0b3IgZGVsZXRlKHZvaWQqKeQHCHNucHJpbnRm5QdDc3RkOjpfXzI6Ol9fYmFzaWNfc3RyaW5nX2NvbW1vbjx0cnVlPjo6X190aHJvd19sZW5ndGhfZXJyb3IoKSBjb25zdOYHK3N0ZDo6X18yOjpfX3Rocm93X2xlbmd0aF9lcnJvcihjaGFyIGNvbnN0KinnB2ZzdGQ6Ol9fMjo6YmFzaWNfc3RyaW5nPGNoYXIsIHN0ZDo6X18yOjpjaGFyX3RyYWl0czxjaGFyPiwgc3RkOjpfXzI6OmFsbG9jYXRvcjxjaGFyPiA+OjpfX2FsbG9jKCkgY29uc3ToB54Bc3RkOjpfXzI6Ol9fY29tcHJlc3NlZF9wYWlyPHN0ZDo6X18yOjpiYXNpY19zdHJpbmc8Y2hhciwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPGNoYXI+LCBzdGQ6Ol9fMjo6YWxsb2NhdG9yPGNoYXI+ID46Ol9fcmVwLCBzdGQ6Ol9fMjo6YWxsb2NhdG9yPGNoYXI+ID46OmZpcnN0KCnpB3lzdGQ6Ol9fMjo6YmFzaWNfc3RyaW5nPGNoYXIsIHN0ZDo6X18yOjpjaGFyX3RyYWl0czxjaGFyPiwgc3RkOjpfXzI6OmFsbG9jYXRvcjxjaGFyPiA+OjpfX2luaXQoY2hhciBjb25zdCosIHVuc2lnbmVkIGxvbmcp6gelAXN0ZDo6X18yOjpfX2NvbXByZXNzZWRfcGFpcjxzdGQ6Ol9fMjo6YmFzaWNfc3RyaW5nPGNoYXIsIHN0ZDo6X18yOjpjaGFyX3RyYWl0czxjaGFyPiwgc3RkOjpfXzI6OmFsbG9jYXRvcjxjaGFyPiA+OjpfX3JlcCwgc3RkOjpfXzI6OmFsbG9jYXRvcjxjaGFyPiA+OjpzZWNvbmQoKSBjb25zdOsHkQFzdGQ6Ol9fMjo6X19jb21wcmVzc2VkX3BhaXJfZWxlbTxzdGQ6Ol9fMjo6YmFzaWNfc3RyaW5nPGNoYXIsIHN0ZDo6X18yOjpjaGFyX3RyYWl0czxjaGFyPiwgc3RkOjpfXzI6OmFsbG9jYXRvcjxjaGFyPiA+OjpfX3JlcCwgMCwgZmFsc2U+OjpfX2dldCgp7Adnc3RkOjpfXzI6OmJhc2ljX3N0cmluZzxjaGFyLCBzdGQ6Ol9fMjo6Y2hhcl90cmFpdHM8Y2hhcj4sIHN0ZDo6X18yOjphbGxvY2F0b3I8Y2hhcj4gPjo6bWF4X3NpemUoKSBjb25zdO0HdnN0ZDo6X18yOjpiYXNpY19zdHJpbmc8Y2hhciwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPGNoYXI+LCBzdGQ6Ol9fMjo6YWxsb2NhdG9yPGNoYXI+ID46Ol9fc2V0X3Nob3J0X3NpemUodW5zaWduZWQgbG9uZynuB2xzdGQ6Ol9fMjo6YmFzaWNfc3RyaW5nPGNoYXIsIHN0ZDo6X18yOjpjaGFyX3RyYWl0czxjaGFyPiwgc3RkOjpfXzI6OmFsbG9jYXRvcjxjaGFyPiA+OjpfX2dldF9zaG9ydF9wb2ludGVyKCnvB3FzdGQ6Ol9fMjo6YmFzaWNfc3RyaW5nPGNoYXIsIHN0ZDo6X18yOjpjaGFyX3RyYWl0czxjaGFyPiwgc3RkOjpfXzI6OmFsbG9jYXRvcjxjaGFyPiA+OjpfX3JlY29tbWVuZCh1bnNpZ25lZCBsb25nKfAHYHN0ZDo6X18yOjpiYXNpY19zdHJpbmc8Y2hhciwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPGNoYXI+LCBzdGQ6Ol9fMjo6YWxsb2NhdG9yPGNoYXI+ID46Ol9fYWxsb2MoKfEHa3N0ZDo6X18yOjphbGxvY2F0b3JfdHJhaXRzPHN0ZDo6X18yOjphbGxvY2F0b3I8Y2hhcj4gPjo6YWxsb2NhdGUoc3RkOjpfXzI6OmFsbG9jYXRvcjxjaGFyPiYsIHVuc2lnbmVkIGxvbmcp8gdwc3RkOjpfXzI6OmJhc2ljX3N0cmluZzxjaGFyLCBzdGQ6Ol9fMjo6Y2hhcl90cmFpdHM8Y2hhcj4sIHN0ZDo6X18yOjphbGxvY2F0b3I8Y2hhcj4gPjo6X19zZXRfbG9uZ19wb2ludGVyKGNoYXIqKfMHdHN0ZDo6X18yOjpiYXNpY19zdHJpbmc8Y2hhciwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPGNoYXI+LCBzdGQ6Ol9fMjo6YWxsb2NhdG9yPGNoYXI+ID46Ol9fc2V0X2xvbmdfY2FwKHVuc2lnbmVkIGxvbmcp9Ad1c3RkOjpfXzI6OmJhc2ljX3N0cmluZzxjaGFyLCBzdGQ6Ol9fMjo6Y2hhcl90cmFpdHM8Y2hhcj4sIHN0ZDo6X18yOjphbGxvY2F0b3I8Y2hhcj4gPjo6X19zZXRfbG9uZ19zaXplKHVuc2lnbmVkIGxvbmcp9QcpY2hhciogc3RkOjpfXzI6Ol9fdG9fYWRkcmVzczxjaGFyPihjaGFyKin2B0RzdGQ6Ol9fMjo6Y2hhcl90cmFpdHM8Y2hhcj46OmNvcHkoY2hhciosIGNoYXIgY29uc3QqLCB1bnNpZ25lZCBsb25nKfcHN3N0ZDo6X18yOjpjaGFyX3RyYWl0czxjaGFyPjo6YXNzaWduKGNoYXImLCBjaGFyIGNvbnN0Jin4B111bnNpZ25lZCBsb25nIGNvbnN0JiBzdGQ6Ol9fMjo6bWluPHVuc2lnbmVkIGxvbmc+KHVuc2lnbmVkIGxvbmcgY29uc3QmLCB1bnNpZ25lZCBsb25nIGNvbnN0Jin5B74BdW5zaWduZWQgbG9uZyBjb25zdCYgc3RkOjpfXzI6Om1pbjx1bnNpZ25lZCBsb25nLCBzdGQ6Ol9fMjo6X19sZXNzPHVuc2lnbmVkIGxvbmcsIHVuc2lnbmVkIGxvbmc+ID4odW5zaWduZWQgbG9uZyBjb25zdCYsIHVuc2lnbmVkIGxvbmcgY29uc3QmLCBzdGQ6Ol9fMjo6X19sZXNzPHVuc2lnbmVkIGxvbmcsIHVuc2lnbmVkIGxvbmc+KfoHZnN0ZDo6X18yOjpiYXNpY19zdHJpbmc8Y2hhciwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPGNoYXI+LCBzdGQ6Ol9fMjo6YWxsb2NhdG9yPGNoYXI+ID46On5iYXNpY19zdHJpbmcoKfsHa3N0ZDo6X18yOjpiYXNpY19zdHJpbmc8Y2hhciwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPGNoYXI+LCBzdGQ6Ol9fMjo6YWxsb2NhdG9yPGNoYXI+ID46Ol9fZ2V0X2xvbmdfcG9pbnRlcigp/Adtc3RkOjpfXzI6OmJhc2ljX3N0cmluZzxjaGFyLCBzdGQ6Ol9fMjo6Y2hhcl90cmFpdHM8Y2hhcj4sIHN0ZDo6X18yOjphbGxvY2F0b3I8Y2hhcj4gPjo6X19nZXRfbG9uZ19jYXAoKSBjb25zdP0HdHN0ZDo6X18yOjphbGxvY2F0b3JfdHJhaXRzPHN0ZDo6X18yOjphbGxvY2F0b3I8Y2hhcj4gPjo6ZGVhbGxvY2F0ZShzdGQ6Ol9fMjo6YWxsb2NhdG9yPGNoYXI+JiwgY2hhciosIHVuc2lnbmVkIGxvbmcp/gc7c3RkOjpfXzI6OmFsbG9jYXRvcjxjaGFyPjo6ZGVhbGxvY2F0ZShjaGFyKiwgdW5zaWduZWQgbG9uZyn/B58Bc3RkOjpfXzI6Ol9fY29tcHJlc3NlZF9wYWlyPHN0ZDo6X18yOjpiYXNpY19zdHJpbmc8Y2hhciwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPGNoYXI+LCBzdGQ6Ol9fMjo6YWxsb2NhdG9yPGNoYXI+ID46Ol9fcmVwLCBzdGQ6Ol9fMjo6YWxsb2NhdG9yPGNoYXI+ID46OnNlY29uZCgpgAgyc3RkOjpfXzI6OnBvaW50ZXJfdHJhaXRzPGNoYXIqPjo6cG9pbnRlcl90byhjaGFyJimBCGJzdGQ6Ol9fMjo6YWxsb2NhdG9yX3RyYWl0czxzdGQ6Ol9fMjo6YWxsb2NhdG9yPGNoYXI+ID46Om1heF9zaXplKHN0ZDo6X18yOjphbGxvY2F0b3I8Y2hhcj4gY29uc3QmKYIIhAF1bnNpZ25lZCBsb25nIHN0ZDo6X18yOjpiYXNpY19zdHJpbmc8Y2hhciwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPGNoYXI+LCBzdGQ6Ol9fMjo6YWxsb2NhdG9yPGNoYXI+ID46Ol9fYWxpZ25faXQ8MTZ1bD4odW5zaWduZWQgbG9uZymDCD9zdGQ6Ol9fMjo6YWxsb2NhdG9yPGNoYXI+OjphbGxvY2F0ZSh1bnNpZ25lZCBsb25nLCB2b2lkIGNvbnN0KimECCRzdGQ6Ol9fMjo6bnVtZXJpY19saW1pdHM8aW50Pjo6bWluKCmFCCRzdGQ6Ol9fMjo6bnVtZXJpY19saW1pdHM8aW50Pjo6bWF4KCmGCGxzdGQ6Ol9fMjo6X19sZXNzPHVuc2lnbmVkIGxvbmcsIHVuc2lnbmVkIGxvbmc+OjpvcGVyYXRvcigpKHVuc2lnbmVkIGxvbmcgY29uc3QmLCB1bnNpZ25lZCBsb25nIGNvbnN0JikgY29uc3SHCDNzdGQ6Ol9fMjo6X19saWJjcHBfbnVtZXJpY19saW1pdHM8aW50LCB0cnVlPjo6bWluKCmICDNzdGQ6Ol9fMjo6X19saWJjcHBfbnVtZXJpY19saW1pdHM8aW50LCB0cnVlPjo6bWF4KCmJCFNzdGQ6Ol9fMjo6X19jb21wcmVzc2VkX3BhaXJfZWxlbTxzdGQ6Ol9fMjo6YWxsb2NhdG9yPGNoYXI+LCAxLCB0cnVlPjo6X19nZXQoKSBjb25zdIoIQnN0ZDo6X18yOjpfX2xpYmNwcF9kZWFsbG9jYXRlKHZvaWQqLCB1bnNpZ25lZCBsb25nLCB1bnNpZ25lZCBsb25nKYsIY3N0ZDo6X18yOjpfRGVhbGxvY2F0ZUNhbGxlcjo6X19kb19kZWFsbG9jYXRlX2hhbmRsZV9zaXplX2FsaWduKHZvaWQqLCB1bnNpZ25lZCBsb25nLCB1bnNpZ25lZCBsb25nKYwITnN0ZDo6X18yOjpfRGVhbGxvY2F0ZUNhbGxlcjo6X19kb19kZWFsbG9jYXRlX2hhbmRsZV9zaXplKHZvaWQqLCB1bnNpZ25lZCBsb25nKY0ILXN0ZDo6X18yOjpfRGVhbGxvY2F0ZUNhbGxlcjo6X19kb19jYWxsKHZvaWQqKY4ITXN0ZDo6X18yOjpfX2NvbXByZXNzZWRfcGFpcl9lbGVtPHN0ZDo6X18yOjphbGxvY2F0b3I8Y2hhcj4sIDEsIHRydWU+OjpfX2dldCgpjwgmY2hhciogc3RkOjpfXzI6OmFkZHJlc3NvZjxjaGFyPihjaGFyJimQCI0Bc3RkOjpfXzI6OmFsbG9jYXRvcl90cmFpdHM8c3RkOjpfXzI6OmFsbG9jYXRvcjxjaGFyPiA+OjpfX21heF9zaXplKHN0ZDo6X18yOjppbnRlZ3JhbF9jb25zdGFudDxib29sLCB0cnVlPiwgc3RkOjpfXzI6OmFsbG9jYXRvcjxjaGFyPiBjb25zdCYpkQgrc3RkOjpfXzI6OmFsbG9jYXRvcjxjaGFyPjo6bWF4X3NpemUoKSBjb25zdJIIOXN0ZDo6X18yOjpfX2xpYmNwcF9hbGxvY2F0ZSh1bnNpZ25lZCBsb25nLCB1bnNpZ25lZCBsb25nKZMIDWFib3J0X21lc3NhZ2WUCB5kZW1hbmdsaW5nX3Rlcm1pbmF0ZV9oYW5kbGVyKCmVCGN2b2lkICgqc3RkOjpfXzI6Oihhbm9ueW1vdXMgbmFtZXNwYWNlKTo6X19saWJjcHBfYXRvbWljX2xvYWQ8dm9pZCAoKikoKT4odm9pZCAoKiBjb25zdCopKCksIGludCkpKCmWCBRzdGQ6OmdldF90ZXJtaW5hdGUoKZcIHHN0ZDo6X190ZXJtaW5hdGUodm9pZCAoKikoKSmYCBBzdGQ6OnRlcm1pbmF0ZSgpmQgWc3RkOjpnZXRfbmV3X2hhbmRsZXIoKZoIHHN0ZDo6dHlwZV9pbmZvOjp+dHlwZV9pbmZvKCmbCBJfX2N4YV9wdXJlX3ZpcnR1YWycCDFfX2N4eGFiaXYxOjpfX3NoaW1fdHlwZV9pbmZvOjp+X19zaGltX3R5cGVfaW5mbygpnQgrX19jeHhhYml2MTo6X19zaGltX3R5cGVfaW5mbzo6bm9vcDEoKSBjb25zdJ4IK19fY3h4YWJpdjE6Ol9fc2hpbV90eXBlX2luZm86Om5vb3AyKCkgY29uc3SfCD9fX2N4eGFiaXYxOjpfX2Z1bmRhbWVudGFsX3R5cGVfaW5mbzo6fl9fZnVuZGFtZW50YWxfdHlwZV9pbmZvKCmgCDNfX2N4eGFiaXYxOjpfX2NsYXNzX3R5cGVfaW5mbzo6fl9fY2xhc3NfdHlwZV9pbmZvKCmhCDlfX2N4eGFiaXYxOjpfX3NpX2NsYXNzX3R5cGVfaW5mbzo6fl9fc2lfY2xhc3NfdHlwZV9pbmZvKCmiCDtfX2N4eGFiaXYxOjpfX3ZtaV9jbGFzc190eXBlX2luZm86On5fX3ZtaV9jbGFzc190eXBlX2luZm8oKaMIN19fY3h4YWJpdjE6Ol9fcG9pbnRlcl90eXBlX2luZm86On5fX3BvaW50ZXJfdHlwZV9pbmZvKCmkCGFfX2N4eGFiaXYxOjpfX2Z1bmRhbWVudGFsX3R5cGVfaW5mbzo6Y2FuX2NhdGNoKF9fY3h4YWJpdjE6Ol9fc2hpbV90eXBlX2luZm8gY29uc3QqLCB2b2lkKiYpIGNvbnN0pQg8aXNfZXF1YWwoc3RkOjp0eXBlX2luZm8gY29uc3QqLCBzdGQ6OnR5cGVfaW5mbyBjb25zdCosIGJvb2wppgg3c3RkOjp0eXBlX2luZm86Om9wZXJhdG9yPT0oc3RkOjp0eXBlX2luZm8gY29uc3QmKSBjb25zdKcIHHN0ZDo6dHlwZV9pbmZvOjpuYW1lKCkgY29uc3SoCFtfX2N4eGFiaXYxOjpfX2NsYXNzX3R5cGVfaW5mbzo6Y2FuX2NhdGNoKF9fY3h4YWJpdjE6Ol9fc2hpbV90eXBlX2luZm8gY29uc3QqLCB2b2lkKiYpIGNvbnN0qQgOX19keW5hbWljX2Nhc3SqCGtfX2N4eGFiaXYxOjpfX2NsYXNzX3R5cGVfaW5mbzo6cHJvY2Vzc19mb3VuZF9iYXNlX2NsYXNzKF9fY3h4YWJpdjE6Ol9fZHluYW1pY19jYXN0X2luZm8qLCB2b2lkKiwgaW50KSBjb25zdKsIbl9fY3h4YWJpdjE6Ol9fY2xhc3NfdHlwZV9pbmZvOjpoYXNfdW5hbWJpZ3VvdXNfcHVibGljX2Jhc2UoX19jeHhhYml2MTo6X19keW5hbWljX2Nhc3RfaW5mbyosIHZvaWQqLCBpbnQpIGNvbnN0rAhxX19jeHhhYml2MTo6X19zaV9jbGFzc190eXBlX2luZm86Omhhc191bmFtYmlndW91c19wdWJsaWNfYmFzZShfX2N4eGFiaXYxOjpfX2R5bmFtaWNfY2FzdF9pbmZvKiwgdm9pZCosIGludCkgY29uc3StCHNfX2N4eGFiaXYxOjpfX2Jhc2VfY2xhc3NfdHlwZV9pbmZvOjpoYXNfdW5hbWJpZ3VvdXNfcHVibGljX2Jhc2UoX19jeHhhYml2MTo6X19keW5hbWljX2Nhc3RfaW5mbyosIHZvaWQqLCBpbnQpIGNvbnN0rghyX19jeHhhYml2MTo6X192bWlfY2xhc3NfdHlwZV9pbmZvOjpoYXNfdW5hbWJpZ3VvdXNfcHVibGljX2Jhc2UoX19jeHhhYml2MTo6X19keW5hbWljX2Nhc3RfaW5mbyosIHZvaWQqLCBpbnQpIGNvbnN0rwhbX19jeHhhYml2MTo6X19wYmFzZV90eXBlX2luZm86OmNhbl9jYXRjaChfX2N4eGFiaXYxOjpfX3NoaW1fdHlwZV9pbmZvIGNvbnN0Kiwgdm9pZComKSBjb25zdLAIXV9fY3h4YWJpdjE6Ol9fcG9pbnRlcl90eXBlX2luZm86OmNhbl9jYXRjaChfX2N4eGFiaXYxOjpfX3NoaW1fdHlwZV9pbmZvIGNvbnN0Kiwgdm9pZComKSBjb25zdLEIXF9fY3h4YWJpdjE6Ol9fcG9pbnRlcl90eXBlX2luZm86OmNhbl9jYXRjaF9uZXN0ZWQoX19jeHhhYml2MTo6X19zaGltX3R5cGVfaW5mbyBjb25zdCopIGNvbnN0sghmX19jeHhhYml2MTo6X19wb2ludGVyX3RvX21lbWJlcl90eXBlX2luZm86OmNhbl9jYXRjaF9uZXN0ZWQoX19jeHhhYml2MTo6X19zaGltX3R5cGVfaW5mbyBjb25zdCopIGNvbnN0swiDAV9fY3h4YWJpdjE6Ol9fY2xhc3NfdHlwZV9pbmZvOjpwcm9jZXNzX3N0YXRpY190eXBlX2Fib3ZlX2RzdChfX2N4eGFiaXYxOjpfX2R5bmFtaWNfY2FzdF9pbmZvKiwgdm9pZCBjb25zdCosIHZvaWQgY29uc3QqLCBpbnQpIGNvbnN0tAh2X19jeHhhYml2MTo6X19jbGFzc190eXBlX2luZm86OnByb2Nlc3Nfc3RhdGljX3R5cGVfYmVsb3dfZHN0KF9fY3h4YWJpdjE6Ol9fZHluYW1pY19jYXN0X2luZm8qLCB2b2lkIGNvbnN0KiwgaW50KSBjb25zdLUIc19fY3h4YWJpdjE6Ol9fdm1pX2NsYXNzX3R5cGVfaW5mbzo6c2VhcmNoX2JlbG93X2RzdChfX2N4eGFiaXYxOjpfX2R5bmFtaWNfY2FzdF9pbmZvKiwgdm9pZCBjb25zdCosIGludCwgYm9vbCkgY29uc3S2CIEBX19jeHhhYml2MTo6X19iYXNlX2NsYXNzX3R5cGVfaW5mbzo6c2VhcmNoX2Fib3ZlX2RzdChfX2N4eGFiaXYxOjpfX2R5bmFtaWNfY2FzdF9pbmZvKiwgdm9pZCBjb25zdCosIHZvaWQgY29uc3QqLCBpbnQsIGJvb2wpIGNvbnN0twh0X19jeHhhYml2MTo6X19iYXNlX2NsYXNzX3R5cGVfaW5mbzo6c2VhcmNoX2JlbG93X2RzdChfX2N4eGFiaXYxOjpfX2R5bmFtaWNfY2FzdF9pbmZvKiwgdm9pZCBjb25zdCosIGludCwgYm9vbCkgY29uc3S4CHJfX2N4eGFiaXYxOjpfX3NpX2NsYXNzX3R5cGVfaW5mbzo6c2VhcmNoX2JlbG93X2RzdChfX2N4eGFiaXYxOjpfX2R5bmFtaWNfY2FzdF9pbmZvKiwgdm9pZCBjb25zdCosIGludCwgYm9vbCkgY29uc3S5CG9fX2N4eGFiaXYxOjpfX2NsYXNzX3R5cGVfaW5mbzo6c2VhcmNoX2JlbG93X2RzdChfX2N4eGFiaXYxOjpfX2R5bmFtaWNfY2FzdF9pbmZvKiwgdm9pZCBjb25zdCosIGludCwgYm9vbCkgY29uc3S6CIABX19jeHhhYml2MTo6X192bWlfY2xhc3NfdHlwZV9pbmZvOjpzZWFyY2hfYWJvdmVfZHN0KF9fY3h4YWJpdjE6Ol9fZHluYW1pY19jYXN0X2luZm8qLCB2b2lkIGNvbnN0Kiwgdm9pZCBjb25zdCosIGludCwgYm9vbCkgY29uc3S7CH9fX2N4eGFiaXYxOjpfX3NpX2NsYXNzX3R5cGVfaW5mbzo6c2VhcmNoX2Fib3ZlX2RzdChfX2N4eGFiaXYxOjpfX2R5bmFtaWNfY2FzdF9pbmZvKiwgdm9pZCBjb25zdCosIHZvaWQgY29uc3QqLCBpbnQsIGJvb2wpIGNvbnN0vAh8X19jeHhhYml2MTo6X19jbGFzc190eXBlX2luZm86OnNlYXJjaF9hYm92ZV9kc3QoX19jeHhhYml2MTo6X19keW5hbWljX2Nhc3RfaW5mbyosIHZvaWQgY29uc3QqLCB2b2lkIGNvbnN0KiwgaW50LCBib29sKSBjb25zdL0ICF9fc3RyZHVwvggNX19nZXRUeXBlTmFtZb8IKl9fZW1iaW5kX3JlZ2lzdGVyX25hdGl2ZV9hbmRfYnVpbHRpbl90eXBlc8AIL2Vtc2NyaXB0ZW46OmludGVybmFsOjpUeXBlSUQ8dm9pZCwgdm9pZD46OmdldCgpwQgvZW1zY3JpcHRlbjo6aW50ZXJuYWw6OlR5cGVJRDxib29sLCB2b2lkPjo6Z2V0KCnCCD92b2lkIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6cmVnaXN0ZXJfaW50ZWdlcjxjaGFyPihjaGFyIGNvbnN0KinDCEZ2b2lkIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6cmVnaXN0ZXJfaW50ZWdlcjxzaWduZWQgY2hhcj4oY2hhciBjb25zdCopxAhIdm9pZCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6OnJlZ2lzdGVyX2ludGVnZXI8dW5zaWduZWQgY2hhcj4oY2hhciBjb25zdCopxQhAdm9pZCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6OnJlZ2lzdGVyX2ludGVnZXI8c2hvcnQ+KGNoYXIgY29uc3QqKcYISXZvaWQgKGFub255bW91cyBuYW1lc3BhY2UpOjpyZWdpc3Rlcl9pbnRlZ2VyPHVuc2lnbmVkIHNob3J0PihjaGFyIGNvbnN0KinHCD52b2lkIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6cmVnaXN0ZXJfaW50ZWdlcjxpbnQ+KGNoYXIgY29uc3QqKcgIR3ZvaWQgKGFub255bW91cyBuYW1lc3BhY2UpOjpyZWdpc3Rlcl9pbnRlZ2VyPHVuc2lnbmVkIGludD4oY2hhciBjb25zdCopyQg/dm9pZCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6OnJlZ2lzdGVyX2ludGVnZXI8bG9uZz4oY2hhciBjb25zdCopyghIdm9pZCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6OnJlZ2lzdGVyX2ludGVnZXI8dW5zaWduZWQgbG9uZz4oY2hhciBjb25zdCopywg+dm9pZCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6OnJlZ2lzdGVyX2Zsb2F0PGZsb2F0PihjaGFyIGNvbnN0KinMCD92b2lkIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6cmVnaXN0ZXJfZmxvYXQ8ZG91YmxlPihjaGFyIGNvbnN0KinNCJsBZW1zY3JpcHRlbjo6aW50ZXJuYWw6OlR5cGVJRDxzdGQ6Ol9fMjo6YmFzaWNfc3RyaW5nPHVuc2lnbmVkIGNoYXIsIHN0ZDo6X18yOjpjaGFyX3RyYWl0czx1bnNpZ25lZCBjaGFyPiwgc3RkOjpfXzI6OmFsbG9jYXRvcjx1bnNpZ25lZCBjaGFyPiA+LCB2b2lkPjo6Z2V0KCnOCIkBZW1zY3JpcHRlbjo6aW50ZXJuYWw6OlR5cGVJRDxzdGQ6Ol9fMjo6YmFzaWNfc3RyaW5nPHdjaGFyX3QsIHN0ZDo6X18yOjpjaGFyX3RyYWl0czx3Y2hhcl90Piwgc3RkOjpfXzI6OmFsbG9jYXRvcjx3Y2hhcl90PiA+LCB2b2lkPjo6Z2V0KCnPCIwBZW1zY3JpcHRlbjo6aW50ZXJuYWw6OlR5cGVJRDxzdGQ6Ol9fMjo6YmFzaWNfc3RyaW5nPGNoYXIxNl90LCBzdGQ6Ol9fMjo6Y2hhcl90cmFpdHM8Y2hhcjE2X3Q+LCBzdGQ6Ol9fMjo6YWxsb2NhdG9yPGNoYXIxNl90PiA+LCB2b2lkPjo6Z2V0KCnQCIwBZW1zY3JpcHRlbjo6aW50ZXJuYWw6OlR5cGVJRDxzdGQ6Ol9fMjo6YmFzaWNfc3RyaW5nPGNoYXIzMl90LCBzdGQ6Ol9fMjo6Y2hhcl90cmFpdHM8Y2hhcjMyX3Q+LCBzdGQ6Ol9fMjo6YWxsb2NhdG9yPGNoYXIzMl90PiA+LCB2b2lkPjo6Z2V0KCnRCDplbXNjcmlwdGVuOjppbnRlcm5hbDo6VHlwZUlEPGVtc2NyaXB0ZW46OnZhbCwgdm9pZD46OmdldCgp0ghDdm9pZCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6OnJlZ2lzdGVyX21lbW9yeV92aWV3PGNoYXI+KGNoYXIgY29uc3QqKdMISnZvaWQgKGFub255bW91cyBuYW1lc3BhY2UpOjpyZWdpc3Rlcl9tZW1vcnlfdmlldzxzaWduZWQgY2hhcj4oY2hhciBjb25zdCop1AhMdm9pZCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6OnJlZ2lzdGVyX21lbW9yeV92aWV3PHVuc2lnbmVkIGNoYXI+KGNoYXIgY29uc3QqKdUIRHZvaWQgKGFub255bW91cyBuYW1lc3BhY2UpOjpyZWdpc3Rlcl9tZW1vcnlfdmlldzxzaG9ydD4oY2hhciBjb25zdCop1ghNdm9pZCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6OnJlZ2lzdGVyX21lbW9yeV92aWV3PHVuc2lnbmVkIHNob3J0PihjaGFyIGNvbnN0KinXCEJ2b2lkIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6cmVnaXN0ZXJfbWVtb3J5X3ZpZXc8aW50PihjaGFyIGNvbnN0KinYCEt2b2lkIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6cmVnaXN0ZXJfbWVtb3J5X3ZpZXc8dW5zaWduZWQgaW50PihjaGFyIGNvbnN0KinZCEN2b2lkIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6cmVnaXN0ZXJfbWVtb3J5X3ZpZXc8bG9uZz4oY2hhciBjb25zdCop2ghMdm9pZCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6OnJlZ2lzdGVyX21lbW9yeV92aWV3PHVuc2lnbmVkIGxvbmc+KGNoYXIgY29uc3QqKdsIRHZvaWQgKGFub255bW91cyBuYW1lc3BhY2UpOjpyZWdpc3Rlcl9tZW1vcnlfdmlldzxmbG9hdD4oY2hhciBjb25zdCop3AhFdm9pZCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6OnJlZ2lzdGVyX21lbW9yeV92aWV3PGRvdWJsZT4oY2hhciBjb25zdCop3QguZW1zY3JpcHRlbjo6aW50ZXJuYWw6OkxpZ2h0VHlwZUlEPHZvaWQ+OjpnZXQoKd4ILmVtc2NyaXB0ZW46OmludGVybmFsOjpMaWdodFR5cGVJRDxib29sPjo6Z2V0KCnfCC9lbXNjcmlwdGVuOjppbnRlcm5hbDo6VHlwZUlEPGNoYXIsIHZvaWQ+OjpnZXQoKeAIJXN0ZDo6X18yOjpudW1lcmljX2xpbWl0czxjaGFyPjo6bWluKCnhCCVzdGQ6Ol9fMjo6bnVtZXJpY19saW1pdHM8Y2hhcj46Om1heCgp4gg2ZW1zY3JpcHRlbjo6aW50ZXJuYWw6OlR5cGVJRDxzaWduZWQgY2hhciwgdm9pZD46OmdldCgp4wgsc3RkOjpfXzI6Om51bWVyaWNfbGltaXRzPHNpZ25lZCBjaGFyPjo6bWluKCnkCCxzdGQ6Ol9fMjo6bnVtZXJpY19saW1pdHM8c2lnbmVkIGNoYXI+OjptYXgoKeUIOGVtc2NyaXB0ZW46OmludGVybmFsOjpUeXBlSUQ8dW5zaWduZWQgY2hhciwgdm9pZD46OmdldCgp5gguc3RkOjpfXzI6Om51bWVyaWNfbGltaXRzPHVuc2lnbmVkIGNoYXI+OjptaW4oKecILnN0ZDo6X18yOjpudW1lcmljX2xpbWl0czx1bnNpZ25lZCBjaGFyPjo6bWF4KCnoCDBlbXNjcmlwdGVuOjppbnRlcm5hbDo6VHlwZUlEPHNob3J0LCB2b2lkPjo6Z2V0KCnpCCZzdGQ6Ol9fMjo6bnVtZXJpY19saW1pdHM8c2hvcnQ+OjptaW4oKeoIJnN0ZDo6X18yOjpudW1lcmljX2xpbWl0czxzaG9ydD46Om1heCgp6wg5ZW1zY3JpcHRlbjo6aW50ZXJuYWw6OlR5cGVJRDx1bnNpZ25lZCBzaG9ydCwgdm9pZD46OmdldCgp7Agvc3RkOjpfXzI6Om51bWVyaWNfbGltaXRzPHVuc2lnbmVkIHNob3J0Pjo6bWluKCntCC9zdGQ6Ol9fMjo6bnVtZXJpY19saW1pdHM8dW5zaWduZWQgc2hvcnQ+OjptYXgoKe4ILmVtc2NyaXB0ZW46OmludGVybmFsOjpUeXBlSUQ8aW50LCB2b2lkPjo6Z2V0KCnvCC1zdGQ6Ol9fMjo6bnVtZXJpY19saW1pdHM8dW5zaWduZWQgaW50Pjo6bWluKCnwCC1zdGQ6Ol9fMjo6bnVtZXJpY19saW1pdHM8dW5zaWduZWQgaW50Pjo6bWF4KCnxCC9lbXNjcmlwdGVuOjppbnRlcm5hbDo6VHlwZUlEPGxvbmcsIHZvaWQ+OjpnZXQoKfIIJXN0ZDo6X18yOjpudW1lcmljX2xpbWl0czxsb25nPjo6bWluKCnzCCVzdGQ6Ol9fMjo6bnVtZXJpY19saW1pdHM8bG9uZz46Om1heCgp9Ag4ZW1zY3JpcHRlbjo6aW50ZXJuYWw6OlR5cGVJRDx1bnNpZ25lZCBsb25nLCB2b2lkPjo6Z2V0KCn1CC5zdGQ6Ol9fMjo6bnVtZXJpY19saW1pdHM8dW5zaWduZWQgbG9uZz46Om1pbigp9gguc3RkOjpfXzI6Om51bWVyaWNfbGltaXRzPHVuc2lnbmVkIGxvbmc+OjptYXgoKfcIMGVtc2NyaXB0ZW46OmludGVybmFsOjpUeXBlSUQ8ZmxvYXQsIHZvaWQ+OjpnZXQoKfgIMWVtc2NyaXB0ZW46OmludGVybmFsOjpUeXBlSUQ8ZG91YmxlLCB2b2lkPjo6Z2V0KCn5CJsBZW1zY3JpcHRlbjo6aW50ZXJuYWw6OkxpZ2h0VHlwZUlEPHN0ZDo6X18yOjpiYXNpY19zdHJpbmc8dW5zaWduZWQgY2hhciwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPHVuc2lnbmVkIGNoYXI+LCBzdGQ6Ol9fMjo6YWxsb2NhdG9yPHVuc2lnbmVkIGNoYXI+ID4gPjo6Z2V0KCn6CIkBZW1zY3JpcHRlbjo6aW50ZXJuYWw6OkxpZ2h0VHlwZUlEPHN0ZDo6X18yOjpiYXNpY19zdHJpbmc8d2NoYXJfdCwgc3RkOjpfXzI6OmNoYXJfdHJhaXRzPHdjaGFyX3Q+LCBzdGQ6Ol9fMjo6YWxsb2NhdG9yPHdjaGFyX3Q+ID4gPjo6Z2V0KCn7CIwBZW1zY3JpcHRlbjo6aW50ZXJuYWw6OkxpZ2h0VHlwZUlEPHN0ZDo6X18yOjpiYXNpY19zdHJpbmc8Y2hhcjE2X3QsIHN0ZDo6X18yOjpjaGFyX3RyYWl0czxjaGFyMTZfdD4sIHN0ZDo6X18yOjphbGxvY2F0b3I8Y2hhcjE2X3Q+ID4gPjo6Z2V0KCn8CIwBZW1zY3JpcHRlbjo6aW50ZXJuYWw6OkxpZ2h0VHlwZUlEPHN0ZDo6X18yOjpiYXNpY19zdHJpbmc8Y2hhcjMyX3QsIHN0ZDo6X18yOjpjaGFyX3RyYWl0czxjaGFyMzJfdD4sIHN0ZDo6X18yOjphbGxvY2F0b3I8Y2hhcjMyX3Q+ID4gPjo6Z2V0KCn9CDllbXNjcmlwdGVuOjppbnRlcm5hbDo6TGlnaHRUeXBlSUQ8ZW1zY3JpcHRlbjo6dmFsPjo6Z2V0KCn+CEhlbXNjcmlwdGVuOjppbnRlcm5hbDo6VHlwZUlEPGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PGNoYXI+LCB2b2lkPjo6Z2V0KCn/CFgoYW5vbnltb3VzIG5hbWVzcGFjZSk6OlR5cGVkQXJyYXlJbmRleCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6OmdldFR5cGVkQXJyYXlJbmRleDxjaGFyPigpgAlPZW1zY3JpcHRlbjo6aW50ZXJuYWw6OlR5cGVJRDxlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxzaWduZWQgY2hhcj4sIHZvaWQ+OjpnZXQoKYEJXyhhbm9ueW1vdXMgbmFtZXNwYWNlKTo6VHlwZWRBcnJheUluZGV4IChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6Z2V0VHlwZWRBcnJheUluZGV4PHNpZ25lZCBjaGFyPigpgglhKGFub255bW91cyBuYW1lc3BhY2UpOjpUeXBlZEFycmF5SW5kZXggKGFub255bW91cyBuYW1lc3BhY2UpOjpnZXRUeXBlZEFycmF5SW5kZXg8dW5zaWduZWQgY2hhcj4oKYMJSWVtc2NyaXB0ZW46OmludGVybmFsOjpUeXBlSUQ8ZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8c2hvcnQ+LCB2b2lkPjo6Z2V0KCmECVkoYW5vbnltb3VzIG5hbWVzcGFjZSk6OlR5cGVkQXJyYXlJbmRleCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6OmdldFR5cGVkQXJyYXlJbmRleDxzaG9ydD4oKYUJUmVtc2NyaXB0ZW46OmludGVybmFsOjpUeXBlSUQ8ZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8dW5zaWduZWQgc2hvcnQ+LCB2b2lkPjo6Z2V0KCmGCWIoYW5vbnltb3VzIG5hbWVzcGFjZSk6OlR5cGVkQXJyYXlJbmRleCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6OmdldFR5cGVkQXJyYXlJbmRleDx1bnNpZ25lZCBzaG9ydD4oKYcJR2Vtc2NyaXB0ZW46OmludGVybmFsOjpUeXBlSUQ8ZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8aW50Piwgdm9pZD46OmdldCgpiAlXKGFub255bW91cyBuYW1lc3BhY2UpOjpUeXBlZEFycmF5SW5kZXggKGFub255bW91cyBuYW1lc3BhY2UpOjpnZXRUeXBlZEFycmF5SW5kZXg8aW50PigpiQlQZW1zY3JpcHRlbjo6aW50ZXJuYWw6OlR5cGVJRDxlbXNjcmlwdGVuOjptZW1vcnlfdmlldzx1bnNpZ25lZCBpbnQ+LCB2b2lkPjo6Z2V0KCmKCWAoYW5vbnltb3VzIG5hbWVzcGFjZSk6OlR5cGVkQXJyYXlJbmRleCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6OmdldFR5cGVkQXJyYXlJbmRleDx1bnNpZ25lZCBpbnQ+KCmLCUhlbXNjcmlwdGVuOjppbnRlcm5hbDo6VHlwZUlEPGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PGxvbmc+LCB2b2lkPjo6Z2V0KCmMCVgoYW5vbnltb3VzIG5hbWVzcGFjZSk6OlR5cGVkQXJyYXlJbmRleCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6OmdldFR5cGVkQXJyYXlJbmRleDxsb25nPigpjQlRZW1zY3JpcHRlbjo6aW50ZXJuYWw6OlR5cGVJRDxlbXNjcmlwdGVuOjptZW1vcnlfdmlldzx1bnNpZ25lZCBsb25nPiwgdm9pZD46OmdldCgpjglhKGFub255bW91cyBuYW1lc3BhY2UpOjpUeXBlZEFycmF5SW5kZXggKGFub255bW91cyBuYW1lc3BhY2UpOjpnZXRUeXBlZEFycmF5SW5kZXg8dW5zaWduZWQgbG9uZz4oKY8JSWVtc2NyaXB0ZW46OmludGVybmFsOjpUeXBlSUQ8ZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8ZmxvYXQ+LCB2b2lkPjo6Z2V0KCmQCVkoYW5vbnltb3VzIG5hbWVzcGFjZSk6OlR5cGVkQXJyYXlJbmRleCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6OmdldFR5cGVkQXJyYXlJbmRleDxmbG9hdD4oKZEJSmVtc2NyaXB0ZW46OmludGVybmFsOjpUeXBlSUQ8ZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8ZG91YmxlPiwgdm9pZD46OmdldCgpkglaKGFub255bW91cyBuYW1lc3BhY2UpOjpUeXBlZEFycmF5SW5kZXggKGFub255bW91cyBuYW1lc3BhY2UpOjpnZXRUeXBlZEFycmF5SW5kZXg8ZG91YmxlPigpkwkXX19jeHhfZ2xvYmFsX3Zhcl9pbml0LjGUCW5FbXNjcmlwdGVuQmluZGluZ0luaXRpYWxpemVyX25hdGl2ZV9hbmRfYnVpbHRpbl90eXBlczo6RW1zY3JpcHRlbkJpbmRpbmdJbml0aWFsaXplcl9uYXRpdmVfYW5kX2J1aWx0aW5fdHlwZXMoKZUJLmVtc2NyaXB0ZW46OmludGVybmFsOjpMaWdodFR5cGVJRDxjaGFyPjo6Z2V0KCmWCTRzdGQ6Ol9fMjo6X19saWJjcHBfbnVtZXJpY19saW1pdHM8Y2hhciwgdHJ1ZT46Om1pbigplwk0c3RkOjpfXzI6Ol9fbGliY3BwX251bWVyaWNfbGltaXRzPGNoYXIsIHRydWU+OjptYXgoKZgJNWVtc2NyaXB0ZW46OmludGVybmFsOjpMaWdodFR5cGVJRDxzaWduZWQgY2hhcj46OmdldCgpmQk7c3RkOjpfXzI6Ol9fbGliY3BwX251bWVyaWNfbGltaXRzPHNpZ25lZCBjaGFyLCB0cnVlPjo6bWluKCmaCTtzdGQ6Ol9fMjo6X19saWJjcHBfbnVtZXJpY19saW1pdHM8c2lnbmVkIGNoYXIsIHRydWU+OjptYXgoKZsJN2Vtc2NyaXB0ZW46OmludGVybmFsOjpMaWdodFR5cGVJRDx1bnNpZ25lZCBjaGFyPjo6Z2V0KCmcCT1zdGQ6Ol9fMjo6X19saWJjcHBfbnVtZXJpY19saW1pdHM8dW5zaWduZWQgY2hhciwgdHJ1ZT46Om1pbigpnQk9c3RkOjpfXzI6Ol9fbGliY3BwX251bWVyaWNfbGltaXRzPHVuc2lnbmVkIGNoYXIsIHRydWU+OjptYXgoKZ4JL2Vtc2NyaXB0ZW46OmludGVybmFsOjpMaWdodFR5cGVJRDxzaG9ydD46OmdldCgpnwk1c3RkOjpfXzI6Ol9fbGliY3BwX251bWVyaWNfbGltaXRzPHNob3J0LCB0cnVlPjo6bWluKCmgCTVzdGQ6Ol9fMjo6X19saWJjcHBfbnVtZXJpY19saW1pdHM8c2hvcnQsIHRydWU+OjptYXgoKaEJOGVtc2NyaXB0ZW46OmludGVybmFsOjpMaWdodFR5cGVJRDx1bnNpZ25lZCBzaG9ydD46OmdldCgpogk+c3RkOjpfXzI6Ol9fbGliY3BwX251bWVyaWNfbGltaXRzPHVuc2lnbmVkIHNob3J0LCB0cnVlPjo6bWluKCmjCT5zdGQ6Ol9fMjo6X19saWJjcHBfbnVtZXJpY19saW1pdHM8dW5zaWduZWQgc2hvcnQsIHRydWU+OjptYXgoKaQJLWVtc2NyaXB0ZW46OmludGVybmFsOjpMaWdodFR5cGVJRDxpbnQ+OjpnZXQoKaUJPHN0ZDo6X18yOjpfX2xpYmNwcF9udW1lcmljX2xpbWl0czx1bnNpZ25lZCBpbnQsIHRydWU+OjptaW4oKaYJPHN0ZDo6X18yOjpfX2xpYmNwcF9udW1lcmljX2xpbWl0czx1bnNpZ25lZCBpbnQsIHRydWU+OjptYXgoKacJLmVtc2NyaXB0ZW46OmludGVybmFsOjpMaWdodFR5cGVJRDxsb25nPjo6Z2V0KCmoCTRzdGQ6Ol9fMjo6X19saWJjcHBfbnVtZXJpY19saW1pdHM8bG9uZywgdHJ1ZT46Om1pbigpqQk0c3RkOjpfXzI6Ol9fbGliY3BwX251bWVyaWNfbGltaXRzPGxvbmcsIHRydWU+OjptYXgoKaoJN2Vtc2NyaXB0ZW46OmludGVybmFsOjpMaWdodFR5cGVJRDx1bnNpZ25lZCBsb25nPjo6Z2V0KCmrCT1zdGQ6Ol9fMjo6X19saWJjcHBfbnVtZXJpY19saW1pdHM8dW5zaWduZWQgbG9uZywgdHJ1ZT46Om1pbigprAk9c3RkOjpfXzI6Ol9fbGliY3BwX251bWVyaWNfbGltaXRzPHVuc2lnbmVkIGxvbmcsIHRydWU+OjptYXgoKa0JL2Vtc2NyaXB0ZW46OmludGVybmFsOjpMaWdodFR5cGVJRDxmbG9hdD46OmdldCgprgkwZW1zY3JpcHRlbjo6aW50ZXJuYWw6OkxpZ2h0VHlwZUlEPGRvdWJsZT46OmdldCgprwlIZW1zY3JpcHRlbjo6aW50ZXJuYWw6OkxpZ2h0VHlwZUlEPGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PGNoYXI+ID46OmdldCgpsAlPZW1zY3JpcHRlbjo6aW50ZXJuYWw6OkxpZ2h0VHlwZUlEPGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHNpZ25lZCBjaGFyPiA+OjpnZXQoKbEJSWVtc2NyaXB0ZW46OmludGVybmFsOjpMaWdodFR5cGVJRDxlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxzaG9ydD4gPjo6Z2V0KCmyCVJlbXNjcmlwdGVuOjppbnRlcm5hbDo6TGlnaHRUeXBlSUQ8ZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8dW5zaWduZWQgc2hvcnQ+ID46OmdldCgpswlHZW1zY3JpcHRlbjo6aW50ZXJuYWw6OkxpZ2h0VHlwZUlEPGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PGludD4gPjo6Z2V0KCm0CVBlbXNjcmlwdGVuOjppbnRlcm5hbDo6TGlnaHRUeXBlSUQ8ZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8dW5zaWduZWQgaW50PiA+OjpnZXQoKbUJSGVtc2NyaXB0ZW46OmludGVybmFsOjpMaWdodFR5cGVJRDxlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxsb25nPiA+OjpnZXQoKbYJUWVtc2NyaXB0ZW46OmludGVybmFsOjpMaWdodFR5cGVJRDxlbXNjcmlwdGVuOjptZW1vcnlfdmlldzx1bnNpZ25lZCBsb25nPiA+OjpnZXQoKbcJSWVtc2NyaXB0ZW46OmludGVybmFsOjpMaWdodFR5cGVJRDxlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxmbG9hdD4gPjo6Z2V0KCm4CUplbXNjcmlwdGVuOjppbnRlcm5hbDo6TGlnaHRUeXBlSUQ8ZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8ZG91YmxlPiA+OjpnZXQoKbkJF19HTE9CQUxfX3N1Yl9JX2JpbmQuY3BwugkIZGxtYWxsb2O7CQZkbGZyZWW8CQhkbGNhbGxvY70JCWRscmVhbGxvY74JEXRyeV9yZWFsbG9jX2NodW5rvwkKZGxtZW1hbGlnbsAJEWludGVybmFsX21lbWFsaWduwQkNZGlzcG9zZV9jaHVua8IJBHNicmvDCQZtZW1jcHnECQZtZW1zZXTFCQdtZW1tb3ZlxgkJX190b3dyaXRlxwkKX19vdmVyZmxvd8gJCV9fZndyaXRleMkJBmZ3cml0ZcoJCl9fbG9ja2ZpbGXLCQxfX3VubG9ja2ZpbGXMCQZzdHJsZW7NCQhpc3hkaWdpdM4JDl9fY3hhX2RlbWFuZ2xlzwmKAShhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6TWFuZ2xpbmdQYXJzZXI8KGFub255bW91cyBuYW1lc3BhY2UpOjpEZWZhdWx0QWxsb2NhdG9yPjo6TWFuZ2xpbmdQYXJzZXIoY2hhciBjb25zdCosIGNoYXIgY29uc3QqKdAJRShhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6T3V0cHV0U3RyZWFtOjpPdXRwdXRTdHJlYW0oKdEJ0wEoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkFic3RyYWN0TWFuZ2xpbmdQYXJzZXI8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpNYW5nbGluZ1BhcnNlcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+LCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+OjpwYXJzZSgp0gmdAShhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6aW5pdGlhbGl6ZU91dHB1dFN0cmVhbShjaGFyKiwgdW5zaWduZWQgbG9uZyosIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6T3V0cHV0U3RyZWFtJiwgdW5zaWduZWQgbG9uZynTCXIoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGU6OnByaW50KChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6T3V0cHV0U3RyZWFtJikgY29uc3TUCUcoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok91dHB1dFN0cmVhbTo6b3BlcmF0b3IrPShjaGFyKdUJUShhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6T3V0cHV0U3RyZWFtOjpnZXRDdXJyZW50UG9zaXRpb24oKSBjb25zdNYJQihhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6T3V0cHV0U3RyZWFtOjpnZXRCdWZmZXIoKdcJ5QEoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkFic3RyYWN0TWFuZ2xpbmdQYXJzZXI8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpNYW5nbGluZ1BhcnNlcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+LCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+Ojp+QWJzdHJhY3RNYW5nbGluZ1BhcnNlcigp2An8AShhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6QWJzdHJhY3RNYW5nbGluZ1BhcnNlcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok1hbmdsaW5nUGFyc2VyPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcj4sIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcj46OkFic3RyYWN0TWFuZ2xpbmdQYXJzZXIoY2hhciBjb25zdCosIGNoYXIgY29uc3QqKdkJTChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6U3RyaW5nVmlldzo6U3RyaW5nVmlldyhjaGFyIGNvbnN0KinaCYoCKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpBYnN0cmFjdE1hbmdsaW5nUGFyc2VyPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6TWFuZ2xpbmdQYXJzZXI8KGFub255bW91cyBuYW1lc3BhY2UpOjpEZWZhdWx0QWxsb2NhdG9yPiwgKGFub255bW91cyBuYW1lc3BhY2UpOjpEZWZhdWx0QWxsb2NhdG9yPjo6Y29uc3VtZUlmKChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6U3RyaW5nVmlldynbCdgBKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpBYnN0cmFjdE1hbmdsaW5nUGFyc2VyPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6TWFuZ2xpbmdQYXJzZXI8KGFub255bW91cyBuYW1lc3BhY2UpOjpEZWZhdWx0QWxsb2NhdG9yPiwgKGFub255bW91cyBuYW1lc3BhY2UpOjpEZWZhdWx0QWxsb2NhdG9yPjo6Z2V0RGVyaXZlZCgp3AnbAShhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6QWJzdHJhY3RNYW5nbGluZ1BhcnNlcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok1hbmdsaW5nUGFyc2VyPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcj4sIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcj46OnBhcnNlRW5jb2RpbmcoKd0J3gEoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkFic3RyYWN0TWFuZ2xpbmdQYXJzZXI8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpNYW5nbGluZ1BhcnNlcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+LCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+Ojpsb29rKHVuc2lnbmVkIGludCneCVkoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OlN0cmluZ1ZpZXc6OlN0cmluZ1ZpZXcoY2hhciBjb25zdCosIGNoYXIgY29uc3QqKd8JgQQoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6QWJzdHJhY3RNYW5nbGluZ1BhcnNlcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok1hbmdsaW5nUGFyc2VyPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcj4sIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcj46Om1ha2U8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpEb3RTdWZmaXgsIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSomLCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OlN0cmluZ1ZpZXc+KChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSomLCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OlN0cmluZ1ZpZXcmJingCdsBKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpBYnN0cmFjdE1hbmdsaW5nUGFyc2VyPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6TWFuZ2xpbmdQYXJzZXI8KGFub255bW91cyBuYW1lc3BhY2UpOjpEZWZhdWx0QWxsb2NhdG9yPiwgKGFub255bW91cyBuYW1lc3BhY2UpOjpEZWZhdWx0QWxsb2NhdG9yPjo6bnVtTGVmdCgpIGNvbnN04QnbAShhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6QWJzdHJhY3RNYW5nbGluZ1BhcnNlcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok1hbmdsaW5nUGFyc2VyPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcj4sIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcj46OmNvbnN1bWVJZihjaGFyKeIJ3QEoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkFic3RyYWN0TWFuZ2xpbmdQYXJzZXI8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpNYW5nbGluZ1BhcnNlcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+LCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+OjpwYXJzZU51bWJlcihib29sKeMJQihhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6U3RyaW5nVmlldzo6ZW1wdHkoKSBjb25zdOQJwQMoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6QWJzdHJhY3RNYW5nbGluZ1BhcnNlcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok1hbmdsaW5nUGFyc2VyPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcj4sIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcj46Om1ha2U8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpTcGVjaWFsTmFtZSwgY2hhciBjb25zdCAoJikgWzM0XSwgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiY+KGNoYXIgY29uc3QgKCYpIFszNF0sIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSomKeUJ1wEoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkFic3RyYWN0TWFuZ2xpbmdQYXJzZXI8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpNYW5nbGluZ1BhcnNlcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+LCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+OjpwYXJzZVR5cGUoKeYJUihhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6T3V0cHV0U3RyZWFtOjpyZXNldChjaGFyKiwgdW5zaWduZWQgbG9uZynnCUooYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok91dHB1dFN0cmVhbTo6Z3Jvdyh1bnNpZ25lZCBsb25nKegJPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcjo6fkRlZmF1bHRBbGxvY2F0b3IoKekJkwEoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OlBPRFNtYWxsVmVjdG9yPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Rm9yd2FyZFRlbXBsYXRlUmVmZXJlbmNlKiwgNHVsPjo6flBPRFNtYWxsVmVjdG9yKCnqCb4BKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpQT0RTbWFsbFZlY3RvcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OlBPRFNtYWxsVmVjdG9yPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSosIDh1bD4qLCA0dWw+Ojp+UE9EU21hbGxWZWN0b3IoKesJfyhhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6UE9EU21hbGxWZWN0b3I8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiwgOHVsPjo6flBPRFNtYWxsVmVjdG9yKCnsCYABKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpQT0RTbWFsbFZlY3RvcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqLCAzMnVsPjo6flBPRFNtYWxsVmVjdG9yKCntCX8oYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OlBPRFNtYWxsVmVjdG9yPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSosIDMydWw+OjpQT0RTbWFsbFZlY3Rvcigp7gl+KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpQT0RTbWFsbFZlY3RvcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqLCA4dWw+OjpQT0RTbWFsbFZlY3Rvcigp7wm9AShhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6UE9EU21hbGxWZWN0b3I8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpQT0RTbWFsbFZlY3RvcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqLCA4dWw+KiwgNHVsPjo6UE9EU21hbGxWZWN0b3IoKfAJkgEoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OlBPRFNtYWxsVmVjdG9yPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Rm9yd2FyZFRlbXBsYXRlUmVmZXJlbmNlKiwgNHVsPjo6UE9EU21hbGxWZWN0b3IoKfEJOyhhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcjo6RGVmYXVsdEFsbG9jYXRvcigp8glDKGFub255bW91cyBuYW1lc3BhY2UpOjpCdW1wUG9pbnRlckFsbG9jYXRvcjo6QnVtcFBvaW50ZXJBbGxvY2F0b3IoKfMJRChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6QnVtcFBvaW50ZXJBbGxvY2F0b3I6On5CdW1wUG9pbnRlckFsbG9jYXRvcigp9AmSAShhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6UE9EU21hbGxWZWN0b3I8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpGb3J3YXJkVGVtcGxhdGVSZWZlcmVuY2UqLCA0dWw+Ojppc0lubGluZSgpIGNvbnN09Qm9AShhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6UE9EU21hbGxWZWN0b3I8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpQT0RTbWFsbFZlY3RvcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqLCA4dWw+KiwgNHVsPjo6aXNJbmxpbmUoKSBjb25zdPYJfihhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6UE9EU21hbGxWZWN0b3I8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiwgOHVsPjo6aXNJbmxpbmUoKSBjb25zdPcJfyhhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6UE9EU21hbGxWZWN0b3I8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiwgMzJ1bD46OmlzSW5saW5lKCkgY29uc3T4CTQoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkJ1bXBQb2ludGVyQWxsb2NhdG9yOjpyZXNldCgp+Ql6KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpTdHJpbmdWaWV3OjpzdGFydHNXaXRoKChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6U3RyaW5nVmlldykgY29uc3T6CUEoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OlN0cmluZ1ZpZXc6OnNpemUoKSBjb25zdPsJ3gEoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkFic3RyYWN0TWFuZ2xpbmdQYXJzZXI8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpNYW5nbGluZ1BhcnNlcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+LCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+OjpwYXJzZVNwZWNpYWxOYW1lKCn8Ca0DKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpBYnN0cmFjdE1hbmdsaW5nUGFyc2VyPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6TWFuZ2xpbmdQYXJzZXI8KGFub255bW91cyBuYW1lc3BhY2UpOjpEZWZhdWx0QWxsb2NhdG9yPiwgKGFub255bW91cyBuYW1lc3BhY2UpOjpEZWZhdWx0QWxsb2NhdG9yPjo6TmFtZVN0YXRlOjpOYW1lU3RhdGUoKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpBYnN0cmFjdE1hbmdsaW5nUGFyc2VyPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6TWFuZ2xpbmdQYXJzZXI8KGFub255bW91cyBuYW1lc3BhY2UpOjpEZWZhdWx0QWxsb2NhdG9yPiwgKGFub255bW91cyBuYW1lc3BhY2UpOjpEZWZhdWx0QWxsb2NhdG9yPiop/QmtAyhhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6QWJzdHJhY3RNYW5nbGluZ1BhcnNlcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok1hbmdsaW5nUGFyc2VyPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcj4sIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcj46OnBhcnNlTmFtZSgoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkFic3RyYWN0TWFuZ2xpbmdQYXJzZXI8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpNYW5nbGluZ1BhcnNlcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+LCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+OjpOYW1lU3RhdGUqKf4JvgMoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkFic3RyYWN0TWFuZ2xpbmdQYXJzZXI8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpNYW5nbGluZ1BhcnNlcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+LCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+OjpyZXNvbHZlRm9yd2FyZFRlbXBsYXRlUmVmcygoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkFic3RyYWN0TWFuZ2xpbmdQYXJzZXI8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpNYW5nbGluZ1BhcnNlcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+LCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+OjpOYW1lU3RhdGUmKf8J+wEoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkFic3RyYWN0TWFuZ2xpbmdQYXJzZXI8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpNYW5nbGluZ1BhcnNlcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+LCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+OjpwYXJzZUVuY29kaW5nKCk6OidsYW1iZGEnKCk6Om9wZXJhdG9yKCkoKSBjb25zdIAKeyhhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6UE9EU21hbGxWZWN0b3I8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiwgMzJ1bD46OnNpemUoKSBjb25zdIEK3gEoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkFic3RyYWN0TWFuZ2xpbmdQYXJzZXI8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpNYW5nbGluZ1BhcnNlcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+LCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+OjpwYXJzZVRlbXBsYXRlQXJnKCmCCq8BKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpQT0RTbWFsbFZlY3RvcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqLCAzMnVsPjo6cHVzaF9iYWNrKChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSogY29uc3QmKYMK7wEoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkFic3RyYWN0TWFuZ2xpbmdQYXJzZXI8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpNYW5nbGluZ1BhcnNlcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+LCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+Ojpwb3BUcmFpbGluZ05vZGVBcnJheSh1bnNpZ25lZCBsb25nKYQKoAMoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6QWJzdHJhY3RNYW5nbGluZ1BhcnNlcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok1hbmdsaW5nUGFyc2VyPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcj4sIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcj46Om1ha2U8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpFbmFibGVJZkF0dHIsIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZUFycmF5PigoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGVBcnJheSYmKYUKPyhhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZUFycmF5OjpOb2RlQXJyYXkoKYYKrAcoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6QWJzdHJhY3RNYW5nbGluZ1BhcnNlcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok1hbmdsaW5nUGFyc2VyPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcj4sIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcj46Om1ha2U8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpGdW5jdGlvbkVuY29kaW5nLCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqJiwgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiYsIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZUFycmF5LCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqJiwgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpRdWFsaWZpZXJzJiwgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpGdW5jdGlvblJlZlF1YWwmPigoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqJiwgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiYsIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZUFycmF5JiYsIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSomLCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OlF1YWxpZmllcnMmLCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkZ1bmN0aW9uUmVmUXVhbCYphwrnAihhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6RG90U3VmZml4KiAoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I6Om1ha2VOb2RlPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6RG90U3VmZml4LCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqJiwgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpTdHJpbmdWaWV3PigoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqJiwgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpTdHJpbmdWaWV3JiYpiApBKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpTdHJpbmdWaWV3OjpTdHJpbmdWaWV3KCmJCnFjaGFyIGNvbnN0ICgmc3RkOjpfXzI6OmZvcndhcmQ8Y2hhciBjb25zdCAoJikgWzM0XT4oc3RkOjpfXzI6OnJlbW92ZV9yZWZlcmVuY2U8Y2hhciBjb25zdCAoJikgWzM0XT46OnR5cGUmKSkgWzM0XYoKqQIoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OlNwZWNpYWxOYW1lKiAoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I6Om1ha2VOb2RlPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6U3BlY2lhbE5hbWUsIGNoYXIgY29uc3QgKCYpIFszNF0sIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSomPihjaGFyIGNvbnN0ICgmKSBbMzRdLCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqJimLCtoCKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkFic3RyYWN0TWFuZ2xpbmdQYXJzZXI8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpNYW5nbGluZ1BhcnNlcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+LCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+OjptYWtlPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6TmFtZVR5cGUsIGNoYXIgY29uc3QgKCYpIFs1XT4oY2hhciBjb25zdCAoJikgWzVdKYwK2gIoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6QWJzdHJhY3RNYW5nbGluZ1BhcnNlcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok1hbmdsaW5nUGFyc2VyPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcj4sIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcj46Om1ha2U8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOYW1lVHlwZSwgY2hhciBjb25zdCAoJikgWzhdPihjaGFyIGNvbnN0ICgmKSBbOF0pjQrcAihhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSogKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpBYnN0cmFjdE1hbmdsaW5nUGFyc2VyPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6TWFuZ2xpbmdQYXJzZXI8KGFub255bW91cyBuYW1lc3BhY2UpOjpEZWZhdWx0QWxsb2NhdG9yPiwgKGFub255bW91cyBuYW1lc3BhY2UpOjpEZWZhdWx0QWxsb2NhdG9yPjo6bWFrZTwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5hbWVUeXBlLCBjaGFyIGNvbnN0ICgmKSBbMTJdPihjaGFyIGNvbnN0ICgmKSBbMTJdKY4K3AIoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6QWJzdHJhY3RNYW5nbGluZ1BhcnNlcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok1hbmdsaW5nUGFyc2VyPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcj4sIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcj46Om1ha2U8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOYW1lVHlwZSwgY2hhciBjb25zdCAoJikgWzE0XT4oY2hhciBjb25zdCAoJikgWzE0XSmPCtoCKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkFic3RyYWN0TWFuZ2xpbmdQYXJzZXI8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpNYW5nbGluZ1BhcnNlcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+LCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+OjptYWtlPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6TmFtZVR5cGUsIGNoYXIgY29uc3QgKCYpIFs2XT4oY2hhciBjb25zdCAoJikgWzZdKZAK3AIoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6QWJzdHJhY3RNYW5nbGluZ1BhcnNlcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok1hbmdsaW5nUGFyc2VyPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcj4sIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcj46Om1ha2U8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOYW1lVHlwZSwgY2hhciBjb25zdCAoJikgWzE1XT4oY2hhciBjb25zdCAoJikgWzE1XSmRCtoCKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkFic3RyYWN0TWFuZ2xpbmdQYXJzZXI8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpNYW5nbGluZ1BhcnNlcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+LCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+OjptYWtlPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6TmFtZVR5cGUsIGNoYXIgY29uc3QgKCYpIFs0XT4oY2hhciBjb25zdCAoJikgWzRdKZIK3AIoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6QWJzdHJhY3RNYW5nbGluZ1BhcnNlcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok1hbmdsaW5nUGFyc2VyPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcj4sIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcj46Om1ha2U8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOYW1lVHlwZSwgY2hhciBjb25zdCAoJikgWzEzXT4oY2hhciBjb25zdCAoJikgWzEzXSmTCtwCKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkFic3RyYWN0TWFuZ2xpbmdQYXJzZXI8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpNYW5nbGluZ1BhcnNlcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+LCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+OjptYWtlPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6TmFtZVR5cGUsIGNoYXIgY29uc3QgKCYpIFsxMF0+KGNoYXIgY29uc3QgKCYpIFsxMF0plArcAihhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSogKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpBYnN0cmFjdE1hbmdsaW5nUGFyc2VyPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6TWFuZ2xpbmdQYXJzZXI8KGFub255bW91cyBuYW1lc3BhY2UpOjpEZWZhdWx0QWxsb2NhdG9yPiwgKGFub255bW91cyBuYW1lc3BhY2UpOjpEZWZhdWx0QWxsb2NhdG9yPjo6bWFrZTwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5hbWVUeXBlLCBjaGFyIGNvbnN0ICgmKSBbMTldPihjaGFyIGNvbnN0ICgmKSBbMTldKZUK2gIoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6QWJzdHJhY3RNYW5nbGluZ1BhcnNlcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok1hbmdsaW5nUGFyc2VyPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcj4sIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcj46Om1ha2U8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOYW1lVHlwZSwgY2hhciBjb25zdCAoJikgWzldPihjaGFyIGNvbnN0ICgmKSBbOV0plgrcAihhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSogKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpBYnN0cmFjdE1hbmdsaW5nUGFyc2VyPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6TWFuZ2xpbmdQYXJzZXI8KGFub255bW91cyBuYW1lc3BhY2UpOjpEZWZhdWx0QWxsb2NhdG9yPiwgKGFub255bW91cyBuYW1lc3BhY2UpOjpEZWZhdWx0QWxsb2NhdG9yPjo6bWFrZTwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5hbWVUeXBlLCBjaGFyIGNvbnN0ICgmKSBbMThdPihjaGFyIGNvbnN0ICgmKSBbMThdKZcK2gIoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6QWJzdHJhY3RNYW5nbGluZ1BhcnNlcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok1hbmdsaW5nUGFyc2VyPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcj4sIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcj46Om1ha2U8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOYW1lVHlwZSwgY2hhciBjb25zdCAoJikgWzddPihjaGFyIGNvbnN0ICgmKSBbN10pmArcAihhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSogKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpBYnN0cmFjdE1hbmdsaW5nUGFyc2VyPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6TWFuZ2xpbmdQYXJzZXI8KGFub255bW91cyBuYW1lc3BhY2UpOjpEZWZhdWx0QWxsb2NhdG9yPiwgKGFub255bW91cyBuYW1lc3BhY2UpOjpEZWZhdWx0QWxsb2NhdG9yPjo6bWFrZTwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5hbWVUeXBlLCBjaGFyIGNvbnN0ICgmKSBbMTFdPihjaGFyIGNvbnN0ICgmKSBbMTFdKZkK4QEoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkFic3RyYWN0TWFuZ2xpbmdQYXJzZXI8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpNYW5nbGluZ1BhcnNlcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+LCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+OjpwYXJzZUJhcmVTb3VyY2VOYW1lKCmaCp4DKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkFic3RyYWN0TWFuZ2xpbmdQYXJzZXI8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpNYW5nbGluZ1BhcnNlcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+LCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+OjptYWtlPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6TmFtZVR5cGUsIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6U3RyaW5nVmlldyY+KChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6U3RyaW5nVmlldyYpmwrbAShhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6QWJzdHJhY3RNYW5nbGluZ1BhcnNlcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok1hbmdsaW5nUGFyc2VyPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcj4sIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcj46OnBhcnNlRGVjbHR5cGUoKZwK3QEoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkFic3RyYWN0TWFuZ2xpbmdQYXJzZXI8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpNYW5nbGluZ1BhcnNlcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+LCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+OjpwYXJzZVZlY3RvclR5cGUoKZ0KogMoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6QWJzdHJhY3RNYW5nbGluZ1BhcnNlcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok1hbmdsaW5nUGFyc2VyPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcj4sIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcj46Om1ha2U8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpQYXJhbWV0ZXJQYWNrRXhwYW5zaW9uLCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqJj4oKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiYpngrfAShhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6QWJzdHJhY3RNYW5nbGluZ1BhcnNlcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok1hbmdsaW5nUGFyc2VyPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcj4sIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcj46OnBhcnNlRnVuY3Rpb25UeXBlKCmfCtwBKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpBYnN0cmFjdE1hbmdsaW5nUGFyc2VyPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6TWFuZ2xpbmdQYXJzZXI8KGFub255bW91cyBuYW1lc3BhY2UpOjpEZWZhdWx0QWxsb2NhdG9yPiwgKGFub255bW91cyBuYW1lc3BhY2UpOjpEZWZhdWx0QWxsb2NhdG9yPjo6cGFyc2VBcnJheVR5cGUoKaAK5gEoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkFic3RyYWN0TWFuZ2xpbmdQYXJzZXI8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpNYW5nbGluZ1BhcnNlcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+LCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+OjpwYXJzZVBvaW50ZXJUb01lbWJlclR5cGUoKaEKlwMoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6QWJzdHJhY3RNYW5nbGluZ1BhcnNlcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok1hbmdsaW5nUGFyc2VyPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcj4sIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcj46Om1ha2U8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpQb2ludGVyVHlwZSwgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiY+KChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSomKaIKiwQoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6QWJzdHJhY3RNYW5nbGluZ1BhcnNlcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok1hbmdsaW5nUGFyc2VyPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcj4sIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcj46Om1ha2U8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpSZWZlcmVuY2VUeXBlLCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqJiwgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpSZWZlcmVuY2VLaW5kPigoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqJiwgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpSZWZlcmVuY2VLaW5kJiYpowrIAyhhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSogKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpBYnN0cmFjdE1hbmdsaW5nUGFyc2VyPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6TWFuZ2xpbmdQYXJzZXI8KGFub255bW91cyBuYW1lc3BhY2UpOjpEZWZhdWx0QWxsb2NhdG9yPiwgKGFub255bW91cyBuYW1lc3BhY2UpOjpEZWZhdWx0QWxsb2NhdG9yPjo6bWFrZTwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OlBvc3RmaXhRdWFsaWZpZWRUeXBlLCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqJiwgY2hhciBjb25zdCAoJikgWzldPigoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqJiwgY2hhciBjb25zdCAoJikgWzldKaQKygMoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6QWJzdHJhY3RNYW5nbGluZ1BhcnNlcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok1hbmdsaW5nUGFyc2VyPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcj4sIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcj46Om1ha2U8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpQb3N0Zml4UXVhbGlmaWVkVHlwZSwgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiYsIGNoYXIgY29uc3QgKCYpIFsxMV0+KChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSomLCBjaGFyIGNvbnN0ICgmKSBbMTFdKaUK3wEoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkFic3RyYWN0TWFuZ2xpbmdQYXJzZXI8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpNYW5nbGluZ1BhcnNlcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+LCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+OjpwYXJzZVN1YnN0aXR1dGlvbigppgrjAShhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6QWJzdHJhY3RNYW5nbGluZ1BhcnNlcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok1hbmdsaW5nUGFyc2VyPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcj4sIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcj46OnBhcnNlVGVtcGxhdGVBcmdzKGJvb2wppwqCBChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSogKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpBYnN0cmFjdE1hbmdsaW5nUGFyc2VyPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6TWFuZ2xpbmdQYXJzZXI8KGFub255bW91cyBuYW1lc3BhY2UpOjpEZWZhdWx0QWxsb2NhdG9yPiwgKGFub255bW91cyBuYW1lc3BhY2UpOjpEZWZhdWx0QWxsb2NhdG9yPjo6bWFrZTwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5hbWVXaXRoVGVtcGxhdGVBcmdzLCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqJiwgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiY+KChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSomLCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqJimoCuABKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpBYnN0cmFjdE1hbmdsaW5nUGFyc2VyPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6TWFuZ2xpbmdQYXJzZXI8KGFub255bW91cyBuYW1lc3BhY2UpOjpEZWZhdWx0QWxsb2NhdG9yPiwgKGFub255bW91cyBuYW1lc3BhY2UpOjpEZWZhdWx0QWxsb2NhdG9yPjo6cGFyc2VDbGFzc0VudW1UeXBlKCmpCuABKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpBYnN0cmFjdE1hbmdsaW5nUGFyc2VyPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6TWFuZ2xpbmdQYXJzZXI8KGFub255bW91cyBuYW1lc3BhY2UpOjpEZWZhdWx0QWxsb2NhdG9yPiwgKGFub255bW91cyBuYW1lc3BhY2UpOjpEZWZhdWx0QWxsb2NhdG9yPjo6cGFyc2VUZW1wbGF0ZVBhcmFtKCmqCuABKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpBYnN0cmFjdE1hbmdsaW5nUGFyc2VyPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6TWFuZ2xpbmdQYXJzZXI8KGFub255bW91cyBuYW1lc3BhY2UpOjpEZWZhdWx0QWxsb2NhdG9yPiwgKGFub255bW91cyBuYW1lc3BhY2UpOjpEZWZhdWx0QWxsb2NhdG9yPjo6cGFyc2VRdWFsaWZpZWRUeXBlKCmrCkIoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OlN0cmluZ1ZpZXc6OmJlZ2luKCkgY29uc3SsCkAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OlN0cmluZ1ZpZXc6OmVuZCgpIGNvbnN0rQpVYm9vbCBzdGQ6Ol9fMjo6ZXF1YWw8Y2hhciBjb25zdCosIGNoYXIgY29uc3QqPihjaGFyIGNvbnN0KiwgY2hhciBjb25zdCosIGNoYXIgY29uc3QqKa4KmgFib29sIHN0ZDo6X18yOjplcXVhbDxjaGFyIGNvbnN0KiwgY2hhciBjb25zdCosIHN0ZDo6X18yOjpfX2VxdWFsX3RvPGNoYXIsIGNoYXI+ID4oY2hhciBjb25zdCosIGNoYXIgY29uc3QqLCBjaGFyIGNvbnN0Kiwgc3RkOjpfXzI6Ol9fZXF1YWxfdG88Y2hhciwgY2hhcj4prwpMc3RkOjpfXzI6Ol9fZXF1YWxfdG88Y2hhciwgY2hhcj46Om9wZXJhdG9yKCkoY2hhciBjb25zdCYsIGNoYXIgY29uc3QmKSBjb25zdLAK3QEoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkFic3RyYWN0TWFuZ2xpbmdQYXJzZXI8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpNYW5nbGluZ1BhcnNlcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+LCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+OjpwYXJzZUNhbGxPZmZzZXQoKbEKwQMoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6QWJzdHJhY3RNYW5nbGluZ1BhcnNlcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok1hbmdsaW5nUGFyc2VyPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcj4sIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcj46Om1ha2U8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpTcGVjaWFsTmFtZSwgY2hhciBjb25zdCAoJikgWzI3XSwgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiY+KGNoYXIgY29uc3QgKCYpIFsyN10sIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSomKbIKwQMoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6QWJzdHJhY3RNYW5nbGluZ1BhcnNlcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok1hbmdsaW5nUGFyc2VyPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcj4sIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcj46Om1ha2U8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpTcGVjaWFsTmFtZSwgY2hhciBjb25zdCAoJikgWzE0XSwgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiY+KGNoYXIgY29uc3QgKCYpIFsxNF0sIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSomKbMKgwQoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6QWJzdHJhY3RNYW5nbGluZ1BhcnNlcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok1hbmdsaW5nUGFyc2VyPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcj4sIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcj46Om1ha2U8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpDdG9yVnRhYmxlU3BlY2lhbE5hbWUsIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSomLCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqJj4oKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiYsIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSomKbQKwQMoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6QWJzdHJhY3RNYW5nbGluZ1BhcnNlcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok1hbmdsaW5nUGFyc2VyPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcj4sIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcj46Om1ha2U8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpTcGVjaWFsTmFtZSwgY2hhciBjb25zdCAoJikgWzQxXSwgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiY+KGNoYXIgY29uc3QgKCYpIFs0MV0sIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSomKbUKwQMoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6QWJzdHJhY3RNYW5nbGluZ1BhcnNlcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok1hbmdsaW5nUGFyc2VyPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcj4sIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcj46Om1ha2U8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpTcGVjaWFsTmFtZSwgY2hhciBjb25zdCAoJikgWzIwXSwgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiY+KGNoYXIgY29uc3QgKCYpIFsyMF0sIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSomKbYK5gEoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkFic3RyYWN0TWFuZ2xpbmdQYXJzZXI8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpNYW5nbGluZ1BhcnNlcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+LCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+OjpwYXJzZVNlcUlkKHVuc2lnbmVkIGxvbmcqKbcKwQMoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6QWJzdHJhY3RNYW5nbGluZ1BhcnNlcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok1hbmdsaW5nUGFyc2VyPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcj4sIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcj46Om1ha2U8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpTcGVjaWFsTmFtZSwgY2hhciBjb25zdCAoJikgWzI1XSwgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiY+KGNoYXIgY29uc3QgKCYpIFsyNV0sIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSomKbgKwQMoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6QWJzdHJhY3RNYW5nbGluZ1BhcnNlcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok1hbmdsaW5nUGFyc2VyPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcj4sIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcj46Om1ha2U8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpTcGVjaWFsTmFtZSwgY2hhciBjb25zdCAoJikgWzE4XSwgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiY+KGNoYXIgY29uc3QgKCYpIFsxOF0sIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSomKbkKwQMoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6QWJzdHJhY3RNYW5nbGluZ1BhcnNlcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok1hbmdsaW5nUGFyc2VyPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcj4sIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcj46Om1ha2U8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpTcGVjaWFsTmFtZSwgY2hhciBjb25zdCAoJikgWzIyXSwgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiY+KGNoYXIgY29uc3QgKCYpIFsyMl0sIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSomKboKwQMoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6QWJzdHJhY3RNYW5nbGluZ1BhcnNlcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok1hbmdsaW5nUGFyc2VyPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcj4sIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcj46Om1ha2U8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpTcGVjaWFsTmFtZSwgY2hhciBjb25zdCAoJikgWzE5XSwgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiY+KGNoYXIgY29uc3QgKCYpIFsxOV0sIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSomKbsKvwMoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6QWJzdHJhY3RNYW5nbGluZ1BhcnNlcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok1hbmdsaW5nUGFyc2VyPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcj4sIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcj46Om1ha2U8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpTcGVjaWFsTmFtZSwgY2hhciBjb25zdCAoJikgWzldLCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqJj4oY2hhciBjb25zdCAoJikgWzldLCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqJim8CsEDKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkFic3RyYWN0TWFuZ2xpbmdQYXJzZXI8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpNYW5nbGluZ1BhcnNlcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+LCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+OjptYWtlPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6U3BlY2lhbE5hbWUsIGNoYXIgY29uc3QgKCYpIFsxMl0sIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSomPihjaGFyIGNvbnN0ICgmKSBbMTJdLCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqJim9Co4BKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpQT0RTbWFsbFZlY3RvcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkZvcndhcmRUZW1wbGF0ZVJlZmVyZW5jZSosIDR1bD46OnNpemUoKSBjb25zdL4KswMoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkFic3RyYWN0TWFuZ2xpbmdQYXJzZXI8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpNYW5nbGluZ1BhcnNlcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+LCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+OjpwYXJzZU5lc3RlZE5hbWUoKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpBYnN0cmFjdE1hbmdsaW5nUGFyc2VyPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6TWFuZ2xpbmdQYXJzZXI8KGFub255bW91cyBuYW1lc3BhY2UpOjpEZWZhdWx0QWxsb2NhdG9yPiwgKGFub255bW91cyBuYW1lc3BhY2UpOjpEZWZhdWx0QWxsb2NhdG9yPjo6TmFtZVN0YXRlKim/CrIDKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpBYnN0cmFjdE1hbmdsaW5nUGFyc2VyPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6TWFuZ2xpbmdQYXJzZXI8KGFub255bW91cyBuYW1lc3BhY2UpOjpEZWZhdWx0QWxsb2NhdG9yPiwgKGFub255bW91cyBuYW1lc3BhY2UpOjpEZWZhdWx0QWxsb2NhdG9yPjo6cGFyc2VMb2NhbE5hbWUoKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpBYnN0cmFjdE1hbmdsaW5nUGFyc2VyPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6TWFuZ2xpbmdQYXJzZXI8KGFub255bW91cyBuYW1lc3BhY2UpOjpEZWZhdWx0QWxsb2NhdG9yPiwgKGFub255bW91cyBuYW1lc3BhY2UpOjpEZWZhdWx0QWxsb2NhdG9yPjo6TmFtZVN0YXRlKinACrUDKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpBYnN0cmFjdE1hbmdsaW5nUGFyc2VyPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6TWFuZ2xpbmdQYXJzZXI8KGFub255bW91cyBuYW1lc3BhY2UpOjpEZWZhdWx0QWxsb2NhdG9yPiwgKGFub255bW91cyBuYW1lc3BhY2UpOjpEZWZhdWx0QWxsb2NhdG9yPjo6cGFyc2VVbnNjb3BlZE5hbWUoKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpBYnN0cmFjdE1hbmdsaW5nUGFyc2VyPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6TWFuZ2xpbmdQYXJzZXI8KGFub255bW91cyBuYW1lc3BhY2UpOjpEZWZhdWx0QWxsb2NhdG9yPiwgKGFub255bW91cyBuYW1lc3BhY2UpOjpEZWZhdWx0QWxsb2NhdG9yPjo6TmFtZVN0YXRlKinBCpsBKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpQT0RTbWFsbFZlY3RvcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkZvcndhcmRUZW1wbGF0ZVJlZmVyZW5jZSosIDR1bD46Om9wZXJhdG9yW10odW5zaWduZWQgbG9uZynCCroBKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpQT0RTbWFsbFZlY3RvcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OlBPRFNtYWxsVmVjdG9yPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSosIDh1bD4qLCA0dWw+OjplbXB0eSgpIGNvbnN0wwrGAShhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6UE9EU21hbGxWZWN0b3I8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpQT0RTbWFsbFZlY3RvcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqLCA4dWw+KiwgNHVsPjo6b3BlcmF0b3JbXSh1bnNpZ25lZCBsb25nKcQKeihhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6UE9EU21hbGxWZWN0b3I8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiwgOHVsPjo6c2l6ZSgpIGNvbnN0xQqHAShhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6UE9EU21hbGxWZWN0b3I8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiwgOHVsPjo6b3BlcmF0b3JbXSh1bnNpZ25lZCBsb25nKcYKmQEoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OlBPRFNtYWxsVmVjdG9yPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Rm9yd2FyZFRlbXBsYXRlUmVmZXJlbmNlKiwgNHVsPjo6ZHJvcEJhY2sodW5zaWduZWQgbG9uZynHCtcBKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpBYnN0cmFjdE1hbmdsaW5nUGFyc2VyPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6TWFuZ2xpbmdQYXJzZXI8KGFub255bW91cyBuYW1lc3BhY2UpOjpEZWZhdWx0QWxsb2NhdG9yPiwgKGFub255bW91cyBuYW1lc3BhY2UpOjpEZWZhdWx0QWxsb2NhdG9yPjo6cGFyc2VFeHByKCnICt4BKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpBYnN0cmFjdE1hbmdsaW5nUGFyc2VyPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6TWFuZ2xpbmdQYXJzZXI8KGFub255bW91cyBuYW1lc3BhY2UpOjpEZWZhdWx0QWxsb2NhdG9yPiwgKGFub255bW91cyBuYW1lc3BhY2UpOjpEZWZhdWx0QWxsb2NhdG9yPjo6cGFyc2VFeHByUHJpbWFyeSgpyQqoAyhhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSogKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpBYnN0cmFjdE1hbmdsaW5nUGFyc2VyPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6TWFuZ2xpbmdQYXJzZXI8KGFub255bW91cyBuYW1lc3BhY2UpOjpEZWZhdWx0QWxsb2NhdG9yPiwgKGFub255bW91cyBuYW1lc3BhY2UpOjpEZWZhdWx0QWxsb2NhdG9yPjo6bWFrZTwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OlRlbXBsYXRlQXJndW1lbnRQYWNrLCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGVBcnJheSY+KChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZUFycmF5JinKCoUBKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpQT0RTbWFsbFZlY3RvcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqLCAzMnVsPjo6cmVzZXJ2ZSh1bnNpZ25lZCBsb25nKcsKiQIoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkVuYWJsZUlmQXR0ciogKGFub255bW91cyBuYW1lc3BhY2UpOjpEZWZhdWx0QWxsb2NhdG9yOjptYWtlTm9kZTwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkVuYWJsZUlmQXR0ciwgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlQXJyYXk+KChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZUFycmF5JiYpzAp2KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpQT0RTbWFsbFZlY3RvcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqLCAzMnVsPjo6YmVnaW4oKc0KdChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6UE9EU21hbGxWZWN0b3I8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiwgMzJ1bD46OmVuZCgpzgqfAyhhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZUFycmF5IChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6QWJzdHJhY3RNYW5nbGluZ1BhcnNlcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok1hbmdsaW5nUGFyc2VyPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcj4sIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcj46Om1ha2VOb2RlQXJyYXk8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKio+KChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSoqLCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqKinPCoYBKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpQT0RTbWFsbFZlY3RvcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqLCAzMnVsPjo6ZHJvcEJhY2sodW5zaWduZWQgbG9uZynQCpkGKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpGdW5jdGlvbkVuY29kaW5nKiAoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I6Om1ha2VOb2RlPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6RnVuY3Rpb25FbmNvZGluZywgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiYsIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSomLCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGVBcnJheSwgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiYsIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6UXVhbGlmaWVycyYsIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6RnVuY3Rpb25SZWZRdWFsJj4oKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiYsIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSomLCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGVBcnJheSYmLCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqJiwgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpRdWFsaWZpZXJzJiwgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpGdW5jdGlvblJlZlF1YWwmKdEKcWNoYXIgY29uc3QgKCZzdGQ6Ol9fMjo6Zm9yd2FyZDxjaGFyIGNvbnN0ICgmKSBbMTJdPihzdGQ6Ol9fMjo6cmVtb3ZlX3JlZmVyZW5jZTxjaGFyIGNvbnN0ICgmKSBbMTJdPjo6dHlwZSYpKSBbMTJd0gqpAihhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6U3BlY2lhbE5hbWUqIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcjo6bWFrZU5vZGU8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpTcGVjaWFsTmFtZSwgY2hhciBjb25zdCAoJikgWzEyXSwgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiY+KGNoYXIgY29uc3QgKCYpIFsxMl0sIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSomKdMKbmNoYXIgY29uc3QgKCZzdGQ6Ol9fMjo6Zm9yd2FyZDxjaGFyIGNvbnN0ICgmKSBbOV0+KHN0ZDo6X18yOjpyZW1vdmVfcmVmZXJlbmNlPGNoYXIgY29uc3QgKCYpIFs5XT46OnR5cGUmKSkgWzld1AqnAihhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6U3BlY2lhbE5hbWUqIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcjo6bWFrZU5vZGU8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpTcGVjaWFsTmFtZSwgY2hhciBjb25zdCAoJikgWzldLCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqJj4oY2hhciBjb25zdCAoJikgWzldLCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqJinVCnFjaGFyIGNvbnN0ICgmc3RkOjpfXzI6OmZvcndhcmQ8Y2hhciBjb25zdCAoJikgWzE0XT4oc3RkOjpfXzI6OnJlbW92ZV9yZWZlcmVuY2U8Y2hhciBjb25zdCAoJikgWzE0XT46OnR5cGUmKSkgWzE0XdYKqQIoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OlNwZWNpYWxOYW1lKiAoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I6Om1ha2VOb2RlPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6U3BlY2lhbE5hbWUsIGNoYXIgY29uc3QgKCYpIFsxNF0sIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSomPihjaGFyIGNvbnN0ICgmKSBbMTRdLCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqJinXCnFjaGFyIGNvbnN0ICgmc3RkOjpfXzI6OmZvcndhcmQ8Y2hhciBjb25zdCAoJikgWzE5XT4oc3RkOjpfXzI6OnJlbW92ZV9yZWZlcmVuY2U8Y2hhciBjb25zdCAoJikgWzE5XT46OnR5cGUmKSkgWzE5XdgKqQIoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OlNwZWNpYWxOYW1lKiAoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I6Om1ha2VOb2RlPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6U3BlY2lhbE5hbWUsIGNoYXIgY29uc3QgKCYpIFsxOV0sIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSomPihjaGFyIGNvbnN0ICgmKSBbMTldLCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqJinZCnFjaGFyIGNvbnN0ICgmc3RkOjpfXzI6OmZvcndhcmQ8Y2hhciBjb25zdCAoJikgWzI3XT4oc3RkOjpfXzI6OnJlbW92ZV9yZWZlcmVuY2U8Y2hhciBjb25zdCAoJikgWzI3XT46OnR5cGUmKSkgWzI3XdoKqQIoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OlNwZWNpYWxOYW1lKiAoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I6Om1ha2VOb2RlPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6U3BlY2lhbE5hbWUsIGNoYXIgY29uc3QgKCYpIFsyN10sIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSomPihjaGFyIGNvbnN0ICgmKSBbMjddLCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqJinbCvUCKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpDdG9yVnRhYmxlU3BlY2lhbE5hbWUqIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcjo6bWFrZU5vZGU8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpDdG9yVnRhYmxlU3BlY2lhbE5hbWUsIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSomLCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqJj4oKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiYsIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSomKdwKcWNoYXIgY29uc3QgKCZzdGQ6Ol9fMjo6Zm9yd2FyZDxjaGFyIGNvbnN0ICgmKSBbNDFdPihzdGQ6Ol9fMjo6cmVtb3ZlX3JlZmVyZW5jZTxjaGFyIGNvbnN0ICgmKSBbNDFdPjo6dHlwZSYpKSBbNDFd3QqpAihhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6U3BlY2lhbE5hbWUqIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcjo6bWFrZU5vZGU8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpTcGVjaWFsTmFtZSwgY2hhciBjb25zdCAoJikgWzQxXSwgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiY+KGNoYXIgY29uc3QgKCYpIFs0MV0sIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSomKd4KcWNoYXIgY29uc3QgKCZzdGQ6Ol9fMjo6Zm9yd2FyZDxjaGFyIGNvbnN0ICgmKSBbMThdPihzdGQ6Ol9fMjo6cmVtb3ZlX3JlZmVyZW5jZTxjaGFyIGNvbnN0ICgmKSBbMThdPjo6dHlwZSYpKSBbMThd3wqpAihhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6U3BlY2lhbE5hbWUqIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcjo6bWFrZU5vZGU8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpTcGVjaWFsTmFtZSwgY2hhciBjb25zdCAoJikgWzE4XSwgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiY+KGNoYXIgY29uc3QgKCYpIFsxOF0sIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSomKeAKcWNoYXIgY29uc3QgKCZzdGQ6Ol9fMjo6Zm9yd2FyZDxjaGFyIGNvbnN0ICgmKSBbMjJdPihzdGQ6Ol9fMjo6cmVtb3ZlX3JlZmVyZW5jZTxjaGFyIGNvbnN0ICgmKSBbMjJdPjo6dHlwZSYpKSBbMjJd4QqpAihhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6U3BlY2lhbE5hbWUqIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcjo6bWFrZU5vZGU8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpTcGVjaWFsTmFtZSwgY2hhciBjb25zdCAoJikgWzIyXSwgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiY+KGNoYXIgY29uc3QgKCYpIFsyMl0sIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSomKeIKcWNoYXIgY29uc3QgKCZzdGQ6Ol9fMjo6Zm9yd2FyZDxjaGFyIGNvbnN0ICgmKSBbMjBdPihzdGQ6Ol9fMjo6cmVtb3ZlX3JlZmVyZW5jZTxjaGFyIGNvbnN0ICgmKSBbMjBdPjo6dHlwZSYpKSBbMjBd4wqpAihhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6U3BlY2lhbE5hbWUqIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcjo6bWFrZU5vZGU8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpTcGVjaWFsTmFtZSwgY2hhciBjb25zdCAoJikgWzIwXSwgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiY+KGNoYXIgY29uc3QgKCYpIFsyMF0sIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSomKeQKcWNoYXIgY29uc3QgKCZzdGQ6Ol9fMjo6Zm9yd2FyZDxjaGFyIGNvbnN0ICgmKSBbMjVdPihzdGQ6Ol9fMjo6cmVtb3ZlX3JlZmVyZW5jZTxjaGFyIGNvbnN0ICgmKSBbMjVdPjo6dHlwZSYpKSBbMjVd5QqpAihhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6U3BlY2lhbE5hbWUqIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcjo6bWFrZU5vZGU8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpTcGVjaWFsTmFtZSwgY2hhciBjb25zdCAoJikgWzI1XSwgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiY+KGNoYXIgY29uc3QgKCYpIFsyNV0sIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSomKeYKRChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6QnVtcFBvaW50ZXJBbGxvY2F0b3I6OmFsbG9jYXRlKHVuc2lnbmVkIGxvbmcp5wqsAShhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6U3BlY2lhbE5hbWU6OlNwZWNpYWxOYW1lKChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6U3RyaW5nVmlldywgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlIGNvbnN0KinoCksoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkJ1bXBQb2ludGVyQWxsb2NhdG9yOjphbGxvY2F0ZU1hc3NpdmUodW5zaWduZWQgbG9uZynpCjMoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkJ1bXBQb2ludGVyQWxsb2NhdG9yOjpncm93KCnqCooCKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlOjpOb2RlKChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZTo6S2luZCwgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlOjpDYWNoZSwgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlOjpDYWNoZSwgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlOjpDYWNoZSnrCoABKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlOjpoYXNSSFNDb21wb25lbnRTbG93KChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6T3V0cHV0U3RyZWFtJikgY29uc3TsCnkoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGU6Omhhc0FycmF5U2xvdygoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok91dHB1dFN0cmVhbSYpIGNvbnN07Qp8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlOjpoYXNGdW5jdGlvblNsb3coKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpPdXRwdXRTdHJlYW0mKSBjb25zdO4Keihhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZTo6Z2V0U3ludGF4Tm9kZSgoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok91dHB1dFN0cmVhbSYpIGNvbnN07wp9KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpTcGVjaWFsTmFtZTo6cHJpbnRMZWZ0KChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6T3V0cHV0U3RyZWFtJikgY29uc3TwCnYoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok91dHB1dFN0cmVhbTo6b3BlcmF0b3IrPSgoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OlN0cmluZ1ZpZXcp8Qp3KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlOjpwcmludFJpZ2h0KChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6T3V0cHV0U3RyZWFtJikgY29uc3TyCkIoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGU6OmdldEJhc2VOYW1lKCkgY29uc3TzCkQoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OlNwZWNpYWxOYW1lOjp+U3BlY2lhbE5hbWUoKfQKNihhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZTo6fk5vZGUoKfUKwQEoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkN0b3JWdGFibGVTcGVjaWFsTmFtZTo6Q3RvclZ0YWJsZVNwZWNpYWxOYW1lKChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSBjb25zdCosIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSBjb25zdCop9gqHAShhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Q3RvclZ0YWJsZVNwZWNpYWxOYW1lOjpwcmludExlZnQoKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpPdXRwdXRTdHJlYW0mKSBjb25zdPcKWChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Q3RvclZ0YWJsZVNwZWNpYWxOYW1lOjp+Q3RvclZ0YWJsZVNwZWNpYWxOYW1lKCn4Ct8BKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpBYnN0cmFjdE1hbmdsaW5nUGFyc2VyPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6TWFuZ2xpbmdQYXJzZXI8KGFub255bW91cyBuYW1lc3BhY2UpOjpEZWZhdWx0QWxsb2NhdG9yPiwgKGFub255bW91cyBuYW1lc3BhY2UpOjpEZWZhdWx0QWxsb2NhdG9yPjo6cGFyc2VDVlF1YWxpZmllcnMoKfkKrwQoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkFic3RyYWN0TWFuZ2xpbmdQYXJzZXI8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpNYW5nbGluZ1BhcnNlcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+LCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+OjpwYXJzZU5lc3RlZE5hbWUoKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpBYnN0cmFjdE1hbmdsaW5nUGFyc2VyPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6TWFuZ2xpbmdQYXJzZXI8KGFub255bW91cyBuYW1lc3BhY2UpOjpEZWZhdWx0QWxsb2NhdG9yPiwgKGFub255bW91cyBuYW1lc3BhY2UpOjpEZWZhdWx0QWxsb2NhdG9yPjo6TmFtZVN0YXRlKik6OidsYW1iZGEnKChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSopOjpvcGVyYXRvcigpKChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSopIGNvbnN0+gp8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpQT0RTbWFsbFZlY3RvcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqLCAzMnVsPjo6ZW1wdHkoKSBjb25zdPsKeShhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6UE9EU21hbGxWZWN0b3I8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiwgMzJ1bD46OnBvcF9iYWNrKCn8CuYDKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpBYnN0cmFjdE1hbmdsaW5nUGFyc2VyPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6TWFuZ2xpbmdQYXJzZXI8KGFub255bW91cyBuYW1lc3BhY2UpOjpEZWZhdWx0QWxsb2NhdG9yPiwgKGFub255bW91cyBuYW1lc3BhY2UpOjpEZWZhdWx0QWxsb2NhdG9yPjo6cGFyc2VDdG9yRHRvck5hbWUoKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiYsIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6QWJzdHJhY3RNYW5nbGluZ1BhcnNlcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok1hbmdsaW5nUGFyc2VyPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcj4sIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcj46Ok5hbWVTdGF0ZSop/QqIAihhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6QWJzdHJhY3RNYW5nbGluZ1BhcnNlcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok1hbmdsaW5nUGFyc2VyPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcj4sIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcj46OnBhcnNlQWJpVGFncygoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqKf4KuAMoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkFic3RyYWN0TWFuZ2xpbmdQYXJzZXI8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpNYW5nbGluZ1BhcnNlcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+LCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+OjpwYXJzZVVucXVhbGlmaWVkTmFtZSgoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkFic3RyYWN0TWFuZ2xpbmdQYXJzZXI8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpNYW5nbGluZ1BhcnNlcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+LCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+OjpOYW1lU3RhdGUqKf8KVihhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6cGFyc2VfZGlzY3JpbWluYXRvcihjaGFyIGNvbnN0KiwgY2hhciBjb25zdCopgAv3Ayhhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSogKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpBYnN0cmFjdE1hbmdsaW5nUGFyc2VyPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6TWFuZ2xpbmdQYXJzZXI8KGFub255bW91cyBuYW1lc3BhY2UpOjpEZWZhdWx0QWxsb2NhdG9yPiwgKGFub255bW91cyBuYW1lc3BhY2UpOjpEZWZhdWx0QWxsb2NhdG9yPjo6bWFrZTwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkxvY2FsTmFtZSwgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiYsIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSomPigoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqJiwgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiYpgQuxAyhhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSogKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpBYnN0cmFjdE1hbmdsaW5nUGFyc2VyPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6TWFuZ2xpbmdQYXJzZXI8KGFub255bW91cyBuYW1lc3BhY2UpOjpEZWZhdWx0QWxsb2NhdG9yPiwgKGFub255bW91cyBuYW1lc3BhY2UpOjpEZWZhdWx0QWxsb2NhdG9yPjo6bWFrZTwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OlNwZWNpYWxTdWJzdGl0dXRpb24sIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6U3BlY2lhbFN1YktpbmQ+KChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6U3BlY2lhbFN1YktpbmQmJimCC4gBKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpQT0RTbWFsbFZlY3RvcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqLCAzMnVsPjo6b3BlcmF0b3JbXSh1bnNpZ25lZCBsb25nKYMLtAEoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OlBPRFNtYWxsVmVjdG9yPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6UE9EU21hbGxWZWN0b3I8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiwgOHVsPiosIDR1bD46OmNsZWFyKCmEC6wCKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpQT0RTbWFsbFZlY3RvcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OlBPRFNtYWxsVmVjdG9yPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSosIDh1bD4qLCA0dWw+OjpwdXNoX2JhY2soKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpQT0RTbWFsbFZlY3RvcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqLCA4dWw+KiBjb25zdCYphQt1KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpQT0RTbWFsbFZlY3RvcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqLCA4dWw+OjpjbGVhcigphgvqAihhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6UE9EU21hbGxWZWN0b3I8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpQT0RTbWFsbFZlY3RvcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqLCA4dWw+KiwgNHVsPjo6UE9EU21hbGxWZWN0b3IoKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpQT0RTbWFsbFZlY3RvcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OlBPRFNtYWxsVmVjdG9yPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSosIDh1bD4qLCA0dWw+JiYphwvlAihhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6UE9EU21hbGxWZWN0b3I8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpQT0RTbWFsbFZlY3RvcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqLCA4dWw+KiwgNHVsPjo6b3BlcmF0b3I9KChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6UE9EU21hbGxWZWN0b3I8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpQT0RTbWFsbFZlY3RvcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqLCA4dWw+KiwgNHVsPiYmKYgLPihhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZTo6Z2V0S2luZCgpIGNvbnN0iQtSKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpUZW1wbGF0ZUFyZ3VtZW50UGFjazo6Z2V0RWxlbWVudHMoKSBjb25zdIoLoQMoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6QWJzdHJhY3RNYW5nbGluZ1BhcnNlcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok1hbmdsaW5nUGFyc2VyPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcj4sIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcj46Om1ha2U8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpQYXJhbWV0ZXJQYWNrLCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGVBcnJheT4oKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlQXJyYXkmJimLC7MBKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpQT0RTbWFsbFZlY3RvcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OlBPRFNtYWxsVmVjdG9yPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSosIDh1bD4qLCA0dWw+OjpiYWNrKCmMC64BKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpQT0RTbWFsbFZlY3RvcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqLCA4dWw+OjpwdXNoX2JhY2soKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiBjb25zdCYpjQugAyhhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSogKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpBYnN0cmFjdE1hbmdsaW5nUGFyc2VyPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6TWFuZ2xpbmdQYXJzZXI8KGFub255bW91cyBuYW1lc3BhY2UpOjpEZWZhdWx0QWxsb2NhdG9yPiwgKGFub255bW91cyBuYW1lc3BhY2UpOjpEZWZhdWx0QWxsb2NhdG9yPjo6bWFrZTwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OlRlbXBsYXRlQXJncywgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlQXJyYXk+KChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZUFycmF5JiYpjgvzAihhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6TmFtZVdpdGhUZW1wbGF0ZUFyZ3MqIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcjo6bWFrZU5vZGU8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOYW1lV2l0aFRlbXBsYXRlQXJncywgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiYsIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSomPigoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqJiwgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiYpjwucAyhhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSogKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpBYnN0cmFjdE1hbmdsaW5nUGFyc2VyPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6TWFuZ2xpbmdQYXJzZXI8KGFub255bW91cyBuYW1lc3BhY2UpOjpEZWZhdWx0QWxsb2NhdG9yPiwgKGFub255bW91cyBuYW1lc3BhY2UpOjpEZWZhdWx0QWxsb2NhdG9yPjo6bWFrZTwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OlN0ZFF1YWxpZmllZE5hbWUsIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSomPigoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqJimQC54BKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpvcGVyYXRvcnw9KChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6UXVhbGlmaWVycyYsIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6UXVhbGlmaWVycymRC25jaGFyIGNvbnN0ICgmc3RkOjpfXzI6OmZvcndhcmQ8Y2hhciBjb25zdCAoJikgWzRdPihzdGQ6Ol9fMjo6cmVtb3ZlX3JlZmVyZW5jZTxjaGFyIGNvbnN0ICgmKSBbNF0+Ojp0eXBlJikpIFs0XZILvwEoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5hbWVUeXBlKiAoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I6Om1ha2VOb2RlPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6TmFtZVR5cGUsIGNoYXIgY29uc3QgKCYpIFs0XT4oY2hhciBjb25zdCAoJikgWzRdKZML+AMoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6QWJzdHJhY3RNYW5nbGluZ1BhcnNlcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok1hbmdsaW5nUGFyc2VyPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcj4sIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcj46Om1ha2U8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOZXN0ZWROYW1lLCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqJiwgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiY+KChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSomLCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqJimUC/ABKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpBYnN0cmFjdE1hbmdsaW5nUGFyc2VyPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6TWFuZ2xpbmdQYXJzZXI8KGFub255bW91cyBuYW1lc3BhY2UpOjpEZWZhdWx0QWxsb2NhdG9yPiwgKGFub255bW91cyBuYW1lc3BhY2UpOjpEZWZhdWx0QWxsb2NhdG9yPjo6cGFyc2VQb3NpdGl2ZUludGVnZXIodW5zaWduZWQgbG9uZyoplQviAihhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSogKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpBYnN0cmFjdE1hbmdsaW5nUGFyc2VyPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6TWFuZ2xpbmdQYXJzZXI8KGFub255bW91cyBuYW1lc3BhY2UpOjpEZWZhdWx0QWxsb2NhdG9yPiwgKGFub255bW91cyBuYW1lc3BhY2UpOjpEZWZhdWx0QWxsb2NhdG9yPjo6bWFrZTwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkZvcndhcmRUZW1wbGF0ZVJlZmVyZW5jZSwgdW5zaWduZWQgbG9uZyY+KHVuc2lnbmVkIGxvbmcmKZYL1gEoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OlBPRFNtYWxsVmVjdG9yPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Rm9yd2FyZFRlbXBsYXRlUmVmZXJlbmNlKiwgNHVsPjo6cHVzaF9iYWNrKChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Rm9yd2FyZFRlbXBsYXRlUmVmZXJlbmNlKiBjb25zdCYplwu5AShhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6UE9EU21hbGxWZWN0b3I8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpQT0RTbWFsbFZlY3RvcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqLCA4dWw+KiwgNHVsPjo6c2l6ZSgpIGNvbnN0mAvrAyhhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSogKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpBYnN0cmFjdE1hbmdsaW5nUGFyc2VyPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6TWFuZ2xpbmdQYXJzZXI8KGFub255bW91cyBuYW1lc3BhY2UpOjpEZWZhdWx0QWxsb2NhdG9yPiwgKGFub255bW91cyBuYW1lc3BhY2UpOjpEZWZhdWx0QWxsb2NhdG9yPjo6bWFrZTwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkVuY2xvc2luZ0V4cHIsIGNoYXIgY29uc3QgKCYpIFsxMF0sIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSomLCBjaGFyIGNvbnN0ICgmKSBbMl0+KGNoYXIgY29uc3QgKCYpIFsxMF0sIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSomLCBjaGFyIGNvbnN0ICgmKSBbMl0pmQu5Ayhhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSogKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpBYnN0cmFjdE1hbmdsaW5nUGFyc2VyPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6TWFuZ2xpbmdQYXJzZXI8KGFub255bW91cyBuYW1lc3BhY2UpOjpEZWZhdWx0QWxsb2NhdG9yPiwgKGFub255bW91cyBuYW1lc3BhY2UpOjpEZWZhdWx0QWxsb2NhdG9yPjo6bWFrZTwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkV4cGFuZGVkU3BlY2lhbFN1YnN0aXR1dGlvbiwgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpTcGVjaWFsU3ViS2luZCY+KChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6U3BlY2lhbFN1YktpbmQmKZoLsgMoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6QWJzdHJhY3RNYW5nbGluZ1BhcnNlcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok1hbmdsaW5nUGFyc2VyPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcj4sIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcj46Om1ha2U8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpDdG9yRHRvck5hbWUsIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSomLCBib29sLCBpbnQmPigoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqJiwgYm9vbCYmLCBpbnQmKZsLggQoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6QWJzdHJhY3RNYW5nbGluZ1BhcnNlcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok1hbmdsaW5nUGFyc2VyPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcj4sIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcj46Om1ha2U8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpBYmlUYWdBdHRyLCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqJiwgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpTdHJpbmdWaWV3Jj4oKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiYsIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6U3RyaW5nVmlldyYpnAu4Ayhhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6QWJzdHJhY3RNYW5nbGluZ1BhcnNlcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok1hbmdsaW5nUGFyc2VyPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcj4sIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcj46OnBhcnNlVW5uYW1lZFR5cGVOYW1lKChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6QWJzdHJhY3RNYW5nbGluZ1BhcnNlcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok1hbmdsaW5nUGFyc2VyPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcj4sIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcj46Ok5hbWVTdGF0ZSopnQuzAyhhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6QWJzdHJhY3RNYW5nbGluZ1BhcnNlcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok1hbmdsaW5nUGFyc2VyPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcj4sIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcj46OnBhcnNlU291cmNlTmFtZSgoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkFic3RyYWN0TWFuZ2xpbmdQYXJzZXI8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpNYW5nbGluZ1BhcnNlcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+LCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+OjpOYW1lU3RhdGUqKZ4LqQMoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6QWJzdHJhY3RNYW5nbGluZ1BhcnNlcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok1hbmdsaW5nUGFyc2VyPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcj4sIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcj46Om1ha2U8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpTdHJ1Y3R1cmVkQmluZGluZ05hbWUsIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZUFycmF5PigoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGVBcnJheSYmKZ8LtQMoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkFic3RyYWN0TWFuZ2xpbmdQYXJzZXI8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpNYW5nbGluZ1BhcnNlcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+LCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+OjpwYXJzZU9wZXJhdG9yTmFtZSgoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkFic3RyYWN0TWFuZ2xpbmdQYXJzZXI8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpNYW5nbGluZ1BhcnNlcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+LCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+OjpOYW1lU3RhdGUqKaALcChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6TmFtZVR5cGU6Ok5hbWVUeXBlKChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6U3RyaW5nVmlldymhC3ooYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5hbWVUeXBlOjpwcmludExlZnQoKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpPdXRwdXRTdHJlYW0mKSBjb25zdKILRihhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6TmFtZVR5cGU6OmdldEJhc2VOYW1lKCkgY29uc3SjCz4oYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5hbWVUeXBlOjp+TmFtZVR5cGUoKaQL3wIoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5lc3RlZE5hbWUqIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcjo6bWFrZU5vZGU8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOZXN0ZWROYW1lLCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqJiwgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiY+KChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSomLCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqJimlC58BKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOZXN0ZWROYW1lOjpOZXN0ZWROYW1lKChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSosIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSoppgt8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOZXN0ZWROYW1lOjpwcmludExlZnQoKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpPdXRwdXRTdHJlYW0mKSBjb25zdKcLSChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6TmVzdGVkTmFtZTo6Z2V0QmFzZU5hbWUoKSBjb25zdKgLQihhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6TmVzdGVkTmFtZTo6fk5lc3RlZE5hbWUoKakL1QEoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkFic3RyYWN0TWFuZ2xpbmdQYXJzZXI8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpNYW5nbGluZ1BhcnNlcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+LCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+Ojpjb25zdW1lKCmqC2N1bnNpZ25lZCBsb25nJiBzdGQ6Ol9fMjo6Zm9yd2FyZDx1bnNpZ25lZCBsb25nJj4oc3RkOjpfXzI6OnJlbW92ZV9yZWZlcmVuY2U8dW5zaWduZWQgbG9uZyY+Ojp0eXBlJimrC9cBKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpGb3J3YXJkVGVtcGxhdGVSZWZlcmVuY2UqIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcjo6bWFrZU5vZGU8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpGb3J3YXJkVGVtcGxhdGVSZWZlcmVuY2UsIHVuc2lnbmVkIGxvbmcmPih1bnNpZ25lZCBsb25nJimsC5gBKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpQT0RTbWFsbFZlY3RvcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkZvcndhcmRUZW1wbGF0ZVJlZmVyZW5jZSosIDR1bD46OnJlc2VydmUodW5zaWduZWQgbG9uZymtC7QBKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpQT0RTbWFsbFZlY3RvcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OlBPRFNtYWxsVmVjdG9yPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSosIDh1bD4qLCA0dWw+OjpiZWdpbigprgvDAShhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6UE9EU21hbGxWZWN0b3I8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpQT0RTbWFsbFZlY3RvcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqLCA4dWw+KiwgNHVsPjo6cmVzZXJ2ZSh1bnNpZ25lZCBsb25nKa8LbmNoYXIgY29uc3QgKCZzdGQ6Ol9fMjo6Zm9yd2FyZDxjaGFyIGNvbnN0ICgmKSBbNV0+KHN0ZDo6X18yOjpyZW1vdmVfcmVmZXJlbmNlPGNoYXIgY29uc3QgKCYpIFs1XT46OnR5cGUmKSkgWzVdsAu/AShhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6TmFtZVR5cGUqIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcjo6bWFrZU5vZGU8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOYW1lVHlwZSwgY2hhciBjb25zdCAoJikgWzVdPihjaGFyIGNvbnN0ICgmKSBbNV0psQt1KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpQT0RTbWFsbFZlY3RvcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqLCA4dWw+OjpiZWdpbigpsgtqKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpGb3J3YXJkVGVtcGxhdGVSZWZlcmVuY2U6OkZvcndhcmRUZW1wbGF0ZVJlZmVyZW5jZSh1bnNpZ25lZCBsb25nKbMLlAEoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkZvcndhcmRUZW1wbGF0ZVJlZmVyZW5jZTo6aGFzUkhTQ29tcG9uZW50U2xvdygoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok91dHB1dFN0cmVhbSYpIGNvbnN0tAtaKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpTd2FwQW5kUmVzdG9yZTxib29sPjo6U3dhcEFuZFJlc3RvcmUoYm9vbCYsIGJvb2wptQt8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlOjpoYXNSSFNDb21wb25lbnQoKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpPdXRwdXRTdHJlYW0mKSBjb25zdLYLUChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6U3dhcEFuZFJlc3RvcmU8Ym9vbD46On5Td2FwQW5kUmVzdG9yZSgptwuNAShhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Rm9yd2FyZFRlbXBsYXRlUmVmZXJlbmNlOjpoYXNBcnJheVNsb3coKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpPdXRwdXRTdHJlYW0mKSBjb25zdLgLdShhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZTo6aGFzQXJyYXkoKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpPdXRwdXRTdHJlYW0mKSBjb25zdLkLkAEoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkZvcndhcmRUZW1wbGF0ZVJlZmVyZW5jZTo6aGFzRnVuY3Rpb25TbG93KChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6T3V0cHV0U3RyZWFtJikgY29uc3S6C3goYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGU6Omhhc0Z1bmN0aW9uKChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6T3V0cHV0U3RyZWFtJikgY29uc3S7C44BKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpGb3J3YXJkVGVtcGxhdGVSZWZlcmVuY2U6OmdldFN5bnRheE5vZGUoKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpPdXRwdXRTdHJlYW0mKSBjb25zdLwLigEoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkZvcndhcmRUZW1wbGF0ZVJlZmVyZW5jZTo6cHJpbnRMZWZ0KChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6T3V0cHV0U3RyZWFtJikgY29uc3S9C4sBKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpGb3J3YXJkVGVtcGxhdGVSZWZlcmVuY2U6OnByaW50UmlnaHQoKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpPdXRwdXRTdHJlYW0mKSBjb25zdL4LXihhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Rm9yd2FyZFRlbXBsYXRlUmVmZXJlbmNlOjp+Rm9yd2FyZFRlbXBsYXRlUmVmZXJlbmNlKCm/C0ZzdGQ6Ol9fMjo6cmVtb3ZlX3JlZmVyZW5jZTxib29sJj46OnR5cGUmJiBzdGQ6Ol9fMjo6bW92ZTxib29sJj4oYm9vbCYpwAurAyhhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Rm9yd2FyZFRlbXBsYXRlUmVmZXJlbmNlKiogc3RkOjpfXzI6OmNvcHk8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpGb3J3YXJkVGVtcGxhdGVSZWZlcmVuY2UqKiwgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpGb3J3YXJkVGVtcGxhdGVSZWZlcmVuY2UqKj4oKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpGb3J3YXJkVGVtcGxhdGVSZWZlcmVuY2UqKiwgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpGb3J3YXJkVGVtcGxhdGVSZWZlcmVuY2UqKiwgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpGb3J3YXJkVGVtcGxhdGVSZWZlcmVuY2UqKinBC+sFc3RkOjpfXzI6OmVuYWJsZV9pZjwoaXNfc2FtZTxzdGQ6Ol9fMjo6cmVtb3ZlX2NvbnN0PChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Rm9yd2FyZFRlbXBsYXRlUmVmZXJlbmNlKj46OnR5cGUsIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Rm9yd2FyZFRlbXBsYXRlUmVmZXJlbmNlKj46OnZhbHVlKSAmJiAoaXNfdHJpdmlhbGx5X2NvcHlfYXNzaWduYWJsZTwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkZvcndhcmRUZW1wbGF0ZVJlZmVyZW5jZSo+Ojp2YWx1ZSksIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Rm9yd2FyZFRlbXBsYXRlUmVmZXJlbmNlKio+Ojp0eXBlIHN0ZDo6X18yOjpfX2NvcHk8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpGb3J3YXJkVGVtcGxhdGVSZWZlcmVuY2UqLCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkZvcndhcmRUZW1wbGF0ZVJlZmVyZW5jZSo+KChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Rm9yd2FyZFRlbXBsYXRlUmVmZXJlbmNlKiosIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Rm9yd2FyZFRlbXBsYXRlUmVmZXJlbmNlKiosIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Rm9yd2FyZFRlbXBsYXRlUmVmZXJlbmNlKiopwgutBShhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6UE9EU21hbGxWZWN0b3I8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiwgOHVsPioqIHN0ZDo6X18yOjpjb3B5PChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6UE9EU21hbGxWZWN0b3I8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiwgOHVsPioqLCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OlBPRFNtYWxsVmVjdG9yPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSosIDh1bD4qKj4oKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpQT0RTbWFsbFZlY3RvcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqLCA4dWw+KiosIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6UE9EU21hbGxWZWN0b3I8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiwgOHVsPioqLCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OlBPRFNtYWxsVmVjdG9yPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSosIDh1bD4qKinDC+4Ic3RkOjpfXzI6OmVuYWJsZV9pZjwoaXNfc2FtZTxzdGQ6Ol9fMjo6cmVtb3ZlX2NvbnN0PChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6UE9EU21hbGxWZWN0b3I8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiwgOHVsPio+Ojp0eXBlLCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OlBPRFNtYWxsVmVjdG9yPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSosIDh1bD4qPjo6dmFsdWUpICYmIChpc190cml2aWFsbHlfY29weV9hc3NpZ25hYmxlPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6UE9EU21hbGxWZWN0b3I8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiwgOHVsPio+Ojp2YWx1ZSksIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6UE9EU21hbGxWZWN0b3I8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiwgOHVsPioqPjo6dHlwZSBzdGQ6Ol9fMjo6X19jb3B5PChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6UE9EU21hbGxWZWN0b3I8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiwgOHVsPiosIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6UE9EU21hbGxWZWN0b3I8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiwgOHVsPio+KChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6UE9EU21hbGxWZWN0b3I8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiwgOHVsPioqLCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OlBPRFNtYWxsVmVjdG9yPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSosIDh1bD4qKiwgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpQT0RTbWFsbFZlY3RvcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqLCA4dWw+KiopxAvhAShhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6QWJzdHJhY3RNYW5nbGluZ1BhcnNlcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok1hbmdsaW5nUGFyc2VyPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcj4sIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcj46OnBhcnNlVW5yZXNvbHZlZE5hbWUoKcUL4AEoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkFic3RyYWN0TWFuZ2xpbmdQYXJzZXI8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpNYW5nbGluZ1BhcnNlcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+LCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+OjpwYXJzZUZ1bmN0aW9uUGFyYW0oKcYL2wEoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkFic3RyYWN0TWFuZ2xpbmdQYXJzZXI8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpNYW5nbGluZ1BhcnNlcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+LCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+OjpwYXJzZUZvbGRFeHByKCnHC5ACKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpBYnN0cmFjdE1hbmdsaW5nUGFyc2VyPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6TWFuZ2xpbmdQYXJzZXI8KGFub255bW91cyBuYW1lc3BhY2UpOjpEZWZhdWx0QWxsb2NhdG9yPiwgKGFub255bW91cyBuYW1lc3BhY2UpOjpEZWZhdWx0QWxsb2NhdG9yPjo6cGFyc2VCaW5hcnlFeHByKChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6U3RyaW5nVmlldynIC6AEKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkFic3RyYWN0TWFuZ2xpbmdQYXJzZXI8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpNYW5nbGluZ1BhcnNlcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+LCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+OjptYWtlPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Q2FzdEV4cHIsIGNoYXIgY29uc3QgKCYpIFsxMV0sIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSomLCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqJj4oY2hhciBjb25zdCAoJikgWzExXSwgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiYsIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSomKckL4QEoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkFic3RyYWN0TWFuZ2xpbmdQYXJzZXI8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpNYW5nbGluZ1BhcnNlcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+LCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+OjpwYXJzZUNvbnZlcnNpb25FeHByKCnKC7IDKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkFic3RyYWN0TWFuZ2xpbmdQYXJzZXI8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpNYW5nbGluZ1BhcnNlcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+LCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+OjptYWtlPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6RGVsZXRlRXhwciwgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiYsIGJvb2wmLCBib29sPigoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqJiwgYm9vbCYsIGJvb2wmJinLC6AEKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkFic3RyYWN0TWFuZ2xpbmdQYXJzZXI8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpNYW5nbGluZ1BhcnNlcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+LCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+OjptYWtlPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Q2FzdEV4cHIsIGNoYXIgY29uc3QgKCYpIFsxM10sIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSomLCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqJj4oY2hhciBjb25zdCAoJikgWzEzXSwgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiYsIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSomKcwLkAIoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkFic3RyYWN0TWFuZ2xpbmdQYXJzZXI8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpNYW5nbGluZ1BhcnNlcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+LCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+OjpwYXJzZVByZWZpeEV4cHIoKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpTdHJpbmdWaWV3Kc0LgAQoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6QWJzdHJhY3RNYW5nbGluZ1BhcnNlcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok1hbmdsaW5nUGFyc2VyPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcj4sIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcj46Om1ha2U8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpBcnJheVN1YnNjcmlwdEV4cHIsIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSomLCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqJj4oKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiYsIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSomKc4L3QEoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkFic3RyYWN0TWFuZ2xpbmdQYXJzZXI8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpNYW5nbGluZ1BhcnNlcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+LCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+OjpwYXJzZUJyYWNlZEV4cHIoKc8LwgMoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6QWJzdHJhY3RNYW5nbGluZ1BhcnNlcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok1hbmdsaW5nUGFyc2VyPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcj4sIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcj46Om1ha2U8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpJbml0TGlzdEV4cHIsIHN0ZDo6bnVsbHB0cl90LCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGVBcnJheT4oc3RkOjpudWxscHRyX3QmJiwgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlQXJyYXkmJinQC+sDKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkFic3RyYWN0TWFuZ2xpbmdQYXJzZXI8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpNYW5nbGluZ1BhcnNlcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+LCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+OjptYWtlPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6RW5jbG9zaW5nRXhwciwgY2hhciBjb25zdCAoJikgWzExXSwgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiYsIGNoYXIgY29uc3QgKCYpIFsyXT4oY2hhciBjb25zdCAoJikgWzExXSwgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiYsIGNoYXIgY29uc3QgKCYpIFsyXSnRC78DKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkFic3RyYWN0TWFuZ2xpbmdQYXJzZXI8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpNYW5nbGluZ1BhcnNlcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+LCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+OjptYWtlPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6UG9zdGZpeEV4cHIsIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSomLCBjaGFyIGNvbnN0ICgmKSBbM10+KChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSomLCBjaGFyIGNvbnN0ICgmKSBbM10p0gugBChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSogKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpBYnN0cmFjdE1hbmdsaW5nUGFyc2VyPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6TWFuZ2xpbmdQYXJzZXI8KGFub255bW91cyBuYW1lc3BhY2UpOjpEZWZhdWx0QWxsb2NhdG9yPiwgKGFub255bW91cyBuYW1lc3BhY2UpOjpEZWZhdWx0QWxsb2NhdG9yPjo6bWFrZTwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok1lbWJlckV4cHIsIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSomLCBjaGFyIGNvbnN0ICgmKSBbM10sIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSomPigoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqJiwgY2hhciBjb25zdCAoJikgWzNdLCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqJinTC98EKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkFic3RyYWN0TWFuZ2xpbmdQYXJzZXI8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpNYW5nbGluZ1BhcnNlcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+LCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+OjptYWtlPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Q29uZGl0aW9uYWxFeHByLCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqJiwgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiYsIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSomPigoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqJiwgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiYsIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSomKdQLoAQoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6QWJzdHJhY3RNYW5nbGluZ1BhcnNlcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok1hbmdsaW5nUGFyc2VyPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcj4sIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcj46Om1ha2U8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpDYXN0RXhwciwgY2hhciBjb25zdCAoJikgWzE3XSwgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiYsIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSomPihjaGFyIGNvbnN0ICgmKSBbMTddLCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqJiwgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiYp1QugBChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSogKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpBYnN0cmFjdE1hbmdsaW5nUGFyc2VyPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6TWFuZ2xpbmdQYXJzZXI8KGFub255bW91cyBuYW1lc3BhY2UpOjpEZWZhdWx0QWxsb2NhdG9yPiwgKGFub255bW91cyBuYW1lc3BhY2UpOjpEZWZhdWx0QWxsb2NhdG9yPjo6bWFrZTwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkNhc3RFeHByLCBjaGFyIGNvbnN0ICgmKSBbMTJdLCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqJiwgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiY+KGNoYXIgY29uc3QgKCYpIFsxMl0sIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSomLCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqJinWC+kDKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkFic3RyYWN0TWFuZ2xpbmdQYXJzZXI8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpNYW5nbGluZ1BhcnNlcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+LCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+OjptYWtlPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6RW5jbG9zaW5nRXhwciwgY2hhciBjb25zdCAoJikgWzldLCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqJiwgY2hhciBjb25zdCAoJikgWzJdPihjaGFyIGNvbnN0ICgmKSBbOV0sIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSomLCBjaGFyIGNvbnN0ICgmKSBbMl0p1wufAyhhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSogKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpBYnN0cmFjdE1hbmdsaW5nUGFyc2VyPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6TWFuZ2xpbmdQYXJzZXI8KGFub255bW91cyBuYW1lc3BhY2UpOjpEZWZhdWx0QWxsb2NhdG9yPiwgKGFub255bW91cyBuYW1lc3BhY2UpOjpEZWZhdWx0QWxsb2NhdG9yPjo6bWFrZTwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OlNpemVvZlBhcmFtUGFja0V4cHIsIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSomPigoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqJinYC+sDKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkFic3RyYWN0TWFuZ2xpbmdQYXJzZXI8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpNYW5nbGluZ1BhcnNlcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+LCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+OjptYWtlPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6RW5jbG9zaW5nRXhwciwgY2hhciBjb25zdCAoJikgWzEyXSwgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiYsIGNoYXIgY29uc3QgKCYpIFsyXT4oY2hhciBjb25zdCAoJikgWzEyXSwgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiYsIGNoYXIgY29uc3QgKCYpIFsyXSnZC6EDKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkFic3RyYWN0TWFuZ2xpbmdQYXJzZXI8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpNYW5nbGluZ1BhcnNlcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+LCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+OjptYWtlPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZUFycmF5Tm9kZSwgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlQXJyYXk+KChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZUFycmF5JiYp2guVAyhhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSogKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpBYnN0cmFjdE1hbmdsaW5nUGFyc2VyPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6TWFuZ2xpbmdQYXJzZXI8KGFub255bW91cyBuYW1lc3BhY2UpOjpEZWZhdWx0QWxsb2NhdG9yPiwgKGFub255bW91cyBuYW1lc3BhY2UpOjpEZWZhdWx0QWxsb2NhdG9yPjo6bWFrZTwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OlRocm93RXhwciwgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiY+KChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSomKdsLlgMoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6QWJzdHJhY3RNYW5nbGluZ1BhcnNlcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok1hbmdsaW5nUGFyc2VyPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcj4sIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcj46Om1ha2U8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpVVUlET2ZFeHByLCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqJj4oKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiYp3AuCBChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSogKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpBYnN0cmFjdE1hbmdsaW5nUGFyc2VyPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6TWFuZ2xpbmdQYXJzZXI8KGFub255bW91cyBuYW1lc3BhY2UpOjpEZWZhdWx0QWxsb2NhdG9yPiwgKGFub255bW91cyBuYW1lc3BhY2UpOjpEZWZhdWx0QWxsb2NhdG9yPjo6bWFrZTwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkluaXRMaXN0RXhwciwgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiYsIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZUFycmF5PigoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqJiwgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlQXJyYXkmJindC9oBKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpBYnN0cmFjdE1hbmdsaW5nUGFyc2VyPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6TWFuZ2xpbmdQYXJzZXI8KGFub255bW91cyBuYW1lc3BhY2UpOjpEZWZhdWx0QWxsb2NhdG9yPiwgKGFub255bW91cyBuYW1lc3BhY2UpOjpEZWZhdWx0QWxsb2NhdG9yPjo6cGFyc2VOZXdFeHByKCneC6AEKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkFic3RyYWN0TWFuZ2xpbmdQYXJzZXI8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpNYW5nbGluZ1BhcnNlcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+LCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+OjptYWtlPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6TWVtYmVyRXhwciwgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiYsIGNoYXIgY29uc3QgKCYpIFsyXSwgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiY+KChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSomLCBjaGFyIGNvbnN0ICgmKSBbMl0sIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSomKd8L/gMoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6QWJzdHJhY3RNYW5nbGluZ1BhcnNlcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok1hbmdsaW5nUGFyc2VyPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcj4sIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcj46Om1ha2U8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpDYWxsRXhwciwgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiYsIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZUFycmF5PigoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqJiwgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlQXJyYXkmJingC3FjaGFyIGNvbnN0ICgmc3RkOjpfXzI6OmZvcndhcmQ8Y2hhciBjb25zdCAoJikgWzEwXT4oc3RkOjpfXzI6OnJlbW92ZV9yZWZlcmVuY2U8Y2hhciBjb25zdCAoJikgWzEwXT46OnR5cGUmKSkgWzEwXeELbmNoYXIgY29uc3QgKCZzdGQ6Ol9fMjo6Zm9yd2FyZDxjaGFyIGNvbnN0ICgmKSBbMl0+KHN0ZDo6X18yOjpyZW1vdmVfcmVmZXJlbmNlPGNoYXIgY29uc3QgKCYpIFsyXT46OnR5cGUmKSkgWzJd4gvVAihhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6RW5jbG9zaW5nRXhwciogKGFub255bW91cyBuYW1lc3BhY2UpOjpEZWZhdWx0QWxsb2NhdG9yOjptYWtlTm9kZTwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkVuY2xvc2luZ0V4cHIsIGNoYXIgY29uc3QgKCYpIFsxMF0sIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSomLCBjaGFyIGNvbnN0ICgmKSBbMl0+KGNoYXIgY29uc3QgKCYpIFsxMF0sIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSomLCBjaGFyIGNvbnN0ICgmKSBbMl0p4wuUAihhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6QWJzdHJhY3RNYW5nbGluZ1BhcnNlcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok1hbmdsaW5nUGFyc2VyPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcj4sIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcj46OnBhcnNlSW50ZWdlckxpdGVyYWwoKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpTdHJpbmdWaWV3KeQLvgIoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6QWJzdHJhY3RNYW5nbGluZ1BhcnNlcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok1hbmdsaW5nUGFyc2VyPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcj4sIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcj46Om1ha2U8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpCb29sRXhwciwgaW50PihpbnQmJinlC5gCKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkFic3RyYWN0TWFuZ2xpbmdQYXJzZXI8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpNYW5nbGluZ1BhcnNlcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+LCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+OjpwYXJzZUZsb2F0aW5nTGl0ZXJhbDxmbG9hdD4oKeYLmQIoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6QWJzdHJhY3RNYW5nbGluZ1BhcnNlcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok1hbmdsaW5nUGFyc2VyPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcj4sIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcj46OnBhcnNlRmxvYXRpbmdMaXRlcmFsPGRvdWJsZT4oKecLngIoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6QWJzdHJhY3RNYW5nbGluZ1BhcnNlcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok1hbmdsaW5nUGFyc2VyPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcj4sIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcj46OnBhcnNlRmxvYXRpbmdMaXRlcmFsPGxvbmcgZG91YmxlPigp6AuZAyhhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSogKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpBYnN0cmFjdE1hbmdsaW5nUGFyc2VyPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6TWFuZ2xpbmdQYXJzZXI8KGFub255bW91cyBuYW1lc3BhY2UpOjpEZWZhdWx0QWxsb2NhdG9yPiwgKGFub255bW91cyBuYW1lc3BhY2UpOjpEZWZhdWx0QWxsb2NhdG9yPjo6bWFrZTwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OlN0cmluZ0xpdGVyYWwsIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSomPigoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqJinpC5YDKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkFic3RyYWN0TWFuZ2xpbmdQYXJzZXI8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpNYW5nbGluZ1BhcnNlcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+LCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+OjptYWtlPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6TGFtYmRhRXhwciwgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiY+KChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSomKeoLhwQoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6QWJzdHJhY3RNYW5nbGluZ1BhcnNlcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok1hbmdsaW5nUGFyc2VyPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcj4sIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcj46Om1ha2U8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpJbnRlZ2VyQ2FzdEV4cHIsIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSomLCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OlN0cmluZ1ZpZXcmPigoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqJiwgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpTdHJpbmdWaWV3JinrC6MDKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkFic3RyYWN0TWFuZ2xpbmdQYXJzZXI8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpNYW5nbGluZ1BhcnNlcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+LCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+OjptYWtlPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6RnVuY3Rpb25QYXJhbSwgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpTdHJpbmdWaWV3Jj4oKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpTdHJpbmdWaWV3JinsC98Cc3RkOjpfXzI6OmVuYWJsZV9pZjwoaXNfbW92ZV9jb25zdHJ1Y3RpYmxlPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSo+Ojp2YWx1ZSkgJiYgKGlzX21vdmVfYXNzaWduYWJsZTwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqPjo6dmFsdWUpLCB2b2lkPjo6dHlwZSBzdGQ6Ol9fMjo6c3dhcDwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqPigoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqJiwgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiYp7QvwBChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSogKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpBYnN0cmFjdE1hbmdsaW5nUGFyc2VyPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6TWFuZ2xpbmdQYXJzZXI8KGFub255bW91cyBuYW1lc3BhY2UpOjpEZWZhdWx0QWxsb2NhdG9yPiwgKGFub255bW91cyBuYW1lc3BhY2UpOjpEZWZhdWx0QWxsb2NhdG9yPjo6bWFrZTwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkZvbGRFeHByLCBib29sJiwgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpTdHJpbmdWaWV3JiwgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiYsIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSomPihib29sJiwgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpTdHJpbmdWaWV3JiwgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiYsIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSomKe4L5AQoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6QWJzdHJhY3RNYW5nbGluZ1BhcnNlcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok1hbmdsaW5nUGFyc2VyPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcj4sIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcj46Om1ha2U8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpCaW5hcnlFeHByLCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqJiwgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpTdHJpbmdWaWV3JiwgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiY+KChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSomLCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OlN0cmluZ1ZpZXcmLCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqJinvC4IEKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkFic3RyYWN0TWFuZ2xpbmdQYXJzZXI8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpNYW5nbGluZ1BhcnNlcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+LCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+OjptYWtlPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6UHJlZml4RXhwciwgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpTdHJpbmdWaWV3JiwgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiY+KChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6U3RyaW5nVmlldyYsIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSomKfALcWNoYXIgY29uc3QgKCZzdGQ6Ol9fMjo6Zm9yd2FyZDxjaGFyIGNvbnN0ICgmKSBbMTFdPihzdGQ6Ol9fMjo6cmVtb3ZlX3JlZmVyZW5jZTxjaGFyIGNvbnN0ICgmKSBbMTFdPjo6dHlwZSYpKSBbMTFd8QuFAyhhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Q2FzdEV4cHIqIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcjo6bWFrZU5vZGU8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpDYXN0RXhwciwgY2hhciBjb25zdCAoJikgWzExXSwgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiYsIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSomPihjaGFyIGNvbnN0ICgmKSBbMTFdLCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqJiwgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiYp8gvjAihhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Q2FsbEV4cHIqIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcjo6bWFrZU5vZGU8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpDYWxsRXhwciwgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiYsIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZUFycmF5PigoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqJiwgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlQXJyYXkmJinzC4QEKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkFic3RyYWN0TWFuZ2xpbmdQYXJzZXI8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpNYW5nbGluZ1BhcnNlcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+LCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+OjptYWtlPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Q29udmVyc2lvbkV4cHIsIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSomLCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGVBcnJheSY+KChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSomLCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGVBcnJheSYp9AuEBChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSogKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpBYnN0cmFjdE1hbmdsaW5nUGFyc2VyPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6TWFuZ2xpbmdQYXJzZXI8KGFub255bW91cyBuYW1lc3BhY2UpOjpEZWZhdWx0QWxsb2NhdG9yPiwgKGFub255bW91cyBuYW1lc3BhY2UpOjpEZWZhdWx0QWxsb2NhdG9yPjo6bWFrZTwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkNvbnZlcnNpb25FeHByLCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqJiwgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlQXJyYXk+KChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSomLCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGVBcnJheSYmKfULSGJvb2wmIHN0ZDo6X18yOjpmb3J3YXJkPGJvb2wmPihzdGQ6Ol9fMjo6cmVtb3ZlX3JlZmVyZW5jZTxib29sJj46OnR5cGUmKfYLR2Jvb2wmJiBzdGQ6Ol9fMjo6Zm9yd2FyZDxib29sPihzdGQ6Ol9fMjo6cmVtb3ZlX3JlZmVyZW5jZTxib29sPjo6dHlwZSYp9wuZAihhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6RGVsZXRlRXhwciogKGFub255bW91cyBuYW1lc3BhY2UpOjpEZWZhdWx0QWxsb2NhdG9yOjptYWtlTm9kZTwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkRlbGV0ZUV4cHIsIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSomLCBib29sJiwgYm9vbD4oKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiYsIGJvb2wmLCBib29sJiYp+AtxY2hhciBjb25zdCAoJnN0ZDo6X18yOjpmb3J3YXJkPGNoYXIgY29uc3QgKCYpIFsxM10+KHN0ZDo6X18yOjpyZW1vdmVfcmVmZXJlbmNlPGNoYXIgY29uc3QgKCYpIFsxM10+Ojp0eXBlJikpIFsxM135C4UDKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpDYXN0RXhwciogKGFub255bW91cyBuYW1lc3BhY2UpOjpEZWZhdWx0QWxsb2NhdG9yOjptYWtlTm9kZTwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkNhc3RFeHByLCBjaGFyIGNvbnN0ICgmKSBbMTNdLCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqJiwgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiY+KGNoYXIgY29uc3QgKCYpIFsxM10sIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSomLCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqJin6C+EBKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpBYnN0cmFjdE1hbmdsaW5nUGFyc2VyPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6TWFuZ2xpbmdQYXJzZXI8KGFub255bW91cyBuYW1lc3BhY2UpOjpEZWZhdWx0QWxsb2NhdG9yPiwgKGFub255bW91cyBuYW1lc3BhY2UpOjpEZWZhdWx0QWxsb2NhdG9yPjo6cGFyc2VVbnJlc29sdmVkVHlwZSgp+wvbAShhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6QWJzdHJhY3RNYW5nbGluZ1BhcnNlcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok1hbmdsaW5nUGFyc2VyPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcj4sIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcj46OnBhcnNlU2ltcGxlSWQoKfwL+wMoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6QWJzdHJhY3RNYW5nbGluZ1BhcnNlcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok1hbmdsaW5nUGFyc2VyPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcj4sIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcj46Om1ha2U8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpRdWFsaWZpZWROYW1lLCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqJiwgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiY+KChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSomLCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqJin9C+UBKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpBYnN0cmFjdE1hbmdsaW5nUGFyc2VyPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6TWFuZ2xpbmdQYXJzZXI8KGFub255bW91cyBuYW1lc3BhY2UpOjpEZWZhdWx0QWxsb2NhdG9yPiwgKGFub255bW91cyBuYW1lc3BhY2UpOjpEZWZhdWx0QWxsb2NhdG9yPjo6cGFyc2VCYXNlVW5yZXNvbHZlZE5hbWUoKf4LnwMoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6QWJzdHJhY3RNYW5nbGluZ1BhcnNlcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok1hbmdsaW5nUGFyc2VyPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcj4sIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcj46Om1ha2U8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpHbG9iYWxRdWFsaWZpZWROYW1lLCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqJj4oKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiYp/wtuY2hhciBjb25zdCAoJnN0ZDo6X18yOjpmb3J3YXJkPGNoYXIgY29uc3QgKCYpIFszXT4oc3RkOjpfXzI6OnJlbW92ZV9yZWZlcmVuY2U8Y2hhciBjb25zdCAoJikgWzNdPjo6dHlwZSYpKSBbM12ADIcDKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpNZW1iZXJFeHByKiAoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I6Om1ha2VOb2RlPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6TWVtYmVyRXhwciwgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiYsIGNoYXIgY29uc3QgKCYpIFszXSwgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiY+KChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSomLCBjaGFyIGNvbnN0ICgmKSBbM10sIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSomKYEMhwMoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok1lbWJlckV4cHIqIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcjo6bWFrZU5vZGU8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpNZW1iZXJFeHByLCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqJiwgY2hhciBjb25zdCAoJikgWzJdLCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqJj4oKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiYsIGNoYXIgY29uc3QgKCYpIFsyXSwgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiYpggzvAihhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6QXJyYXlTdWJzY3JpcHRFeHByKiAoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I6Om1ha2VOb2RlPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6QXJyYXlTdWJzY3JpcHRFeHByLCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqJiwgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiY+KChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSomLCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqJimDDIYEKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkFic3RyYWN0TWFuZ2xpbmdQYXJzZXI8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpNYW5nbGluZ1BhcnNlcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+LCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+OjptYWtlPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6QnJhY2VkRXhwciwgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiYsIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSomLCBib29sPigoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqJiwgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiYsIGJvb2wmJimEDN8EKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkFic3RyYWN0TWFuZ2xpbmdQYXJzZXI8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpNYW5nbGluZ1BhcnNlcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+LCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+OjptYWtlPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6QnJhY2VkUmFuZ2VFeHByLCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqJiwgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiYsIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSomPigoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqJiwgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiYsIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSomKYUMZXN0ZDo6bnVsbHB0cl90JiYgc3RkOjpfXzI6OmZvcndhcmQ8c3RkOjpudWxscHRyX3Q+KHN0ZDo6X18yOjpyZW1vdmVfcmVmZXJlbmNlPHN0ZDo6bnVsbHB0cl90Pjo6dHlwZSYphgyrAihhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6SW5pdExpc3RFeHByKiAoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I6Om1ha2VOb2RlPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6SW5pdExpc3RFeHByLCBzdGQ6Om51bGxwdHJfdCwgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlQXJyYXk+KHN0ZDo6bnVsbHB0cl90JiYsIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZUFycmF5JiYphwynAihhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6UG9zdGZpeEV4cHIqIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcjo6bWFrZU5vZGU8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpQb3N0Zml4RXhwciwgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiYsIGNoYXIgY29uc3QgKCYpIFszXT4oKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiYsIGNoYXIgY29uc3QgKCYpIFszXSmIDIMFKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkFic3RyYWN0TWFuZ2xpbmdQYXJzZXI8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpNYW5nbGluZ1BhcnNlcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+LCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+OjptYWtlPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6TmV3RXhwciwgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlQXJyYXkmLCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqJiwgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlQXJyYXkmLCBib29sJiwgYm9vbCY+KChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZUFycmF5JiwgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiYsIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZUFycmF5JiwgYm9vbCYsIGJvb2wmKYkMgwUoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6QWJzdHJhY3RNYW5nbGluZ1BhcnNlcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok1hbmdsaW5nUGFyc2VyPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcj4sIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcj46Om1ha2U8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOZXdFeHByLCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGVBcnJheSYsIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSomLCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGVBcnJheSwgYm9vbCYsIGJvb2wmPigoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGVBcnJheSYsIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSomLCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGVBcnJheSYmLCBib29sJiwgYm9vbCYpigzVAihhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6RW5jbG9zaW5nRXhwciogKGFub255bW91cyBuYW1lc3BhY2UpOjpEZWZhdWx0QWxsb2NhdG9yOjptYWtlTm9kZTwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkVuY2xvc2luZ0V4cHIsIGNoYXIgY29uc3QgKCYpIFsxMV0sIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSomLCBjaGFyIGNvbnN0ICgmKSBbMl0+KGNoYXIgY29uc3QgKCYpIFsxMV0sIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSomLCBjaGFyIGNvbnN0ICgmKSBbMl0piwzLAyhhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Q29uZGl0aW9uYWxFeHByKiAoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I6Om1ha2VOb2RlPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Q29uZGl0aW9uYWxFeHByLCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqJiwgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiYsIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSomPigoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqJiwgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiYsIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSomKYwMcWNoYXIgY29uc3QgKCZzdGQ6Ol9fMjo6Zm9yd2FyZDxjaGFyIGNvbnN0ICgmKSBbMTddPihzdGQ6Ol9fMjo6cmVtb3ZlX3JlZmVyZW5jZTxjaGFyIGNvbnN0ICgmKSBbMTddPjo6dHlwZSYpKSBbMTddjQyFAyhhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Q2FzdEV4cHIqIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcjo6bWFrZU5vZGU8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpDYXN0RXhwciwgY2hhciBjb25zdCAoJikgWzE3XSwgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiYsIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSomPihjaGFyIGNvbnN0ICgmKSBbMTddLCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqJiwgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiYpjgyFAyhhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Q2FzdEV4cHIqIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcjo6bWFrZU5vZGU8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpDYXN0RXhwciwgY2hhciBjb25zdCAoJikgWzEyXSwgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiYsIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSomPihjaGFyIGNvbnN0ICgmKSBbMTJdLCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqJiwgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiYpjwyVAihhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6UGFyYW1ldGVyUGFja0V4cGFuc2lvbiogKGFub255bW91cyBuYW1lc3BhY2UpOjpEZWZhdWx0QWxsb2NhdG9yOjptYWtlTm9kZTwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OlBhcmFtZXRlclBhY2tFeHBhbnNpb24sIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSomPigoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqJimQDNMCKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpFbmNsb3NpbmdFeHByKiAoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I6Om1ha2VOb2RlPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6RW5jbG9zaW5nRXhwciwgY2hhciBjb25zdCAoJikgWzldLCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqJiwgY2hhciBjb25zdCAoJikgWzJdPihjaGFyIGNvbnN0ICgmKSBbOV0sIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSomLCBjaGFyIGNvbnN0ICgmKSBbMl0pkQyPAihhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6U2l6ZW9mUGFyYW1QYWNrRXhwciogKGFub255bW91cyBuYW1lc3BhY2UpOjpEZWZhdWx0QWxsb2NhdG9yOjptYWtlTm9kZTwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OlNpemVvZlBhcmFtUGFja0V4cHIsIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSomPigoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqJimSDNUCKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpFbmNsb3NpbmdFeHByKiAoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I6Om1ha2VOb2RlPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6RW5jbG9zaW5nRXhwciwgY2hhciBjb25zdCAoJikgWzEyXSwgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiYsIGNoYXIgY29uc3QgKCYpIFsyXT4oY2hhciBjb25zdCAoJikgWzEyXSwgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiYsIGNoYXIgY29uc3QgKCYpIFsyXSmTDIsCKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlQXJyYXlOb2RlKiAoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I6Om1ha2VOb2RlPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZUFycmF5Tm9kZSwgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlQXJyYXk+KChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZUFycmF5JiYplAzrAihhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6SW5pdExpc3RFeHByKiAoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I6Om1ha2VOb2RlPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6SW5pdExpc3RFeHByLCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqJiwgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlQXJyYXk+KChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSomLCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGVBcnJheSYmKZUMbmNoYXIgY29uc3QgKCZzdGQ6Ol9fMjo6Zm9yd2FyZDxjaGFyIGNvbnN0ICgmKSBbNl0+KHN0ZDo6X18yOjpyZW1vdmVfcmVmZXJlbmNlPGNoYXIgY29uc3QgKCYpIFs2XT46OnR5cGUmKSkgWzZdlgy/AShhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6TmFtZVR5cGUqIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcjo6bWFrZU5vZGU8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOYW1lVHlwZSwgY2hhciBjb25zdCAoJikgWzZdPihjaGFyIGNvbnN0ICgmKSBbNl0plwz7AShhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6VGhyb3dFeHByKiAoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I6Om1ha2VOb2RlPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6VGhyb3dFeHByLCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqJj4oKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiYpmAz9AShhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6VVVJRE9mRXhwciogKGFub255bW91cyBuYW1lc3BhY2UpOjpEZWZhdWx0QWxsb2NhdG9yOjptYWtlTm9kZTwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OlVVSURPZkV4cHIsIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSomPigoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqJimZDJAEKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkFic3RyYWN0TWFuZ2xpbmdQYXJzZXI8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpNYW5nbGluZ1BhcnNlcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+LCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+OjptYWtlPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6SW50ZWdlckxpdGVyYWwsIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6U3RyaW5nVmlldyYsIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6U3RyaW5nVmlldyY+KChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6U3RyaW5nVmlldyYsIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6U3RyaW5nVmlldyYpmgxEaW50JiYgc3RkOjpfXzI6OmZvcndhcmQ8aW50PihzdGQ6Ol9fMjo6cmVtb3ZlX3JlZmVyZW5jZTxpbnQ+Ojp0eXBlJimbDKMBKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpCb29sRXhwciogKGFub255bW91cyBuYW1lc3BhY2UpOjpEZWZhdWx0QWxsb2NhdG9yOjptYWtlTm9kZTwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkJvb2xFeHByLCBpbnQ+KGludCYmKZwMrQMoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6QWJzdHJhY3RNYW5nbGluZ1BhcnNlcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok1hbmdsaW5nUGFyc2VyPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcj4sIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcj46Om1ha2U8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpGbG9hdExpdGVyYWxJbXBsPGZsb2F0PiwgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpTdHJpbmdWaWV3Jj4oKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpTdHJpbmdWaWV3JimdDK4DKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkFic3RyYWN0TWFuZ2xpbmdQYXJzZXI8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpNYW5nbGluZ1BhcnNlcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+LCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+OjptYWtlPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6RmxvYXRMaXRlcmFsSW1wbDxkb3VibGU+LCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OlN0cmluZ1ZpZXcmPigoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OlN0cmluZ1ZpZXcmKZ4MswMoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6QWJzdHJhY3RNYW5nbGluZ1BhcnNlcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok1hbmdsaW5nUGFyc2VyPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcj4sIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcj46Om1ha2U8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpGbG9hdExpdGVyYWxJbXBsPGxvbmcgZG91YmxlPiwgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpTdHJpbmdWaWV3Jj4oKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpTdHJpbmdWaWV3JimfDIMCKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpTdHJpbmdMaXRlcmFsKiAoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I6Om1ha2VOb2RlPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6U3RyaW5nTGl0ZXJhbCwgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiY+KChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSomKaAMbmNoYXIgY29uc3QgKCZzdGQ6Ol9fMjo6Zm9yd2FyZDxjaGFyIGNvbnN0ICgmKSBbOF0+KHN0ZDo6X18yOjpyZW1vdmVfcmVmZXJlbmNlPGNoYXIgY29uc3QgKCYpIFs4XT46OnR5cGUmKSkgWzhdoQy/AShhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6TmFtZVR5cGUqIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcjo6bWFrZU5vZGU8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOYW1lVHlwZSwgY2hhciBjb25zdCAoJikgWzhdPihjaGFyIGNvbnN0ICgmKSBbOF0pogylAyhhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSogKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpBYnN0cmFjdE1hbmdsaW5nUGFyc2VyPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6TWFuZ2xpbmdQYXJzZXI8KGFub255bW91cyBuYW1lc3BhY2UpOjpEZWZhdWx0QWxsb2NhdG9yPiwgKGFub255bW91cyBuYW1lc3BhY2UpOjpEZWZhdWx0QWxsb2NhdG9yPjo6bWFrZTwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OlVubmFtZWRUeXBlTmFtZSwgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpTdHJpbmdWaWV3Jj4oKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpTdHJpbmdWaWV3JimjDHUoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OlN3YXBBbmRSZXN0b3JlPHVuc2lnbmVkIGxvbmc+OjpTd2FwQW5kUmVzdG9yZSh1bnNpZ25lZCBsb25nJiwgdW5zaWduZWQgbG9uZymkDMkDKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpBYnN0cmFjdE1hbmdsaW5nUGFyc2VyPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6TWFuZ2xpbmdQYXJzZXI8KGFub255bW91cyBuYW1lc3BhY2UpOjpEZWZhdWx0QWxsb2NhdG9yPiwgKGFub255bW91cyBuYW1lc3BhY2UpOjpEZWZhdWx0QWxsb2NhdG9yPjo6U2NvcGVkVGVtcGxhdGVQYXJhbUxpc3Q6OlNjb3BlZFRlbXBsYXRlUGFyYW1MaXN0KChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6QWJzdHJhY3RNYW5nbGluZ1BhcnNlcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok1hbmdsaW5nUGFyc2VyPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcj4sIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcj4qKaUMVChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6U3RyaW5nVmlldzo6ZmluZChjaGFyLCB1bnNpZ25lZCBsb25nKSBjb25zdKYM5AEoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkFic3RyYWN0TWFuZ2xpbmdQYXJzZXI8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpNYW5nbGluZ1BhcnNlcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+LCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+OjpwYXJzZVRlbXBsYXRlUGFyYW1EZWNsKCmnDEEoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGVBcnJheTo6ZW1wdHkoKSBjb25zdKgMtwEoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OlBPRFNtYWxsVmVjdG9yPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6UE9EU21hbGxWZWN0b3I8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiwgOHVsPiosIDR1bD46OnBvcF9iYWNrKCmpDPkEKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkFic3RyYWN0TWFuZ2xpbmdQYXJzZXI8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpNYW5nbGluZ1BhcnNlcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+LCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+OjptYWtlPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Q2xvc3VyZVR5cGVOYW1lLCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGVBcnJheSYsIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZUFycmF5JiwgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpTdHJpbmdWaWV3Jj4oKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlQXJyYXkmLCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGVBcnJheSYsIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6U3RyaW5nVmlldyYpqgzcAihhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSogKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpBYnN0cmFjdE1hbmdsaW5nUGFyc2VyPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6TWFuZ2xpbmdQYXJzZXI8KGFub255bW91cyBuYW1lc3BhY2UpOjpEZWZhdWx0QWxsb2NhdG9yPiwgKGFub255bW91cyBuYW1lc3BhY2UpOjpEZWZhdWx0QWxsb2NhdG9yPjo6bWFrZTwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5hbWVUeXBlLCBjaGFyIGNvbnN0ICgmKSBbMTZdPihjaGFyIGNvbnN0ICgmKSBbMTZdKasM/wEoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkFic3RyYWN0TWFuZ2xpbmdQYXJzZXI8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpNYW5nbGluZ1BhcnNlcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+LCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+OjpTY29wZWRUZW1wbGF0ZVBhcmFtTGlzdDo6flNjb3BlZFRlbXBsYXRlUGFyYW1MaXN0KCmsDFkoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OlN3YXBBbmRSZXN0b3JlPHVuc2lnbmVkIGxvbmc+Ojp+U3dhcEFuZFJlc3RvcmUoKa0M/QEoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkxhbWJkYUV4cHIqIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcjo6bWFrZU5vZGU8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpMYW1iZGFFeHByLCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqJj4oKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiYprgzzAihhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6SW50ZWdlckNhc3RFeHByKiAoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I6Om1ha2VOb2RlPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6SW50ZWdlckNhc3RFeHByLCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqJiwgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpTdHJpbmdWaWV3Jj4oKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiYsIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6U3RyaW5nVmlldyYprwz7Aihhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6SW50ZWdlckxpdGVyYWwqIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcjo6bWFrZU5vZGU8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpJbnRlZ2VyTGl0ZXJhbCwgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpTdHJpbmdWaWV3JiwgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpTdHJpbmdWaWV3Jj4oKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpTdHJpbmdWaWV3JiwgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpTdHJpbmdWaWV3JimwDLEBKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpJbnRlZ2VyTGl0ZXJhbDo6SW50ZWdlckxpdGVyYWwoKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpTdHJpbmdWaWV3LCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OlN0cmluZ1ZpZXcpsQyAAShhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6SW50ZWdlckxpdGVyYWw6OnByaW50TGVmdCgoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok91dHB1dFN0cmVhbSYpIGNvbnN0sgxUKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpTdHJpbmdWaWV3OjpvcGVyYXRvcltdKHVuc2lnbmVkIGxvbmcpIGNvbnN0swxTKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpTdHJpbmdWaWV3Ojpkcm9wRnJvbnQodW5zaWduZWQgbG9uZykgY29uc3S0DEooYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkludGVnZXJMaXRlcmFsOjp+SW50ZWdlckxpdGVyYWwoKbUMQShhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Qm9vbEV4cHI6OkJvb2xFeHByKGJvb2wptgx6KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpCb29sRXhwcjo6cHJpbnRMZWZ0KChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6T3V0cHV0U3RyZWFtJikgY29uc3S3DD4oYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkJvb2xFeHByOjp+Qm9vbEV4cHIoKbgMoQIoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkZsb2F0TGl0ZXJhbEltcGw8ZmxvYXQ+KiAoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I6Om1ha2VOb2RlPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6RmxvYXRMaXRlcmFsSW1wbDxmbG9hdD4sIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6U3RyaW5nVmlldyY+KChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6U3RyaW5nVmlldyYpuQyHAShhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6RmxvYXRMaXRlcmFsSW1wbDxmbG9hdD46OkZsb2F0TGl0ZXJhbEltcGwoKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpTdHJpbmdWaWV3KboMiQEoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkZsb2F0TGl0ZXJhbEltcGw8ZmxvYXQ+OjpwcmludExlZnQoKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpPdXRwdXRTdHJlYW0mKSBjb25zdLsMK3ZvaWQgc3RkOjpfXzI6OnJldmVyc2U8Y2hhcio+KGNoYXIqLCBjaGFyKim8DFUoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkZsb2F0TGl0ZXJhbEltcGw8ZmxvYXQ+Ojp+RmxvYXRMaXRlcmFsSW1wbCgpvQxTdm9pZCBzdGQ6Ol9fMjo6X19yZXZlcnNlPGNoYXIqPihjaGFyKiwgY2hhciosIHN0ZDo6X18yOjpyYW5kb21fYWNjZXNzX2l0ZXJhdG9yX3RhZym+DDR2b2lkIHN0ZDo6X18yOjppdGVyX3N3YXA8Y2hhciosIGNoYXIqPihjaGFyKiwgY2hhciopvwyNAXN0ZDo6X18yOjplbmFibGVfaWY8KGlzX21vdmVfY29uc3RydWN0aWJsZTxjaGFyPjo6dmFsdWUpICYmIChpc19tb3ZlX2Fzc2lnbmFibGU8Y2hhcj46OnZhbHVlKSwgdm9pZD46OnR5cGUgc3RkOjpfXzI6OnN3YXA8Y2hhcj4oY2hhciYsIGNoYXImKcAMRnN0ZDo6X18yOjpyZW1vdmVfcmVmZXJlbmNlPGNoYXImPjo6dHlwZSYmIHN0ZDo6X18yOjptb3ZlPGNoYXImPihjaGFyJinBDKMCKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpGbG9hdExpdGVyYWxJbXBsPGRvdWJsZT4qIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcjo6bWFrZU5vZGU8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpGbG9hdExpdGVyYWxJbXBsPGRvdWJsZT4sIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6U3RyaW5nVmlldyY+KChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6U3RyaW5nVmlldyYpwgyIAShhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6RmxvYXRMaXRlcmFsSW1wbDxkb3VibGU+OjpGbG9hdExpdGVyYWxJbXBsKChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6U3RyaW5nVmlldynDDIoBKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpGbG9hdExpdGVyYWxJbXBsPGRvdWJsZT46OnByaW50TGVmdCgoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok91dHB1dFN0cmVhbSYpIGNvbnN0xAxWKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpGbG9hdExpdGVyYWxJbXBsPGRvdWJsZT46On5GbG9hdExpdGVyYWxJbXBsKCnFDK0CKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpGbG9hdExpdGVyYWxJbXBsPGxvbmcgZG91YmxlPiogKGFub255bW91cyBuYW1lc3BhY2UpOjpEZWZhdWx0QWxsb2NhdG9yOjptYWtlTm9kZTwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkZsb2F0TGl0ZXJhbEltcGw8bG9uZyBkb3VibGU+LCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OlN0cmluZ1ZpZXcmPigoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OlN0cmluZ1ZpZXcmKcYMjQEoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkZsb2F0TGl0ZXJhbEltcGw8bG9uZyBkb3VibGU+OjpGbG9hdExpdGVyYWxJbXBsKChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6U3RyaW5nVmlldynHDI8BKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpGbG9hdExpdGVyYWxJbXBsPGxvbmcgZG91YmxlPjo6cHJpbnRMZWZ0KChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6T3V0cHV0U3RyZWFtJikgY29uc3TIDFsoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkZsb2F0TGl0ZXJhbEltcGw8bG9uZyBkb3VibGU+Ojp+RmxvYXRMaXRlcmFsSW1wbCgpyQx7KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpTdHJpbmdMaXRlcmFsOjpTdHJpbmdMaXRlcmFsKChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSBjb25zdCopygx/KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpTdHJpbmdMaXRlcmFsOjpwcmludExlZnQoKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpPdXRwdXRTdHJlYW0mKSBjb25zdMsMSChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6U3RyaW5nTGl0ZXJhbDo6flN0cmluZ0xpdGVyYWwoKcwMkQIoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OlVubmFtZWRUeXBlTmFtZSogKGFub255bW91cyBuYW1lc3BhY2UpOjpEZWZhdWx0QWxsb2NhdG9yOjptYWtlTm9kZTwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OlVubmFtZWRUeXBlTmFtZSwgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpTdHJpbmdWaWV3Jj4oKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpTdHJpbmdWaWV3JinNDGFzdGQ6Ol9fMjo6cmVtb3ZlX3JlZmVyZW5jZTx1bnNpZ25lZCBsb25nJj46OnR5cGUmJiBzdGQ6Ol9fMjo6bW92ZTx1bnNpZ25lZCBsb25nJj4odW5zaWduZWQgbG9uZyYpzgw4bWVtY2hyKHZvaWQgY29uc3QqLCBpbnQsIHVuc2lnbmVkIGxvbmcpIFtlbmFibGVfaWY6dHJ1ZV3PDPgCKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpBYnN0cmFjdE1hbmdsaW5nUGFyc2VyPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6TWFuZ2xpbmdQYXJzZXI8KGFub255bW91cyBuYW1lc3BhY2UpOjpEZWZhdWx0QWxsb2NhdG9yPiwgKGFub255bW91cyBuYW1lc3BhY2UpOjpEZWZhdWx0QWxsb2NhdG9yPjo6cGFyc2VUZW1wbGF0ZVBhcmFtRGVjbCgpOjonbGFtYmRhJygoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OlRlbXBsYXRlUGFyYW1LaW5kKTo6b3BlcmF0b3IoKSgoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OlRlbXBsYXRlUGFyYW1LaW5kKSBjb25zdNAMoQMoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6QWJzdHJhY3RNYW5nbGluZ1BhcnNlcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok1hbmdsaW5nUGFyc2VyPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcj4sIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcj46Om1ha2U8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpUeXBlVGVtcGxhdGVQYXJhbURlY2wsIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSomPigoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqJinRDIYEKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkFic3RyYWN0TWFuZ2xpbmdQYXJzZXI8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpNYW5nbGluZ1BhcnNlcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+LCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+OjptYWtlPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9uVHlwZVRlbXBsYXRlUGFyYW1EZWNsLCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqJiwgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiY+KChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSomLCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqJinSDI8EKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkFic3RyYWN0TWFuZ2xpbmdQYXJzZXI8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpNYW5nbGluZ1BhcnNlcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+LCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+OjptYWtlPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6VGVtcGxhdGVUZW1wbGF0ZVBhcmFtRGVjbCwgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiYsIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZUFycmF5Jj4oKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiYsIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZUFycmF5JinTDKEDKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkFic3RyYWN0TWFuZ2xpbmdQYXJzZXI8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpNYW5nbGluZ1BhcnNlcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+LCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+OjptYWtlPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6VGVtcGxhdGVQYXJhbVBhY2tEZWNsLCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqJj4oKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiYp1AzlAyhhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Q2xvc3VyZVR5cGVOYW1lKiAoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I6Om1ha2VOb2RlPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Q2xvc3VyZVR5cGVOYW1lLCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGVBcnJheSYsIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZUFycmF5JiwgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpTdHJpbmdWaWV3Jj4oKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlQXJyYXkmLCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGVBcnJheSYsIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6U3RyaW5nVmlldyYp1QzEAShhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6UE9EU21hbGxWZWN0b3I8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpQT0RTbWFsbFZlY3RvcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqLCA4dWw+KiwgNHVsPjo6ZHJvcEJhY2sodW5zaWduZWQgbG9uZynWDHFjaGFyIGNvbnN0ICgmc3RkOjpfXzI6OmZvcndhcmQ8Y2hhciBjb25zdCAoJikgWzE2XT4oc3RkOjpfXzI6OnJlbW92ZV9yZWZlcmVuY2U8Y2hhciBjb25zdCAoJikgWzE2XT46OnR5cGUmKSkgWzE2XdcMwQEoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5hbWVUeXBlKiAoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I6Om1ha2VOb2RlPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6TmFtZVR5cGUsIGNoYXIgY29uc3QgKCYpIFsxNl0+KGNoYXIgY29uc3QgKCYpIFsxNl0p2Ax+KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpVbm5hbWVkVHlwZU5hbWU6OlVubmFtZWRUeXBlTmFtZSgoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OlN0cmluZ1ZpZXcp2QyBAShhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6VW5uYW1lZFR5cGVOYW1lOjpwcmludExlZnQoKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpPdXRwdXRTdHJlYW0mKSBjb25zdNoMTChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6VW5uYW1lZFR5cGVOYW1lOjp+VW5uYW1lZFR5cGVOYW1lKCnbDDBfX2xpYmNwcF9tZW1jaHIodm9pZCBjb25zdCosIGludCwgdW5zaWduZWQgbG9uZyncDNwDKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkFic3RyYWN0TWFuZ2xpbmdQYXJzZXI8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpNYW5nbGluZ1BhcnNlcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+LCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+OjptYWtlPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6U3ludGhldGljVGVtcGxhdGVQYXJhbU5hbWUsIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6VGVtcGxhdGVQYXJhbUtpbmQmLCB1bnNpZ25lZCBpbnQmPigoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OlRlbXBsYXRlUGFyYW1LaW5kJiwgdW5zaWduZWQgaW50JindDJMCKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpUeXBlVGVtcGxhdGVQYXJhbURlY2wqIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcjo6bWFrZU5vZGU8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpUeXBlVGVtcGxhdGVQYXJhbURlY2wsIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSomPigoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqJineDPsCKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb25UeXBlVGVtcGxhdGVQYXJhbURlY2wqIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcjo6bWFrZU5vZGU8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb25UeXBlVGVtcGxhdGVQYXJhbURlY2wsIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSomLCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqJj4oKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiYsIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSomKd8MhQMoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OlRlbXBsYXRlVGVtcGxhdGVQYXJhbURlY2wqIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcjo6bWFrZU5vZGU8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpUZW1wbGF0ZVRlbXBsYXRlUGFyYW1EZWNsLCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqJiwgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlQXJyYXkmPigoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqJiwgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlQXJyYXkmKeAMkwIoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OlRlbXBsYXRlUGFyYW1QYWNrRGVjbCogKGFub255bW91cyBuYW1lc3BhY2UpOjpEZWZhdWx0QWxsb2NhdG9yOjptYWtlTm9kZTwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OlRlbXBsYXRlUGFyYW1QYWNrRGVjbCwgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiY+KChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSomKeEMYHVuc2lnbmVkIGludCYgc3RkOjpfXzI6OmZvcndhcmQ8dW5zaWduZWQgaW50Jj4oc3RkOjpfXzI6OnJlbW92ZV9yZWZlcmVuY2U8dW5zaWduZWQgaW50Jj46OnR5cGUmKeIM0wIoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OlN5bnRoZXRpY1RlbXBsYXRlUGFyYW1OYW1lKiAoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I6Om1ha2VOb2RlPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6U3ludGhldGljVGVtcGxhdGVQYXJhbU5hbWUsIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6VGVtcGxhdGVQYXJhbUtpbmQmLCB1bnNpZ25lZCBpbnQmPigoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OlRlbXBsYXRlUGFyYW1LaW5kJiwgdW5zaWduZWQgaW50JinjDIQBKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpQT0RTbWFsbFZlY3RvcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqLCA4dWw+OjpyZXNlcnZlKHVuc2lnbmVkIGxvbmcp5AypAShhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6U3ludGhldGljVGVtcGxhdGVQYXJhbU5hbWU6OlN5bnRoZXRpY1RlbXBsYXRlUGFyYW1OYW1lKChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6VGVtcGxhdGVQYXJhbUtpbmQsIHVuc2lnbmVkIGludCnlDIwBKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpTeW50aGV0aWNUZW1wbGF0ZVBhcmFtTmFtZTo6cHJpbnRMZWZ0KChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6T3V0cHV0U3RyZWFtJikgY29uc3TmDE8oYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok91dHB1dFN0cmVhbTo6b3BlcmF0b3I8PCh1bnNpZ25lZCBpbnQp5wxiKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpTeW50aGV0aWNUZW1wbGF0ZVBhcmFtTmFtZTo6flN5bnRoZXRpY1RlbXBsYXRlUGFyYW1OYW1lKCnoDFUoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok91dHB1dFN0cmVhbTo6b3BlcmF0b3I8PCh1bnNpZ25lZCBsb25nIGxvbmcp6QxeKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpPdXRwdXRTdHJlYW06OndyaXRlVW5zaWduZWQodW5zaWduZWQgbG9uZyBsb25nLCBib29sKeoMRyhhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6T3V0cHV0U3RyZWFtOjpvcGVyYXRvcjw8KGNoYXIp6wwwY2hhciogc3RkOjpfXzI6OmVuZDxjaGFyLCAyMXVsPihjaGFyICgmKSBbMjF1bF0p7Ax2KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpPdXRwdXRTdHJlYW06Om9wZXJhdG9yPDwoKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpTdHJpbmdWaWV3Ke0MswIoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqKiBzdGQ6Ol9fMjo6Y29weTwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqKiwgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKio+KChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSoqLCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqKiwgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiop7gy3BHN0ZDo6X18yOjplbmFibGVfaWY8KGlzX3NhbWU8c3RkOjpfXzI6OnJlbW92ZV9jb25zdDwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqPjo6dHlwZSwgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKj46OnZhbHVlKSAmJiAoaXNfdHJpdmlhbGx5X2NvcHlfYXNzaWduYWJsZTwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqPjo6dmFsdWUpLCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqKj46OnR5cGUgc3RkOjpfXzI6Ol9fY29weTwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqLCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqPigoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqKiwgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiosIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSoqKe8MhQEoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OlR5cGVUZW1wbGF0ZVBhcmFtRGVjbDo6VHlwZVRlbXBsYXRlUGFyYW1EZWNsKChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSop8AyHAShhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6VHlwZVRlbXBsYXRlUGFyYW1EZWNsOjpwcmludExlZnQoKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpPdXRwdXRTdHJlYW0mKSBjb25zdPEMiAEoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OlR5cGVUZW1wbGF0ZVBhcmFtRGVjbDo6cHJpbnRSaWdodCgoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok91dHB1dFN0cmVhbSYpIGNvbnN08gxYKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpUeXBlVGVtcGxhdGVQYXJhbURlY2w6On5UeXBlVGVtcGxhdGVQYXJhbURlY2woKfMMuwEoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vblR5cGVUZW1wbGF0ZVBhcmFtRGVjbDo6Tm9uVHlwZVRlbXBsYXRlUGFyYW1EZWNsKChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSosIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSop9AyKAShhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9uVHlwZVRlbXBsYXRlUGFyYW1EZWNsOjpwcmludExlZnQoKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpPdXRwdXRTdHJlYW0mKSBjb25zdPUMiwEoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vblR5cGVUZW1wbGF0ZVBhcmFtRGVjbDo6cHJpbnRSaWdodCgoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok91dHB1dFN0cmVhbSYpIGNvbnN09gxeKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb25UeXBlVGVtcGxhdGVQYXJhbURlY2w6On5Ob25UeXBlVGVtcGxhdGVQYXJhbURlY2woKfcMwQEoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OlRlbXBsYXRlVGVtcGxhdGVQYXJhbURlY2w6OlRlbXBsYXRlVGVtcGxhdGVQYXJhbURlY2woKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiwgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlQXJyYXkp+AyLAShhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6VGVtcGxhdGVUZW1wbGF0ZVBhcmFtRGVjbDo6cHJpbnRMZWZ0KChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6T3V0cHV0U3RyZWFtJikgY29uc3T5DIABKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlQXJyYXk6OnByaW50V2l0aENvbW1hKChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6T3V0cHV0U3RyZWFtJikgY29uc3T6DIwBKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpUZW1wbGF0ZVRlbXBsYXRlUGFyYW1EZWNsOjpwcmludFJpZ2h0KChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6T3V0cHV0U3RyZWFtJikgY29uc3T7DGAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OlRlbXBsYXRlVGVtcGxhdGVQYXJhbURlY2w6On5UZW1wbGF0ZVRlbXBsYXRlUGFyYW1EZWNsKCn8DFgoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok91dHB1dFN0cmVhbTo6c2V0Q3VycmVudFBvc2l0aW9uKHVuc2lnbmVkIGxvbmcp/QyFAShhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6VGVtcGxhdGVQYXJhbVBhY2tEZWNsOjpUZW1wbGF0ZVBhcmFtUGFja0RlY2woKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKin+DIcBKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpUZW1wbGF0ZVBhcmFtUGFja0RlY2w6OnByaW50TGVmdCgoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok91dHB1dFN0cmVhbSYpIGNvbnN0/wyIAShhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6VGVtcGxhdGVQYXJhbVBhY2tEZWNsOjpwcmludFJpZ2h0KChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6T3V0cHV0U3RyZWFtJikgY29uc3SADVgoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OlRlbXBsYXRlUGFyYW1QYWNrRGVjbDo6flRlbXBsYXRlUGFyYW1QYWNrRGVjbCgpgQ3mAShhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Q2xvc3VyZVR5cGVOYW1lOjpDbG9zdXJlVHlwZU5hbWUoKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlQXJyYXksIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZUFycmF5LCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OlN0cmluZ1ZpZXcpgg2BAShhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Q2xvc3VyZVR5cGVOYW1lOjpwcmludExlZnQoKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpPdXRwdXRTdHJlYW0mKSBjb25zdIMNhwEoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkNsb3N1cmVUeXBlTmFtZTo6cHJpbnREZWNsYXJhdG9yKChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6T3V0cHV0U3RyZWFtJikgY29uc3SEDUwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkNsb3N1cmVUeXBlTmFtZTo6fkNsb3N1cmVUeXBlTmFtZSgphQ11KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpMYW1iZGFFeHByOjpMYW1iZGFFeHByKChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSBjb25zdCophg18KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpMYW1iZGFFeHByOjpwcmludExlZnQoKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpPdXRwdXRTdHJlYW0mKSBjb25zdIcNQihhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6TGFtYmRhRXhwcjo6fkxhbWJkYUV4cHIoKYgNtAEoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkludGVnZXJDYXN0RXhwcjo6SW50ZWdlckNhc3RFeHByKChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSBjb25zdCosIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6U3RyaW5nVmlldymJDYEBKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpJbnRlZ2VyQ2FzdEV4cHI6OnByaW50TGVmdCgoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok91dHB1dFN0cmVhbSYpIGNvbnN0ig1MKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpJbnRlZ2VyQ2FzdEV4cHI6On5JbnRlZ2VyQ2FzdEV4cHIoKYsNjQIoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkZ1bmN0aW9uUGFyYW0qIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcjo6bWFrZU5vZGU8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpGdW5jdGlvblBhcmFtLCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OlN0cmluZ1ZpZXcmPigoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OlN0cmluZ1ZpZXcmKYwNeihhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6RnVuY3Rpb25QYXJhbTo6RnVuY3Rpb25QYXJhbSgoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OlN0cmluZ1ZpZXcpjQ1/KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpGdW5jdGlvblBhcmFtOjpwcmludExlZnQoKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpPdXRwdXRTdHJlYW0mKSBjb25zdI4NOChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZTo6fk5vZGUoKS4xjw1IKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpGdW5jdGlvblBhcmFtOjp+RnVuY3Rpb25QYXJhbSgpkA3VAyhhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Rm9sZEV4cHIqIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcjo6bWFrZU5vZGU8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpGb2xkRXhwciwgYm9vbCYsIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6U3RyaW5nVmlldyYsIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSomLCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqJj4oYm9vbCYsIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6U3RyaW5nVmlldyYsIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSomLCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqJimRDeIBKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpGb2xkRXhwcjo6Rm9sZEV4cHIoYm9vbCwgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpTdHJpbmdWaWV3LCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUgY29uc3QqLCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUgY29uc3QqKZINeihhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Rm9sZEV4cHI6OnByaW50TGVmdCgoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok91dHB1dFN0cmVhbSYpIGNvbnN0kw2aAShhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Rm9sZEV4cHI6OnByaW50TGVmdCgoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok91dHB1dFN0cmVhbSYpIGNvbnN0OjonbGFtYmRhJygpOjpvcGVyYXRvcigpKCkgY29uc3SUDT4oYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkZvbGRFeHByOjp+Rm9sZEV4cHIoKZUNjQEoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OlBhcmFtZXRlclBhY2tFeHBhbnNpb246OlBhcmFtZXRlclBhY2tFeHBhbnNpb24oKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlIGNvbnN0KimWDYgBKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpQYXJhbWV0ZXJQYWNrRXhwYW5zaW9uOjpwcmludExlZnQoKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpPdXRwdXRTdHJlYW0mKSBjb25zdJcNcihhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6U3dhcEFuZFJlc3RvcmU8dW5zaWduZWQgaW50Pjo6U3dhcEFuZFJlc3RvcmUodW5zaWduZWQgaW50JiwgdW5zaWduZWQgaW50KZgNWChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6U3dhcEFuZFJlc3RvcmU8dW5zaWduZWQgaW50Pjo6flN3YXBBbmRSZXN0b3JlKCmZDVooYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OlBhcmFtZXRlclBhY2tFeHBhbnNpb246On5QYXJhbWV0ZXJQYWNrRXhwYW5zaW9uKCmaDV5zdGQ6Ol9fMjo6cmVtb3ZlX3JlZmVyZW5jZTx1bnNpZ25lZCBpbnQmPjo6dHlwZSYmIHN0ZDo6X18yOjptb3ZlPHVuc2lnbmVkIGludCY+KHVuc2lnbmVkIGludCYpmw3LAyhhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6QmluYXJ5RXhwciogKGFub255bW91cyBuYW1lc3BhY2UpOjpEZWZhdWx0QWxsb2NhdG9yOjptYWtlTm9kZTwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkJpbmFyeUV4cHIsIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSomLCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OlN0cmluZ1ZpZXcmLCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqJj4oKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiYsIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6U3RyaW5nVmlldyYsIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSomKZwN4AEoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkJpbmFyeUV4cHI6OkJpbmFyeUV4cHIoKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlIGNvbnN0KiwgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpTdHJpbmdWaWV3LCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUgY29uc3QqKZ0NfChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6QmluYXJ5RXhwcjo6cHJpbnRMZWZ0KChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6T3V0cHV0U3RyZWFtJikgY29uc3SeDasBKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpvcGVyYXRvcj09KChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6U3RyaW5nVmlldyBjb25zdCYsIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6U3RyaW5nVmlldyBjb25zdCYpnw1CKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpCaW5hcnlFeHByOjp+QmluYXJ5RXhwcigpoA3pAihhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6UHJlZml4RXhwciogKGFub255bW91cyBuYW1lc3BhY2UpOjpEZWZhdWx0QWxsb2NhdG9yOjptYWtlTm9kZTwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OlByZWZpeEV4cHIsIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6U3RyaW5nVmlldyYsIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSomPigoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OlN0cmluZ1ZpZXcmLCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqJimhDaQBKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpQcmVmaXhFeHByOjpQcmVmaXhFeHByKChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6U3RyaW5nVmlldywgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKimiDXwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OlByZWZpeEV4cHI6OnByaW50TGVmdCgoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok91dHB1dFN0cmVhbSYpIGNvbnN0ow1CKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpQcmVmaXhFeHByOjp+UHJlZml4RXhwcigppA3cAShhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Q2FzdEV4cHI6OkNhc3RFeHByKChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6U3RyaW5nVmlldywgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlIGNvbnN0KiwgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlIGNvbnN0KimlDXooYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkNhc3RFeHByOjpwcmludExlZnQoKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpPdXRwdXRTdHJlYW0mKSBjb25zdKYNPihhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Q2FzdEV4cHI6On5DYXN0RXhwcigppw2lAShhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Q2FsbEV4cHI6OkNhbGxFeHByKChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSBjb25zdCosIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZUFycmF5KagNeihhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Q2FsbEV4cHI6OnByaW50TGVmdCgoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok91dHB1dFN0cmVhbSYpIGNvbnN0qQ0+KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpDYWxsRXhwcjo6fkNhbGxFeHByKCmqDe8CKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpDb252ZXJzaW9uRXhwciogKGFub255bW91cyBuYW1lc3BhY2UpOjpEZWZhdWx0QWxsb2NhdG9yOjptYWtlTm9kZTwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkNvbnZlcnNpb25FeHByLCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqJiwgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlQXJyYXkmPigoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqJiwgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlQXJyYXkmKasN7wIoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkNvbnZlcnNpb25FeHByKiAoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I6Om1ha2VOb2RlPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Q29udmVyc2lvbkV4cHIsIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSomLCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGVBcnJheT4oKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiYsIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZUFycmF5JiYprA1JKGFub255bW91cyBuYW1lc3BhY2UpOjpEZWZhdWx0QWxsb2NhdG9yOjphbGxvY2F0ZU5vZGVBcnJheSh1bnNpZ25lZCBsb25nKa0NfShhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZUFycmF5OjpOb2RlQXJyYXkoKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiosIHVuc2lnbmVkIGxvbmcprg2xAShhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Q29udmVyc2lvbkV4cHI6OkNvbnZlcnNpb25FeHByKChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSBjb25zdCosIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZUFycmF5Ka8NgAEoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkNvbnZlcnNpb25FeHByOjpwcmludExlZnQoKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpPdXRwdXRTdHJlYW0mKSBjb25zdLANSihhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Q29udmVyc2lvbkV4cHI6On5Db252ZXJzaW9uRXhwcigpsQ17KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpEZWxldGVFeHByOjpEZWxldGVFeHByKChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSosIGJvb2wsIGJvb2wpsg18KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpEZWxldGVFeHByOjpwcmludExlZnQoKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpPdXRwdXRTdHJlYW0mKSBjb25zdLMNQihhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6RGVsZXRlRXhwcjo6fkRlbGV0ZUV4cHIoKbQN5QIoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OlF1YWxpZmllZE5hbWUqIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcjo6bWFrZU5vZGU8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpRdWFsaWZpZWROYW1lLCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqJiwgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiY+KChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSomLCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqJim1DeEBKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpBYnN0cmFjdE1hbmdsaW5nUGFyc2VyPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6TWFuZ2xpbmdQYXJzZXI8KGFub255bW91cyBuYW1lc3BhY2UpOjpEZWZhdWx0QWxsb2NhdG9yPiwgKGFub255bW91cyBuYW1lc3BhY2UpOjpEZWZhdWx0QWxsb2NhdG9yPjo6cGFyc2VEZXN0cnVjdG9yTmFtZSgptg2PAihhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6R2xvYmFsUXVhbGlmaWVkTmFtZSogKGFub255bW91cyBuYW1lc3BhY2UpOjpEZWZhdWx0QWxsb2NhdG9yOjptYWtlTm9kZTwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Okdsb2JhbFF1YWxpZmllZE5hbWUsIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSomPigoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqJim3DdwCKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkFic3RyYWN0TWFuZ2xpbmdQYXJzZXI8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpNYW5nbGluZ1BhcnNlcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+LCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+OjptYWtlPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6TmFtZVR5cGUsIGNoYXIgY29uc3QgKCYpIFsyMl0+KGNoYXIgY29uc3QgKCYpIFsyMl0puA3BAShhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6TmFtZVR5cGUqIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcjo6bWFrZU5vZGU8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOYW1lVHlwZSwgY2hhciBjb25zdCAoJikgWzIyXT4oY2hhciBjb25zdCAoJikgWzIyXSm5DYMCKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOYW1lVHlwZSogKGFub255bW91cyBuYW1lc3BhY2UpOjpEZWZhdWx0QWxsb2NhdG9yOjptYWtlTm9kZTwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5hbWVUeXBlLCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OlN0cmluZ1ZpZXcmPigoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OlN0cmluZ1ZpZXcmKboNsQEoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OlF1YWxpZmllZE5hbWU6OlF1YWxpZmllZE5hbWUoKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlIGNvbnN0KiwgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlIGNvbnN0Kim7DX8oYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OlF1YWxpZmllZE5hbWU6OnByaW50TGVmdCgoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok91dHB1dFN0cmVhbSYpIGNvbnN0vA1LKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpRdWFsaWZpZWROYW1lOjpnZXRCYXNlTmFtZSgpIGNvbnN0vQ1IKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpRdWFsaWZpZWROYW1lOjp+UXVhbGlmaWVkTmFtZSgpvg2UAyhhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSogKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpBYnN0cmFjdE1hbmdsaW5nUGFyc2VyPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6TWFuZ2xpbmdQYXJzZXI8KGFub255bW91cyBuYW1lc3BhY2UpOjpEZWZhdWx0QWxsb2NhdG9yPiwgKGFub255bW91cyBuYW1lc3BhY2UpOjpEZWZhdWx0QWxsb2NhdG9yPjo6bWFrZTwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkR0b3JOYW1lLCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqJj4oKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiYpvw2iAyhhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSogKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpBYnN0cmFjdE1hbmdsaW5nUGFyc2VyPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6TWFuZ2xpbmdQYXJzZXI8KGFub255bW91cyBuYW1lc3BhY2UpOjpEZWZhdWx0QWxsb2NhdG9yPiwgKGFub255bW91cyBuYW1lc3BhY2UpOjpEZWZhdWx0QWxsb2NhdG9yPjo6bWFrZTwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkNvbnZlcnNpb25PcGVyYXRvclR5cGUsIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSomPigoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqJinADZsDKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkFic3RyYWN0TWFuZ2xpbmdQYXJzZXI8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpNYW5nbGluZ1BhcnNlcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+LCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+OjptYWtlPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6TGl0ZXJhbE9wZXJhdG9yLCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqJj4oKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiYpwQ35AShhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6RHRvck5hbWUqIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcjo6bWFrZU5vZGU8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpEdG9yTmFtZSwgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiY+KChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSomKcINcShhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6RHRvck5hbWU6OkR0b3JOYW1lKChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSBjb25zdCopww16KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpEdG9yTmFtZTo6cHJpbnRMZWZ0KChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6T3V0cHV0U3RyZWFtJikgY29uc3TEDT4oYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkR0b3JOYW1lOjp+RHRvck5hbWUoKcUNwQEoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5hbWVUeXBlKiAoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I6Om1ha2VOb2RlPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6TmFtZVR5cGUsIGNoYXIgY29uc3QgKCYpIFsxMV0+KGNoYXIgY29uc3QgKCYpIFsxMV0pxg3BAShhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6TmFtZVR5cGUqIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcjo6bWFrZU5vZGU8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOYW1lVHlwZSwgY2hhciBjb25zdCAoJikgWzEwXT4oY2hhciBjb25zdCAoJikgWzEwXSnHDZUCKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpDb252ZXJzaW9uT3BlcmF0b3JUeXBlKiAoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I6Om1ha2VOb2RlPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Q29udmVyc2lvbk9wZXJhdG9yVHlwZSwgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiY+KChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSomKcgNwQEoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5hbWVUeXBlKiAoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I6Om1ha2VOb2RlPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6TmFtZVR5cGUsIGNoYXIgY29uc3QgKCYpIFsxOF0+KGNoYXIgY29uc3QgKCYpIFsxOF0pyQ2HAihhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6TGl0ZXJhbE9wZXJhdG9yKiAoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I6Om1ha2VOb2RlPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6TGl0ZXJhbE9wZXJhdG9yLCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqJj4oKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiYpyg3BAShhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6TmFtZVR5cGUqIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcjo6bWFrZU5vZGU8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOYW1lVHlwZSwgY2hhciBjb25zdCAoJikgWzEyXT4oY2hhciBjb25zdCAoJikgWzEyXSnLDXFjaGFyIGNvbnN0ICgmc3RkOjpfXzI6OmZvcndhcmQ8Y2hhciBjb25zdCAoJikgWzE1XT4oc3RkOjpfXzI6OnJlbW92ZV9yZWZlcmVuY2U8Y2hhciBjb25zdCAoJikgWzE1XT46OnR5cGUmKSkgWzE1XcwNwQEoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5hbWVUeXBlKiAoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I6Om1ha2VOb2RlPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6TmFtZVR5cGUsIGNoYXIgY29uc3QgKCYpIFsxNV0+KGNoYXIgY29uc3QgKCYpIFsxNV0pzQ3BAShhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6TmFtZVR5cGUqIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcjo6bWFrZU5vZGU8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOYW1lVHlwZSwgY2hhciBjb25zdCAoJikgWzEzXT4oY2hhciBjb25zdCAoJikgWzEzXSnODY0BKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpDb252ZXJzaW9uT3BlcmF0b3JUeXBlOjpDb252ZXJzaW9uT3BlcmF0b3JUeXBlKChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSBjb25zdCopzw2IAShhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Q29udmVyc2lvbk9wZXJhdG9yVHlwZTo6cHJpbnRMZWZ0KChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6T3V0cHV0U3RyZWFtJikgY29uc3TQDVooYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkNvbnZlcnNpb25PcGVyYXRvclR5cGU6On5Db252ZXJzaW9uT3BlcmF0b3JUeXBlKCnRDX8oYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkxpdGVyYWxPcGVyYXRvcjo6TGl0ZXJhbE9wZXJhdG9yKChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSBjb25zdCop0g2BAShhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6TGl0ZXJhbE9wZXJhdG9yOjpwcmludExlZnQoKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpPdXRwdXRTdHJlYW0mKSBjb25zdNMNTChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6TGl0ZXJhbE9wZXJhdG9yOjp+TGl0ZXJhbE9wZXJhdG9yKCnUDYEBKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpHbG9iYWxRdWFsaWZpZWROYW1lOjpHbG9iYWxRdWFsaWZpZWROYW1lKChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSop1Q2FAShhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6R2xvYmFsUXVhbGlmaWVkTmFtZTo6cHJpbnRMZWZ0KChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6T3V0cHV0U3RyZWFtJikgY29uc3TWDVEoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Okdsb2JhbFF1YWxpZmllZE5hbWU6OmdldEJhc2VOYW1lKCkgY29uc3TXDVQoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Okdsb2JhbFF1YWxpZmllZE5hbWU6On5HbG9iYWxRdWFsaWZpZWROYW1lKCnYDeABKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpNZW1iZXJFeHByOjpNZW1iZXJFeHByKChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSBjb25zdCosIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6U3RyaW5nVmlldywgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlIGNvbnN0KinZDXwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok1lbWJlckV4cHI6OnByaW50TGVmdCgoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok91dHB1dFN0cmVhbSYpIGNvbnN02g1CKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpNZW1iZXJFeHByOjp+TWVtYmVyRXhwcigp2w27AShhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6QXJyYXlTdWJzY3JpcHRFeHByOjpBcnJheVN1YnNjcmlwdEV4cHIoKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlIGNvbnN0KiwgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlIGNvbnN0KincDYQBKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpBcnJheVN1YnNjcmlwdEV4cHI6OnByaW50TGVmdCgoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok91dHB1dFN0cmVhbSYpIGNvbnN03Q1SKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpBcnJheVN1YnNjcmlwdEV4cHI6On5BcnJheVN1YnNjcmlwdEV4cHIoKd4N7QIoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkJyYWNlZEV4cHIqIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcjo6bWFrZU5vZGU8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpCcmFjZWRFeHByLCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqJiwgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiYsIGJvb2w+KChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSomLCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqJiwgYm9vbCYmKd8NywMoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkJyYWNlZFJhbmdlRXhwciogKGFub255bW91cyBuYW1lc3BhY2UpOjpEZWZhdWx0QWxsb2NhdG9yOjptYWtlTm9kZTwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkJyYWNlZFJhbmdlRXhwciwgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiYsIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSomLCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqJj4oKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiYsIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSomLCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqJingDbEBKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpCcmFjZWRFeHByOjpCcmFjZWRFeHByKChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSBjb25zdCosIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSBjb25zdCosIGJvb2wp4Q18KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpCcmFjZWRFeHByOjpwcmludExlZnQoKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpPdXRwdXRTdHJlYW0mKSBjb25zdOINQihhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6QnJhY2VkRXhwcjo6fkJyYWNlZEV4cHIoKeMN6wEoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkJyYWNlZFJhbmdlRXhwcjo6QnJhY2VkUmFuZ2VFeHByKChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSBjb25zdCosIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSBjb25zdCosIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSBjb25zdCop5A2BAShhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6QnJhY2VkUmFuZ2VFeHByOjpwcmludExlZnQoKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpPdXRwdXRTdHJlYW0mKSBjb25zdOUNTChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6QnJhY2VkUmFuZ2VFeHByOjp+QnJhY2VkUmFuZ2VFeHByKCnmDa0BKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpJbml0TGlzdEV4cHI6OkluaXRMaXN0RXhwcigoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUgY29uc3QqLCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGVBcnJheSnnDX4oYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkluaXRMaXN0RXhwcjo6cHJpbnRMZWZ0KChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6T3V0cHV0U3RyZWFtJikgY29uc3ToDUYoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkluaXRMaXN0RXhwcjo6fkluaXRMaXN0RXhwcigp6Q2sAShhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6UG9zdGZpeEV4cHI6OlBvc3RmaXhFeHByKChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSBjb25zdCosIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6U3RyaW5nVmlldynqDX0oYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OlBvc3RmaXhFeHByOjpwcmludExlZnQoKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpPdXRwdXRTdHJlYW0mKSBjb25zdOsNRChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6UG9zdGZpeEV4cHI6On5Qb3N0Zml4RXhwcigp7A3nAyhhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6TmV3RXhwciogKGFub255bW91cyBuYW1lc3BhY2UpOjpEZWZhdWx0QWxsb2NhdG9yOjptYWtlTm9kZTwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5ld0V4cHIsIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZUFycmF5JiwgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiYsIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZUFycmF5JiwgYm9vbCYsIGJvb2wmPigoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGVBcnJheSYsIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSomLCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGVBcnJheSYsIGJvb2wmLCBib29sJintDecDKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOZXdFeHByKiAoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I6Om1ha2VOb2RlPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6TmV3RXhwciwgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlQXJyYXkmLCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqJiwgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlQXJyYXksIGJvb2wmLCBib29sJj4oKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlQXJyYXkmLCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqJiwgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlQXJyYXkmJiwgYm9vbCYsIGJvb2wmKe4N3QEoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5ld0V4cHI6Ok5ld0V4cHIoKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlQXJyYXksIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSosIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZUFycmF5LCBib29sLCBib29sKe8NeShhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6TmV3RXhwcjo6cHJpbnRMZWZ0KChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6T3V0cHV0U3RyZWFtJikgY29uc3TwDTwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5ld0V4cHI6On5OZXdFeHByKCnxDd8BKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpFbmNsb3NpbmdFeHByOjpFbmNsb3NpbmdFeHByKChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6U3RyaW5nVmlldywgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiwgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpTdHJpbmdWaWV3KfINfyhhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6RW5jbG9zaW5nRXhwcjo6cHJpbnRMZWZ0KChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6T3V0cHV0U3RyZWFtJikgY29uc3TzDUgoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkVuY2xvc2luZ0V4cHI6On5FbmNsb3NpbmdFeHByKCn0DesBKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpDb25kaXRpb25hbEV4cHI6OkNvbmRpdGlvbmFsRXhwcigoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUgY29uc3QqLCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUgY29uc3QqLCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUgY29uc3QqKfUNgQEoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkNvbmRpdGlvbmFsRXhwcjo6cHJpbnRMZWZ0KChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6T3V0cHV0U3RyZWFtJikgY29uc3T2DUwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkNvbmRpdGlvbmFsRXhwcjo6fkNvbmRpdGlvbmFsRXhwcigp9w2HAShhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6U2l6ZW9mUGFyYW1QYWNrRXhwcjo6U2l6ZW9mUGFyYW1QYWNrRXhwcigoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUgY29uc3QqKfgNhQEoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OlNpemVvZlBhcmFtUGFja0V4cHI6OnByaW50TGVmdCgoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok91dHB1dFN0cmVhbSYpIGNvbnN0+Q1UKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpTaXplb2ZQYXJhbVBhY2tFeHByOjp+U2l6ZW9mUGFyYW1QYWNrRXhwcigp+g15KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlQXJyYXlOb2RlOjpOb2RlQXJyYXlOb2RlKChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZUFycmF5KfsNfyhhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZUFycmF5Tm9kZTo6cHJpbnRMZWZ0KChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6T3V0cHV0U3RyZWFtJikgY29uc3T8DUgoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGVBcnJheU5vZGU6On5Ob2RlQXJyYXlOb2RlKCn9DXMoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OlRocm93RXhwcjo6VGhyb3dFeHByKChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSBjb25zdCop/g17KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpUaHJvd0V4cHI6OnByaW50TGVmdCgoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok91dHB1dFN0cmVhbSYpIGNvbnN0/w1AKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpUaHJvd0V4cHI6On5UaHJvd0V4cHIoKYAObyhhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6VVVJRE9mRXhwcjo6VVVJRE9mRXhwcigoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqKYEOfChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6VVVJRE9mRXhwcjo6cHJpbnRMZWZ0KChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6T3V0cHV0U3RyZWFtJikgY29uc3SCDkIoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OlVVSURPZkV4cHI6On5VVUlET2ZFeHByKCmDDrECKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpFeHBhbmRlZFNwZWNpYWxTdWJzdGl0dXRpb24qIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcjo6bWFrZU5vZGU8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpFeHBhbmRlZFNwZWNpYWxTdWJzdGl0dXRpb24sIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6U3BlY2lhbFN1YktpbmQmPigoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OlNwZWNpYWxTdWJLaW5kJimEDkVpbnQmIHN0ZDo6X18yOjpmb3J3YXJkPGludCY+KHN0ZDo6X18yOjpyZW1vdmVfcmVmZXJlbmNlPGludCY+Ojp0eXBlJimFDpsCKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpDdG9yRHRvck5hbWUqIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcjo6bWFrZU5vZGU8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpDdG9yRHRvck5hbWUsIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSomLCBib29sLCBpbnQmPigoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqJiwgYm9vbCYmLCBpbnQmKYYOmgEoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkV4cGFuZGVkU3BlY2lhbFN1YnN0aXR1dGlvbjo6RXhwYW5kZWRTcGVjaWFsU3Vic3RpdHV0aW9uKChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6U3BlY2lhbFN1YktpbmQphw6NAShhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6RXhwYW5kZWRTcGVjaWFsU3Vic3RpdHV0aW9uOjpwcmludExlZnQoKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpPdXRwdXRTdHJlYW0mKSBjb25zdIgOWShhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6RXhwYW5kZWRTcGVjaWFsU3Vic3RpdHV0aW9uOjpnZXRCYXNlTmFtZSgpIGNvbnN0iQ5kKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpFeHBhbmRlZFNwZWNpYWxTdWJzdGl0dXRpb246On5FeHBhbmRlZFNwZWNpYWxTdWJzdGl0dXRpb24oKYoOhAEoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkN0b3JEdG9yTmFtZTo6Q3RvckR0b3JOYW1lKChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSBjb25zdCosIGJvb2wsIGludCmLDn4oYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkN0b3JEdG9yTmFtZTo6cHJpbnRMZWZ0KChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6T3V0cHV0U3RyZWFtJikgY29uc3SMDkYoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkN0b3JEdG9yTmFtZTo6fkN0b3JEdG9yTmFtZSgpjQ7pAihhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6QWJpVGFnQXR0ciogKGFub255bW91cyBuYW1lc3BhY2UpOjpEZWZhdWx0QWxsb2NhdG9yOjptYWtlTm9kZTwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkFiaVRhZ0F0dHIsIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSomLCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OlN0cmluZ1ZpZXcmPigoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqJiwgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpTdHJpbmdWaWV3JimODqQBKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpBYmlUYWdBdHRyOjpBYmlUYWdBdHRyKChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSosIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6U3RyaW5nVmlldymPDnwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkFiaVRhZ0F0dHI6OnByaW50TGVmdCgoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok91dHB1dFN0cmVhbSYpIGNvbnN0kA5CKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpBYmlUYWdBdHRyOjp+QWJpVGFnQXR0cigpkQ6bAihhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6U3RydWN0dXJlZEJpbmRpbmdOYW1lKiAoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I6Om1ha2VOb2RlPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6U3RydWN0dXJlZEJpbmRpbmdOYW1lLCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGVBcnJheT4oKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlQXJyYXkmJimSDokBKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpTdHJ1Y3R1cmVkQmluZGluZ05hbWU6OlN0cnVjdHVyZWRCaW5kaW5nTmFtZSgoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGVBcnJheSmTDocBKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpTdHJ1Y3R1cmVkQmluZGluZ05hbWU6OnByaW50TGVmdCgoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok91dHB1dFN0cmVhbSYpIGNvbnN0lA5YKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpTdHJ1Y3R1cmVkQmluZGluZ05hbWU6On5TdHJ1Y3R1cmVkQmluZGluZ05hbWUoKZUO3QIoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkxvY2FsTmFtZSogKGFub255bW91cyBuYW1lc3BhY2UpOjpEZWZhdWx0QWxsb2NhdG9yOjptYWtlTm9kZTwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkxvY2FsTmFtZSwgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiYsIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSomPigoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqJiwgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiYplg6dAShhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6TG9jYWxOYW1lOjpMb2NhbE5hbWUoKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiwgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKimXDnsoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkxvY2FsTmFtZTo6cHJpbnRMZWZ0KChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6T3V0cHV0U3RyZWFtJikgY29uc3SYDkAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkxvY2FsTmFtZTo6fkxvY2FsTmFtZSgpmQ6hAihhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6U3BlY2lhbFN1YnN0aXR1dGlvbiogKGFub255bW91cyBuYW1lc3BhY2UpOjpEZWZhdWx0QWxsb2NhdG9yOjptYWtlTm9kZTwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OlNwZWNpYWxTdWJzdGl0dXRpb24sIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6U3BlY2lhbFN1YktpbmQ+KChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6U3BlY2lhbFN1YktpbmQmJimaDooBKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpTcGVjaWFsU3Vic3RpdHV0aW9uOjpTcGVjaWFsU3Vic3RpdHV0aW9uKChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6U3BlY2lhbFN1YktpbmQpmw6FAShhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6U3BlY2lhbFN1YnN0aXR1dGlvbjo6cHJpbnRMZWZ0KChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6T3V0cHV0U3RyZWFtJikgY29uc3ScDlEoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OlNwZWNpYWxTdWJzdGl0dXRpb246OmdldEJhc2VOYW1lKCkgY29uc3SdDlQoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OlNwZWNpYWxTdWJzdGl0dXRpb246On5TcGVjaWFsU3Vic3RpdHV0aW9uKCmeDrIBKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpQT0RTbWFsbFZlY3RvcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OlBPRFNtYWxsVmVjdG9yPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSosIDh1bD4qLCA0dWw+OjplbmQoKZ8OugEoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OlBPRFNtYWxsVmVjdG9yPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6UE9EU21hbGxWZWN0b3I8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiwgOHVsPiosIDR1bD46OmNsZWFySW5saW5lKCmgDp8Fc3RkOjpfXzI6OmVuYWJsZV9pZjwoaXNfbW92ZV9jb25zdHJ1Y3RpYmxlPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6UE9EU21hbGxWZWN0b3I8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiwgOHVsPioqPjo6dmFsdWUpICYmIChpc19tb3ZlX2Fzc2lnbmFibGU8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpQT0RTbWFsbFZlY3RvcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqLCA4dWw+Kio+Ojp2YWx1ZSksIHZvaWQ+Ojp0eXBlIHN0ZDo6X18yOjpzd2FwPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6UE9EU21hbGxWZWN0b3I8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiwgOHVsPioqPigoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OlBPRFNtYWxsVmVjdG9yPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSosIDh1bD4qKiYsIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6UE9EU21hbGxWZWN0b3I8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiwgOHVsPioqJimhDosCKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpQYXJhbWV0ZXJQYWNrKiAoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I6Om1ha2VOb2RlPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6UGFyYW1ldGVyUGFjaywgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlQXJyYXk+KChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZUFycmF5JiYpog6JAihhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6VGVtcGxhdGVBcmdzKiAoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I6Om1ha2VOb2RlPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6VGVtcGxhdGVBcmdzLCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGVBcnJheT4oKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlQXJyYXkmJimjDnkoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OlBhcmFtZXRlclBhY2s6OlBhcmFtZXRlclBhY2soKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlQXJyYXkppA5BKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlQXJyYXk6OmJlZ2luKCkgY29uc3SlDj8oYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGVBcnJheTo6ZW5kKCkgY29uc3SmDpIEYm9vbCBzdGQ6Ol9fMjo6YWxsX29mPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSoqLCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OlBhcmFtZXRlclBhY2s6OlBhcmFtZXRlclBhY2soKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlQXJyYXkpOjonbGFtYmRhJygoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqKT4oKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiosIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSoqLCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OlBhcmFtZXRlclBhY2s6OlBhcmFtZXRlclBhY2soKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlQXJyYXkpOjonbGFtYmRhJygoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqKSmnDpQEYm9vbCBzdGQ6Ol9fMjo6YWxsX29mPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSoqLCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OlBhcmFtZXRlclBhY2s6OlBhcmFtZXRlclBhY2soKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlQXJyYXkpOjonbGFtYmRhMCcoKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKik+KChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSoqLCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqKiwgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpQYXJhbWV0ZXJQYWNrOjpQYXJhbWV0ZXJQYWNrKChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZUFycmF5KTo6J2xhbWJkYTAnKChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSopKagOlARib29sIHN0ZDo6X18yOjphbGxfb2Y8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiosIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6UGFyYW1ldGVyUGFjazo6UGFyYW1ldGVyUGFjaygoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGVBcnJheSk6OidsYW1iZGExJygoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqKT4oKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiosIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSoqLCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OlBhcmFtZXRlclBhY2s6OlBhcmFtZXRlclBhY2soKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlQXJyYXkpOjonbGFtYmRhMScoKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKikpqQ71AShhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6UGFyYW1ldGVyUGFjazo6UGFyYW1ldGVyUGFjaygoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGVBcnJheSk6OidsYW1iZGEnKChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSopOjpvcGVyYXRvcigpKChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSopIGNvbnN0qg72AShhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6UGFyYW1ldGVyUGFjazo6UGFyYW1ldGVyUGFjaygoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGVBcnJheSk6OidsYW1iZGEwJygoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqKTo6b3BlcmF0b3IoKSgoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqKSBjb25zdKsO9gEoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OlBhcmFtZXRlclBhY2s6OlBhcmFtZXRlclBhY2soKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlQXJyYXkpOjonbGFtYmRhMScoKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKik6Om9wZXJhdG9yKCkoKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKikgY29uc3SsDokBKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpQYXJhbWV0ZXJQYWNrOjpoYXNSSFNDb21wb25lbnRTbG93KChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6T3V0cHV0U3RyZWFtJikgY29uc3StDo0BKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpQYXJhbWV0ZXJQYWNrOjppbml0aWFsaXplUGFja0V4cGFuc2lvbigoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok91dHB1dFN0cmVhbSYpIGNvbnN0rg5AKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlQXJyYXk6OnNpemUoKSBjb25zdK8OUyhhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZUFycmF5OjpvcGVyYXRvcltdKHVuc2lnbmVkIGxvbmcpIGNvbnN0sA6CAShhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6UGFyYW1ldGVyUGFjazo6aGFzQXJyYXlTbG93KChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6T3V0cHV0U3RyZWFtJikgY29uc3SxDoUBKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpQYXJhbWV0ZXJQYWNrOjpoYXNGdW5jdGlvblNsb3coKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpPdXRwdXRTdHJlYW0mKSBjb25zdLIOgwEoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OlBhcmFtZXRlclBhY2s6OmdldFN5bnRheE5vZGUoKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpPdXRwdXRTdHJlYW0mKSBjb25zdLMOfyhhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6UGFyYW1ldGVyUGFjazo6cHJpbnRMZWZ0KChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6T3V0cHV0U3RyZWFtJikgY29uc3S0DoABKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpQYXJhbWV0ZXJQYWNrOjpwcmludFJpZ2h0KChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6T3V0cHV0U3RyZWFtJikgY29uc3S1DkgoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OlBhcmFtZXRlclBhY2s6On5QYXJhbWV0ZXJQYWNrKCm2DncoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OlRlbXBsYXRlQXJnczo6VGVtcGxhdGVBcmdzKChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZUFycmF5KbcOfihhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6VGVtcGxhdGVBcmdzOjpwcmludExlZnQoKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpPdXRwdXRTdHJlYW0mKSBjb25zdLgOQyhhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6T3V0cHV0U3RyZWFtOjpiYWNrKCkgY29uc3S5DkYoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OlRlbXBsYXRlQXJnczo6flRlbXBsYXRlQXJncygpug6zAShhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6TmFtZVdpdGhUZW1wbGF0ZUFyZ3M6Ok5hbWVXaXRoVGVtcGxhdGVBcmdzKChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSosIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSopuw6GAShhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6TmFtZVdpdGhUZW1wbGF0ZUFyZ3M6OnByaW50TGVmdCgoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok91dHB1dFN0cmVhbSYpIGNvbnN0vA5SKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOYW1lV2l0aFRlbXBsYXRlQXJnczo6Z2V0QmFzZU5hbWUoKSBjb25zdL0OVihhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6TmFtZVdpdGhUZW1wbGF0ZUFyZ3M6On5OYW1lV2l0aFRlbXBsYXRlQXJncygpvg6JAihhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6U3RkUXVhbGlmaWVkTmFtZSogKGFub255bW91cyBuYW1lc3BhY2UpOjpEZWZhdWx0QWxsb2NhdG9yOjptYWtlTm9kZTwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OlN0ZFF1YWxpZmllZE5hbWUsIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSomPigoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqJim/DnsoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OlN0ZFF1YWxpZmllZE5hbWU6OlN0ZFF1YWxpZmllZE5hbWUoKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKinADoIBKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpTdGRRdWFsaWZpZWROYW1lOjpwcmludExlZnQoKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpPdXRwdXRTdHJlYW0mKSBjb25zdMEOTihhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6U3RkUXVhbGlmaWVkTmFtZTo6Z2V0QmFzZU5hbWUoKSBjb25zdMIOTihhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6U3RkUXVhbGlmaWVkTmFtZTo6flN0ZFF1YWxpZmllZE5hbWUoKcMOiQEoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OlBPRFNtYWxsVmVjdG9yPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Rm9yd2FyZFRlbXBsYXRlUmVmZXJlbmNlKiwgNHVsPjo6YmVnaW4oKcQOmQIoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OlRlbXBsYXRlQXJndW1lbnRQYWNrKiAoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I6Om1ha2VOb2RlPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6VGVtcGxhdGVBcmd1bWVudFBhY2ssIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZUFycmF5Jj4oKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlQXJyYXkmKcUOhwEoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OlRlbXBsYXRlQXJndW1lbnRQYWNrOjpUZW1wbGF0ZUFyZ3VtZW50UGFjaygoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGVBcnJheSnGDoYBKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpUZW1wbGF0ZUFyZ3VtZW50UGFjazo6cHJpbnRMZWZ0KChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6T3V0cHV0U3RyZWFtJikgY29uc3THDlYoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OlRlbXBsYXRlQXJndW1lbnRQYWNrOjp+VGVtcGxhdGVBcmd1bWVudFBhY2soKcgOdyhhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6RW5hYmxlSWZBdHRyOjpFbmFibGVJZkF0dHIoKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlQXJyYXkpyQ5+KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpFbmFibGVJZkF0dHI6OnByaW50TGVmdCgoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok91dHB1dFN0cmVhbSYpIGNvbnN0yg5GKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpFbmFibGVJZkF0dHI6On5FbmFibGVJZkF0dHIoKcsOkAMoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkZ1bmN0aW9uRW5jb2Rpbmc6OkZ1bmN0aW9uRW5jb2RpbmcoKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlIGNvbnN0KiwgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlIGNvbnN0KiwgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlQXJyYXksIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSBjb25zdCosIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6UXVhbGlmaWVycywgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpGdW5jdGlvblJlZlF1YWwpzA6MAShhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6RnVuY3Rpb25FbmNvZGluZzo6aGFzUkhTQ29tcG9uZW50U2xvdygoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok91dHB1dFN0cmVhbSYpIGNvbnN0zQ6IAShhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6RnVuY3Rpb25FbmNvZGluZzo6aGFzRnVuY3Rpb25TbG93KChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6T3V0cHV0U3RyZWFtJikgY29uc3TODoIBKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpGdW5jdGlvbkVuY29kaW5nOjpwcmludExlZnQoKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpPdXRwdXRTdHJlYW0mKSBjb25zdM8OgwEoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkZ1bmN0aW9uRW5jb2Rpbmc6OnByaW50UmlnaHQoKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpPdXRwdXRTdHJlYW0mKSBjb25zdNAOTihhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6RnVuY3Rpb25FbmNvZGluZzo6fkZ1bmN0aW9uRW5jb2RpbmcoKdEOqAEoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkRvdFN1ZmZpeDo6RG90U3VmZml4KChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSBjb25zdCosIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6U3RyaW5nVmlldynSDnsoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkRvdFN1ZmZpeDo6cHJpbnRMZWZ0KChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6T3V0cHV0U3RyZWFtJikgY29uc3TTDkAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkRvdFN1ZmZpeDo6fkRvdFN1ZmZpeCgp1A6YAyhhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSogKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpBYnN0cmFjdE1hbmdsaW5nUGFyc2VyPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6TWFuZ2xpbmdQYXJzZXI8KGFub255bW91cyBuYW1lc3BhY2UpOjpEZWZhdWx0QWxsb2NhdG9yPiwgKGFub255bW91cyBuYW1lc3BhY2UpOjpEZWZhdWx0QWxsb2NhdG9yPjo6bWFrZTwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZXhjZXB0U3BlYywgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiY+KChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSomKdUOqAMoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6QWJzdHJhY3RNYW5nbGluZ1BhcnNlcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok1hbmdsaW5nUGFyc2VyPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcj4sIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcj46Om1ha2U8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpEeW5hbWljRXhjZXB0aW9uU3BlYywgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlQXJyYXk+KChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZUFycmF5JiYp1g7GBihhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSogKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpBYnN0cmFjdE1hbmdsaW5nUGFyc2VyPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6TWFuZ2xpbmdQYXJzZXI8KGFub255bW91cyBuYW1lc3BhY2UpOjpEZWZhdWx0QWxsb2NhdG9yPiwgKGFub255bW91cyBuYW1lc3BhY2UpOjpEZWZhdWx0QWxsb2NhdG9yPjo6bWFrZTwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkZ1bmN0aW9uVHlwZSwgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiYsIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZUFycmF5JiwgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpRdWFsaWZpZXJzJiwgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpGdW5jdGlvblJlZlF1YWwmLCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqJj4oKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiYsIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZUFycmF5JiwgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpRdWFsaWZpZXJzJiwgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpGdW5jdGlvblJlZlF1YWwmLCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqJinXDm8oYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OlN3YXBBbmRSZXN0b3JlPGNoYXIgY29uc3QqPjo6U3dhcEFuZFJlc3RvcmUoY2hhciBjb25zdComLCBjaGFyIGNvbnN0KinYDlcoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OlN3YXBBbmRSZXN0b3JlPGNoYXIgY29uc3QqPjo6flN3YXBBbmRSZXN0b3JlKCnZDoUEKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkFic3RyYWN0TWFuZ2xpbmdQYXJzZXI8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpNYW5nbGluZ1BhcnNlcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+LCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+OjptYWtlPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6T2JqQ1Byb3RvTmFtZSwgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiYsIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6U3RyaW5nVmlldyY+KChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSomLCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OlN0cmluZ1ZpZXcmKdoOiQQoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6QWJzdHJhY3RNYW5nbGluZ1BhcnNlcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok1hbmdsaW5nUGFyc2VyPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcj4sIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcj46Om1ha2U8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpWZW5kb3JFeHRRdWFsVHlwZSwgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiYsIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6U3RyaW5nVmlldyY+KChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSomLCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OlN0cmluZ1ZpZXcmKdsOgAQoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6QWJzdHJhY3RNYW5nbGluZ1BhcnNlcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok1hbmdsaW5nUGFyc2VyPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcj4sIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcj46Om1ha2U8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpRdWFsVHlwZSwgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiYsIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6UXVhbGlmaWVycyY+KChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSomLCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OlF1YWxpZmllcnMmKdwOwQEoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5hbWVUeXBlKiAoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I6Om1ha2VOb2RlPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6TmFtZVR5cGUsIGNoYXIgY29uc3QgKCYpIFsxNF0+KGNoYXIgY29uc3QgKCYpIFsxNF0p3Q7BAShhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6TmFtZVR5cGUqIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcjo6bWFrZU5vZGU8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOYW1lVHlwZSwgY2hhciBjb25zdCAoJikgWzE5XT4oY2hhciBjb25zdCAoJikgWzE5XSneDr8BKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOYW1lVHlwZSogKGFub255bW91cyBuYW1lc3BhY2UpOjpEZWZhdWx0QWxsb2NhdG9yOjptYWtlTm9kZTwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5hbWVUeXBlLCBjaGFyIGNvbnN0ICgmKSBbOV0+KGNoYXIgY29uc3QgKCYpIFs5XSnfDm5jaGFyIGNvbnN0ICgmc3RkOjpfXzI6OmZvcndhcmQ8Y2hhciBjb25zdCAoJikgWzddPihzdGQ6Ol9fMjo6cmVtb3ZlX3JlZmVyZW5jZTxjaGFyIGNvbnN0ICgmKSBbN10+Ojp0eXBlJikpIFs3XeAOvwEoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5hbWVUeXBlKiAoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I6Om1ha2VOb2RlPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6TmFtZVR5cGUsIGNoYXIgY29uc3QgKCYpIFs3XT4oY2hhciBjb25zdCAoJikgWzddKeEOngMoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6QWJzdHJhY3RNYW5nbGluZ1BhcnNlcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok1hbmdsaW5nUGFyc2VyPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcj4sIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcj46Om1ha2U8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOYW1lVHlwZSwgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpTdHJpbmdWaWV3PigoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OlN0cmluZ1ZpZXcmJiniDpsDKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkFic3RyYWN0TWFuZ2xpbmdQYXJzZXI8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpNYW5nbGluZ1BhcnNlcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+LCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+OjptYWtlPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6UGl4ZWxWZWN0b3JUeXBlLCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqJj4oKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiYp4w74Ayhhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSogKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpBYnN0cmFjdE1hbmdsaW5nUGFyc2VyPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6TWFuZ2xpbmdQYXJzZXI8KGFub255bW91cyBuYW1lc3BhY2UpOjpEZWZhdWx0QWxsb2NhdG9yPiwgKGFub255bW91cyBuYW1lc3BhY2UpOjpEZWZhdWx0QWxsb2NhdG9yPjo6bWFrZTwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OlZlY3RvclR5cGUsIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSomLCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqJj4oKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiYsIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSomKeQOuAMoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6QWJzdHJhY3RNYW5nbGluZ1BhcnNlcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok1hbmdsaW5nUGFyc2VyPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcj4sIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcj46Om1ha2U8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpWZWN0b3JUeXBlLCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqJiwgc3RkOjpudWxscHRyX3Q+KChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSomLCBzdGQ6Om51bGxwdHJfdCYmKeUO9wMoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6QWJzdHJhY3RNYW5nbGluZ1BhcnNlcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok1hbmdsaW5nUGFyc2VyPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcj4sIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcj46Om1ha2U8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpBcnJheVR5cGUsIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSomLCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqJj4oKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiYsIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSomKeYOgQQoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6QWJzdHJhY3RNYW5nbGluZ1BhcnNlcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok1hbmdsaW5nUGFyc2VyPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcj4sIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcj46Om1ha2U8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpQb2ludGVyVG9NZW1iZXJUeXBlLCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqJiwgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiY+KChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSomLCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqJinnDo4EKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkFic3RyYWN0TWFuZ2xpbmdQYXJzZXI8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpNYW5nbGluZ1BhcnNlcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+LCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I+OjptYWtlPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6RWxhYm9yYXRlZFR5cGVTcGVmVHlwZSwgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpTdHJpbmdWaWV3JiwgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiY+KChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6U3RyaW5nVmlldyYsIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSomKegO/wEoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OlBvaW50ZXJUeXBlKiAoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I6Om1ha2VOb2RlPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6UG9pbnRlclR5cGUsIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSomPigoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqJinpDvUCKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpSZWZlcmVuY2VUeXBlKiAoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I6Om1ha2VOb2RlPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6UmVmZXJlbmNlVHlwZSwgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiYsIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6UmVmZXJlbmNlS2luZD4oKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiYsIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6UmVmZXJlbmNlS2luZCYmKeoOuQIoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OlBvc3RmaXhRdWFsaWZpZWRUeXBlKiAoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I6Om1ha2VOb2RlPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6UG9zdGZpeFF1YWxpZmllZFR5cGUsIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSomLCBjaGFyIGNvbnN0ICgmKSBbOV0+KChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSomLCBjaGFyIGNvbnN0ICgmKSBbOV0p6w67Aihhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6UG9zdGZpeFF1YWxpZmllZFR5cGUqIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcjo6bWFrZU5vZGU8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpQb3N0Zml4UXVhbGlmaWVkVHlwZSwgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiYsIGNoYXIgY29uc3QgKCYpIFsxMV0+KChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSomLCBjaGFyIGNvbnN0ICgmKSBbMTFdKewOgQIoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZXhjZXB0U3BlYyogKGFub255bW91cyBuYW1lc3BhY2UpOjpEZWZhdWx0QWxsb2NhdG9yOjptYWtlTm9kZTwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZXhjZXB0U3BlYywgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiY+KChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSomKe0OmQIoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkR5bmFtaWNFeGNlcHRpb25TcGVjKiAoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I6Om1ha2VOb2RlPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6RHluYW1pY0V4Y2VwdGlvblNwZWMsIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZUFycmF5PigoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGVBcnJheSYmKe4OrwUoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkZ1bmN0aW9uVHlwZSogKGFub255bW91cyBuYW1lc3BhY2UpOjpEZWZhdWx0QWxsb2NhdG9yOjptYWtlTm9kZTwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkZ1bmN0aW9uVHlwZSwgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiYsIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZUFycmF5JiwgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpRdWFsaWZpZXJzJiwgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpGdW5jdGlvblJlZlF1YWwmLCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqJj4oKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiYsIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZUFycmF5JiwgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpRdWFsaWZpZXJzJiwgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpGdW5jdGlvblJlZlF1YWwmLCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqJinvDnkoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZXhjZXB0U3BlYzo6Tm9leGNlcHRTcGVjKChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSBjb25zdCop8A5+KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2V4Y2VwdFNwZWM6OnByaW50TGVmdCgoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok91dHB1dFN0cmVhbSYpIGNvbnN08Q5GKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2V4Y2VwdFNwZWM6On5Ob2V4Y2VwdFNwZWMoKfIOhwEoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkR5bmFtaWNFeGNlcHRpb25TcGVjOjpEeW5hbWljRXhjZXB0aW9uU3BlYygoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGVBcnJheSnzDoYBKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpEeW5hbWljRXhjZXB0aW9uU3BlYzo6cHJpbnRMZWZ0KChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6T3V0cHV0U3RyZWFtJikgY29uc3T0DlYoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkR5bmFtaWNFeGNlcHRpb25TcGVjOjp+RHluYW1pY0V4Y2VwdGlvblNwZWMoKfUO0gIoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkZ1bmN0aW9uVHlwZTo6RnVuY3Rpb25UeXBlKChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSBjb25zdCosIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZUFycmF5LCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OlF1YWxpZmllcnMsIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6RnVuY3Rpb25SZWZRdWFsLCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUgY29uc3QqKfYOiAEoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkZ1bmN0aW9uVHlwZTo6aGFzUkhTQ29tcG9uZW50U2xvdygoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok91dHB1dFN0cmVhbSYpIGNvbnN09w6EAShhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6RnVuY3Rpb25UeXBlOjpoYXNGdW5jdGlvblNsb3coKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpPdXRwdXRTdHJlYW0mKSBjb25zdPgOfihhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6RnVuY3Rpb25UeXBlOjpwcmludExlZnQoKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpPdXRwdXRTdHJlYW0mKSBjb25zdPkOfyhhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6RnVuY3Rpb25UeXBlOjpwcmludFJpZ2h0KChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6T3V0cHV0U3RyZWFtJikgY29uc3T6DkYoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkZ1bmN0aW9uVHlwZTo6fkZ1bmN0aW9uVHlwZSgp+w5bc3RkOjpfXzI6OnJlbW92ZV9yZWZlcmVuY2U8Y2hhciBjb25zdComPjo6dHlwZSYmIHN0ZDo6X18yOjptb3ZlPGNoYXIgY29uc3QqJj4oY2hhciBjb25zdComKfwO7wIoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok9iakNQcm90b05hbWUqIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcjo6bWFrZU5vZGU8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpPYmpDUHJvdG9OYW1lLCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqJiwgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpTdHJpbmdWaWV3Jj4oKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiYsIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6U3RyaW5nVmlldyYp/Q73Aihhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6VmVuZG9yRXh0UXVhbFR5cGUqIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcjo6bWFrZU5vZGU8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpWZW5kb3JFeHRRdWFsVHlwZSwgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiYsIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6U3RyaW5nVmlldyY+KChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSomLCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OlN0cmluZ1ZpZXcmKf4O5QIoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OlF1YWxUeXBlKiAoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I6Om1ha2VOb2RlPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6UXVhbFR5cGUsIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSomLCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OlF1YWxpZmllcnMmPigoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqJiwgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpRdWFsaWZpZXJzJin/DrABKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpPYmpDUHJvdG9OYW1lOjpPYmpDUHJvdG9OYW1lKChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSBjb25zdCosIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6U3RyaW5nVmlldymAD38oYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok9iakNQcm90b05hbWU6OnByaW50TGVmdCgoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok91dHB1dFN0cmVhbSYpIGNvbnN0gQ9IKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpPYmpDUHJvdG9OYW1lOjp+T2JqQ1Byb3RvTmFtZSgpgg+4AShhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6VmVuZG9yRXh0UXVhbFR5cGU6OlZlbmRvckV4dFF1YWxUeXBlKChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSBjb25zdCosIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6U3RyaW5nVmlldymDD4MBKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpWZW5kb3JFeHRRdWFsVHlwZTo6cHJpbnRMZWZ0KChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6T3V0cHV0U3RyZWFtJikgY29uc3SED1AoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OlZlbmRvckV4dFF1YWxUeXBlOjp+VmVuZG9yRXh0UXVhbFR5cGUoKYUPpgEoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OlF1YWxUeXBlOjpRdWFsVHlwZSgoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUgY29uc3QqLCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OlF1YWxpZmllcnMphg+EAShhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6UXVhbFR5cGU6Omhhc1JIU0NvbXBvbmVudFNsb3coKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpPdXRwdXRTdHJlYW0mKSBjb25zdIcPfShhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6UXVhbFR5cGU6Omhhc0FycmF5U2xvdygoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok91dHB1dFN0cmVhbSYpIGNvbnN0iA+AAShhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6UXVhbFR5cGU6Omhhc0Z1bmN0aW9uU2xvdygoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok91dHB1dFN0cmVhbSYpIGNvbnN0iQ96KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpRdWFsVHlwZTo6cHJpbnRMZWZ0KChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6T3V0cHV0U3RyZWFtJikgY29uc3SKD3soYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OlF1YWxUeXBlOjpwcmludFF1YWxzKChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6T3V0cHV0U3RyZWFtJikgY29uc3SLD3soYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OlF1YWxUeXBlOjpwcmludFJpZ2h0KChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6T3V0cHV0U3RyZWFtJikgY29uc3SMDz4oYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OlF1YWxUeXBlOjp+UXVhbFR5cGUoKY0PgwIoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5hbWVUeXBlKiAoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I6Om1ha2VOb2RlPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6TmFtZVR5cGUsIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6U3RyaW5nVmlldz4oKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpTdHJpbmdWaWV3JiYpjg+HAihhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6UGl4ZWxWZWN0b3JUeXBlKiAoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I6Om1ha2VOb2RlPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6UGl4ZWxWZWN0b3JUeXBlLCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqJj4oKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiYpjw/fAihhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6VmVjdG9yVHlwZSogKGFub255bW91cyBuYW1lc3BhY2UpOjpEZWZhdWx0QWxsb2NhdG9yOjptYWtlTm9kZTwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OlZlY3RvclR5cGUsIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSomLCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqJj4oKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiYsIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSomKZAPnwIoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OlZlY3RvclR5cGUqIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6RGVmYXVsdEFsbG9jYXRvcjo6bWFrZU5vZGU8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpWZWN0b3JUeXBlLCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqJiwgc3RkOjpudWxscHRyX3Q+KChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSomLCBzdGQ6Om51bGxwdHJfdCYmKZEPfyhhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6UGl4ZWxWZWN0b3JUeXBlOjpQaXhlbFZlY3RvclR5cGUoKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlIGNvbnN0KimSD4EBKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpQaXhlbFZlY3RvclR5cGU6OnByaW50TGVmdCgoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok91dHB1dFN0cmVhbSYpIGNvbnN0kw9MKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpQaXhlbFZlY3RvclR5cGU6On5QaXhlbFZlY3RvclR5cGUoKZQPpQEoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OlZlY3RvclR5cGU6OlZlY3RvclR5cGUoKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlIGNvbnN0KiwgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKimVD3woYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OlZlY3RvclR5cGU6OnByaW50TGVmdCgoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok91dHB1dFN0cmVhbSYpIGNvbnN0lg9CKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpWZWN0b3JUeXBlOjp+VmVjdG9yVHlwZSgplw/dAihhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6QXJyYXlUeXBlKiAoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I6Om1ha2VOb2RlPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6QXJyYXlUeXBlLCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqJiwgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiY+KChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSomLCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqJimYD6MBKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpBcnJheVR5cGU6OkFycmF5VHlwZSgoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUgY29uc3QqLCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqKZkPhQEoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkFycmF5VHlwZTo6aGFzUkhTQ29tcG9uZW50U2xvdygoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok91dHB1dFN0cmVhbSYpIGNvbnN0mg9+KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpBcnJheVR5cGU6Omhhc0FycmF5U2xvdygoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok91dHB1dFN0cmVhbSYpIGNvbnN0mw97KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpBcnJheVR5cGU6OnByaW50TGVmdCgoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok91dHB1dFN0cmVhbSYpIGNvbnN0nA98KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpBcnJheVR5cGU6OnByaW50UmlnaHQoKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpPdXRwdXRTdHJlYW0mKSBjb25zdJ0PQChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6QXJyYXlUeXBlOjp+QXJyYXlUeXBlKCmeD/ECKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpQb2ludGVyVG9NZW1iZXJUeXBlKiAoYW5vbnltb3VzIG5hbWVzcGFjZSk6OkRlZmF1bHRBbGxvY2F0b3I6Om1ha2VOb2RlPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6UG9pbnRlclRvTWVtYmVyVHlwZSwgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiYsIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSomPigoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqJiwgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKiYpnw+9AShhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6UG9pbnRlclRvTWVtYmVyVHlwZTo6UG9pbnRlclRvTWVtYmVyVHlwZSgoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUgY29uc3QqLCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUgY29uc3QqKaAPjwEoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OlBvaW50ZXJUb01lbWJlclR5cGU6Omhhc1JIU0NvbXBvbmVudFNsb3coKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpPdXRwdXRTdHJlYW0mKSBjb25zdKEPhQEoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OlBvaW50ZXJUb01lbWJlclR5cGU6OnByaW50TGVmdCgoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok91dHB1dFN0cmVhbSYpIGNvbnN0og+GAShhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6UG9pbnRlclRvTWVtYmVyVHlwZTo6cHJpbnRSaWdodCgoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok91dHB1dFN0cmVhbSYpIGNvbnN0ow9UKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpQb2ludGVyVG9NZW1iZXJUeXBlOjp+UG9pbnRlclRvTWVtYmVyVHlwZSgppA+BAyhhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6RWxhYm9yYXRlZFR5cGVTcGVmVHlwZSogKGFub255bW91cyBuYW1lc3BhY2UpOjpEZWZhdWx0QWxsb2NhdG9yOjptYWtlTm9kZTwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OkVsYWJvcmF0ZWRUeXBlU3BlZlR5cGUsIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6U3RyaW5nVmlldyYsIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSomPigoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OlN0cmluZ1ZpZXcmLCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqJimlD7wBKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpFbGFib3JhdGVkVHlwZVNwZWZUeXBlOjpFbGFib3JhdGVkVHlwZVNwZWZUeXBlKChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6U3RyaW5nVmlldywgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlKimmD4gBKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpFbGFib3JhdGVkVHlwZVNwZWZUeXBlOjpwcmludExlZnQoKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpPdXRwdXRTdHJlYW0mKSBjb25zdKcPWihhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6RWxhYm9yYXRlZFR5cGVTcGVmVHlwZTo6fkVsYWJvcmF0ZWRUeXBlU3BlZlR5cGUoKagPdyhhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6UG9pbnRlclR5cGU6OlBvaW50ZXJUeXBlKChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSBjb25zdCopqQ+HAShhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6UG9pbnRlclR5cGU6Omhhc1JIU0NvbXBvbmVudFNsb3coKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpPdXRwdXRTdHJlYW0mKSBjb25zdKoPfShhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6UG9pbnRlclR5cGU6OnByaW50TGVmdCgoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok91dHB1dFN0cmVhbSYpIGNvbnN0qw9MKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpPYmpDUHJvdG9OYW1lOjppc09iakNPYmplY3QoKSBjb25zdKwPfihhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6UG9pbnRlclR5cGU6OnByaW50UmlnaHQoKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpPdXRwdXRTdHJlYW0mKSBjb25zdK0PRChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6UG9pbnRlclR5cGU6On5Qb2ludGVyVHlwZSgprg9CKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOYW1lVHlwZTo6Z2V0TmFtZSgpIGNvbnN0rw+zAShhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6UmVmZXJlbmNlVHlwZTo6UmVmZXJlbmNlVHlwZSgoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUgY29uc3QqLCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OlJlZmVyZW5jZUtpbmQpsA+JAShhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6UmVmZXJlbmNlVHlwZTo6aGFzUkhTQ29tcG9uZW50U2xvdygoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok91dHB1dFN0cmVhbSYpIGNvbnN0sQ9/KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpSZWZlcmVuY2VUeXBlOjpwcmludExlZnQoKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpPdXRwdXRTdHJlYW0mKSBjb25zdLIPfihhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6UmVmZXJlbmNlVHlwZTo6Y29sbGFwc2UoKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpPdXRwdXRTdHJlYW0mKSBjb25zdLMPgAEoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OlJlZmVyZW5jZVR5cGU6OnByaW50UmlnaHQoKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpPdXRwdXRTdHJlYW0mKSBjb25zdLQPSChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6UmVmZXJlbmNlVHlwZTo6flJlZmVyZW5jZVR5cGUoKbUP3gNzdGQ6Ol9fMjo6cGFpcjxzdGQ6Ol9fMjo6X191bndyYXBfcmVmX2RlY2F5PChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6UmVmZXJlbmNlS2luZCBjb25zdCY+Ojp0eXBlLCBzdGQ6Ol9fMjo6X191bndyYXBfcmVmX2RlY2F5PChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSBjb25zdCogY29uc3QmPjo6dHlwZT4gc3RkOjpfXzI6Om1ha2VfcGFpcjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OlJlZmVyZW5jZUtpbmQgY29uc3QmLCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUgY29uc3QqIGNvbnN0Jj4oKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpSZWZlcmVuY2VLaW5kIGNvbnN0JiwgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlIGNvbnN0KiBjb25zdCYptg+BAihhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6UmVmZXJlbmNlS2luZCBjb25zdCYgc3RkOjpfXzI6Om1pbjwoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OlJlZmVyZW5jZUtpbmQ+KChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6UmVmZXJlbmNlS2luZCBjb25zdCYsIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6UmVmZXJlbmNlS2luZCBjb25zdCYptw+LAnN0ZDo6X18yOjpwYWlyPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6UmVmZXJlbmNlS2luZCwgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpOb2RlIGNvbnN0Kj46OnBhaXI8dHJ1ZSwgZmFsc2U+KChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6UmVmZXJlbmNlS2luZCBjb25zdCYsIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6Tm9kZSBjb25zdCogY29uc3QmKbgPhgQoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OlJlZmVyZW5jZUtpbmQgY29uc3QmIHN0ZDo6X18yOjptaW48KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpSZWZlcmVuY2VLaW5kLCBzdGQ6Ol9fMjo6X19sZXNzPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6UmVmZXJlbmNlS2luZCwgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpSZWZlcmVuY2VLaW5kPiA+KChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6UmVmZXJlbmNlS2luZCBjb25zdCYsIChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6UmVmZXJlbmNlS2luZCBjb25zdCYsIHN0ZDo6X18yOjpfX2xlc3M8KGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpSZWZlcmVuY2VLaW5kLCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OlJlZmVyZW5jZUtpbmQ+KbkPkAJzdGQ6Ol9fMjo6X19sZXNzPChhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6UmVmZXJlbmNlS2luZCwgKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpSZWZlcmVuY2VLaW5kPjo6b3BlcmF0b3IoKSgoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OlJlZmVyZW5jZUtpbmQgY29uc3QmLCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OlJlZmVyZW5jZUtpbmQgY29uc3QmKSBjb25zdLoPuAEoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OlBvc3RmaXhRdWFsaWZpZWRUeXBlOjpQb3N0Zml4UXVhbGlmaWVkVHlwZSgoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok5vZGUqLCAoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6OlN0cmluZ1ZpZXcpuw+GAShhbm9ueW1vdXMgbmFtZXNwYWNlKTo6aXRhbml1bV9kZW1hbmdsZTo6UG9zdGZpeFF1YWxpZmllZFR5cGU6OnByaW50TGVmdCgoYW5vbnltb3VzIG5hbWVzcGFjZSk6Oml0YW5pdW1fZGVtYW5nbGU6Ok91dHB1dFN0cmVhbSYpIGNvbnN0vA9WKGFub255bW91cyBuYW1lc3BhY2UpOjppdGFuaXVtX2RlbWFuZ2xlOjpQb3N0Zml4UXVhbGlmaWVkVHlwZTo6flBvc3RmaXhRdWFsaWZpZWRUeXBlKCm9DxFfX3NldF9zdGFja19saW1pdL4PCXN0YWNrU2F2Zb8PCnN0YWNrQWxsb2PADwxzdGFja1Jlc3RvcmXBDxBfX2dyb3dXYXNtTWVtb3J5wg8KZHluQ2FsbF9pacMPDGR5bkNhbGxfaWlpacQPC2R5bkNhbGxfaWlpxQ8JZHluQ2FsbF9pxg8KZHluQ2FsbF92accPDWR5bkNhbGxfaWlpaWnIDw5keW5DYWxsX2lpaWlpackPD2R5bkNhbGxfaWlpaWlpacoPC2R5bkNhbGxfaWlqyw8PZHluQ2FsbF9paWpqaWlpzA8LZHluQ2FsbF92aWnNDwxkeW5DYWxsX3ZpaWnODw9keW5DYWxsX3ZpaWlpaWnPDwxkeW5DYWxsX2lpamrQDwxkeW5DYWxsX2ppamnRDw9keW5DYWxsX2lpZGlpaWnSDwlkeW5DYWxsX3bTDw5keW5DYWxsX3ZpaWlpadQPDWR5bkNhbGxfdmlpaWnVDxVsZWdhbHN0dWIkZHluQ2FsbF9paWrWDxlsZWdhbHN0dWIkZHluQ2FsbF9paWpqaWlp1w8WbGVnYWxzdHViJGR5bkNhbGxfaWlqatgPFmxlZ2Fsc3R1YiRkeW5DYWxsX2ppamnZDxhsZWdhbGZ1bmMkX193YXNpX2ZkX3NlZWs=';
if (!isDataURI(wasmBinaryFile)) {
  wasmBinaryFile = locateFile(wasmBinaryFile);
}

function getBinary() {
  try {
    if (wasmBinary) {
      return new Uint8Array(wasmBinary);
    }

    var binary = tryParseAsDataURI(wasmBinaryFile);
    if (binary) {
      return binary;
    }
    if (readBinary) {
      return readBinary(wasmBinaryFile);
    } else {
      throw "both async and sync fetching of the wasm failed";
    }
  }
  catch (err) {
    abort(err);
  }
}

function getBinaryPromise() {
  // If we don't have the binary yet, and have the Fetch api, use that;
  // in some environments, like Electron's render process, Fetch api may be present, but have a different context than expected, let's only use it on the Web
  if (!wasmBinary && (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) && typeof fetch === 'function'
      // Let's not use fetch to get objects over file:// as it's most likely Cordova which doesn't support fetch for file://
      && !isFileURI(wasmBinaryFile)
      ) {
    return fetch(wasmBinaryFile, { credentials: 'same-origin' }).then(function(response) {
      if (!response['ok']) {
        throw "failed to load wasm binary file at '" + wasmBinaryFile + "'";
      }
      return response['arrayBuffer']();
    }).catch(function () {
      return getBinary();
    });
  }
  // Otherwise, getBinary should be able to get it synchronously
  return new Promise(function(resolve, reject) {
    resolve(getBinary());
  });
}



// Create the wasm instance.
// Receives the wasm imports, returns the exports.
function createWasm() {
  // prepare imports
  var info = {
    'env': asmLibraryArg,
    'wasi_snapshot_preview1': asmLibraryArg
  };
  // Load the wasm module and create an instance of using native support in the JS engine.
  // handle a generated wasm instance, receiving its exports and
  // performing other necessary setup
  /** @param {WebAssembly.Module=} module*/
  function receiveInstance(instance, module) {
    var exports = instance.exports;
    Module['asm'] = exports;
    removeRunDependency('wasm-instantiate');
  }
  // we can't run yet (except in a pthread, where we have a custom sync instantiator)
  addRunDependency('wasm-instantiate');


  // Async compilation can be confusing when an error on the page overwrites Module
  // (for example, if the order of elements is wrong, and the one defining Module is
  // later), so we save Module and check it later.
  var trueModule = Module;
  function receiveInstantiatedSource(output) {
    // 'output' is a WebAssemblyInstantiatedSource object which has both the module and instance.
    // receiveInstance() will swap in the exports (to Module.asm) so they can be called
    assert(Module === trueModule, 'the Module object should not be replaced during async compilation - perhaps the order of HTML elements is wrong?');
    trueModule = null;
    // TODO: Due to Closure regression https://github.com/google/closure-compiler/issues/3193, the above line no longer optimizes out down to the following line.
    // When the regression is fixed, can restore the above USE_PTHREADS-enabled path.
    receiveInstance(output['instance']);
  }


  function instantiateArrayBuffer(receiver) {
    return getBinaryPromise().then(function(binary) {
      return WebAssembly.instantiate(binary, info);
    }).then(receiver, function(reason) {
      err('failed to asynchronously prepare wasm: ' + reason);
      abort(reason);
    });
  }

  // Prefer streaming instantiation if available.
  function instantiateAsync() {
    if (!wasmBinary &&
        typeof WebAssembly.instantiateStreaming === 'function' &&
        !isDataURI(wasmBinaryFile) &&
        // Don't use streaming for file:// delivered objects in a webview, fetch them synchronously.
        !isFileURI(wasmBinaryFile) &&
        typeof fetch === 'function') {
      fetch(wasmBinaryFile, { credentials: 'same-origin' }).then(function (response) {
        var result = WebAssembly.instantiateStreaming(response, info);
        return result.then(receiveInstantiatedSource, function(reason) {
            // We expect the most common failure cause to be a bad MIME type for the binary,
            // in which case falling back to ArrayBuffer instantiation should work.
            err('wasm streaming compile failed: ' + reason);
            err('falling back to ArrayBuffer instantiation');
            instantiateArrayBuffer(receiveInstantiatedSource);
          });
      });
    } else {
      return instantiateArrayBuffer(receiveInstantiatedSource);
    }
  }
  // User shell pages can write their own Module.instantiateWasm = function(imports, successCallback) callback
  // to manually instantiate the Wasm module themselves. This allows pages to run the instantiation parallel
  // to any other async startup actions they are performing.
  if (Module['instantiateWasm']) {
    try {
      var exports = Module['instantiateWasm'](info, receiveInstance);
      return exports;
    } catch(e) {
      err('Module.instantiateWasm callback failed with error: ' + e);
      return false;
    }
  }

  instantiateAsync();
  return {}; // no exports yet; we'll fill them in later
}


// Globals used by JS i64 conversions
var tempDouble;
var tempI64;

// === Body ===

var ASM_CONSTS = {
  
};




// STATICTOP = STATIC_BASE + 69744;
/* global initializers */  __ATINIT__.push({ func: function() { ___wasm_call_ctors() } });




/* no memory initializer */
// {{PRE_LIBRARY}}


  function demangle(func) {
      // If demangle has failed before, stop demangling any further function names
      // This avoids an infinite recursion with malloc()->abort()->stackTrace()->demangle()->malloc()->...
      demangle.recursionGuard = (demangle.recursionGuard|0)+1;
      if (demangle.recursionGuard > 1) return func;
      var __cxa_demangle_func = Module['___cxa_demangle'] || Module['__cxa_demangle'];
      assert(__cxa_demangle_func);
      var stackTop = stackSave();
      try {
        var s = func;
        if (s.startsWith('__Z'))
          s = s.substr(1);
        var len = lengthBytesUTF8(s)+1;
        var buf = stackAlloc(len);
        stringToUTF8(s, buf, len);
        var status = stackAlloc(4);
        var ret = __cxa_demangle_func(buf, 0, 0, status);
        if (HEAP32[((status)>>2)] === 0 && ret) {
          return UTF8ToString(ret);
        }
        // otherwise, libcxxabi failed
      } catch(e) {
      } finally {
        _free(ret);
        stackRestore(stackTop);
        if (demangle.recursionGuard < 2) --demangle.recursionGuard;
      }
      // failure when using libcxxabi, don't demangle
      return func;
    }

  function demangleAll(text) {
      var regex =
        /\b_Z[\w\d_]+/g;
      return text.replace(regex,
        function(x) {
          var y = demangle(x);
          return x === y ? x : (y + ' [' + x + ']');
        });
    }

  function jsStackTrace() {
      var err = new Error();
      if (!err.stack) {
        // IE10+ special cases: It does have callstack info, but it is only populated if an Error object is thrown,
        // so try that as a special-case.
        try {
          throw new Error();
        } catch(e) {
          err = e;
        }
        if (!err.stack) {
          return '(no stack trace available)';
        }
      }
      return err.stack.toString();
    }

  function stackTrace() {
      var js = jsStackTrace();
      if (Module['extraStackTrace']) js += '\n' + Module['extraStackTrace']();
      return demangleAll(js);
    }

  function ___handle_stack_overflow() {
      abort('stack overflow')
    }

  
  
  var PATH={splitPath:function(filename) {
        var splitPathRe = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
        return splitPathRe.exec(filename).slice(1);
      },normalizeArray:function(parts, allowAboveRoot) {
        // if the path tries to go above the root, `up` ends up > 0
        var up = 0;
        for (var i = parts.length - 1; i >= 0; i--) {
          var last = parts[i];
          if (last === '.') {
            parts.splice(i, 1);
          } else if (last === '..') {
            parts.splice(i, 1);
            up++;
          } else if (up) {
            parts.splice(i, 1);
            up--;
          }
        }
        // if the path is allowed to go above the root, restore leading ..s
        if (allowAboveRoot) {
          for (; up; up--) {
            parts.unshift('..');
          }
        }
        return parts;
      },normalize:function(path) {
        var isAbsolute = path.charAt(0) === '/',
            trailingSlash = path.substr(-1) === '/';
        // Normalize the path
        path = PATH.normalizeArray(path.split('/').filter(function(p) {
          return !!p;
        }), !isAbsolute).join('/');
        if (!path && !isAbsolute) {
          path = '.';
        }
        if (path && trailingSlash) {
          path += '/';
        }
        return (isAbsolute ? '/' : '') + path;
      },dirname:function(path) {
        var result = PATH.splitPath(path),
            root = result[0],
            dir = result[1];
        if (!root && !dir) {
          // No dirname whatsoever
          return '.';
        }
        if (dir) {
          // It has a dirname, strip trailing slash
          dir = dir.substr(0, dir.length - 1);
        }
        return root + dir;
      },basename:function(path) {
        // EMSCRIPTEN return '/'' for '/', not an empty string
        if (path === '/') return '/';
        var lastSlash = path.lastIndexOf('/');
        if (lastSlash === -1) return path;
        return path.substr(lastSlash+1);
      },extname:function(path) {
        return PATH.splitPath(path)[3];
      },join:function() {
        var paths = Array.prototype.slice.call(arguments, 0);
        return PATH.normalize(paths.join('/'));
      },join2:function(l, r) {
        return PATH.normalize(l + '/' + r);
      }};
  
  
  function setErrNo(value) {
      HEAP32[((___errno_location())>>2)]=value;
      return value;
    }
  
  var PATH_FS={resolve:function() {
        var resolvedPath = '',
          resolvedAbsolute = false;
        for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
          var path = (i >= 0) ? arguments[i] : FS.cwd();
          // Skip empty and invalid entries
          if (typeof path !== 'string') {
            throw new TypeError('Arguments to path.resolve must be strings');
          } else if (!path) {
            return ''; // an invalid portion invalidates the whole thing
          }
          resolvedPath = path + '/' + resolvedPath;
          resolvedAbsolute = path.charAt(0) === '/';
        }
        // At this point the path should be resolved to a full absolute path, but
        // handle relative paths to be safe (might happen when process.cwd() fails)
        resolvedPath = PATH.normalizeArray(resolvedPath.split('/').filter(function(p) {
          return !!p;
        }), !resolvedAbsolute).join('/');
        return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
      },relative:function(from, to) {
        from = PATH_FS.resolve(from).substr(1);
        to = PATH_FS.resolve(to).substr(1);
        function trim(arr) {
          var start = 0;
          for (; start < arr.length; start++) {
            if (arr[start] !== '') break;
          }
          var end = arr.length - 1;
          for (; end >= 0; end--) {
            if (arr[end] !== '') break;
          }
          if (start > end) return [];
          return arr.slice(start, end - start + 1);
        }
        var fromParts = trim(from.split('/'));
        var toParts = trim(to.split('/'));
        var length = Math.min(fromParts.length, toParts.length);
        var samePartsLength = length;
        for (var i = 0; i < length; i++) {
          if (fromParts[i] !== toParts[i]) {
            samePartsLength = i;
            break;
          }
        }
        var outputParts = [];
        for (var i = samePartsLength; i < fromParts.length; i++) {
          outputParts.push('..');
        }
        outputParts = outputParts.concat(toParts.slice(samePartsLength));
        return outputParts.join('/');
      }};
  
  var TTY={ttys:[],init:function () {
        // https://github.com/emscripten-core/emscripten/pull/1555
        // if (ENVIRONMENT_IS_NODE) {
        //   // currently, FS.init does not distinguish if process.stdin is a file or TTY
        //   // device, it always assumes it's a TTY device. because of this, we're forcing
        //   // process.stdin to UTF8 encoding to at least make stdin reading compatible
        //   // with text files until FS.init can be refactored.
        //   process['stdin']['setEncoding']('utf8');
        // }
      },shutdown:function() {
        // https://github.com/emscripten-core/emscripten/pull/1555
        // if (ENVIRONMENT_IS_NODE) {
        //   // inolen: any idea as to why node -e 'process.stdin.read()' wouldn't exit immediately (with process.stdin being a tty)?
        //   // isaacs: because now it's reading from the stream, you've expressed interest in it, so that read() kicks off a _read() which creates a ReadReq operation
        //   // inolen: I thought read() in that case was a synchronous operation that just grabbed some amount of buffered data if it exists?
        //   // isaacs: it is. but it also triggers a _read() call, which calls readStart() on the handle
        //   // isaacs: do process.stdin.pause() and i'd think it'd probably close the pending call
        //   process['stdin']['pause']();
        // }
      },register:function(dev, ops) {
        TTY.ttys[dev] = { input: [], output: [], ops: ops };
        FS.registerDevice(dev, TTY.stream_ops);
      },stream_ops:{open:function(stream) {
          var tty = TTY.ttys[stream.node.rdev];
          if (!tty) {
            throw new FS.ErrnoError(43);
          }
          stream.tty = tty;
          stream.seekable = false;
        },close:function(stream) {
          // flush any pending line data
          stream.tty.ops.flush(stream.tty);
        },flush:function(stream) {
          stream.tty.ops.flush(stream.tty);
        },read:function(stream, buffer, offset, length, pos /* ignored */) {
          if (!stream.tty || !stream.tty.ops.get_char) {
            throw new FS.ErrnoError(60);
          }
          var bytesRead = 0;
          for (var i = 0; i < length; i++) {
            var result;
            try {
              result = stream.tty.ops.get_char(stream.tty);
            } catch (e) {
              throw new FS.ErrnoError(29);
            }
            if (result === undefined && bytesRead === 0) {
              throw new FS.ErrnoError(6);
            }
            if (result === null || result === undefined) break;
            bytesRead++;
            buffer[offset+i] = result;
          }
          if (bytesRead) {
            stream.node.timestamp = Date.now();
          }
          return bytesRead;
        },write:function(stream, buffer, offset, length, pos) {
          if (!stream.tty || !stream.tty.ops.put_char) {
            throw new FS.ErrnoError(60);
          }
          try {
            for (var i = 0; i < length; i++) {
              stream.tty.ops.put_char(stream.tty, buffer[offset+i]);
            }
          } catch (e) {
            throw new FS.ErrnoError(29);
          }
          if (length) {
            stream.node.timestamp = Date.now();
          }
          return i;
        }},default_tty_ops:{get_char:function(tty) {
          if (!tty.input.length) {
            var result = null;
            if (ENVIRONMENT_IS_NODE) {
              // we will read data by chunks of BUFSIZE
              var BUFSIZE = 256;
              var buf = Buffer.alloc ? Buffer.alloc(BUFSIZE) : new Buffer(BUFSIZE);
              var bytesRead = 0;
  
              try {
                bytesRead = nodeFS.readSync(process.stdin.fd, buf, 0, BUFSIZE, null);
              } catch(e) {
                // Cross-platform differences: on Windows, reading EOF throws an exception, but on other OSes,
                // reading EOF returns 0. Uniformize behavior by treating the EOF exception to return 0.
                if (e.toString().indexOf('EOF') != -1) bytesRead = 0;
                else throw e;
              }
  
              if (bytesRead > 0) {
                result = buf.slice(0, bytesRead).toString('utf-8');
              } else {
                result = null;
              }
            } else
            if (typeof window != 'undefined' &&
              typeof window.prompt == 'function') {
              // Browser.
              result = window.prompt('Input: ');  // returns null on cancel
              if (result !== null) {
                result += '\n';
              }
            } else if (typeof readline == 'function') {
              // Command line.
              result = readline();
              if (result !== null) {
                result += '\n';
              }
            }
            if (!result) {
              return null;
            }
            tty.input = intArrayFromString(result, true);
          }
          return tty.input.shift();
        },put_char:function(tty, val) {
          if (val === null || val === 10) {
            out(UTF8ArrayToString(tty.output, 0));
            tty.output = [];
          } else {
            if (val != 0) tty.output.push(val); // val == 0 would cut text output off in the middle.
          }
        },flush:function(tty) {
          if (tty.output && tty.output.length > 0) {
            out(UTF8ArrayToString(tty.output, 0));
            tty.output = [];
          }
        }},default_tty1_ops:{put_char:function(tty, val) {
          if (val === null || val === 10) {
            err(UTF8ArrayToString(tty.output, 0));
            tty.output = [];
          } else {
            if (val != 0) tty.output.push(val);
          }
        },flush:function(tty) {
          if (tty.output && tty.output.length > 0) {
            err(UTF8ArrayToString(tty.output, 0));
            tty.output = [];
          }
        }}};
  
  var MEMFS={ops_table:null,mount:function(mount) {
        return MEMFS.createNode(null, '/', 16384 | 511 /* 0777 */, 0);
      },createNode:function(parent, name, mode, dev) {
        if (FS.isBlkdev(mode) || FS.isFIFO(mode)) {
          // no supported
          throw new FS.ErrnoError(63);
        }
        if (!MEMFS.ops_table) {
          MEMFS.ops_table = {
            dir: {
              node: {
                getattr: MEMFS.node_ops.getattr,
                setattr: MEMFS.node_ops.setattr,
                lookup: MEMFS.node_ops.lookup,
                mknod: MEMFS.node_ops.mknod,
                rename: MEMFS.node_ops.rename,
                unlink: MEMFS.node_ops.unlink,
                rmdir: MEMFS.node_ops.rmdir,
                readdir: MEMFS.node_ops.readdir,
                symlink: MEMFS.node_ops.symlink
              },
              stream: {
                llseek: MEMFS.stream_ops.llseek
              }
            },
            file: {
              node: {
                getattr: MEMFS.node_ops.getattr,
                setattr: MEMFS.node_ops.setattr
              },
              stream: {
                llseek: MEMFS.stream_ops.llseek,
                read: MEMFS.stream_ops.read,
                write: MEMFS.stream_ops.write,
                allocate: MEMFS.stream_ops.allocate,
                mmap: MEMFS.stream_ops.mmap,
                msync: MEMFS.stream_ops.msync
              }
            },
            link: {
              node: {
                getattr: MEMFS.node_ops.getattr,
                setattr: MEMFS.node_ops.setattr,
                readlink: MEMFS.node_ops.readlink
              },
              stream: {}
            },
            chrdev: {
              node: {
                getattr: MEMFS.node_ops.getattr,
                setattr: MEMFS.node_ops.setattr
              },
              stream: FS.chrdev_stream_ops
            }
          };
        }
        var node = FS.createNode(parent, name, mode, dev);
        if (FS.isDir(node.mode)) {
          node.node_ops = MEMFS.ops_table.dir.node;
          node.stream_ops = MEMFS.ops_table.dir.stream;
          node.contents = {};
        } else if (FS.isFile(node.mode)) {
          node.node_ops = MEMFS.ops_table.file.node;
          node.stream_ops = MEMFS.ops_table.file.stream;
          node.usedBytes = 0; // The actual number of bytes used in the typed array, as opposed to contents.length which gives the whole capacity.
          // When the byte data of the file is populated, this will point to either a typed array, or a normal JS array. Typed arrays are preferred
          // for performance, and used by default. However, typed arrays are not resizable like normal JS arrays are, so there is a small disk size
          // penalty involved for appending file writes that continuously grow a file similar to std::vector capacity vs used -scheme.
          node.contents = null; 
        } else if (FS.isLink(node.mode)) {
          node.node_ops = MEMFS.ops_table.link.node;
          node.stream_ops = MEMFS.ops_table.link.stream;
        } else if (FS.isChrdev(node.mode)) {
          node.node_ops = MEMFS.ops_table.chrdev.node;
          node.stream_ops = MEMFS.ops_table.chrdev.stream;
        }
        node.timestamp = Date.now();
        // add the new node to the parent
        if (parent) {
          parent.contents[name] = node;
        }
        return node;
      },getFileDataAsRegularArray:function(node) {
        if (node.contents && node.contents.subarray) {
          var arr = [];
          for (var i = 0; i < node.usedBytes; ++i) arr.push(node.contents[i]);
          return arr; // Returns a copy of the original data.
        }
        return node.contents; // No-op, the file contents are already in a JS array. Return as-is.
      },getFileDataAsTypedArray:function(node) {
        if (!node.contents) return new Uint8Array(0);
        if (node.contents.subarray) return node.contents.subarray(0, node.usedBytes); // Make sure to not return excess unused bytes.
        return new Uint8Array(node.contents);
      },expandFileStorage:function(node, newCapacity) {
        var prevCapacity = node.contents ? node.contents.length : 0;
        if (prevCapacity >= newCapacity) return; // No need to expand, the storage was already large enough.
        // Don't expand strictly to the given requested limit if it's only a very small increase, but instead geometrically grow capacity.
        // For small filesizes (<1MB), perform size*2 geometric increase, but for large sizes, do a much more conservative size*1.125 increase to
        // avoid overshooting the allocation cap by a very large margin.
        var CAPACITY_DOUBLING_MAX = 1024 * 1024;
        newCapacity = Math.max(newCapacity, (prevCapacity * (prevCapacity < CAPACITY_DOUBLING_MAX ? 2.0 : 1.125)) >>> 0);
        if (prevCapacity != 0) newCapacity = Math.max(newCapacity, 256); // At minimum allocate 256b for each file when expanding.
        var oldContents = node.contents;
        node.contents = new Uint8Array(newCapacity); // Allocate new storage.
        if (node.usedBytes > 0) node.contents.set(oldContents.subarray(0, node.usedBytes), 0); // Copy old data over to the new storage.
        return;
      },resizeFileStorage:function(node, newSize) {
        if (node.usedBytes == newSize) return;
        if (newSize == 0) {
          node.contents = null; // Fully decommit when requesting a resize to zero.
          node.usedBytes = 0;
          return;
        }
        if (!node.contents || node.contents.subarray) { // Resize a typed array if that is being used as the backing store.
          var oldContents = node.contents;
          node.contents = new Uint8Array(newSize); // Allocate new storage.
          if (oldContents) {
            node.contents.set(oldContents.subarray(0, Math.min(newSize, node.usedBytes))); // Copy old data over to the new storage.
          }
          node.usedBytes = newSize;
          return;
        }
        // Backing with a JS array.
        if (!node.contents) node.contents = [];
        if (node.contents.length > newSize) node.contents.length = newSize;
        else while (node.contents.length < newSize) node.contents.push(0);
        node.usedBytes = newSize;
      },node_ops:{getattr:function(node) {
          var attr = {};
          // device numbers reuse inode numbers.
          attr.dev = FS.isChrdev(node.mode) ? node.id : 1;
          attr.ino = node.id;
          attr.mode = node.mode;
          attr.nlink = 1;
          attr.uid = 0;
          attr.gid = 0;
          attr.rdev = node.rdev;
          if (FS.isDir(node.mode)) {
            attr.size = 4096;
          } else if (FS.isFile(node.mode)) {
            attr.size = node.usedBytes;
          } else if (FS.isLink(node.mode)) {
            attr.size = node.link.length;
          } else {
            attr.size = 0;
          }
          attr.atime = new Date(node.timestamp);
          attr.mtime = new Date(node.timestamp);
          attr.ctime = new Date(node.timestamp);
          // NOTE: In our implementation, st_blocks = Math.ceil(st_size/st_blksize),
          //       but this is not required by the standard.
          attr.blksize = 4096;
          attr.blocks = Math.ceil(attr.size / attr.blksize);
          return attr;
        },setattr:function(node, attr) {
          if (attr.mode !== undefined) {
            node.mode = attr.mode;
          }
          if (attr.timestamp !== undefined) {
            node.timestamp = attr.timestamp;
          }
          if (attr.size !== undefined) {
            MEMFS.resizeFileStorage(node, attr.size);
          }
        },lookup:function(parent, name) {
          throw FS.genericErrors[44];
        },mknod:function(parent, name, mode, dev) {
          return MEMFS.createNode(parent, name, mode, dev);
        },rename:function(old_node, new_dir, new_name) {
          // if we're overwriting a directory at new_name, make sure it's empty.
          if (FS.isDir(old_node.mode)) {
            var new_node;
            try {
              new_node = FS.lookupNode(new_dir, new_name);
            } catch (e) {
            }
            if (new_node) {
              for (var i in new_node.contents) {
                throw new FS.ErrnoError(55);
              }
            }
          }
          // do the internal rewiring
          delete old_node.parent.contents[old_node.name];
          old_node.name = new_name;
          new_dir.contents[new_name] = old_node;
          old_node.parent = new_dir;
        },unlink:function(parent, name) {
          delete parent.contents[name];
        },rmdir:function(parent, name) {
          var node = FS.lookupNode(parent, name);
          for (var i in node.contents) {
            throw new FS.ErrnoError(55);
          }
          delete parent.contents[name];
        },readdir:function(node) {
          var entries = ['.', '..'];
          for (var key in node.contents) {
            if (!node.contents.hasOwnProperty(key)) {
              continue;
            }
            entries.push(key);
          }
          return entries;
        },symlink:function(parent, newname, oldpath) {
          var node = MEMFS.createNode(parent, newname, 511 /* 0777 */ | 40960, 0);
          node.link = oldpath;
          return node;
        },readlink:function(node) {
          if (!FS.isLink(node.mode)) {
            throw new FS.ErrnoError(28);
          }
          return node.link;
        }},stream_ops:{read:function(stream, buffer, offset, length, position) {
          var contents = stream.node.contents;
          if (position >= stream.node.usedBytes) return 0;
          var size = Math.min(stream.node.usedBytes - position, length);
          assert(size >= 0);
          if (size > 8 && contents.subarray) { // non-trivial, and typed array
            buffer.set(contents.subarray(position, position + size), offset);
          } else {
            for (var i = 0; i < size; i++) buffer[offset + i] = contents[position + i];
          }
          return size;
        },write:function(stream, buffer, offset, length, position, canOwn) {
          // The data buffer should be a typed array view
          assert(!(buffer instanceof ArrayBuffer));
          // If the buffer is located in main memory (HEAP), and if
          // memory can grow, we can't hold on to references of the
          // memory buffer, as they may get invalidated. That means we
          // need to do copy its contents.
          if (buffer.buffer === HEAP8.buffer) {
            // FIXME: this is inefficient as the file packager may have
            //        copied the data into memory already - we may want to
            //        integrate more there and let the file packager loading
            //        code be able to query if memory growth is on or off.
            if (canOwn) {
              warnOnce('file packager has copied file data into memory, but in memory growth we are forced to copy it again (see --no-heap-copy)');
            }
            canOwn = false;
          }
  
          if (!length) return 0;
          var node = stream.node;
          node.timestamp = Date.now();
  
          if (buffer.subarray && (!node.contents || node.contents.subarray)) { // This write is from a typed array to a typed array?
            if (canOwn) {
              assert(position === 0, 'canOwn must imply no weird position inside the file');
              node.contents = buffer.subarray(offset, offset + length);
              node.usedBytes = length;
              return length;
            } else if (node.usedBytes === 0 && position === 0) { // If this is a simple first write to an empty file, do a fast set since we don't need to care about old data.
              node.contents = buffer.slice(offset, offset + length);
              node.usedBytes = length;
              return length;
            } else if (position + length <= node.usedBytes) { // Writing to an already allocated and used subrange of the file?
              node.contents.set(buffer.subarray(offset, offset + length), position);
              return length;
            }
          }
  
          // Appending to an existing file and we need to reallocate, or source data did not come as a typed array.
          MEMFS.expandFileStorage(node, position+length);
          if (node.contents.subarray && buffer.subarray) node.contents.set(buffer.subarray(offset, offset + length), position); // Use typed array write if available.
          else {
            for (var i = 0; i < length; i++) {
             node.contents[position + i] = buffer[offset + i]; // Or fall back to manual write if not.
            }
          }
          node.usedBytes = Math.max(node.usedBytes, position + length);
          return length;
        },llseek:function(stream, offset, whence) {
          var position = offset;
          if (whence === 1) {
            position += stream.position;
          } else if (whence === 2) {
            if (FS.isFile(stream.node.mode)) {
              position += stream.node.usedBytes;
            }
          }
          if (position < 0) {
            throw new FS.ErrnoError(28);
          }
          return position;
        },allocate:function(stream, offset, length) {
          MEMFS.expandFileStorage(stream.node, offset + length);
          stream.node.usedBytes = Math.max(stream.node.usedBytes, offset + length);
        },mmap:function(stream, buffer, offset, length, position, prot, flags) {
          // The data buffer should be a typed array view
          assert(!(buffer instanceof ArrayBuffer));
          if (!FS.isFile(stream.node.mode)) {
            throw new FS.ErrnoError(43);
          }
          var ptr;
          var allocated;
          var contents = stream.node.contents;
          // Only make a new copy when MAP_PRIVATE is specified.
          if ( !(flags & 2) &&
                contents.buffer === buffer.buffer ) {
            // We can't emulate MAP_SHARED when the file is not backed by the buffer
            // we're mapping to (e.g. the HEAP buffer).
            allocated = false;
            ptr = contents.byteOffset;
          } else {
            // Try to avoid unnecessary slices.
            if (position > 0 || position + length < contents.length) {
              if (contents.subarray) {
                contents = contents.subarray(position, position + length);
              } else {
                contents = Array.prototype.slice.call(contents, position, position + length);
              }
            }
            allocated = true;
            // malloc() can lead to growing the heap. If targeting the heap, we need to
            // re-acquire the heap buffer object in case growth had occurred.
            var fromHeap = (buffer.buffer == HEAP8.buffer);
            ptr = _malloc(length);
            if (!ptr) {
              throw new FS.ErrnoError(48);
            }
            (fromHeap ? HEAP8 : buffer).set(contents, ptr);
          }
          return { ptr: ptr, allocated: allocated };
        },msync:function(stream, buffer, offset, length, mmapFlags) {
          if (!FS.isFile(stream.node.mode)) {
            throw new FS.ErrnoError(43);
          }
          if (mmapFlags & 2) {
            // MAP_PRIVATE calls need not to be synced back to underlying fs
            return 0;
          }
  
          var bytesWritten = MEMFS.stream_ops.write(stream, buffer, 0, length, offset, false);
          // should we check if bytesWritten and length are the same?
          return 0;
        }}};
  
  
  var ERRNO_CODES={EPERM:63,ENOENT:44,ESRCH:71,EINTR:27,EIO:29,ENXIO:60,E2BIG:1,ENOEXEC:45,EBADF:8,ECHILD:12,EAGAIN:6,EWOULDBLOCK:6,ENOMEM:48,EACCES:2,EFAULT:21,ENOTBLK:105,EBUSY:10,EEXIST:20,EXDEV:75,ENODEV:43,ENOTDIR:54,EISDIR:31,EINVAL:28,ENFILE:41,EMFILE:33,ENOTTY:59,ETXTBSY:74,EFBIG:22,ENOSPC:51,ESPIPE:70,EROFS:69,EMLINK:34,EPIPE:64,EDOM:18,ERANGE:68,ENOMSG:49,EIDRM:24,ECHRNG:106,EL2NSYNC:156,EL3HLT:107,EL3RST:108,ELNRNG:109,EUNATCH:110,ENOCSI:111,EL2HLT:112,EDEADLK:16,ENOLCK:46,EBADE:113,EBADR:114,EXFULL:115,ENOANO:104,EBADRQC:103,EBADSLT:102,EDEADLOCK:16,EBFONT:101,ENOSTR:100,ENODATA:116,ETIME:117,ENOSR:118,ENONET:119,ENOPKG:120,EREMOTE:121,ENOLINK:47,EADV:122,ESRMNT:123,ECOMM:124,EPROTO:65,EMULTIHOP:36,EDOTDOT:125,EBADMSG:9,ENOTUNIQ:126,EBADFD:127,EREMCHG:128,ELIBACC:129,ELIBBAD:130,ELIBSCN:131,ELIBMAX:132,ELIBEXEC:133,ENOSYS:52,ENOTEMPTY:55,ENAMETOOLONG:37,ELOOP:32,EOPNOTSUPP:138,EPFNOSUPPORT:139,ECONNRESET:15,ENOBUFS:42,EAFNOSUPPORT:5,EPROTOTYPE:67,ENOTSOCK:57,ENOPROTOOPT:50,ESHUTDOWN:140,ECONNREFUSED:14,EADDRINUSE:3,ECONNABORTED:13,ENETUNREACH:40,ENETDOWN:38,ETIMEDOUT:73,EHOSTDOWN:142,EHOSTUNREACH:23,EINPROGRESS:26,EALREADY:7,EDESTADDRREQ:17,EMSGSIZE:35,EPROTONOSUPPORT:66,ESOCKTNOSUPPORT:137,EADDRNOTAVAIL:4,ENETRESET:39,EISCONN:30,ENOTCONN:53,ETOOMANYREFS:141,EUSERS:136,EDQUOT:19,ESTALE:72,ENOTSUP:138,ENOMEDIUM:148,EILSEQ:25,EOVERFLOW:61,ECANCELED:11,ENOTRECOVERABLE:56,EOWNERDEAD:62,ESTRPIPE:135};var NODEFS={isWindows:false,staticInit:function() {
        NODEFS.isWindows = !!process.platform.match(/^win/);
        var flags = process["binding"]("constants");
        // Node.js 4 compatibility: it has no namespaces for constants
        if (flags["fs"]) {
          flags = flags["fs"];
        }
        NODEFS.flagsForNodeMap = {
          "1024": flags["O_APPEND"],
          "64": flags["O_CREAT"],
          "128": flags["O_EXCL"],
          "0": flags["O_RDONLY"],
          "2": flags["O_RDWR"],
          "4096": flags["O_SYNC"],
          "512": flags["O_TRUNC"],
          "1": flags["O_WRONLY"]
        };
      },bufferFrom:function (arrayBuffer) {
        // Node.js < 4.5 compatibility: Buffer.from does not support ArrayBuffer
        // Buffer.from before 4.5 was just a method inherited from Uint8Array
        // Buffer.alloc has been added with Buffer.from together, so check it instead
        return Buffer["alloc"] ? Buffer.from(arrayBuffer) : new Buffer(arrayBuffer);
      },convertNodeCode:function(e) {
        var code = e.code;
        assert(code in ERRNO_CODES);
        return ERRNO_CODES[code];
      },mount:function (mount) {
        assert(ENVIRONMENT_IS_NODE);
        return NODEFS.createNode(null, '/', NODEFS.getMode(mount.opts.root), 0);
      },createNode:function (parent, name, mode, dev) {
        if (!FS.isDir(mode) && !FS.isFile(mode) && !FS.isLink(mode)) {
          throw new FS.ErrnoError(28);
        }
        var node = FS.createNode(parent, name, mode);
        node.node_ops = NODEFS.node_ops;
        node.stream_ops = NODEFS.stream_ops;
        return node;
      },getMode:function (path) {
        var stat;
        try {
          stat = fs.lstatSync(path);
          if (NODEFS.isWindows) {
            // Node.js on Windows never represents permission bit 'x', so
            // propagate read bits to execute bits
            stat.mode = stat.mode | ((stat.mode & 292) >> 2);
          }
        } catch (e) {
          if (!e.code) throw e;
          throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
        }
        return stat.mode;
      },realPath:function (node) {
        var parts = [];
        while (node.parent !== node) {
          parts.push(node.name);
          node = node.parent;
        }
        parts.push(node.mount.opts.root);
        parts.reverse();
        return PATH.join.apply(null, parts);
      },flagsForNode:function(flags) {
        flags &= ~0x200000 /*O_PATH*/; // Ignore this flag from musl, otherwise node.js fails to open the file.
        flags &= ~0x800 /*O_NONBLOCK*/; // Ignore this flag from musl, otherwise node.js fails to open the file.
        flags &= ~0x8000 /*O_LARGEFILE*/; // Ignore this flag from musl, otherwise node.js fails to open the file.
        flags &= ~0x80000 /*O_CLOEXEC*/; // Some applications may pass it; it makes no sense for a single process.
        var newFlags = 0;
        for (var k in NODEFS.flagsForNodeMap) {
          if (flags & k) {
            newFlags |= NODEFS.flagsForNodeMap[k];
            flags ^= k;
          }
        }
  
        if (!flags) {
          return newFlags;
        } else {
          throw new FS.ErrnoError(28);
        }
      },node_ops:{getattr:function(node) {
          var path = NODEFS.realPath(node);
          var stat;
          try {
            stat = fs.lstatSync(path);
          } catch (e) {
            if (!e.code) throw e;
            throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
          }
          // node.js v0.10.20 doesn't report blksize and blocks on Windows. Fake them with default blksize of 4096.
          // See http://support.microsoft.com/kb/140365
          if (NODEFS.isWindows && !stat.blksize) {
            stat.blksize = 4096;
          }
          if (NODEFS.isWindows && !stat.blocks) {
            stat.blocks = (stat.size+stat.blksize-1)/stat.blksize|0;
          }
          return {
            dev: stat.dev,
            ino: stat.ino,
            mode: stat.mode,
            nlink: stat.nlink,
            uid: stat.uid,
            gid: stat.gid,
            rdev: stat.rdev,
            size: stat.size,
            atime: stat.atime,
            mtime: stat.mtime,
            ctime: stat.ctime,
            blksize: stat.blksize,
            blocks: stat.blocks
          };
        },setattr:function(node, attr) {
          var path = NODEFS.realPath(node);
          try {
            if (attr.mode !== undefined) {
              fs.chmodSync(path, attr.mode);
              // update the common node structure mode as well
              node.mode = attr.mode;
            }
            if (attr.timestamp !== undefined) {
              var date = new Date(attr.timestamp);
              fs.utimesSync(path, date, date);
            }
            if (attr.size !== undefined) {
              fs.truncateSync(path, attr.size);
            }
          } catch (e) {
            if (!e.code) throw e;
            throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
          }
        },lookup:function (parent, name) {
          var path = PATH.join2(NODEFS.realPath(parent), name);
          var mode = NODEFS.getMode(path);
          return NODEFS.createNode(parent, name, mode);
        },mknod:function (parent, name, mode, dev) {
          var node = NODEFS.createNode(parent, name, mode, dev);
          // create the backing node for this in the fs root as well
          var path = NODEFS.realPath(node);
          try {
            if (FS.isDir(node.mode)) {
              fs.mkdirSync(path, node.mode);
            } else {
              fs.writeFileSync(path, '', { mode: node.mode });
            }
          } catch (e) {
            if (!e.code) throw e;
            throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
          }
          return node;
        },rename:function (oldNode, newDir, newName) {
          var oldPath = NODEFS.realPath(oldNode);
          var newPath = PATH.join2(NODEFS.realPath(newDir), newName);
          try {
            fs.renameSync(oldPath, newPath);
          } catch (e) {
            if (!e.code) throw e;
            throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
          }
          oldNode.name = newName;
        },unlink:function(parent, name) {
          var path = PATH.join2(NODEFS.realPath(parent), name);
          try {
            fs.unlinkSync(path);
          } catch (e) {
            if (!e.code) throw e;
            throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
          }
        },rmdir:function(parent, name) {
          var path = PATH.join2(NODEFS.realPath(parent), name);
          try {
            fs.rmdirSync(path);
          } catch (e) {
            if (!e.code) throw e;
            throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
          }
        },readdir:function(node) {
          var path = NODEFS.realPath(node);
          try {
            return fs.readdirSync(path);
          } catch (e) {
            if (!e.code) throw e;
            throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
          }
        },symlink:function(parent, newName, oldPath) {
          var newPath = PATH.join2(NODEFS.realPath(parent), newName);
          try {
            fs.symlinkSync(oldPath, newPath);
          } catch (e) {
            if (!e.code) throw e;
            throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
          }
        },readlink:function(node) {
          var path = NODEFS.realPath(node);
          try {
            path = fs.readlinkSync(path);
            path = NODEJS_PATH.relative(NODEJS_PATH.resolve(node.mount.opts.root), path);
            return path;
          } catch (e) {
            if (!e.code) throw e;
            throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
          }
        }},stream_ops:{open:function (stream) {
          var path = NODEFS.realPath(stream.node);
          try {
            if (FS.isFile(stream.node.mode)) {
              stream.nfd = fs.openSync(path, NODEFS.flagsForNode(stream.flags));
            }
          } catch (e) {
            if (!e.code) throw e;
            throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
          }
        },close:function (stream) {
          try {
            if (FS.isFile(stream.node.mode) && stream.nfd) {
              fs.closeSync(stream.nfd);
            }
          } catch (e) {
            if (!e.code) throw e;
            throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
          }
        },read:function (stream, buffer, offset, length, position) {
          // Node.js < 6 compatibility: node errors on 0 length reads
          if (length === 0) return 0;
          try {
            return fs.readSync(stream.nfd, NODEFS.bufferFrom(buffer.buffer), offset, length, position);
          } catch (e) {
            throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
          }
        },write:function (stream, buffer, offset, length, position) {
          try {
            return fs.writeSync(stream.nfd, NODEFS.bufferFrom(buffer.buffer), offset, length, position);
          } catch (e) {
            throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
          }
        },llseek:function (stream, offset, whence) {
          var position = offset;
          if (whence === 1) {
            position += stream.position;
          } else if (whence === 2) {
            if (FS.isFile(stream.node.mode)) {
              try {
                var stat = fs.fstatSync(stream.nfd);
                position += stat.size;
              } catch (e) {
                throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
              }
            }
          }
  
          if (position < 0) {
            throw new FS.ErrnoError(28);
          }
  
          return position;
        },mmap:function(stream, buffer, offset, length, position, prot, flags) {
          if (!FS.isFile(stream.node.mode)) {
            throw new FS.ErrnoError(43);
          }
          var ptr = _malloc(length);
  
          assert(offset === 0);
          NODEFS.stream_ops.read(stream, buffer, ptr + offset, length, position);
          
          return { ptr: ptr, allocated: true };
        },msync:function(stream, buffer, offset, length, mmapFlags) {
          if (!FS.isFile(stream.node.mode)) {
            throw new FS.ErrnoError(43);
          }
          if (mmapFlags & 2) {
            // MAP_PRIVATE calls need not to be synced back to underlying fs
            return 0;
          }
  
          var bytesWritten = NODEFS.stream_ops.write(stream, buffer, 0, length, offset, false);
          return 0;
        }}};
  
  var ERRNO_MESSAGES={0:"Success",1:"Arg list too long",2:"Permission denied",3:"Address already in use",4:"Address not available",5:"Address family not supported by protocol family",6:"No more processes",7:"Socket already connected",8:"Bad file number",9:"Trying to read unreadable message",10:"Mount device busy",11:"Operation canceled",12:"No children",13:"Connection aborted",14:"Connection refused",15:"Connection reset by peer",16:"File locking deadlock error",17:"Destination address required",18:"Math arg out of domain of func",19:"Quota exceeded",20:"File exists",21:"Bad address",22:"File too large",23:"Host is unreachable",24:"Identifier removed",25:"Illegal byte sequence",26:"Connection already in progress",27:"Interrupted system call",28:"Invalid argument",29:"I/O error",30:"Socket is already connected",31:"Is a directory",32:"Too many symbolic links",33:"Too many open files",34:"Too many links",35:"Message too long",36:"Multihop attempted",37:"File or path name too long",38:"Network interface is not configured",39:"Connection reset by network",40:"Network is unreachable",41:"Too many open files in system",42:"No buffer space available",43:"No such device",44:"No such file or directory",45:"Exec format error",46:"No record locks available",47:"The link has been severed",48:"Not enough core",49:"No message of desired type",50:"Protocol not available",51:"No space left on device",52:"Function not implemented",53:"Socket is not connected",54:"Not a directory",55:"Directory not empty",56:"State not recoverable",57:"Socket operation on non-socket",59:"Not a typewriter",60:"No such device or address",61:"Value too large for defined data type",62:"Previous owner died",63:"Not super-user",64:"Broken pipe",65:"Protocol error",66:"Unknown protocol",67:"Protocol wrong type for socket",68:"Math result not representable",69:"Read only file system",70:"Illegal seek",71:"No such process",72:"Stale file handle",73:"Connection timed out",74:"Text file busy",75:"Cross-device link",100:"Device not a stream",101:"Bad font file fmt",102:"Invalid slot",103:"Invalid request code",104:"No anode",105:"Block device required",106:"Channel number out of range",107:"Level 3 halted",108:"Level 3 reset",109:"Link number out of range",110:"Protocol driver not attached",111:"No CSI structure available",112:"Level 2 halted",113:"Invalid exchange",114:"Invalid request descriptor",115:"Exchange full",116:"No data (for no delay io)",117:"Timer expired",118:"Out of streams resources",119:"Machine is not on the network",120:"Package not installed",121:"The object is remote",122:"Advertise error",123:"Srmount error",124:"Communication error on send",125:"Cross mount point (not really error)",126:"Given log. name not unique",127:"f.d. invalid for this operation",128:"Remote address changed",129:"Can   access a needed shared lib",130:"Accessing a corrupted shared lib",131:".lib section in a.out corrupted",132:"Attempting to link in too many libs",133:"Attempting to exec a shared library",135:"Streams pipe error",136:"Too many users",137:"Socket type not supported",138:"Not supported",139:"Protocol family not supported",140:"Can't send after socket shutdown",141:"Too many references",142:"Host is down",148:"No medium (in tape drive)",156:"Level 2 not synchronized"};var FS={root:null,mounts:[],devices:{},streams:[],nextInode:1,nameTable:null,currentPath:"/",initialized:false,ignorePermissions:true,trackingDelegate:{},tracking:{openFlags:{READ:1,WRITE:2}},ErrnoError:null,genericErrors:{},filesystems:null,syncFSRequests:0,handleFSError:function(e) {
        if (!(e instanceof FS.ErrnoError)) throw e + ' : ' + stackTrace();
        return setErrNo(e.errno);
      },lookupPath:function(path, opts) {
        path = PATH_FS.resolve(FS.cwd(), path);
        opts = opts || {};
  
        if (!path) return { path: '', node: null };
  
        var defaults = {
          follow_mount: true,
          recurse_count: 0
        };
        for (var key in defaults) {
          if (opts[key] === undefined) {
            opts[key] = defaults[key];
          }
        }
  
        if (opts.recurse_count > 8) {  // max recursive lookup of 8
          throw new FS.ErrnoError(32);
        }
  
        // split the path
        var parts = PATH.normalizeArray(path.split('/').filter(function(p) {
          return !!p;
        }), false);
  
        // start at the root
        var current = FS.root;
        var current_path = '/';
  
        for (var i = 0; i < parts.length; i++) {
          var islast = (i === parts.length-1);
          if (islast && opts.parent) {
            // stop resolving
            break;
          }
  
          current = FS.lookupNode(current, parts[i]);
          current_path = PATH.join2(current_path, parts[i]);
  
          // jump to the mount's root node if this is a mountpoint
          if (FS.isMountpoint(current)) {
            if (!islast || (islast && opts.follow_mount)) {
              current = current.mounted.root;
            }
          }
  
          // by default, lookupPath will not follow a symlink if it is the final path component.
          // setting opts.follow = true will override this behavior.
          if (!islast || opts.follow) {
            var count = 0;
            while (FS.isLink(current.mode)) {
              var link = FS.readlink(current_path);
              current_path = PATH_FS.resolve(PATH.dirname(current_path), link);
  
              var lookup = FS.lookupPath(current_path, { recurse_count: opts.recurse_count });
              current = lookup.node;
  
              if (count++ > 40) {  // limit max consecutive symlinks to 40 (SYMLOOP_MAX).
                throw new FS.ErrnoError(32);
              }
            }
          }
        }
  
        return { path: current_path, node: current };
      },getPath:function(node) {
        var path;
        while (true) {
          if (FS.isRoot(node)) {
            var mount = node.mount.mountpoint;
            if (!path) return mount;
            return mount[mount.length-1] !== '/' ? mount + '/' + path : mount + path;
          }
          path = path ? node.name + '/' + path : node.name;
          node = node.parent;
        }
      },hashName:function(parentid, name) {
        var hash = 0;
  
  
        for (var i = 0; i < name.length; i++) {
          hash = ((hash << 5) - hash + name.charCodeAt(i)) | 0;
        }
        return ((parentid + hash) >>> 0) % FS.nameTable.length;
      },hashAddNode:function(node) {
        var hash = FS.hashName(node.parent.id, node.name);
        node.name_next = FS.nameTable[hash];
        FS.nameTable[hash] = node;
      },hashRemoveNode:function(node) {
        var hash = FS.hashName(node.parent.id, node.name);
        if (FS.nameTable[hash] === node) {
          FS.nameTable[hash] = node.name_next;
        } else {
          var current = FS.nameTable[hash];
          while (current) {
            if (current.name_next === node) {
              current.name_next = node.name_next;
              break;
            }
            current = current.name_next;
          }
        }
      },lookupNode:function(parent, name) {
        var errCode = FS.mayLookup(parent);
        if (errCode) {
          throw new FS.ErrnoError(errCode, parent);
        }
        var hash = FS.hashName(parent.id, name);
        for (var node = FS.nameTable[hash]; node; node = node.name_next) {
          var nodeName = node.name;
          if (node.parent.id === parent.id && nodeName === name) {
            return node;
          }
        }
        // if we failed to find it in the cache, call into the VFS
        return FS.lookup(parent, name);
      },createNode:function(parent, name, mode, rdev) {
        var node = new FS.FSNode(parent, name, mode, rdev);
  
        FS.hashAddNode(node);
  
        return node;
      },destroyNode:function(node) {
        FS.hashRemoveNode(node);
      },isRoot:function(node) {
        return node === node.parent;
      },isMountpoint:function(node) {
        return !!node.mounted;
      },isFile:function(mode) {
        return (mode & 61440) === 32768;
      },isDir:function(mode) {
        return (mode & 61440) === 16384;
      },isLink:function(mode) {
        return (mode & 61440) === 40960;
      },isChrdev:function(mode) {
        return (mode & 61440) === 8192;
      },isBlkdev:function(mode) {
        return (mode & 61440) === 24576;
      },isFIFO:function(mode) {
        return (mode & 61440) === 4096;
      },isSocket:function(mode) {
        return (mode & 49152) === 49152;
      },flagModes:{"r":0,"rs":1052672,"r+":2,"w":577,"wx":705,"xw":705,"w+":578,"wx+":706,"xw+":706,"a":1089,"ax":1217,"xa":1217,"a+":1090,"ax+":1218,"xa+":1218},modeStringToFlags:function(str) {
        var flags = FS.flagModes[str];
        if (typeof flags === 'undefined') {
          throw new Error('Unknown file open mode: ' + str);
        }
        return flags;
      },flagsToPermissionString:function(flag) {
        var perms = ['r', 'w', 'rw'][flag & 3];
        if ((flag & 512)) {
          perms += 'w';
        }
        return perms;
      },nodePermissions:function(node, perms) {
        if (FS.ignorePermissions) {
          return 0;
        }
        // return 0 if any user, group or owner bits are set.
        if (perms.indexOf('r') !== -1 && !(node.mode & 292)) {
          return 2;
        } else if (perms.indexOf('w') !== -1 && !(node.mode & 146)) {
          return 2;
        } else if (perms.indexOf('x') !== -1 && !(node.mode & 73)) {
          return 2;
        }
        return 0;
      },mayLookup:function(dir) {
        var errCode = FS.nodePermissions(dir, 'x');
        if (errCode) return errCode;
        if (!dir.node_ops.lookup) return 2;
        return 0;
      },mayCreate:function(dir, name) {
        try {
          var node = FS.lookupNode(dir, name);
          return 20;
        } catch (e) {
        }
        return FS.nodePermissions(dir, 'wx');
      },mayDelete:function(dir, name, isdir) {
        var node;
        try {
          node = FS.lookupNode(dir, name);
        } catch (e) {
          return e.errno;
        }
        var errCode = FS.nodePermissions(dir, 'wx');
        if (errCode) {
          return errCode;
        }
        if (isdir) {
          if (!FS.isDir(node.mode)) {
            return 54;
          }
          if (FS.isRoot(node) || FS.getPath(node) === FS.cwd()) {
            return 10;
          }
        } else {
          if (FS.isDir(node.mode)) {
            return 31;
          }
        }
        return 0;
      },mayOpen:function(node, flags) {
        if (!node) {
          return 44;
        }
        if (FS.isLink(node.mode)) {
          return 32;
        } else if (FS.isDir(node.mode)) {
          if (FS.flagsToPermissionString(flags) !== 'r' || // opening for write
              (flags & 512)) { // TODO: check for O_SEARCH? (== search for dir only)
            return 31;
          }
        }
        return FS.nodePermissions(node, FS.flagsToPermissionString(flags));
      },MAX_OPEN_FDS:4096,nextfd:function(fd_start, fd_end) {
        fd_start = fd_start || 0;
        fd_end = fd_end || FS.MAX_OPEN_FDS;
        for (var fd = fd_start; fd <= fd_end; fd++) {
          if (!FS.streams[fd]) {
            return fd;
          }
        }
        throw new FS.ErrnoError(33);
      },getStream:function(fd) {
        return FS.streams[fd];
      },createStream:function(stream, fd_start, fd_end) {
        if (!FS.FSStream) {
          FS.FSStream = /** @constructor */ function(){};
          FS.FSStream.prototype = {
            object: {
              get: function() { return this.node; },
              set: function(val) { this.node = val; }
            },
            isRead: {
              get: function() { return (this.flags & 2097155) !== 1; }
            },
            isWrite: {
              get: function() { return (this.flags & 2097155) !== 0; }
            },
            isAppend: {
              get: function() { return (this.flags & 1024); }
            }
          };
        }
        // clone it, so we can return an instance of FSStream
        var newStream = new FS.FSStream();
        for (var p in stream) {
          newStream[p] = stream[p];
        }
        stream = newStream;
        var fd = FS.nextfd(fd_start, fd_end);
        stream.fd = fd;
        FS.streams[fd] = stream;
        return stream;
      },closeStream:function(fd) {
        FS.streams[fd] = null;
      },chrdev_stream_ops:{open:function(stream) {
          var device = FS.getDevice(stream.node.rdev);
          // override node's stream ops with the device's
          stream.stream_ops = device.stream_ops;
          // forward the open call
          if (stream.stream_ops.open) {
            stream.stream_ops.open(stream);
          }
        },llseek:function() {
          throw new FS.ErrnoError(70);
        }},major:function(dev) {
        return ((dev) >> 8);
      },minor:function(dev) {
        return ((dev) & 0xff);
      },makedev:function(ma, mi) {
        return ((ma) << 8 | (mi));
      },registerDevice:function(dev, ops) {
        FS.devices[dev] = { stream_ops: ops };
      },getDevice:function(dev) {
        return FS.devices[dev];
      },getMounts:function(mount) {
        var mounts = [];
        var check = [mount];
  
        while (check.length) {
          var m = check.pop();
  
          mounts.push(m);
  
          check.push.apply(check, m.mounts);
        }
  
        return mounts;
      },syncfs:function(populate, callback) {
        if (typeof(populate) === 'function') {
          callback = populate;
          populate = false;
        }
  
        FS.syncFSRequests++;
  
        if (FS.syncFSRequests > 1) {
          err('warning: ' + FS.syncFSRequests + ' FS.syncfs operations in flight at once, probably just doing extra work');
        }
  
        var mounts = FS.getMounts(FS.root.mount);
        var completed = 0;
  
        function doCallback(errCode) {
          assert(FS.syncFSRequests > 0);
          FS.syncFSRequests--;
          return callback(errCode);
        }
  
        function done(errCode) {
          if (errCode) {
            if (!done.errored) {
              done.errored = true;
              return doCallback(errCode);
            }
            return;
          }
          if (++completed >= mounts.length) {
            doCallback(null);
          }
        };
  
        // sync all mounts
        mounts.forEach(function (mount) {
          if (!mount.type.syncfs) {
            return done(null);
          }
          mount.type.syncfs(mount, populate, done);
        });
      },mount:function(type, opts, mountpoint) {
        if (typeof type === 'string') {
          // The filesystem was not included, and instead we have an error
          // message stored in the variable.
          throw type;
        }
        var root = mountpoint === '/';
        var pseudo = !mountpoint;
        var node;
  
        if (root && FS.root) {
          throw new FS.ErrnoError(10);
        } else if (!root && !pseudo) {
          var lookup = FS.lookupPath(mountpoint, { follow_mount: false });
  
          mountpoint = lookup.path;  // use the absolute path
          node = lookup.node;
  
          if (FS.isMountpoint(node)) {
            throw new FS.ErrnoError(10);
          }
  
          if (!FS.isDir(node.mode)) {
            throw new FS.ErrnoError(54);
          }
        }
  
        var mount = {
          type: type,
          opts: opts,
          mountpoint: mountpoint,
          mounts: []
        };
  
        // create a root node for the fs
        var mountRoot = type.mount(mount);
        mountRoot.mount = mount;
        mount.root = mountRoot;
  
        if (root) {
          FS.root = mountRoot;
        } else if (node) {
          // set as a mountpoint
          node.mounted = mount;
  
          // add the new mount to the current mount's children
          if (node.mount) {
            node.mount.mounts.push(mount);
          }
        }
  
        return mountRoot;
      },unmount:function (mountpoint) {
        var lookup = FS.lookupPath(mountpoint, { follow_mount: false });
  
        if (!FS.isMountpoint(lookup.node)) {
          throw new FS.ErrnoError(28);
        }
  
        // destroy the nodes for this mount, and all its child mounts
        var node = lookup.node;
        var mount = node.mounted;
        var mounts = FS.getMounts(mount);
  
        Object.keys(FS.nameTable).forEach(function (hash) {
          var current = FS.nameTable[hash];
  
          while (current) {
            var next = current.name_next;
  
            if (mounts.indexOf(current.mount) !== -1) {
              FS.destroyNode(current);
            }
  
            current = next;
          }
        });
  
        // no longer a mountpoint
        node.mounted = null;
  
        // remove this mount from the child mounts
        var idx = node.mount.mounts.indexOf(mount);
        assert(idx !== -1);
        node.mount.mounts.splice(idx, 1);
      },lookup:function(parent, name) {
        return parent.node_ops.lookup(parent, name);
      },mknod:function(path, mode, dev) {
        var lookup = FS.lookupPath(path, { parent: true });
        var parent = lookup.node;
        var name = PATH.basename(path);
        if (!name || name === '.' || name === '..') {
          throw new FS.ErrnoError(28);
        }
        var errCode = FS.mayCreate(parent, name);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        if (!parent.node_ops.mknod) {
          throw new FS.ErrnoError(63);
        }
        return parent.node_ops.mknod(parent, name, mode, dev);
      },create:function(path, mode) {
        mode = mode !== undefined ? mode : 438 /* 0666 */;
        mode &= 4095;
        mode |= 32768;
        return FS.mknod(path, mode, 0);
      },mkdir:function(path, mode) {
        mode = mode !== undefined ? mode : 511 /* 0777 */;
        mode &= 511 | 512;
        mode |= 16384;
        return FS.mknod(path, mode, 0);
      },mkdirTree:function(path, mode) {
        var dirs = path.split('/');
        var d = '';
        for (var i = 0; i < dirs.length; ++i) {
          if (!dirs[i]) continue;
          d += '/' + dirs[i];
          try {
            FS.mkdir(d, mode);
          } catch(e) {
            if (e.errno != 20) throw e;
          }
        }
      },mkdev:function(path, mode, dev) {
        if (typeof(dev) === 'undefined') {
          dev = mode;
          mode = 438 /* 0666 */;
        }
        mode |= 8192;
        return FS.mknod(path, mode, dev);
      },symlink:function(oldpath, newpath) {
        if (!PATH_FS.resolve(oldpath)) {
          throw new FS.ErrnoError(44);
        }
        var lookup = FS.lookupPath(newpath, { parent: true });
        var parent = lookup.node;
        if (!parent) {
          throw new FS.ErrnoError(44);
        }
        var newname = PATH.basename(newpath);
        var errCode = FS.mayCreate(parent, newname);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        if (!parent.node_ops.symlink) {
          throw new FS.ErrnoError(63);
        }
        return parent.node_ops.symlink(parent, newname, oldpath);
      },rename:function(old_path, new_path) {
        var old_dirname = PATH.dirname(old_path);
        var new_dirname = PATH.dirname(new_path);
        var old_name = PATH.basename(old_path);
        var new_name = PATH.basename(new_path);
        // parents must exist
        var lookup, old_dir, new_dir;
        try {
          lookup = FS.lookupPath(old_path, { parent: true });
          old_dir = lookup.node;
          lookup = FS.lookupPath(new_path, { parent: true });
          new_dir = lookup.node;
        } catch (e) {
          throw new FS.ErrnoError(10);
        }
        if (!old_dir || !new_dir) throw new FS.ErrnoError(44);
        // need to be part of the same mount
        if (old_dir.mount !== new_dir.mount) {
          throw new FS.ErrnoError(75);
        }
        // source must exist
        var old_node = FS.lookupNode(old_dir, old_name);
        // old path should not be an ancestor of the new path
        var relative = PATH_FS.relative(old_path, new_dirname);
        if (relative.charAt(0) !== '.') {
          throw new FS.ErrnoError(28);
        }
        // new path should not be an ancestor of the old path
        relative = PATH_FS.relative(new_path, old_dirname);
        if (relative.charAt(0) !== '.') {
          throw new FS.ErrnoError(55);
        }
        // see if the new path already exists
        var new_node;
        try {
          new_node = FS.lookupNode(new_dir, new_name);
        } catch (e) {
          // not fatal
        }
        // early out if nothing needs to change
        if (old_node === new_node) {
          return;
        }
        // we'll need to delete the old entry
        var isdir = FS.isDir(old_node.mode);
        var errCode = FS.mayDelete(old_dir, old_name, isdir);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        // need delete permissions if we'll be overwriting.
        // need create permissions if new doesn't already exist.
        errCode = new_node ?
          FS.mayDelete(new_dir, new_name, isdir) :
          FS.mayCreate(new_dir, new_name);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        if (!old_dir.node_ops.rename) {
          throw new FS.ErrnoError(63);
        }
        if (FS.isMountpoint(old_node) || (new_node && FS.isMountpoint(new_node))) {
          throw new FS.ErrnoError(10);
        }
        // if we are going to change the parent, check write permissions
        if (new_dir !== old_dir) {
          errCode = FS.nodePermissions(old_dir, 'w');
          if (errCode) {
            throw new FS.ErrnoError(errCode);
          }
        }
        try {
          if (FS.trackingDelegate['willMovePath']) {
            FS.trackingDelegate['willMovePath'](old_path, new_path);
          }
        } catch(e) {
          err("FS.trackingDelegate['willMovePath']('"+old_path+"', '"+new_path+"') threw an exception: " + e.message);
        }
        // remove the node from the lookup hash
        FS.hashRemoveNode(old_node);
        // do the underlying fs rename
        try {
          old_dir.node_ops.rename(old_node, new_dir, new_name);
        } catch (e) {
          throw e;
        } finally {
          // add the node back to the hash (in case node_ops.rename
          // changed its name)
          FS.hashAddNode(old_node);
        }
        try {
          if (FS.trackingDelegate['onMovePath']) FS.trackingDelegate['onMovePath'](old_path, new_path);
        } catch(e) {
          err("FS.trackingDelegate['onMovePath']('"+old_path+"', '"+new_path+"') threw an exception: " + e.message);
        }
      },rmdir:function(path) {
        var lookup = FS.lookupPath(path, { parent: true });
        var parent = lookup.node;
        var name = PATH.basename(path);
        var node = FS.lookupNode(parent, name);
        var errCode = FS.mayDelete(parent, name, true);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        if (!parent.node_ops.rmdir) {
          throw new FS.ErrnoError(63);
        }
        if (FS.isMountpoint(node)) {
          throw new FS.ErrnoError(10);
        }
        try {
          if (FS.trackingDelegate['willDeletePath']) {
            FS.trackingDelegate['willDeletePath'](path);
          }
        } catch(e) {
          err("FS.trackingDelegate['willDeletePath']('"+path+"') threw an exception: " + e.message);
        }
        parent.node_ops.rmdir(parent, name);
        FS.destroyNode(node);
        try {
          if (FS.trackingDelegate['onDeletePath']) FS.trackingDelegate['onDeletePath'](path);
        } catch(e) {
          err("FS.trackingDelegate['onDeletePath']('"+path+"') threw an exception: " + e.message);
        }
      },readdir:function(path) {
        var lookup = FS.lookupPath(path, { follow: true });
        var node = lookup.node;
        if (!node.node_ops.readdir) {
          throw new FS.ErrnoError(54);
        }
        return node.node_ops.readdir(node);
      },unlink:function(path) {
        var lookup = FS.lookupPath(path, { parent: true });
        var parent = lookup.node;
        var name = PATH.basename(path);
        var node = FS.lookupNode(parent, name);
        var errCode = FS.mayDelete(parent, name, false);
        if (errCode) {
          // According to POSIX, we should map EISDIR to EPERM, but
          // we instead do what Linux does (and we must, as we use
          // the musl linux libc).
          throw new FS.ErrnoError(errCode);
        }
        if (!parent.node_ops.unlink) {
          throw new FS.ErrnoError(63);
        }
        if (FS.isMountpoint(node)) {
          throw new FS.ErrnoError(10);
        }
        try {
          if (FS.trackingDelegate['willDeletePath']) {
            FS.trackingDelegate['willDeletePath'](path);
          }
        } catch(e) {
          err("FS.trackingDelegate['willDeletePath']('"+path+"') threw an exception: " + e.message);
        }
        parent.node_ops.unlink(parent, name);
        FS.destroyNode(node);
        try {
          if (FS.trackingDelegate['onDeletePath']) FS.trackingDelegate['onDeletePath'](path);
        } catch(e) {
          err("FS.trackingDelegate['onDeletePath']('"+path+"') threw an exception: " + e.message);
        }
      },readlink:function(path) {
        var lookup = FS.lookupPath(path);
        var link = lookup.node;
        if (!link) {
          throw new FS.ErrnoError(44);
        }
        if (!link.node_ops.readlink) {
          throw new FS.ErrnoError(28);
        }
        return PATH_FS.resolve(FS.getPath(link.parent), link.node_ops.readlink(link));
      },stat:function(path, dontFollow) {
        var lookup = FS.lookupPath(path, { follow: !dontFollow });
        var node = lookup.node;
        if (!node) {
          throw new FS.ErrnoError(44);
        }
        if (!node.node_ops.getattr) {
          throw new FS.ErrnoError(63);
        }
        return node.node_ops.getattr(node);
      },lstat:function(path) {
        return FS.stat(path, true);
      },chmod:function(path, mode, dontFollow) {
        var node;
        if (typeof path === 'string') {
          var lookup = FS.lookupPath(path, { follow: !dontFollow });
          node = lookup.node;
        } else {
          node = path;
        }
        if (!node.node_ops.setattr) {
          throw new FS.ErrnoError(63);
        }
        node.node_ops.setattr(node, {
          mode: (mode & 4095) | (node.mode & ~4095),
          timestamp: Date.now()
        });
      },lchmod:function(path, mode) {
        FS.chmod(path, mode, true);
      },fchmod:function(fd, mode) {
        var stream = FS.getStream(fd);
        if (!stream) {
          throw new FS.ErrnoError(8);
        }
        FS.chmod(stream.node, mode);
      },chown:function(path, uid, gid, dontFollow) {
        var node;
        if (typeof path === 'string') {
          var lookup = FS.lookupPath(path, { follow: !dontFollow });
          node = lookup.node;
        } else {
          node = path;
        }
        if (!node.node_ops.setattr) {
          throw new FS.ErrnoError(63);
        }
        node.node_ops.setattr(node, {
          timestamp: Date.now()
          // we ignore the uid / gid for now
        });
      },lchown:function(path, uid, gid) {
        FS.chown(path, uid, gid, true);
      },fchown:function(fd, uid, gid) {
        var stream = FS.getStream(fd);
        if (!stream) {
          throw new FS.ErrnoError(8);
        }
        FS.chown(stream.node, uid, gid);
      },truncate:function(path, len) {
        if (len < 0) {
          throw new FS.ErrnoError(28);
        }
        var node;
        if (typeof path === 'string') {
          var lookup = FS.lookupPath(path, { follow: true });
          node = lookup.node;
        } else {
          node = path;
        }
        if (!node.node_ops.setattr) {
          throw new FS.ErrnoError(63);
        }
        if (FS.isDir(node.mode)) {
          throw new FS.ErrnoError(31);
        }
        if (!FS.isFile(node.mode)) {
          throw new FS.ErrnoError(28);
        }
        var errCode = FS.nodePermissions(node, 'w');
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        node.node_ops.setattr(node, {
          size: len,
          timestamp: Date.now()
        });
      },ftruncate:function(fd, len) {
        var stream = FS.getStream(fd);
        if (!stream) {
          throw new FS.ErrnoError(8);
        }
        if ((stream.flags & 2097155) === 0) {
          throw new FS.ErrnoError(28);
        }
        FS.truncate(stream.node, len);
      },utime:function(path, atime, mtime) {
        var lookup = FS.lookupPath(path, { follow: true });
        var node = lookup.node;
        node.node_ops.setattr(node, {
          timestamp: Math.max(atime, mtime)
        });
      },open:function(path, flags, mode, fd_start, fd_end) {
        if (path === "") {
          throw new FS.ErrnoError(44);
        }
        flags = typeof flags === 'string' ? FS.modeStringToFlags(flags) : flags;
        mode = typeof mode === 'undefined' ? 438 /* 0666 */ : mode;
        if ((flags & 64)) {
          mode = (mode & 4095) | 32768;
        } else {
          mode = 0;
        }
        var node;
        if (typeof path === 'object') {
          node = path;
        } else {
          path = PATH.normalize(path);
          try {
            var lookup = FS.lookupPath(path, {
              follow: !(flags & 131072)
            });
            node = lookup.node;
          } catch (e) {
            // ignore
          }
        }
        // perhaps we need to create the node
        var created = false;
        if ((flags & 64)) {
          if (node) {
            // if O_CREAT and O_EXCL are set, error out if the node already exists
            if ((flags & 128)) {
              throw new FS.ErrnoError(20);
            }
          } else {
            // node doesn't exist, try to create it
            node = FS.mknod(path, mode, 0);
            created = true;
          }
        }
        if (!node) {
          throw new FS.ErrnoError(44);
        }
        // can't truncate a device
        if (FS.isChrdev(node.mode)) {
          flags &= ~512;
        }
        // if asked only for a directory, then this must be one
        if ((flags & 65536) && !FS.isDir(node.mode)) {
          throw new FS.ErrnoError(54);
        }
        // check permissions, if this is not a file we just created now (it is ok to
        // create and write to a file with read-only permissions; it is read-only
        // for later use)
        if (!created) {
          var errCode = FS.mayOpen(node, flags);
          if (errCode) {
            throw new FS.ErrnoError(errCode);
          }
        }
        // do truncation if necessary
        if ((flags & 512)) {
          FS.truncate(node, 0);
        }
        // we've already handled these, don't pass down to the underlying vfs
        flags &= ~(128 | 512 | 131072);
  
        // register the stream with the filesystem
        var stream = FS.createStream({
          node: node,
          path: FS.getPath(node),  // we want the absolute path to the node
          flags: flags,
          seekable: true,
          position: 0,
          stream_ops: node.stream_ops,
          // used by the file family libc calls (fopen, fwrite, ferror, etc.)
          ungotten: [],
          error: false
        }, fd_start, fd_end);
        // call the new stream's open function
        if (stream.stream_ops.open) {
          stream.stream_ops.open(stream);
        }
        if (Module['logReadFiles'] && !(flags & 1)) {
          if (!FS.readFiles) FS.readFiles = {};
          if (!(path in FS.readFiles)) {
            FS.readFiles[path] = 1;
            err("FS.trackingDelegate error on read file: " + path);
          }
        }
        try {
          if (FS.trackingDelegate['onOpenFile']) {
            var trackingFlags = 0;
            if ((flags & 2097155) !== 1) {
              trackingFlags |= FS.tracking.openFlags.READ;
            }
            if ((flags & 2097155) !== 0) {
              trackingFlags |= FS.tracking.openFlags.WRITE;
            }
            FS.trackingDelegate['onOpenFile'](path, trackingFlags);
          }
        } catch(e) {
          err("FS.trackingDelegate['onOpenFile']('"+path+"', flags) threw an exception: " + e.message);
        }
        return stream;
      },close:function(stream) {
        if (FS.isClosed(stream)) {
          throw new FS.ErrnoError(8);
        }
        if (stream.getdents) stream.getdents = null; // free readdir state
        try {
          if (stream.stream_ops.close) {
            stream.stream_ops.close(stream);
          }
        } catch (e) {
          throw e;
        } finally {
          FS.closeStream(stream.fd);
        }
        stream.fd = null;
      },isClosed:function(stream) {
        return stream.fd === null;
      },llseek:function(stream, offset, whence) {
        if (FS.isClosed(stream)) {
          throw new FS.ErrnoError(8);
        }
        if (!stream.seekable || !stream.stream_ops.llseek) {
          throw new FS.ErrnoError(70);
        }
        if (whence != 0 && whence != 1 && whence != 2) {
          throw new FS.ErrnoError(28);
        }
        stream.position = stream.stream_ops.llseek(stream, offset, whence);
        stream.ungotten = [];
        return stream.position;
      },read:function(stream, buffer, offset, length, position) {
        if (length < 0 || position < 0) {
          throw new FS.ErrnoError(28);
        }
        if (FS.isClosed(stream)) {
          throw new FS.ErrnoError(8);
        }
        if ((stream.flags & 2097155) === 1) {
          throw new FS.ErrnoError(8);
        }
        if (FS.isDir(stream.node.mode)) {
          throw new FS.ErrnoError(31);
        }
        if (!stream.stream_ops.read) {
          throw new FS.ErrnoError(28);
        }
        var seeking = typeof position !== 'undefined';
        if (!seeking) {
          position = stream.position;
        } else if (!stream.seekable) {
          throw new FS.ErrnoError(70);
        }
        var bytesRead = stream.stream_ops.read(stream, buffer, offset, length, position);
        if (!seeking) stream.position += bytesRead;
        return bytesRead;
      },write:function(stream, buffer, offset, length, position, canOwn) {
        if (length < 0 || position < 0) {
          throw new FS.ErrnoError(28);
        }
        if (FS.isClosed(stream)) {
          throw new FS.ErrnoError(8);
        }
        if ((stream.flags & 2097155) === 0) {
          throw new FS.ErrnoError(8);
        }
        if (FS.isDir(stream.node.mode)) {
          throw new FS.ErrnoError(31);
        }
        if (!stream.stream_ops.write) {
          throw new FS.ErrnoError(28);
        }
        if (stream.seekable && stream.flags & 1024) {
          // seek to the end before writing in append mode
          FS.llseek(stream, 0, 2);
        }
        var seeking = typeof position !== 'undefined';
        if (!seeking) {
          position = stream.position;
        } else if (!stream.seekable) {
          throw new FS.ErrnoError(70);
        }
        var bytesWritten = stream.stream_ops.write(stream, buffer, offset, length, position, canOwn);
        if (!seeking) stream.position += bytesWritten;
        try {
          if (stream.path && FS.trackingDelegate['onWriteToFile']) FS.trackingDelegate['onWriteToFile'](stream.path);
        } catch(e) {
          err("FS.trackingDelegate['onWriteToFile']('"+stream.path+"') threw an exception: " + e.message);
        }
        return bytesWritten;
      },allocate:function(stream, offset, length) {
        if (FS.isClosed(stream)) {
          throw new FS.ErrnoError(8);
        }
        if (offset < 0 || length <= 0) {
          throw new FS.ErrnoError(28);
        }
        if ((stream.flags & 2097155) === 0) {
          throw new FS.ErrnoError(8);
        }
        if (!FS.isFile(stream.node.mode) && !FS.isDir(stream.node.mode)) {
          throw new FS.ErrnoError(43);
        }
        if (!stream.stream_ops.allocate) {
          throw new FS.ErrnoError(138);
        }
        stream.stream_ops.allocate(stream, offset, length);
      },mmap:function(stream, buffer, offset, length, position, prot, flags) {
        // User requests writing to file (prot & PROT_WRITE != 0).
        // Checking if we have permissions to write to the file unless
        // MAP_PRIVATE flag is set. According to POSIX spec it is possible
        // to write to file opened in read-only mode with MAP_PRIVATE flag,
        // as all modifications will be visible only in the memory of
        // the current process.
        if ((prot & 2) !== 0
            && (flags & 2) === 0
            && (stream.flags & 2097155) !== 2) {
          throw new FS.ErrnoError(2);
        }
        if ((stream.flags & 2097155) === 1) {
          throw new FS.ErrnoError(2);
        }
        if (!stream.stream_ops.mmap) {
          throw new FS.ErrnoError(43);
        }
        return stream.stream_ops.mmap(stream, buffer, offset, length, position, prot, flags);
      },msync:function(stream, buffer, offset, length, mmapFlags) {
        if (!stream || !stream.stream_ops.msync) {
          return 0;
        }
        return stream.stream_ops.msync(stream, buffer, offset, length, mmapFlags);
      },munmap:function(stream) {
        return 0;
      },ioctl:function(stream, cmd, arg) {
        if (!stream.stream_ops.ioctl) {
          throw new FS.ErrnoError(59);
        }
        return stream.stream_ops.ioctl(stream, cmd, arg);
      },readFile:function(path, opts) {
        opts = opts || {};
        opts.flags = opts.flags || 'r';
        opts.encoding = opts.encoding || 'binary';
        if (opts.encoding !== 'utf8' && opts.encoding !== 'binary') {
          throw new Error('Invalid encoding type "' + opts.encoding + '"');
        }
        var ret;
        var stream = FS.open(path, opts.flags);
        var stat = FS.stat(path);
        var length = stat.size;
        var buf = new Uint8Array(length);
        FS.read(stream, buf, 0, length, 0);
        if (opts.encoding === 'utf8') {
          ret = UTF8ArrayToString(buf, 0);
        } else if (opts.encoding === 'binary') {
          ret = buf;
        }
        FS.close(stream);
        return ret;
      },writeFile:function(path, data, opts) {
        opts = opts || {};
        opts.flags = opts.flags || 'w';
        var stream = FS.open(path, opts.flags, opts.mode);
        if (typeof data === 'string') {
          var buf = new Uint8Array(lengthBytesUTF8(data)+1);
          var actualNumBytes = stringToUTF8Array(data, buf, 0, buf.length);
          FS.write(stream, buf, 0, actualNumBytes, undefined, opts.canOwn);
        } else if (ArrayBuffer.isView(data)) {
          FS.write(stream, data, 0, data.byteLength, undefined, opts.canOwn);
        } else {
          throw new Error('Unsupported data type');
        }
        FS.close(stream);
      },cwd:function() {
        return FS.currentPath;
      },chdir:function(path) {
        var lookup = FS.lookupPath(path, { follow: true });
        if (lookup.node === null) {
          throw new FS.ErrnoError(44);
        }
        if (!FS.isDir(lookup.node.mode)) {
          throw new FS.ErrnoError(54);
        }
        var errCode = FS.nodePermissions(lookup.node, 'x');
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        FS.currentPath = lookup.path;
      },createDefaultDirectories:function() {
        FS.mkdir('/tmp');
        FS.mkdir('/home');
        FS.mkdir('/home/web_user');
      },createDefaultDevices:function() {
        // create /dev
        FS.mkdir('/dev');
        // setup /dev/null
        FS.registerDevice(FS.makedev(1, 3), {
          read: function() { return 0; },
          write: function(stream, buffer, offset, length, pos) { return length; }
        });
        FS.mkdev('/dev/null', FS.makedev(1, 3));
        // setup /dev/tty and /dev/tty1
        // stderr needs to print output using Module['printErr']
        // so we register a second tty just for it.
        TTY.register(FS.makedev(5, 0), TTY.default_tty_ops);
        TTY.register(FS.makedev(6, 0), TTY.default_tty1_ops);
        FS.mkdev('/dev/tty', FS.makedev(5, 0));
        FS.mkdev('/dev/tty1', FS.makedev(6, 0));
        // setup /dev/[u]random
        var random_device;
        if (typeof crypto === 'object' && typeof crypto['getRandomValues'] === 'function') {
          // for modern web browsers
          var randomBuffer = new Uint8Array(1);
          random_device = function() { crypto.getRandomValues(randomBuffer); return randomBuffer[0]; };
        } else
        if (ENVIRONMENT_IS_NODE) {
          // for nodejs with or without crypto support included
          try {
            var crypto_module = require('crypto');
            // nodejs has crypto support
            random_device = function() { return crypto_module['randomBytes'](1)[0]; };
          } catch (e) {
            // nodejs doesn't have crypto support
          }
        } else
        {}
        if (!random_device) {
          // we couldn't find a proper implementation, as Math.random() is not suitable for /dev/random, see emscripten-core/emscripten/pull/7096
          random_device = function() { abort("no cryptographic support found for random_device. consider polyfilling it if you want to use something insecure like Math.random(), e.g. put this in a --pre-js: var crypto = { getRandomValues: function(array) { for (var i = 0; i < array.length; i++) array[i] = (Math.random()*256)|0 } };"); };
        }
        FS.createDevice('/dev', 'random', random_device);
        FS.createDevice('/dev', 'urandom', random_device);
        // we're not going to emulate the actual shm device,
        // just create the tmp dirs that reside in it commonly
        FS.mkdir('/dev/shm');
        FS.mkdir('/dev/shm/tmp');
      },createSpecialDirectories:function() {
        // create /proc/self/fd which allows /proc/self/fd/6 => readlink gives the name of the stream for fd 6 (see test_unistd_ttyname)
        FS.mkdir('/proc');
        FS.mkdir('/proc/self');
        FS.mkdir('/proc/self/fd');
        FS.mount({
          mount: function() {
            var node = FS.createNode('/proc/self', 'fd', 16384 | 511 /* 0777 */, 73);
            node.node_ops = {
              lookup: function(parent, name) {
                var fd = +name;
                var stream = FS.getStream(fd);
                if (!stream) throw new FS.ErrnoError(8);
                var ret = {
                  parent: null,
                  mount: { mountpoint: 'fake' },
                  node_ops: { readlink: function() { return stream.path } }
                };
                ret.parent = ret; // make it look like a simple root node
                return ret;
              }
            };
            return node;
          }
        }, {}, '/proc/self/fd');
      },createStandardStreams:function() {
        // TODO deprecate the old functionality of a single
        // input / output callback and that utilizes FS.createDevice
        // and instead require a unique set of stream ops
  
        // by default, we symlink the standard streams to the
        // default tty devices. however, if the standard streams
        // have been overwritten we create a unique device for
        // them instead.
        if (Module['stdin']) {
          FS.createDevice('/dev', 'stdin', Module['stdin']);
        } else {
          FS.symlink('/dev/tty', '/dev/stdin');
        }
        if (Module['stdout']) {
          FS.createDevice('/dev', 'stdout', null, Module['stdout']);
        } else {
          FS.symlink('/dev/tty', '/dev/stdout');
        }
        if (Module['stderr']) {
          FS.createDevice('/dev', 'stderr', null, Module['stderr']);
        } else {
          FS.symlink('/dev/tty1', '/dev/stderr');
        }
  
        // open default streams for the stdin, stdout and stderr devices
        var stdin = FS.open('/dev/stdin', 'r');
        var stdout = FS.open('/dev/stdout', 'w');
        var stderr = FS.open('/dev/stderr', 'w');
        assert(stdin.fd === 0, 'invalid handle for stdin (' + stdin.fd + ')');
        assert(stdout.fd === 1, 'invalid handle for stdout (' + stdout.fd + ')');
        assert(stderr.fd === 2, 'invalid handle for stderr (' + stderr.fd + ')');
      },ensureErrnoError:function() {
        if (FS.ErrnoError) return;
        FS.ErrnoError = /** @this{Object} */ function ErrnoError(errno, node) {
          this.node = node;
          this.setErrno = /** @this{Object} */ function(errno) {
            this.errno = errno;
            for (var key in ERRNO_CODES) {
              if (ERRNO_CODES[key] === errno) {
                this.code = key;
                break;
              }
            }
          };
          this.setErrno(errno);
          this.message = ERRNO_MESSAGES[errno];
  
          // Try to get a maximally helpful stack trace. On Node.js, getting Error.stack
          // now ensures it shows what we want.
          if (this.stack) {
            // Define the stack property for Node.js 4, which otherwise errors on the next line.
            Object.defineProperty(this, "stack", { value: (new Error).stack, writable: true });
            this.stack = demangleAll(this.stack);
          }
        };
        FS.ErrnoError.prototype = new Error();
        FS.ErrnoError.prototype.constructor = FS.ErrnoError;
        // Some errors may happen quite a bit, to avoid overhead we reuse them (and suffer a lack of stack info)
        [44].forEach(function(code) {
          FS.genericErrors[code] = new FS.ErrnoError(code);
          FS.genericErrors[code].stack = '<generic error, no stack>';
        });
      },staticInit:function() {
        FS.ensureErrnoError();
  
        FS.nameTable = new Array(4096);
  
        FS.mount(MEMFS, {}, '/');
  
        FS.createDefaultDirectories();
        FS.createDefaultDevices();
        FS.createSpecialDirectories();
  
        FS.filesystems = {
          'MEMFS': MEMFS,
          'NODEFS': NODEFS,
        };
      },init:function(input, output, error) {
        assert(!FS.init.initialized, 'FS.init was previously called. If you want to initialize later with custom parameters, remove any earlier calls (note that one is automatically added to the generated code)');
        FS.init.initialized = true;
  
        FS.ensureErrnoError();
  
        // Allow Module.stdin etc. to provide defaults, if none explicitly passed to us here
        Module['stdin'] = input || Module['stdin'];
        Module['stdout'] = output || Module['stdout'];
        Module['stderr'] = error || Module['stderr'];
  
        FS.createStandardStreams();
      },quit:function() {
        FS.init.initialized = false;
        // force-flush all streams, so we get musl std streams printed out
        var fflush = Module['_fflush'];
        if (fflush) fflush(0);
        // close all of our streams
        for (var i = 0; i < FS.streams.length; i++) {
          var stream = FS.streams[i];
          if (!stream) {
            continue;
          }
          FS.close(stream);
        }
      },getMode:function(canRead, canWrite) {
        var mode = 0;
        if (canRead) mode |= 292 | 73;
        if (canWrite) mode |= 146;
        return mode;
      },joinPath:function(parts, forceRelative) {
        var path = PATH.join.apply(null, parts);
        if (forceRelative && path[0] == '/') path = path.substr(1);
        return path;
      },absolutePath:function(relative, base) {
        return PATH_FS.resolve(base, relative);
      },standardizePath:function(path) {
        return PATH.normalize(path);
      },findObject:function(path, dontResolveLastLink) {
        var ret = FS.analyzePath(path, dontResolveLastLink);
        if (ret.exists) {
          return ret.object;
        } else {
          setErrNo(ret.error);
          return null;
        }
      },analyzePath:function(path, dontResolveLastLink) {
        // operate from within the context of the symlink's target
        try {
          var lookup = FS.lookupPath(path, { follow: !dontResolveLastLink });
          path = lookup.path;
        } catch (e) {
        }
        var ret = {
          isRoot: false, exists: false, error: 0, name: null, path: null, object: null,
          parentExists: false, parentPath: null, parentObject: null
        };
        try {
          var lookup = FS.lookupPath(path, { parent: true });
          ret.parentExists = true;
          ret.parentPath = lookup.path;
          ret.parentObject = lookup.node;
          ret.name = PATH.basename(path);
          lookup = FS.lookupPath(path, { follow: !dontResolveLastLink });
          ret.exists = true;
          ret.path = lookup.path;
          ret.object = lookup.node;
          ret.name = lookup.node.name;
          ret.isRoot = lookup.path === '/';
        } catch (e) {
          ret.error = e.errno;
        };
        return ret;
      },createFolder:function(parent, name, canRead, canWrite) {
        var path = PATH.join2(typeof parent === 'string' ? parent : FS.getPath(parent), name);
        var mode = FS.getMode(canRead, canWrite);
        return FS.mkdir(path, mode);
      },createPath:function(parent, path, canRead, canWrite) {
        parent = typeof parent === 'string' ? parent : FS.getPath(parent);
        var parts = path.split('/').reverse();
        while (parts.length) {
          var part = parts.pop();
          if (!part) continue;
          var current = PATH.join2(parent, part);
          try {
            FS.mkdir(current);
          } catch (e) {
            // ignore EEXIST
          }
          parent = current;
        }
        return current;
      },createFile:function(parent, name, properties, canRead, canWrite) {
        var path = PATH.join2(typeof parent === 'string' ? parent : FS.getPath(parent), name);
        var mode = FS.getMode(canRead, canWrite);
        return FS.create(path, mode);
      },createDataFile:function(parent, name, data, canRead, canWrite, canOwn) {
        var path = name ? PATH.join2(typeof parent === 'string' ? parent : FS.getPath(parent), name) : parent;
        var mode = FS.getMode(canRead, canWrite);
        var node = FS.create(path, mode);
        if (data) {
          if (typeof data === 'string') {
            var arr = new Array(data.length);
            for (var i = 0, len = data.length; i < len; ++i) arr[i] = data.charCodeAt(i);
            data = arr;
          }
          // make sure we can write to the file
          FS.chmod(node, mode | 146);
          var stream = FS.open(node, 'w');
          FS.write(stream, data, 0, data.length, 0, canOwn);
          FS.close(stream);
          FS.chmod(node, mode);
        }
        return node;
      },createDevice:function(parent, name, input, output) {
        var path = PATH.join2(typeof parent === 'string' ? parent : FS.getPath(parent), name);
        var mode = FS.getMode(!!input, !!output);
        if (!FS.createDevice.major) FS.createDevice.major = 64;
        var dev = FS.makedev(FS.createDevice.major++, 0);
        // Create a fake device that a set of stream ops to emulate
        // the old behavior.
        FS.registerDevice(dev, {
          open: function(stream) {
            stream.seekable = false;
          },
          close: function(stream) {
            // flush any pending line data
            if (output && output.buffer && output.buffer.length) {
              output(10);
            }
          },
          read: function(stream, buffer, offset, length, pos /* ignored */) {
            var bytesRead = 0;
            for (var i = 0; i < length; i++) {
              var result;
              try {
                result = input();
              } catch (e) {
                throw new FS.ErrnoError(29);
              }
              if (result === undefined && bytesRead === 0) {
                throw new FS.ErrnoError(6);
              }
              if (result === null || result === undefined) break;
              bytesRead++;
              buffer[offset+i] = result;
            }
            if (bytesRead) {
              stream.node.timestamp = Date.now();
            }
            return bytesRead;
          },
          write: function(stream, buffer, offset, length, pos) {
            for (var i = 0; i < length; i++) {
              try {
                output(buffer[offset+i]);
              } catch (e) {
                throw new FS.ErrnoError(29);
              }
            }
            if (length) {
              stream.node.timestamp = Date.now();
            }
            return i;
          }
        });
        return FS.mkdev(path, mode, dev);
      },createLink:function(parent, name, target, canRead, canWrite) {
        var path = PATH.join2(typeof parent === 'string' ? parent : FS.getPath(parent), name);
        return FS.symlink(target, path);
      },forceLoadFile:function(obj) {
        if (obj.isDevice || obj.isFolder || obj.link || obj.contents) return true;
        var success = true;
        if (typeof XMLHttpRequest !== 'undefined') {
          throw new Error("Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread.");
        } else if (read_) {
          // Command-line.
          try {
            // WARNING: Can't read binary files in V8's d8 or tracemonkey's js, as
            //          read() will try to parse UTF8.
            obj.contents = intArrayFromString(read_(obj.url), true);
            obj.usedBytes = obj.contents.length;
          } catch (e) {
            success = false;
          }
        } else {
          throw new Error('Cannot load without read() or XMLHttpRequest.');
        }
        if (!success) setErrNo(29);
        return success;
      },createLazyFile:function(parent, name, url, canRead, canWrite) {
        // Lazy chunked Uint8Array (implements get and length from Uint8Array). Actual getting is abstracted away for eventual reuse.
        /** @constructor */
        function LazyUint8Array() {
          this.lengthKnown = false;
          this.chunks = []; // Loaded chunks. Index is the chunk number
        }
        LazyUint8Array.prototype.get = /** @this{Object} */ function LazyUint8Array_get(idx) {
          if (idx > this.length-1 || idx < 0) {
            return undefined;
          }
          var chunkOffset = idx % this.chunkSize;
          var chunkNum = (idx / this.chunkSize)|0;
          return this.getter(chunkNum)[chunkOffset];
        };
        LazyUint8Array.prototype.setDataGetter = function LazyUint8Array_setDataGetter(getter) {
          this.getter = getter;
        };
        LazyUint8Array.prototype.cacheLength = function LazyUint8Array_cacheLength() {
          // Find length
          var xhr = new XMLHttpRequest();
          xhr.open('HEAD', url, false);
          xhr.send(null);
          if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304)) throw new Error("Couldn't load " + url + ". Status: " + xhr.status);
          var datalength = Number(xhr.getResponseHeader("Content-length"));
          var header;
          var hasByteServing = (header = xhr.getResponseHeader("Accept-Ranges")) && header === "bytes";
          var usesGzip = (header = xhr.getResponseHeader("Content-Encoding")) && header === "gzip";
  
          var chunkSize = 1024*1024; // Chunk size in bytes
  
          if (!hasByteServing) chunkSize = datalength;
  
          // Function to get a range from the remote URL.
          var doXHR = (function(from, to) {
            if (from > to) throw new Error("invalid range (" + from + ", " + to + ") or no bytes requested!");
            if (to > datalength-1) throw new Error("only " + datalength + " bytes available! programmer error!");
  
            // TODO: Use mozResponseArrayBuffer, responseStream, etc. if available.
            var xhr = new XMLHttpRequest();
            xhr.open('GET', url, false);
            if (datalength !== chunkSize) xhr.setRequestHeader("Range", "bytes=" + from + "-" + to);
  
            // Some hints to the browser that we want binary data.
            if (typeof Uint8Array != 'undefined') xhr.responseType = 'arraybuffer';
            if (xhr.overrideMimeType) {
              xhr.overrideMimeType('text/plain; charset=x-user-defined');
            }
  
            xhr.send(null);
            if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304)) throw new Error("Couldn't load " + url + ". Status: " + xhr.status);
            if (xhr.response !== undefined) {
              return new Uint8Array(/** @type{Array<number>} */(xhr.response || []));
            } else {
              return intArrayFromString(xhr.responseText || '', true);
            }
          });
          var lazyArray = this;
          lazyArray.setDataGetter(function(chunkNum) {
            var start = chunkNum * chunkSize;
            var end = (chunkNum+1) * chunkSize - 1; // including this byte
            end = Math.min(end, datalength-1); // if datalength-1 is selected, this is the last block
            if (typeof(lazyArray.chunks[chunkNum]) === "undefined") {
              lazyArray.chunks[chunkNum] = doXHR(start, end);
            }
            if (typeof(lazyArray.chunks[chunkNum]) === "undefined") throw new Error("doXHR failed!");
            return lazyArray.chunks[chunkNum];
          });
  
          if (usesGzip || !datalength) {
            // if the server uses gzip or doesn't supply the length, we have to download the whole file to get the (uncompressed) length
            chunkSize = datalength = 1; // this will force getter(0)/doXHR do download the whole file
            datalength = this.getter(0).length;
            chunkSize = datalength;
            out("LazyFiles on gzip forces download of the whole file when length is accessed");
          }
  
          this._length = datalength;
          this._chunkSize = chunkSize;
          this.lengthKnown = true;
        };
        if (typeof XMLHttpRequest !== 'undefined') {
          if (!ENVIRONMENT_IS_WORKER) throw 'Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc';
          var lazyArray = new LazyUint8Array();
          Object.defineProperties(lazyArray, {
            length: {
              get: /** @this{Object} */ function() {
                if(!this.lengthKnown) {
                  this.cacheLength();
                }
                return this._length;
              }
            },
            chunkSize: {
              get: /** @this{Object} */ function() {
                if(!this.lengthKnown) {
                  this.cacheLength();
                }
                return this._chunkSize;
              }
            }
          });
  
          var properties = { isDevice: false, contents: lazyArray };
        } else {
          var properties = { isDevice: false, url: url };
        }
  
        var node = FS.createFile(parent, name, properties, canRead, canWrite);
        // This is a total hack, but I want to get this lazy file code out of the
        // core of MEMFS. If we want to keep this lazy file concept I feel it should
        // be its own thin LAZYFS proxying calls to MEMFS.
        if (properties.contents) {
          node.contents = properties.contents;
        } else if (properties.url) {
          node.contents = null;
          node.url = properties.url;
        }
        // Add a function that defers querying the file size until it is asked the first time.
        Object.defineProperties(node, {
          usedBytes: {
            get: /** @this {FSNode} */ function() { return this.contents.length; }
          }
        });
        // override each stream op with one that tries to force load the lazy file first
        var stream_ops = {};
        var keys = Object.keys(node.stream_ops);
        keys.forEach(function(key) {
          var fn = node.stream_ops[key];
          stream_ops[key] = function forceLoadLazyFile() {
            if (!FS.forceLoadFile(node)) {
              throw new FS.ErrnoError(29);
            }
            return fn.apply(null, arguments);
          };
        });
        // use a custom read function
        stream_ops.read = function stream_ops_read(stream, buffer, offset, length, position) {
          if (!FS.forceLoadFile(node)) {
            throw new FS.ErrnoError(29);
          }
          var contents = stream.node.contents;
          if (position >= contents.length)
            return 0;
          var size = Math.min(contents.length - position, length);
          assert(size >= 0);
          if (contents.slice) { // normal array
            for (var i = 0; i < size; i++) {
              buffer[offset + i] = contents[position + i];
            }
          } else {
            for (var i = 0; i < size; i++) { // LazyUint8Array from sync binary XHR
              buffer[offset + i] = contents.get(position + i);
            }
          }
          return size;
        };
        node.stream_ops = stream_ops;
        return node;
      },createPreloadedFile:function(parent, name, url, canRead, canWrite, onload, onerror, dontCreateFile, canOwn, preFinish) {
        Browser.init(); // XXX perhaps this method should move onto Browser?
        // TODO we should allow people to just pass in a complete filename instead
        // of parent and name being that we just join them anyways
        var fullname = name ? PATH_FS.resolve(PATH.join2(parent, name)) : parent;
        var dep = getUniqueRunDependency('cp ' + fullname); // might have several active requests for the same fullname
        function processData(byteArray) {
          function finish(byteArray) {
            if (preFinish) preFinish();
            if (!dontCreateFile) {
              FS.createDataFile(parent, name, byteArray, canRead, canWrite, canOwn);
            }
            if (onload) onload();
            removeRunDependency(dep);
          }
          var handled = false;
          Module['preloadPlugins'].forEach(function(plugin) {
            if (handled) return;
            if (plugin['canHandle'](fullname)) {
              plugin['handle'](byteArray, fullname, finish, function() {
                if (onerror) onerror();
                removeRunDependency(dep);
              });
              handled = true;
            }
          });
          if (!handled) finish(byteArray);
        }
        addRunDependency(dep);
        if (typeof url == 'string') {
          Browser.asyncLoad(url, function(byteArray) {
            processData(byteArray);
          }, onerror);
        } else {
          processData(url);
        }
      },indexedDB:function() {
        return window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB;
      },DB_NAME:function() {
        return 'EM_FS_' + window.location.pathname;
      },DB_VERSION:20,DB_STORE_NAME:"FILE_DATA",saveFilesToDB:function(paths, onload, onerror) {
        onload = onload || function(){};
        onerror = onerror || function(){};
        var indexedDB = FS.indexedDB();
        try {
          var openRequest = indexedDB.open(FS.DB_NAME(), FS.DB_VERSION);
        } catch (e) {
          return onerror(e);
        }
        openRequest.onupgradeneeded = function openRequest_onupgradeneeded() {
          out('creating db');
          var db = openRequest.result;
          db.createObjectStore(FS.DB_STORE_NAME);
        };
        openRequest.onsuccess = function openRequest_onsuccess() {
          var db = openRequest.result;
          var transaction = db.transaction([FS.DB_STORE_NAME], 'readwrite');
          var files = transaction.objectStore(FS.DB_STORE_NAME);
          var ok = 0, fail = 0, total = paths.length;
          function finish() {
            if (fail == 0) onload(); else onerror();
          }
          paths.forEach(function(path) {
            var putRequest = files.put(FS.analyzePath(path).object.contents, path);
            putRequest.onsuccess = function putRequest_onsuccess() { ok++; if (ok + fail == total) finish() };
            putRequest.onerror = function putRequest_onerror() { fail++; if (ok + fail == total) finish() };
          });
          transaction.onerror = onerror;
        };
        openRequest.onerror = onerror;
      },loadFilesFromDB:function(paths, onload, onerror) {
        onload = onload || function(){};
        onerror = onerror || function(){};
        var indexedDB = FS.indexedDB();
        try {
          var openRequest = indexedDB.open(FS.DB_NAME(), FS.DB_VERSION);
        } catch (e) {
          return onerror(e);
        }
        openRequest.onupgradeneeded = onerror; // no database to load from
        openRequest.onsuccess = function openRequest_onsuccess() {
          var db = openRequest.result;
          try {
            var transaction = db.transaction([FS.DB_STORE_NAME], 'readonly');
          } catch(e) {
            onerror(e);
            return;
          }
          var files = transaction.objectStore(FS.DB_STORE_NAME);
          var ok = 0, fail = 0, total = paths.length;
          function finish() {
            if (fail == 0) onload(); else onerror();
          }
          paths.forEach(function(path) {
            var getRequest = files.get(path);
            getRequest.onsuccess = function getRequest_onsuccess() {
              if (FS.analyzePath(path).exists) {
                FS.unlink(path);
              }
              FS.createDataFile(PATH.dirname(path), PATH.basename(path), getRequest.result, true, true, true);
              ok++;
              if (ok + fail == total) finish();
            };
            getRequest.onerror = function getRequest_onerror() { fail++; if (ok + fail == total) finish() };
          });
          transaction.onerror = onerror;
        };
        openRequest.onerror = onerror;
      }};var SYSCALLS={mappings:{},DEFAULT_POLLMASK:5,umask:511,calculateAt:function(dirfd, path) {
        if (path[0] !== '/') {
          // relative path
          var dir;
          if (dirfd === -100) {
            dir = FS.cwd();
          } else {
            var dirstream = FS.getStream(dirfd);
            if (!dirstream) throw new FS.ErrnoError(8);
            dir = dirstream.path;
          }
          path = PATH.join2(dir, path);
        }
        return path;
      },doStat:function(func, path, buf) {
        try {
          var stat = func(path);
        } catch (e) {
          if (e && e.node && PATH.normalize(path) !== PATH.normalize(FS.getPath(e.node))) {
            // an error occurred while trying to look up the path; we should just report ENOTDIR
            return -54;
          }
          throw e;
        }
        HEAP32[((buf)>>2)]=stat.dev;
        HEAP32[(((buf)+(4))>>2)]=0;
        HEAP32[(((buf)+(8))>>2)]=stat.ino;
        HEAP32[(((buf)+(12))>>2)]=stat.mode;
        HEAP32[(((buf)+(16))>>2)]=stat.nlink;
        HEAP32[(((buf)+(20))>>2)]=stat.uid;
        HEAP32[(((buf)+(24))>>2)]=stat.gid;
        HEAP32[(((buf)+(28))>>2)]=stat.rdev;
        HEAP32[(((buf)+(32))>>2)]=0;
        (tempI64 = [stat.size>>>0,(tempDouble=stat.size,(+(Math_abs(tempDouble))) >= 1.0 ? (tempDouble > 0.0 ? ((Math_min((+(Math_floor((tempDouble)/4294967296.0))), 4294967295.0))|0)>>>0 : (~~((+(Math_ceil((tempDouble - +(((~~(tempDouble)))>>>0))/4294967296.0)))))>>>0) : 0)],HEAP32[(((buf)+(40))>>2)]=tempI64[0],HEAP32[(((buf)+(44))>>2)]=tempI64[1]);
        HEAP32[(((buf)+(48))>>2)]=4096;
        HEAP32[(((buf)+(52))>>2)]=stat.blocks;
        HEAP32[(((buf)+(56))>>2)]=(stat.atime.getTime() / 1000)|0;
        HEAP32[(((buf)+(60))>>2)]=0;
        HEAP32[(((buf)+(64))>>2)]=(stat.mtime.getTime() / 1000)|0;
        HEAP32[(((buf)+(68))>>2)]=0;
        HEAP32[(((buf)+(72))>>2)]=(stat.ctime.getTime() / 1000)|0;
        HEAP32[(((buf)+(76))>>2)]=0;
        (tempI64 = [stat.ino>>>0,(tempDouble=stat.ino,(+(Math_abs(tempDouble))) >= 1.0 ? (tempDouble > 0.0 ? ((Math_min((+(Math_floor((tempDouble)/4294967296.0))), 4294967295.0))|0)>>>0 : (~~((+(Math_ceil((tempDouble - +(((~~(tempDouble)))>>>0))/4294967296.0)))))>>>0) : 0)],HEAP32[(((buf)+(80))>>2)]=tempI64[0],HEAP32[(((buf)+(84))>>2)]=tempI64[1]);
        return 0;
      },doMsync:function(addr, stream, len, flags, offset) {
        var buffer = HEAPU8.slice(addr, addr + len);
        FS.msync(stream, buffer, offset, len, flags);
      },doMkdir:function(path, mode) {
        // remove a trailing slash, if one - /a/b/ has basename of '', but
        // we want to create b in the context of this function
        path = PATH.normalize(path);
        if (path[path.length-1] === '/') path = path.substr(0, path.length-1);
        FS.mkdir(path, mode, 0);
        return 0;
      },doMknod:function(path, mode, dev) {
        // we don't want this in the JS API as it uses mknod to create all nodes.
        switch (mode & 61440) {
          case 32768:
          case 8192:
          case 24576:
          case 4096:
          case 49152:
            break;
          default: return -28;
        }
        FS.mknod(path, mode, dev);
        return 0;
      },doReadlink:function(path, buf, bufsize) {
        if (bufsize <= 0) return -28;
        var ret = FS.readlink(path);
  
        var len = Math.min(bufsize, lengthBytesUTF8(ret));
        var endChar = HEAP8[buf+len];
        stringToUTF8(ret, buf, bufsize+1);
        // readlink is one of the rare functions that write out a C string, but does never append a null to the output buffer(!)
        // stringToUTF8() always appends a null byte, so restore the character under the null byte after the write.
        HEAP8[buf+len] = endChar;
  
        return len;
      },doAccess:function(path, amode) {
        if (amode & ~7) {
          // need a valid mode
          return -28;
        }
        var node;
        var lookup = FS.lookupPath(path, { follow: true });
        node = lookup.node;
        if (!node) {
          return -44;
        }
        var perms = '';
        if (amode & 4) perms += 'r';
        if (amode & 2) perms += 'w';
        if (amode & 1) perms += 'x';
        if (perms /* otherwise, they've just passed F_OK */ && FS.nodePermissions(node, perms)) {
          return -2;
        }
        return 0;
      },doDup:function(path, flags, suggestFD) {
        var suggest = FS.getStream(suggestFD);
        if (suggest) FS.close(suggest);
        return FS.open(path, flags, 0, suggestFD, suggestFD).fd;
      },doReadv:function(stream, iov, iovcnt, offset) {
        var ret = 0;
        for (var i = 0; i < iovcnt; i++) {
          var ptr = HEAP32[(((iov)+(i*8))>>2)];
          var len = HEAP32[(((iov)+(i*8 + 4))>>2)];
          var curr = FS.read(stream, HEAP8,ptr, len, offset);
          if (curr < 0) return -1;
          ret += curr;
          if (curr < len) break; // nothing more to read
        }
        return ret;
      },doWritev:function(stream, iov, iovcnt, offset) {
        var ret = 0;
        for (var i = 0; i < iovcnt; i++) {
          var ptr = HEAP32[(((iov)+(i*8))>>2)];
          var len = HEAP32[(((iov)+(i*8 + 4))>>2)];
          var curr = FS.write(stream, HEAP8,ptr, len, offset);
          if (curr < 0) return -1;
          ret += curr;
        }
        return ret;
      },varargs:undefined,get:function() {
        assert(SYSCALLS.varargs != undefined);
        SYSCALLS.varargs += 4;
        var ret = HEAP32[(((SYSCALLS.varargs)-(4))>>2)];
        return ret;
      },getStr:function(ptr) {
        var ret = UTF8ToString(ptr);
        return ret;
      },getStreamFromFD:function(fd) {
        var stream = FS.getStream(fd);
        if (!stream) throw new FS.ErrnoError(8);
        return stream;
      },get64:function(low, high) {
        if (low >= 0) assert(high === 0);
        else assert(high === -1);
        return low;
      }};function ___sys_fstat64(fd, buf) {try {
  
      var stream = SYSCALLS.getStreamFromFD(fd);
      return SYSCALLS.doStat(FS.stat, stream.path, buf);
    } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
  }

  function ___sys_ftruncate64(fd, zero, low, high) {try {
  
      var length = SYSCALLS.get64(low, high);
      FS.ftruncate(fd, length);
      return 0;
    } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
  }

  
  function syscallMmap2(addr, len, prot, flags, fd, off) {
      off <<= 12; // undo pgoffset
      var ptr;
      var allocated = false;
  
      // addr argument must be page aligned if MAP_FIXED flag is set.
      if ((flags & 16) !== 0 && (addr % 16384) !== 0) {
        return -28;
      }
  
      // MAP_ANONYMOUS (aka MAP_ANON) isn't actually defined by POSIX spec,
      // but it is widely used way to allocate memory pages on Linux, BSD and Mac.
      // In this case fd argument is ignored.
      if ((flags & 32) !== 0) {
        ptr = _memalign(16384, len);
        if (!ptr) return -48;
        _memset(ptr, 0, len);
        allocated = true;
      } else {
        var info = FS.getStream(fd);
        if (!info) return -8;
        var res = FS.mmap(info, HEAPU8, addr, len, off, prot, flags);
        ptr = res.ptr;
        allocated = res.allocated;
      }
      SYSCALLS.mappings[ptr] = { malloc: ptr, len: len, allocated: allocated, fd: fd, prot: prot, flags: flags, offset: off };
      return ptr;
    }function ___sys_mmap2(addr, len, prot, flags, fd, off) {try {
  
      return syscallMmap2(addr, len, prot, flags, fd, off);
    } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
  }

  
  function syscallMunmap(addr, len) {
      if ((addr | 0) === -1 || len === 0) {
        return -28;
      }
      // TODO: support unmmap'ing parts of allocations
      var info = SYSCALLS.mappings[addr];
      if (!info) return 0;
      if (len === info.len) {
        var stream = FS.getStream(info.fd);
        if (info.prot & 2) {
          SYSCALLS.doMsync(addr, stream, len, info.flags, info.offset);
        }
        FS.munmap(stream);
        SYSCALLS.mappings[addr] = null;
        if (info.allocated) {
          _free(info.malloc);
        }
      }
      return 0;
    }function ___sys_munmap(addr, len) {try {
  
      return syscallMunmap(addr, len);
    } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
  }

  function ___sys_open(path, flags, varargs) {SYSCALLS.varargs = varargs;
  try {
  
      var pathname = SYSCALLS.getStr(path);
      var mode = SYSCALLS.get();
      var stream = FS.open(pathname, flags, mode);
      return stream.fd;
    } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
  }

  function ___sys_read(fd, buf, count) {try {
  
      var stream = SYSCALLS.getStreamFromFD(fd);
      return FS.read(stream, HEAP8,buf, count);
    } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
  }

  function ___sys_stat64(path, buf) {try {
  
      path = SYSCALLS.getStr(path);
      return SYSCALLS.doStat(FS.stat, path, buf);
    } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
  }

  
  function getShiftFromSize(size) {
      switch (size) {
          case 1: return 0;
          case 2: return 1;
          case 4: return 2;
          case 8: return 3;
          default:
              throw new TypeError('Unknown type size: ' + size);
      }
    }
  
  
  
  function embind_init_charCodes() {
      var codes = new Array(256);
      for (var i = 0; i < 256; ++i) {
          codes[i] = String.fromCharCode(i);
      }
      embind_charCodes = codes;
    }var embind_charCodes=undefined;function readLatin1String(ptr) {
      var ret = "";
      var c = ptr;
      while (HEAPU8[c]) {
          ret += embind_charCodes[HEAPU8[c++]];
      }
      return ret;
    }
  
  
  var awaitingDependencies={};
  
  var registeredTypes={};
  
  var typeDependencies={};
  
  
  
  
  
  
  var char_0=48;
  
  var char_9=57;function makeLegalFunctionName(name) {
      if (undefined === name) {
          return '_unknown';
      }
      name = name.replace(/[^a-zA-Z0-9_]/g, '$');
      var f = name.charCodeAt(0);
      if (f >= char_0 && f <= char_9) {
          return '_' + name;
      } else {
          return name;
      }
    }function createNamedFunction(name, body) {
      name = makeLegalFunctionName(name);
      /*jshint evil:true*/
      return new Function(
          "body",
          "return function " + name + "() {\n" +
          "    \"use strict\";" +
          "    return body.apply(this, arguments);\n" +
          "};\n"
      )(body);
    }function extendError(baseErrorType, errorName) {
      var errorClass = createNamedFunction(errorName, function(message) {
          this.name = errorName;
          this.message = message;
  
          var stack = (new Error(message)).stack;
          if (stack !== undefined) {
              this.stack = this.toString() + '\n' +
                  stack.replace(/^Error(:[^\n]*)?\n/, '');
          }
      });
      errorClass.prototype = Object.create(baseErrorType.prototype);
      errorClass.prototype.constructor = errorClass;
      errorClass.prototype.toString = function() {
          if (this.message === undefined) {
              return this.name;
          } else {
              return this.name + ': ' + this.message;
          }
      };
  
      return errorClass;
    }var BindingError=undefined;function throwBindingError(message) {
      throw new BindingError(message);
    }
  
  
  
  var InternalError=undefined;function throwInternalError(message) {
      throw new InternalError(message);
    }function whenDependentTypesAreResolved(myTypes, dependentTypes, getTypeConverters) {
      myTypes.forEach(function(type) {
          typeDependencies[type] = dependentTypes;
      });
  
      function onComplete(typeConverters) {
          var myTypeConverters = getTypeConverters(typeConverters);
          if (myTypeConverters.length !== myTypes.length) {
              throwInternalError('Mismatched type converter count');
          }
          for (var i = 0; i < myTypes.length; ++i) {
              registerType(myTypes[i], myTypeConverters[i]);
          }
      }
  
      var typeConverters = new Array(dependentTypes.length);
      var unregisteredTypes = [];
      var registered = 0;
      dependentTypes.forEach(function(dt, i) {
          if (registeredTypes.hasOwnProperty(dt)) {
              typeConverters[i] = registeredTypes[dt];
          } else {
              unregisteredTypes.push(dt);
              if (!awaitingDependencies.hasOwnProperty(dt)) {
                  awaitingDependencies[dt] = [];
              }
              awaitingDependencies[dt].push(function() {
                  typeConverters[i] = registeredTypes[dt];
                  ++registered;
                  if (registered === unregisteredTypes.length) {
                      onComplete(typeConverters);
                  }
              });
          }
      });
      if (0 === unregisteredTypes.length) {
          onComplete(typeConverters);
      }
    }/** @param {Object=} options */
  function registerType(rawType, registeredInstance, options) {
      options = options || {};
  
      if (!('argPackAdvance' in registeredInstance)) {
          throw new TypeError('registerType registeredInstance requires argPackAdvance');
      }
  
      var name = registeredInstance.name;
      if (!rawType) {
          throwBindingError('type "' + name + '" must have a positive integer typeid pointer');
      }
      if (registeredTypes.hasOwnProperty(rawType)) {
          if (options.ignoreDuplicateRegistrations) {
              return;
          } else {
              throwBindingError("Cannot register type '" + name + "' twice");
          }
      }
  
      registeredTypes[rawType] = registeredInstance;
      delete typeDependencies[rawType];
  
      if (awaitingDependencies.hasOwnProperty(rawType)) {
          var callbacks = awaitingDependencies[rawType];
          delete awaitingDependencies[rawType];
          callbacks.forEach(function(cb) {
              cb();
          });
      }
    }function __embind_register_bool(rawType, name, size, trueValue, falseValue) {
      var shift = getShiftFromSize(size);
  
      name = readLatin1String(name);
      registerType(rawType, {
          name: name,
          'fromWireType': function(wt) {
              // ambiguous emscripten ABI: sometimes return values are
              // true or false, and sometimes integers (0 or 1)
              return !!wt;
          },
          'toWireType': function(destructors, o) {
              return o ? trueValue : falseValue;
          },
          'argPackAdvance': 8,
          'readValueFromPointer': function(pointer) {
              // TODO: if heap is fixed (like in asm.js) this could be executed outside
              var heap;
              if (size === 1) {
                  heap = HEAP8;
              } else if (size === 2) {
                  heap = HEAP16;
              } else if (size === 4) {
                  heap = HEAP32;
              } else {
                  throw new TypeError("Unknown boolean type size: " + name);
              }
              return this['fromWireType'](heap[pointer >> shift]);
          },
          destructorFunction: null, // This type does not need a destructor
      });
    }

  
  
  
  function ClassHandle_isAliasOf(other) {
      if (!(this instanceof ClassHandle)) {
          return false;
      }
      if (!(other instanceof ClassHandle)) {
          return false;
      }
  
      var leftClass = this.$$.ptrType.registeredClass;
      var left = this.$$.ptr;
      var rightClass = other.$$.ptrType.registeredClass;
      var right = other.$$.ptr;
  
      while (leftClass.baseClass) {
          left = leftClass.upcast(left);
          leftClass = leftClass.baseClass;
      }
  
      while (rightClass.baseClass) {
          right = rightClass.upcast(right);
          rightClass = rightClass.baseClass;
      }
  
      return leftClass === rightClass && left === right;
    }
  
  
  function shallowCopyInternalPointer(o) {
      return {
          count: o.count,
          deleteScheduled: o.deleteScheduled,
          preservePointerOnDelete: o.preservePointerOnDelete,
          ptr: o.ptr,
          ptrType: o.ptrType,
          smartPtr: o.smartPtr,
          smartPtrType: o.smartPtrType,
      };
    }
  
  function throwInstanceAlreadyDeleted(obj) {
      function getInstanceTypeName(handle) {
        return handle.$$.ptrType.registeredClass.name;
      }
      throwBindingError(getInstanceTypeName(obj) + ' instance already deleted');
    }
  
  
  var finalizationGroup=false;
  
  function detachFinalizer(handle) {}
  
  
  function runDestructor($$) {
      if ($$.smartPtr) {
          $$.smartPtrType.rawDestructor($$.smartPtr);
      } else {
          $$.ptrType.registeredClass.rawDestructor($$.ptr);
      }
    }function releaseClassHandle($$) {
      $$.count.value -= 1;
      var toDelete = 0 === $$.count.value;
      if (toDelete) {
          runDestructor($$);
      }
    }function attachFinalizer(handle) {
      if ('undefined' === typeof FinalizationGroup) {
          attachFinalizer = function (handle) { return handle; };
          return handle;
      }
      // If the running environment has a FinalizationGroup (see
      // https://github.com/tc39/proposal-weakrefs), then attach finalizers
      // for class handles.  We check for the presence of FinalizationGroup
      // at run-time, not build-time.
      finalizationGroup = new FinalizationGroup(function (iter) {
          for (var result = iter.next(); !result.done; result = iter.next()) {
              var $$ = result.value;
              if (!$$.ptr) {
                  console.warn('object already deleted: ' + $$.ptr);
              } else {
                  releaseClassHandle($$);
              }
          }
      });
      attachFinalizer = function(handle) {
          finalizationGroup.register(handle, handle.$$, handle.$$);
          return handle;
      };
      detachFinalizer = function(handle) {
          finalizationGroup.unregister(handle.$$);
      };
      return attachFinalizer(handle);
    }function ClassHandle_clone() {
      if (!this.$$.ptr) {
          throwInstanceAlreadyDeleted(this);
      }
  
      if (this.$$.preservePointerOnDelete) {
          this.$$.count.value += 1;
          return this;
      } else {
          var clone = attachFinalizer(Object.create(Object.getPrototypeOf(this), {
              $$: {
                  value: shallowCopyInternalPointer(this.$$),
              }
          }));
  
          clone.$$.count.value += 1;
          clone.$$.deleteScheduled = false;
          return clone;
      }
    }
  
  function ClassHandle_delete() {
      if (!this.$$.ptr) {
          throwInstanceAlreadyDeleted(this);
      }
  
      if (this.$$.deleteScheduled && !this.$$.preservePointerOnDelete) {
          throwBindingError('Object already scheduled for deletion');
      }
  
      detachFinalizer(this);
      releaseClassHandle(this.$$);
  
      if (!this.$$.preservePointerOnDelete) {
          this.$$.smartPtr = undefined;
          this.$$.ptr = undefined;
      }
    }
  
  function ClassHandle_isDeleted() {
      return !this.$$.ptr;
    }
  
  
  var delayFunction=undefined;
  
  var deletionQueue=[];
  
  function flushPendingDeletes() {
      while (deletionQueue.length) {
          var obj = deletionQueue.pop();
          obj.$$.deleteScheduled = false;
          obj['delete']();
      }
    }function ClassHandle_deleteLater() {
      if (!this.$$.ptr) {
          throwInstanceAlreadyDeleted(this);
      }
      if (this.$$.deleteScheduled && !this.$$.preservePointerOnDelete) {
          throwBindingError('Object already scheduled for deletion');
      }
      deletionQueue.push(this);
      if (deletionQueue.length === 1 && delayFunction) {
          delayFunction(flushPendingDeletes);
      }
      this.$$.deleteScheduled = true;
      return this;
    }function init_ClassHandle() {
      ClassHandle.prototype['isAliasOf'] = ClassHandle_isAliasOf;
      ClassHandle.prototype['clone'] = ClassHandle_clone;
      ClassHandle.prototype['delete'] = ClassHandle_delete;
      ClassHandle.prototype['isDeleted'] = ClassHandle_isDeleted;
      ClassHandle.prototype['deleteLater'] = ClassHandle_deleteLater;
    }function ClassHandle() {
    }
  
  var registeredPointers={};
  
  
  function ensureOverloadTable(proto, methodName, humanName) {
      if (undefined === proto[methodName].overloadTable) {
          var prevFunc = proto[methodName];
          // Inject an overload resolver function that routes to the appropriate overload based on the number of arguments.
          proto[methodName] = function() {
              // TODO This check can be removed in -O3 level "unsafe" optimizations.
              if (!proto[methodName].overloadTable.hasOwnProperty(arguments.length)) {
                  throwBindingError("Function '" + humanName + "' called with an invalid number of arguments (" + arguments.length + ") - expects one of (" + proto[methodName].overloadTable + ")!");
              }
              return proto[methodName].overloadTable[arguments.length].apply(this, arguments);
          };
          // Move the previous function into the overload table.
          proto[methodName].overloadTable = [];
          proto[methodName].overloadTable[prevFunc.argCount] = prevFunc;
      }
    }/** @param {number=} numArguments */
  function exposePublicSymbol(name, value, numArguments) {
      if (Module.hasOwnProperty(name)) {
          if (undefined === numArguments || (undefined !== Module[name].overloadTable && undefined !== Module[name].overloadTable[numArguments])) {
              throwBindingError("Cannot register public name '" + name + "' twice");
          }
  
          // We are exposing a function with the same name as an existing function. Create an overload table and a function selector
          // that routes between the two.
          ensureOverloadTable(Module, name, name);
          if (Module.hasOwnProperty(numArguments)) {
              throwBindingError("Cannot register multiple overloads of a function with the same number of arguments (" + numArguments + ")!");
          }
          // Add the new function into the overload table.
          Module[name].overloadTable[numArguments] = value;
      }
      else {
          Module[name] = value;
          if (undefined !== numArguments) {
              Module[name].numArguments = numArguments;
          }
      }
    }
  
  /** @constructor */
  function RegisteredClass(
      name,
      constructor,
      instancePrototype,
      rawDestructor,
      baseClass,
      getActualType,
      upcast,
      downcast
    ) {
      this.name = name;
      this.constructor = constructor;
      this.instancePrototype = instancePrototype;
      this.rawDestructor = rawDestructor;
      this.baseClass = baseClass;
      this.getActualType = getActualType;
      this.upcast = upcast;
      this.downcast = downcast;
      this.pureVirtualFunctions = [];
    }
  
  
  
  function upcastPointer(ptr, ptrClass, desiredClass) {
      while (ptrClass !== desiredClass) {
          if (!ptrClass.upcast) {
              throwBindingError("Expected null or instance of " + desiredClass.name + ", got an instance of " + ptrClass.name);
          }
          ptr = ptrClass.upcast(ptr);
          ptrClass = ptrClass.baseClass;
      }
      return ptr;
    }function constNoSmartPtrRawPointerToWireType(destructors, handle) {
      if (handle === null) {
          if (this.isReference) {
              throwBindingError('null is not a valid ' + this.name);
          }
          return 0;
      }
  
      if (!handle.$$) {
          throwBindingError('Cannot pass "' + _embind_repr(handle) + '" as a ' + this.name);
      }
      if (!handle.$$.ptr) {
          throwBindingError('Cannot pass deleted object as a pointer of type ' + this.name);
      }
      var handleClass = handle.$$.ptrType.registeredClass;
      var ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);
      return ptr;
    }
  
  function genericPointerToWireType(destructors, handle) {
      var ptr;
      if (handle === null) {
          if (this.isReference) {
              throwBindingError('null is not a valid ' + this.name);
          }
  
          if (this.isSmartPointer) {
              ptr = this.rawConstructor();
              if (destructors !== null) {
                  destructors.push(this.rawDestructor, ptr);
              }
              return ptr;
          } else {
              return 0;
          }
      }
  
      if (!handle.$$) {
          throwBindingError('Cannot pass "' + _embind_repr(handle) + '" as a ' + this.name);
      }
      if (!handle.$$.ptr) {
          throwBindingError('Cannot pass deleted object as a pointer of type ' + this.name);
      }
      if (!this.isConst && handle.$$.ptrType.isConst) {
          throwBindingError('Cannot convert argument of type ' + (handle.$$.smartPtrType ? handle.$$.smartPtrType.name : handle.$$.ptrType.name) + ' to parameter type ' + this.name);
      }
      var handleClass = handle.$$.ptrType.registeredClass;
      ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);
  
      if (this.isSmartPointer) {
          // TODO: this is not strictly true
          // We could support BY_EMVAL conversions from raw pointers to smart pointers
          // because the smart pointer can hold a reference to the handle
          if (undefined === handle.$$.smartPtr) {
              throwBindingError('Passing raw pointer to smart pointer is illegal');
          }
  
          switch (this.sharingPolicy) {
              case 0: // NONE
                  // no upcasting
                  if (handle.$$.smartPtrType === this) {
                      ptr = handle.$$.smartPtr;
                  } else {
                      throwBindingError('Cannot convert argument of type ' + (handle.$$.smartPtrType ? handle.$$.smartPtrType.name : handle.$$.ptrType.name) + ' to parameter type ' + this.name);
                  }
                  break;
  
              case 1: // INTRUSIVE
                  ptr = handle.$$.smartPtr;
                  break;
  
              case 2: // BY_EMVAL
                  if (handle.$$.smartPtrType === this) {
                      ptr = handle.$$.smartPtr;
                  } else {
                      var clonedHandle = handle['clone']();
                      ptr = this.rawShare(
                          ptr,
                          __emval_register(function() {
                              clonedHandle['delete']();
                          })
                      );
                      if (destructors !== null) {
                          destructors.push(this.rawDestructor, ptr);
                      }
                  }
                  break;
  
              default:
                  throwBindingError('Unsupporting sharing policy');
          }
      }
      return ptr;
    }
  
  function nonConstNoSmartPtrRawPointerToWireType(destructors, handle) {
      if (handle === null) {
          if (this.isReference) {
              throwBindingError('null is not a valid ' + this.name);
          }
          return 0;
      }
  
      if (!handle.$$) {
          throwBindingError('Cannot pass "' + _embind_repr(handle) + '" as a ' + this.name);
      }
      if (!handle.$$.ptr) {
          throwBindingError('Cannot pass deleted object as a pointer of type ' + this.name);
      }
      if (handle.$$.ptrType.isConst) {
          throwBindingError('Cannot convert argument of type ' + handle.$$.ptrType.name + ' to parameter type ' + this.name);
      }
      var handleClass = handle.$$.ptrType.registeredClass;
      var ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);
      return ptr;
    }
  
  
  function simpleReadValueFromPointer(pointer) {
      return this['fromWireType'](HEAPU32[pointer >> 2]);
    }
  
  function RegisteredPointer_getPointee(ptr) {
      if (this.rawGetPointee) {
          ptr = this.rawGetPointee(ptr);
      }
      return ptr;
    }
  
  function RegisteredPointer_destructor(ptr) {
      if (this.rawDestructor) {
          this.rawDestructor(ptr);
      }
    }
  
  function RegisteredPointer_deleteObject(handle) {
      if (handle !== null) {
          handle['delete']();
      }
    }
  
  
  function downcastPointer(ptr, ptrClass, desiredClass) {
      if (ptrClass === desiredClass) {
          return ptr;
      }
      if (undefined === desiredClass.baseClass) {
          return null; // no conversion
      }
  
      var rv = downcastPointer(ptr, ptrClass, desiredClass.baseClass);
      if (rv === null) {
          return null;
      }
      return desiredClass.downcast(rv);
    }
  
  
  
  
  function getInheritedInstanceCount() {
      return Object.keys(registeredInstances).length;
    }
  
  function getLiveInheritedInstances() {
      var rv = [];
      for (var k in registeredInstances) {
          if (registeredInstances.hasOwnProperty(k)) {
              rv.push(registeredInstances[k]);
          }
      }
      return rv;
    }
  
  function setDelayFunction(fn) {
      delayFunction = fn;
      if (deletionQueue.length && delayFunction) {
          delayFunction(flushPendingDeletes);
      }
    }function init_embind() {
      Module['getInheritedInstanceCount'] = getInheritedInstanceCount;
      Module['getLiveInheritedInstances'] = getLiveInheritedInstances;
      Module['flushPendingDeletes'] = flushPendingDeletes;
      Module['setDelayFunction'] = setDelayFunction;
    }var registeredInstances={};
  
  function getBasestPointer(class_, ptr) {
      if (ptr === undefined) {
          throwBindingError('ptr should not be undefined');
      }
      while (class_.baseClass) {
          ptr = class_.upcast(ptr);
          class_ = class_.baseClass;
      }
      return ptr;
    }function getInheritedInstance(class_, ptr) {
      ptr = getBasestPointer(class_, ptr);
      return registeredInstances[ptr];
    }
  
  function makeClassHandle(prototype, record) {
      if (!record.ptrType || !record.ptr) {
          throwInternalError('makeClassHandle requires ptr and ptrType');
      }
      var hasSmartPtrType = !!record.smartPtrType;
      var hasSmartPtr = !!record.smartPtr;
      if (hasSmartPtrType !== hasSmartPtr) {
          throwInternalError('Both smartPtrType and smartPtr must be specified');
      }
      record.count = { value: 1 };
      return attachFinalizer(Object.create(prototype, {
          $$: {
              value: record,
          },
      }));
    }function RegisteredPointer_fromWireType(ptr) {
      // ptr is a raw pointer (or a raw smartpointer)
  
      // rawPointer is a maybe-null raw pointer
      var rawPointer = this.getPointee(ptr);
      if (!rawPointer) {
          this.destructor(ptr);
          return null;
      }
  
      var registeredInstance = getInheritedInstance(this.registeredClass, rawPointer);
      if (undefined !== registeredInstance) {
          // JS object has been neutered, time to repopulate it
          if (0 === registeredInstance.$$.count.value) {
              registeredInstance.$$.ptr = rawPointer;
              registeredInstance.$$.smartPtr = ptr;
              return registeredInstance['clone']();
          } else {
              // else, just increment reference count on existing object
              // it already has a reference to the smart pointer
              var rv = registeredInstance['clone']();
              this.destructor(ptr);
              return rv;
          }
      }
  
      function makeDefaultHandle() {
          if (this.isSmartPointer) {
              return makeClassHandle(this.registeredClass.instancePrototype, {
                  ptrType: this.pointeeType,
                  ptr: rawPointer,
                  smartPtrType: this,
                  smartPtr: ptr,
              });
          } else {
              return makeClassHandle(this.registeredClass.instancePrototype, {
                  ptrType: this,
                  ptr: ptr,
              });
          }
      }
  
      var actualType = this.registeredClass.getActualType(rawPointer);
      var registeredPointerRecord = registeredPointers[actualType];
      if (!registeredPointerRecord) {
          return makeDefaultHandle.call(this);
      }
  
      var toType;
      if (this.isConst) {
          toType = registeredPointerRecord.constPointerType;
      } else {
          toType = registeredPointerRecord.pointerType;
      }
      var dp = downcastPointer(
          rawPointer,
          this.registeredClass,
          toType.registeredClass);
      if (dp === null) {
          return makeDefaultHandle.call(this);
      }
      if (this.isSmartPointer) {
          return makeClassHandle(toType.registeredClass.instancePrototype, {
              ptrType: toType,
              ptr: dp,
              smartPtrType: this,
              smartPtr: ptr,
          });
      } else {
          return makeClassHandle(toType.registeredClass.instancePrototype, {
              ptrType: toType,
              ptr: dp,
          });
      }
    }function init_RegisteredPointer() {
      RegisteredPointer.prototype.getPointee = RegisteredPointer_getPointee;
      RegisteredPointer.prototype.destructor = RegisteredPointer_destructor;
      RegisteredPointer.prototype['argPackAdvance'] = 8;
      RegisteredPointer.prototype['readValueFromPointer'] = simpleReadValueFromPointer;
      RegisteredPointer.prototype['deleteObject'] = RegisteredPointer_deleteObject;
      RegisteredPointer.prototype['fromWireType'] = RegisteredPointer_fromWireType;
    }/** @constructor
      @param {*=} pointeeType,
      @param {*=} sharingPolicy,
      @param {*=} rawGetPointee,
      @param {*=} rawConstructor,
      @param {*=} rawShare,
      @param {*=} rawDestructor,
       */
  function RegisteredPointer(
      name,
      registeredClass,
      isReference,
      isConst,
  
      // smart pointer properties
      isSmartPointer,
      pointeeType,
      sharingPolicy,
      rawGetPointee,
      rawConstructor,
      rawShare,
      rawDestructor
    ) {
      this.name = name;
      this.registeredClass = registeredClass;
      this.isReference = isReference;
      this.isConst = isConst;
  
      // smart pointer properties
      this.isSmartPointer = isSmartPointer;
      this.pointeeType = pointeeType;
      this.sharingPolicy = sharingPolicy;
      this.rawGetPointee = rawGetPointee;
      this.rawConstructor = rawConstructor;
      this.rawShare = rawShare;
      this.rawDestructor = rawDestructor;
  
      if (!isSmartPointer && registeredClass.baseClass === undefined) {
          if (isConst) {
              this['toWireType'] = constNoSmartPtrRawPointerToWireType;
              this.destructorFunction = null;
          } else {
              this['toWireType'] = nonConstNoSmartPtrRawPointerToWireType;
              this.destructorFunction = null;
          }
      } else {
          this['toWireType'] = genericPointerToWireType;
          // Here we must leave this.destructorFunction undefined, since whether genericPointerToWireType returns
          // a pointer that needs to be freed up is runtime-dependent, and cannot be evaluated at registration time.
          // TODO: Create an alternative mechanism that allows removing the use of var destructors = []; array in
          //       craftInvokerFunction altogether.
      }
    }
  
  /** @param {number=} numArguments */
  function replacePublicSymbol(name, value, numArguments) {
      if (!Module.hasOwnProperty(name)) {
          throwInternalError('Replacing nonexistant public symbol');
      }
      // If there's an overload table for this symbol, replace the symbol in the overload table instead.
      if (undefined !== Module[name].overloadTable && undefined !== numArguments) {
          Module[name].overloadTable[numArguments] = value;
      }
      else {
          Module[name] = value;
          Module[name].argCount = numArguments;
      }
    }
  
  function embind__requireFunction(signature, rawFunction) {
      signature = readLatin1String(signature);
  
      function makeDynCaller(dynCall) {
          var args = [];
          for (var i = 1; i < signature.length; ++i) {
              args.push('a' + i);
          }
  
          var name = 'dynCall_' + signature + '_' + rawFunction;
          var body = 'return function ' + name + '(' + args.join(', ') + ') {\n';
          body    += '    return dynCall(rawFunction' + (args.length ? ', ' : '') + args.join(', ') + ');\n';
          body    += '};\n';
  
          return (new Function('dynCall', 'rawFunction', body))(dynCall, rawFunction);
      }
  
      var dc = Module['dynCall_' + signature];
      var fp = makeDynCaller(dc);
  
      if (typeof fp !== "function") {
          throwBindingError("unknown function pointer with signature " + signature + ": " + rawFunction);
      }
      return fp;
    }
  
  
  var UnboundTypeError=undefined;
  
  function getTypeName(type) {
      var ptr = ___getTypeName(type);
      var rv = readLatin1String(ptr);
      _free(ptr);
      return rv;
    }function throwUnboundTypeError(message, types) {
      var unboundTypes = [];
      var seen = {};
      function visit(type) {
          if (seen[type]) {
              return;
          }
          if (registeredTypes[type]) {
              return;
          }
          if (typeDependencies[type]) {
              typeDependencies[type].forEach(visit);
              return;
          }
          unboundTypes.push(type);
          seen[type] = true;
      }
      types.forEach(visit);
  
      throw new UnboundTypeError(message + ': ' + unboundTypes.map(getTypeName).join([', ']));
    }function __embind_register_class(
      rawType,
      rawPointerType,
      rawConstPointerType,
      baseClassRawType,
      getActualTypeSignature,
      getActualType,
      upcastSignature,
      upcast,
      downcastSignature,
      downcast,
      name,
      destructorSignature,
      rawDestructor
    ) {
      name = readLatin1String(name);
      getActualType = embind__requireFunction(getActualTypeSignature, getActualType);
      if (upcast) {
          upcast = embind__requireFunction(upcastSignature, upcast);
      }
      if (downcast) {
          downcast = embind__requireFunction(downcastSignature, downcast);
      }
      rawDestructor = embind__requireFunction(destructorSignature, rawDestructor);
      var legalFunctionName = makeLegalFunctionName(name);
  
      exposePublicSymbol(legalFunctionName, function() {
          // this code cannot run if baseClassRawType is zero
          throwUnboundTypeError('Cannot construct ' + name + ' due to unbound types', [baseClassRawType]);
      });
  
      whenDependentTypesAreResolved(
          [rawType, rawPointerType, rawConstPointerType],
          baseClassRawType ? [baseClassRawType] : [],
          function(base) {
              base = base[0];
  
              var baseClass;
              var basePrototype;
              if (baseClassRawType) {
                  baseClass = base.registeredClass;
                  basePrototype = baseClass.instancePrototype;
              } else {
                  basePrototype = ClassHandle.prototype;
              }
  
              var constructor = createNamedFunction(legalFunctionName, function() {
                  if (Object.getPrototypeOf(this) !== instancePrototype) {
                      throw new BindingError("Use 'new' to construct " + name);
                  }
                  if (undefined === registeredClass.constructor_body) {
                      throw new BindingError(name + " has no accessible constructor");
                  }
                  var body = registeredClass.constructor_body[arguments.length];
                  if (undefined === body) {
                      throw new BindingError("Tried to invoke ctor of " + name + " with invalid number of parameters (" + arguments.length + ") - expected (" + Object.keys(registeredClass.constructor_body).toString() + ") parameters instead!");
                  }
                  return body.apply(this, arguments);
              });
  
              var instancePrototype = Object.create(basePrototype, {
                  constructor: { value: constructor },
              });
  
              constructor.prototype = instancePrototype;
  
              var registeredClass = new RegisteredClass(
                  name,
                  constructor,
                  instancePrototype,
                  rawDestructor,
                  baseClass,
                  getActualType,
                  upcast,
                  downcast);
  
              var referenceConverter = new RegisteredPointer(
                  name,
                  registeredClass,
                  true,
                  false,
                  false);
  
              var pointerConverter = new RegisteredPointer(
                  name + '*',
                  registeredClass,
                  false,
                  false,
                  false);
  
              var constPointerConverter = new RegisteredPointer(
                  name + ' const*',
                  registeredClass,
                  false,
                  true,
                  false);
  
              registeredPointers[rawType] = {
                  pointerType: pointerConverter,
                  constPointerType: constPointerConverter
              };
  
              replacePublicSymbol(legalFunctionName, constructor);
  
              return [referenceConverter, pointerConverter, constPointerConverter];
          }
      );
    }

  
  function heap32VectorToArray(count, firstElement) {
      var array = [];
      for (var i = 0; i < count; i++) {
          array.push(HEAP32[(firstElement >> 2) + i]);
      }
      return array;
    }
  
  function runDestructors(destructors) {
      while (destructors.length) {
          var ptr = destructors.pop();
          var del = destructors.pop();
          del(ptr);
      }
    }function __embind_register_class_constructor(
      rawClassType,
      argCount,
      rawArgTypesAddr,
      invokerSignature,
      invoker,
      rawConstructor
    ) {
      assert(argCount > 0);
      var rawArgTypes = heap32VectorToArray(argCount, rawArgTypesAddr);
      invoker = embind__requireFunction(invokerSignature, invoker);
      var args = [rawConstructor];
      var destructors = [];
  
      whenDependentTypesAreResolved([], [rawClassType], function(classType) {
          classType = classType[0];
          var humanName = 'constructor ' + classType.name;
  
          if (undefined === classType.registeredClass.constructor_body) {
              classType.registeredClass.constructor_body = [];
          }
          if (undefined !== classType.registeredClass.constructor_body[argCount - 1]) {
              throw new BindingError("Cannot register multiple constructors with identical number of parameters (" + (argCount-1) + ") for class '" + classType.name + "'! Overload resolution is currently only performed using the parameter count, not actual type info!");
          }
          classType.registeredClass.constructor_body[argCount - 1] = function unboundTypeHandler() {
              throwUnboundTypeError('Cannot construct ' + classType.name + ' due to unbound types', rawArgTypes);
          };
  
          whenDependentTypesAreResolved([], rawArgTypes, function(argTypes) {
              classType.registeredClass.constructor_body[argCount - 1] = function constructor_body() {
                  if (arguments.length !== argCount - 1) {
                      throwBindingError(humanName + ' called with ' + arguments.length + ' arguments, expected ' + (argCount-1));
                  }
                  destructors.length = 0;
                  args.length = argCount;
                  for (var i = 1; i < argCount; ++i) {
                      args[i] = argTypes[i]['toWireType'](destructors, arguments[i - 1]);
                  }
  
                  var ptr = invoker.apply(null, args);
                  runDestructors(destructors);
  
                  return argTypes[0]['fromWireType'](ptr);
              };
              return [];
          });
          return [];
      });
    }

  
  
  function new_(constructor, argumentList) {
      if (!(constructor instanceof Function)) {
          throw new TypeError('new_ called with constructor type ' + typeof(constructor) + " which is not a function");
      }
  
      /*
       * Previously, the following line was just:
  
       function dummy() {};
  
       * Unfortunately, Chrome was preserving 'dummy' as the object's name, even though at creation, the 'dummy' has the
       * correct constructor name.  Thus, objects created with IMVU.new would show up in the debugger as 'dummy', which
       * isn't very helpful.  Using IMVU.createNamedFunction addresses the issue.  Doublely-unfortunately, there's no way
       * to write a test for this behavior.  -NRD 2013.02.22
       */
      var dummy = createNamedFunction(constructor.name || 'unknownFunctionName', function(){});
      dummy.prototype = constructor.prototype;
      var obj = new dummy;
  
      var r = constructor.apply(obj, argumentList);
      return (r instanceof Object) ? r : obj;
    }function craftInvokerFunction(humanName, argTypes, classType, cppInvokerFunc, cppTargetFunc) {
      // humanName: a human-readable string name for the function to be generated.
      // argTypes: An array that contains the embind type objects for all types in the function signature.
      //    argTypes[0] is the type object for the function return value.
      //    argTypes[1] is the type object for function this object/class type, or null if not crafting an invoker for a class method.
      //    argTypes[2...] are the actual function parameters.
      // classType: The embind type object for the class to be bound, or null if this is not a method of a class.
      // cppInvokerFunc: JS Function object to the C++-side function that interops into C++ code.
      // cppTargetFunc: Function pointer (an integer to FUNCTION_TABLE) to the target C++ function the cppInvokerFunc will end up calling.
      var argCount = argTypes.length;
  
      if (argCount < 2) {
          throwBindingError("argTypes array size mismatch! Must at least get return value and 'this' types!");
      }
  
      var isClassMethodFunc = (argTypes[1] !== null && classType !== null);
  
      // Free functions with signature "void function()" do not need an invoker that marshalls between wire types.
  // TODO: This omits argument count check - enable only at -O3 or similar.
  //    if (ENABLE_UNSAFE_OPTS && argCount == 2 && argTypes[0].name == "void" && !isClassMethodFunc) {
  //       return FUNCTION_TABLE[fn];
  //    }
  
  
      // Determine if we need to use a dynamic stack to store the destructors for the function parameters.
      // TODO: Remove this completely once all function invokers are being dynamically generated.
      var needsDestructorStack = false;
  
      for(var i = 1; i < argTypes.length; ++i) { // Skip return value at index 0 - it's not deleted here.
          if (argTypes[i] !== null && argTypes[i].destructorFunction === undefined) { // The type does not define a destructor function - must use dynamic stack
              needsDestructorStack = true;
              break;
          }
      }
  
      var returns = (argTypes[0].name !== "void");
  
      var argsList = "";
      var argsListWired = "";
      for(var i = 0; i < argCount - 2; ++i) {
          argsList += (i!==0?", ":"")+"arg"+i;
          argsListWired += (i!==0?", ":"")+"arg"+i+"Wired";
      }
  
      var invokerFnBody =
          "return function "+makeLegalFunctionName(humanName)+"("+argsList+") {\n" +
          "if (arguments.length !== "+(argCount - 2)+") {\n" +
              "throwBindingError('function "+humanName+" called with ' + arguments.length + ' arguments, expected "+(argCount - 2)+" args!');\n" +
          "}\n";
  
  
      if (needsDestructorStack) {
          invokerFnBody +=
              "var destructors = [];\n";
      }
  
      var dtorStack = needsDestructorStack ? "destructors" : "null";
      var args1 = ["throwBindingError", "invoker", "fn", "runDestructors", "retType", "classParam"];
      var args2 = [throwBindingError, cppInvokerFunc, cppTargetFunc, runDestructors, argTypes[0], argTypes[1]];
  
  
      if (isClassMethodFunc) {
          invokerFnBody += "var thisWired = classParam.toWireType("+dtorStack+", this);\n";
      }
  
      for(var i = 0; i < argCount - 2; ++i) {
          invokerFnBody += "var arg"+i+"Wired = argType"+i+".toWireType("+dtorStack+", arg"+i+"); // "+argTypes[i+2].name+"\n";
          args1.push("argType"+i);
          args2.push(argTypes[i+2]);
      }
  
      if (isClassMethodFunc) {
          argsListWired = "thisWired" + (argsListWired.length > 0 ? ", " : "") + argsListWired;
      }
  
      invokerFnBody +=
          (returns?"var rv = ":"") + "invoker(fn"+(argsListWired.length>0?", ":"")+argsListWired+");\n";
  
      if (needsDestructorStack) {
          invokerFnBody += "runDestructors(destructors);\n";
      } else {
          for(var i = isClassMethodFunc?1:2; i < argTypes.length; ++i) { // Skip return value at index 0 - it's not deleted here. Also skip class type if not a method.
              var paramName = (i === 1 ? "thisWired" : ("arg"+(i - 2)+"Wired"));
              if (argTypes[i].destructorFunction !== null) {
                  invokerFnBody += paramName+"_dtor("+paramName+"); // "+argTypes[i].name+"\n";
                  args1.push(paramName+"_dtor");
                  args2.push(argTypes[i].destructorFunction);
              }
          }
      }
  
      if (returns) {
          invokerFnBody += "var ret = retType.fromWireType(rv);\n" +
                           "return ret;\n";
      } else {
      }
      invokerFnBody += "}\n";
  
      args1.push(invokerFnBody);
  
      var invokerFunction = new_(Function, args1).apply(null, args2);
      return invokerFunction;
    }function __embind_register_class_function(
      rawClassType,
      methodName,
      argCount,
      rawArgTypesAddr, // [ReturnType, ThisType, Args...]
      invokerSignature,
      rawInvoker,
      context,
      isPureVirtual
    ) {
      var rawArgTypes = heap32VectorToArray(argCount, rawArgTypesAddr);
      methodName = readLatin1String(methodName);
      rawInvoker = embind__requireFunction(invokerSignature, rawInvoker);
  
      whenDependentTypesAreResolved([], [rawClassType], function(classType) {
          classType = classType[0];
          var humanName = classType.name + '.' + methodName;
  
          if (isPureVirtual) {
              classType.registeredClass.pureVirtualFunctions.push(methodName);
          }
  
          function unboundTypesHandler() {
              throwUnboundTypeError('Cannot call ' + humanName + ' due to unbound types', rawArgTypes);
          }
  
          var proto = classType.registeredClass.instancePrototype;
          var method = proto[methodName];
          if (undefined === method || (undefined === method.overloadTable && method.className !== classType.name && method.argCount === argCount - 2)) {
              // This is the first overload to be registered, OR we are replacing a function in the base class with a function in the derived class.
              unboundTypesHandler.argCount = argCount - 2;
              unboundTypesHandler.className = classType.name;
              proto[methodName] = unboundTypesHandler;
          } else {
              // There was an existing function with the same name registered. Set up a function overload routing table.
              ensureOverloadTable(proto, methodName, humanName);
              proto[methodName].overloadTable[argCount - 2] = unboundTypesHandler;
          }
  
          whenDependentTypesAreResolved([], rawArgTypes, function(argTypes) {
  
              var memberFunction = craftInvokerFunction(humanName, argTypes, classType, rawInvoker, context);
  
              // Replace the initial unbound-handler-stub function with the appropriate member function, now that all types
              // are resolved. If multiple overloads are registered for this function, the function goes into an overload table.
              if (undefined === proto[methodName].overloadTable) {
                  // Set argCount in case an overload is registered later
                  memberFunction.argCount = argCount - 2;
                  proto[methodName] = memberFunction;
              } else {
                  proto[methodName].overloadTable[argCount - 2] = memberFunction;
              }
  
              return [];
          });
          return [];
      });
    }

  
  function validateThis(this_, classType, humanName) {
      if (!(this_ instanceof Object)) {
          throwBindingError(humanName + ' with invalid "this": ' + this_);
      }
      if (!(this_ instanceof classType.registeredClass.constructor)) {
          throwBindingError(humanName + ' incompatible with "this" of type ' + this_.constructor.name);
      }
      if (!this_.$$.ptr) {
          throwBindingError('cannot call emscripten binding method ' + humanName + ' on deleted object');
      }
  
      // todo: kill this
      return upcastPointer(
          this_.$$.ptr,
          this_.$$.ptrType.registeredClass,
          classType.registeredClass);
    }function __embind_register_class_property(
      classType,
      fieldName,
      getterReturnType,
      getterSignature,
      getter,
      getterContext,
      setterArgumentType,
      setterSignature,
      setter,
      setterContext
    ) {
      fieldName = readLatin1String(fieldName);
      getter = embind__requireFunction(getterSignature, getter);
  
      whenDependentTypesAreResolved([], [classType], function(classType) {
          classType = classType[0];
          var humanName = classType.name + '.' + fieldName;
          var desc = {
              get: function() {
                  throwUnboundTypeError('Cannot access ' + humanName + ' due to unbound types', [getterReturnType, setterArgumentType]);
              },
              enumerable: true,
              configurable: true
          };
          if (setter) {
              desc.set = function() {
                  throwUnboundTypeError('Cannot access ' + humanName + ' due to unbound types', [getterReturnType, setterArgumentType]);
              };
          } else {
              desc.set = function(v) {
                  throwBindingError(humanName + ' is a read-only property');
              };
          }
  
          Object.defineProperty(classType.registeredClass.instancePrototype, fieldName, desc);
  
          whenDependentTypesAreResolved(
              [],
              (setter ? [getterReturnType, setterArgumentType] : [getterReturnType]),
          function(types) {
              var getterReturnType = types[0];
              var desc = {
                  get: function() {
                      var ptr = validateThis(this, classType, humanName + ' getter');
                      return getterReturnType['fromWireType'](getter(getterContext, ptr));
                  },
                  enumerable: true
              };
  
              if (setter) {
                  setter = embind__requireFunction(setterSignature, setter);
                  var setterArgumentType = types[1];
                  desc.set = function(v) {
                      var ptr = validateThis(this, classType, humanName + ' setter');
                      var destructors = [];
                      setter(setterContext, ptr, setterArgumentType['toWireType'](destructors, v));
                      runDestructors(destructors);
                  };
              }
  
              Object.defineProperty(classType.registeredClass.instancePrototype, fieldName, desc);
              return [];
          });
  
          return [];
      });
    }

  function __embind_register_constant(name, type, value) {
      name = readLatin1String(name);
      whenDependentTypesAreResolved([], [type], function(type) {
          type = type[0];
          Module[name] = type['fromWireType'](value);
          return [];
      });
    }

  
  
  var emval_free_list=[];
  
  var emval_handle_array=[{},{value:undefined},{value:null},{value:true},{value:false}];function __emval_decref(handle) {
      if (handle > 4 && 0 === --emval_handle_array[handle].refcount) {
          emval_handle_array[handle] = undefined;
          emval_free_list.push(handle);
      }
    }
  
  
  
  function count_emval_handles() {
      var count = 0;
      for (var i = 5; i < emval_handle_array.length; ++i) {
          if (emval_handle_array[i] !== undefined) {
              ++count;
          }
      }
      return count;
    }
  
  function get_first_emval() {
      for (var i = 5; i < emval_handle_array.length; ++i) {
          if (emval_handle_array[i] !== undefined) {
              return emval_handle_array[i];
          }
      }
      return null;
    }function init_emval() {
      Module['count_emval_handles'] = count_emval_handles;
      Module['get_first_emval'] = get_first_emval;
    }function __emval_register(value) {
  
      switch(value){
        case undefined :{ return 1; }
        case null :{ return 2; }
        case true :{ return 3; }
        case false :{ return 4; }
        default:{
          var handle = emval_free_list.length ?
              emval_free_list.pop() :
              emval_handle_array.length;
  
          emval_handle_array[handle] = {refcount: 1, value: value};
          return handle;
          }
        }
    }function __embind_register_emval(rawType, name) {
      name = readLatin1String(name);
      registerType(rawType, {
          name: name,
          'fromWireType': function(handle) {
              var rv = emval_handle_array[handle].value;
              __emval_decref(handle);
              return rv;
          },
          'toWireType': function(destructors, value) {
              return __emval_register(value);
          },
          'argPackAdvance': 8,
          'readValueFromPointer': simpleReadValueFromPointer,
          destructorFunction: null, // This type does not need a destructor
  
          // TODO: do we need a deleteObject here?  write a test where
          // emval is passed into JS via an interface
      });
    }

  
  function _embind_repr(v) {
      if (v === null) {
          return 'null';
      }
      var t = typeof v;
      if (t === 'object' || t === 'array' || t === 'function') {
          return v.toString();
      } else {
          return '' + v;
      }
    }
  
  function floatReadValueFromPointer(name, shift) {
      switch (shift) {
          case 2: return function(pointer) {
              return this['fromWireType'](HEAPF32[pointer >> 2]);
          };
          case 3: return function(pointer) {
              return this['fromWireType'](HEAPF64[pointer >> 3]);
          };
          default:
              throw new TypeError("Unknown float type: " + name);
      }
    }function __embind_register_float(rawType, name, size) {
      var shift = getShiftFromSize(size);
      name = readLatin1String(name);
      registerType(rawType, {
          name: name,
          'fromWireType': function(value) {
              return value;
          },
          'toWireType': function(destructors, value) {
              // todo: Here we have an opportunity for -O3 level "unsafe" optimizations: we could
              // avoid the following if() and assume value is of proper type.
              if (typeof value !== "number" && typeof value !== "boolean") {
                  throw new TypeError('Cannot convert "' + _embind_repr(value) + '" to ' + this.name);
              }
              return value;
          },
          'argPackAdvance': 8,
          'readValueFromPointer': floatReadValueFromPointer(name, shift),
          destructorFunction: null, // This type does not need a destructor
      });
    }

  function __embind_register_function(name, argCount, rawArgTypesAddr, signature, rawInvoker, fn) {
      var argTypes = heap32VectorToArray(argCount, rawArgTypesAddr);
      name = readLatin1String(name);
  
      rawInvoker = embind__requireFunction(signature, rawInvoker);
  
      exposePublicSymbol(name, function() {
          throwUnboundTypeError('Cannot call ' + name + ' due to unbound types', argTypes);
      }, argCount - 1);
  
      whenDependentTypesAreResolved([], argTypes, function(argTypes) {
          var invokerArgsArray = [argTypes[0] /* return value */, null /* no class 'this'*/].concat(argTypes.slice(1) /* actual params */);
          replacePublicSymbol(name, craftInvokerFunction(name, invokerArgsArray, null /* no class 'this'*/, rawInvoker, fn), argCount - 1);
          return [];
      });
    }

  
  function integerReadValueFromPointer(name, shift, signed) {
      // integers are quite common, so generate very specialized functions
      switch (shift) {
          case 0: return signed ?
              function readS8FromPointer(pointer) { return HEAP8[pointer]; } :
              function readU8FromPointer(pointer) { return HEAPU8[pointer]; };
          case 1: return signed ?
              function readS16FromPointer(pointer) { return HEAP16[pointer >> 1]; } :
              function readU16FromPointer(pointer) { return HEAPU16[pointer >> 1]; };
          case 2: return signed ?
              function readS32FromPointer(pointer) { return HEAP32[pointer >> 2]; } :
              function readU32FromPointer(pointer) { return HEAPU32[pointer >> 2]; };
          default:
              throw new TypeError("Unknown integer type: " + name);
      }
    }function __embind_register_integer(primitiveType, name, size, minRange, maxRange) {
      name = readLatin1String(name);
      if (maxRange === -1) { // LLVM doesn't have signed and unsigned 32-bit types, so u32 literals come out as 'i32 -1'. Always treat those as max u32.
          maxRange = 4294967295;
      }
  
      var shift = getShiftFromSize(size);
  
      var fromWireType = function(value) {
          return value;
      };
  
      if (minRange === 0) {
          var bitshift = 32 - 8*size;
          fromWireType = function(value) {
              return (value << bitshift) >>> bitshift;
          };
      }
  
      var isUnsignedType = (name.indexOf('unsigned') != -1);
  
      registerType(primitiveType, {
          name: name,
          'fromWireType': fromWireType,
          'toWireType': function(destructors, value) {
              // todo: Here we have an opportunity for -O3 level "unsafe" optimizations: we could
              // avoid the following two if()s and assume value is of proper type.
              if (typeof value !== "number" && typeof value !== "boolean") {
                  throw new TypeError('Cannot convert "' + _embind_repr(value) + '" to ' + this.name);
              }
              if (value < minRange || value > maxRange) {
                  throw new TypeError('Passing a number "' + _embind_repr(value) + '" from JS side to C/C++ side to an argument of type "' + name + '", which is outside the valid range [' + minRange + ', ' + maxRange + ']!');
              }
              return isUnsignedType ? (value >>> 0) : (value | 0);
          },
          'argPackAdvance': 8,
          'readValueFromPointer': integerReadValueFromPointer(name, shift, minRange !== 0),
          destructorFunction: null, // This type does not need a destructor
      });
    }

  function __embind_register_memory_view(rawType, dataTypeIndex, name) {
      var typeMapping = [
          Int8Array,
          Uint8Array,
          Int16Array,
          Uint16Array,
          Int32Array,
          Uint32Array,
          Float32Array,
          Float64Array,
      ];
  
      var TA = typeMapping[dataTypeIndex];
  
      function decodeMemoryView(handle) {
          handle = handle >> 2;
          var heap = HEAPU32;
          var size = heap[handle]; // in elements
          var data = heap[handle + 1]; // byte offset into emscripten heap
          return new TA(buffer, data, size);
      }
  
      name = readLatin1String(name);
      registerType(rawType, {
          name: name,
          'fromWireType': decodeMemoryView,
          'argPackAdvance': 8,
          'readValueFromPointer': decodeMemoryView,
      }, {
          ignoreDuplicateRegistrations: true,
      });
    }

  function __embind_register_std_string(rawType, name) {
      name = readLatin1String(name);
      var stdStringIsUTF8
      //process only std::string bindings with UTF8 support, in contrast to e.g. std::basic_string<unsigned char>
      = (name === "std::string");
  
      registerType(rawType, {
          name: name,
          'fromWireType': function(value) {
              var length = HEAPU32[value >> 2];
  
              var str;
              if (stdStringIsUTF8) {
                  //ensure null termination at one-past-end byte if not present yet
                  var endChar = HEAPU8[value + 4 + length];
                  var endCharSwap = 0;
                  if (endChar != 0) {
                      endCharSwap = endChar;
                      HEAPU8[value + 4 + length] = 0;
                  }
  
                  var decodeStartPtr = value + 4;
                  // Looping here to support possible embedded '0' bytes
                  for (var i = 0; i <= length; ++i) {
                      var currentBytePtr = value + 4 + i;
                      if (HEAPU8[currentBytePtr] == 0) {
                          var stringSegment = UTF8ToString(decodeStartPtr);
                          if (str === undefined) {
                              str = stringSegment;
                          } else {
                              str += String.fromCharCode(0);
                              str += stringSegment;
                          }
                          decodeStartPtr = currentBytePtr + 1;
                      }
                  }
  
                  if (endCharSwap != 0) {
                      HEAPU8[value + 4 + length] = endCharSwap;
                  }
              } else {
                  var a = new Array(length);
                  for (var i = 0; i < length; ++i) {
                      a[i] = String.fromCharCode(HEAPU8[value + 4 + i]);
                  }
                  str = a.join('');
              }
  
              _free(value);
  
              return str;
          },
          'toWireType': function(destructors, value) {
              if (value instanceof ArrayBuffer) {
                  value = new Uint8Array(value);
              }
  
              var getLength;
              var valueIsOfTypeString = (typeof value === 'string');
  
              if (!(valueIsOfTypeString || value instanceof Uint8Array || value instanceof Uint8ClampedArray || value instanceof Int8Array)) {
                  throwBindingError('Cannot pass non-string to std::string');
              }
              if (stdStringIsUTF8 && valueIsOfTypeString) {
                  getLength = function() {return lengthBytesUTF8(value);};
              } else {
                  getLength = function() {return value.length;};
              }
  
              // assumes 4-byte alignment
              var length = getLength();
              var ptr = _malloc(4 + length + 1);
              HEAPU32[ptr >> 2] = length;
              if (stdStringIsUTF8 && valueIsOfTypeString) {
                  stringToUTF8(value, ptr + 4, length + 1);
              } else {
                  if (valueIsOfTypeString) {
                      for (var i = 0; i < length; ++i) {
                          var charCode = value.charCodeAt(i);
                          if (charCode > 255) {
                              _free(ptr);
                              throwBindingError('String has UTF-16 code units that do not fit in 8 bits');
                          }
                          HEAPU8[ptr + 4 + i] = charCode;
                      }
                  } else {
                      for (var i = 0; i < length; ++i) {
                          HEAPU8[ptr + 4 + i] = value[i];
                      }
                  }
              }
  
              if (destructors !== null) {
                  destructors.push(_free, ptr);
              }
              return ptr;
          },
          'argPackAdvance': 8,
          'readValueFromPointer': simpleReadValueFromPointer,
          destructorFunction: function(ptr) { _free(ptr); },
      });
    }

  function __embind_register_std_wstring(rawType, charSize, name) {
      name = readLatin1String(name);
      var decodeString, encodeString, getHeap, lengthBytesUTF, shift;
      if (charSize === 2) {
          decodeString = UTF16ToString;
          encodeString = stringToUTF16;
          lengthBytesUTF = lengthBytesUTF16;
          getHeap = function() { return HEAPU16; };
          shift = 1;
      } else if (charSize === 4) {
          decodeString = UTF32ToString;
          encodeString = stringToUTF32;
          lengthBytesUTF = lengthBytesUTF32;
          getHeap = function() { return HEAPU32; };
          shift = 2;
      }
      registerType(rawType, {
          name: name,
          'fromWireType': function(value) {
              // Code mostly taken from _embind_register_std_string fromWireType
              var length = HEAPU32[value >> 2];
              var HEAP = getHeap();
              var str;
              // Ensure null termination at one-past-end byte if not present yet
              var endChar = HEAP[(value + 4 + length * charSize) >> shift];
              var endCharSwap = 0;
              if (endChar != 0) {
                  endCharSwap = endChar;
                  HEAP[(value + 4 + length * charSize) >> shift] = 0;
              }
  
              var decodeStartPtr = value + 4;
              // Looping here to support possible embedded '0' bytes
              for (var i = 0; i <= length; ++i) {
                  var currentBytePtr = value + 4 + i * charSize;
                  if (HEAP[currentBytePtr >> shift] == 0) {
                      var stringSegment = decodeString(decodeStartPtr);
                      if (str === undefined) {
                          str = stringSegment;
                      } else {
                          str += String.fromCharCode(0);
                          str += stringSegment;
                      }
                      decodeStartPtr = currentBytePtr + charSize;
                  }
              }
  
              if (endCharSwap != 0) {
                  HEAP[(value + 4 + length * charSize) >> shift] = endCharSwap;
              }
  
              _free(value);
  
              return str;
          },
          'toWireType': function(destructors, value) {
              if (!(typeof value === 'string')) {
                  throwBindingError('Cannot pass non-string to C++ string type ' + name);
              }
  
              // assumes 4-byte alignment
              var length = lengthBytesUTF(value);
              var ptr = _malloc(4 + length + charSize);
              HEAPU32[ptr >> 2] = length >> shift;
  
              encodeString(value, ptr + 4, length + charSize);
  
              if (destructors !== null) {
                  destructors.push(_free, ptr);
              }
              return ptr;
          },
          'argPackAdvance': 8,
          'readValueFromPointer': simpleReadValueFromPointer,
          destructorFunction: function(ptr) { _free(ptr); },
      });
    }

  function __embind_register_void(rawType, name) {
      name = readLatin1String(name);
      registerType(rawType, {
          isVoid: true, // void return values can be optimized out sometimes
          name: name,
          'argPackAdvance': 0,
          'fromWireType': function() {
              return undefined;
          },
          'toWireType': function(destructors, o) {
              // TODO: assert if anything else is given?
              return undefined;
          },
      });
    }


  function __emval_incref(handle) {
      if (handle > 4) {
          emval_handle_array[handle].refcount += 1;
      }
    }

  
  
  var emval_symbols={};function getStringOrSymbol(address) {
      var symbol = emval_symbols[address];
      if (symbol === undefined) {
          return readLatin1String(address);
      } else {
          return symbol;
      }
    }function __emval_new_cstring(v) {
      return __emval_register(getStringOrSymbol(v));
    }

  function __emval_new_object() {
      return __emval_register({});
    }

  
  function requireHandle(handle) {
      if (!handle) {
          throwBindingError('Cannot use deleted val. handle = ' + handle);
      }
      return emval_handle_array[handle].value;
    }function __emval_set_property(handle, key, value) {
      handle = requireHandle(handle);
      key = requireHandle(key);
      value = requireHandle(value);
      handle[key] = value;
    }

  
  function requireRegisteredType(rawType, humanName) {
      var impl = registeredTypes[rawType];
      if (undefined === impl) {
          throwBindingError(humanName + " has unknown type " + getTypeName(rawType));
      }
      return impl;
    }function __emval_take_value(type, argv) {
      type = requireRegisteredType(type, '_emval_take_value');
      var v = type['readValueFromPointer'](argv);
      return __emval_register(v);
    }

  function _abort() {
      abort();
    }

  function _emscripten_get_sbrk_ptr() {
      return 70608;
    }

  function _emscripten_memcpy_big(dest, src, num) {
      HEAPU8.copyWithin(dest, src, src + num);
    }

  
  function _emscripten_get_heap_size() {
      return HEAPU8.length;
    }
  
  var _emscripten_get_now;if (ENVIRONMENT_IS_NODE) {
    _emscripten_get_now = function() {
      var t = process['hrtime']();
      return t[0] * 1e3 + t[1] / 1e6;
    };
  } else if (typeof dateNow !== 'undefined') {
    _emscripten_get_now = dateNow;
  } else _emscripten_get_now = function() { return performance.now(); }
  ;
  
  function emscripten_realloc_buffer(size) {
      try {
        // round size grow request up to wasm page size (fixed 64KB per spec)
        wasmMemory.grow((size - buffer.byteLength + 65535) >>> 16); // .grow() takes a delta compared to the previous size
        updateGlobalBufferAndViews(wasmMemory.buffer);
        return 1 /*success*/;
      } catch(e) {
        console.error('emscripten_realloc_buffer: Attempted to grow heap from ' + buffer.byteLength  + ' bytes to ' + size + ' bytes, but got error: ' + e);
      }
    }function _emscripten_resize_heap(requestedSize) {
      requestedSize = requestedSize >>> 0;
      var oldSize = _emscripten_get_heap_size();
      // With pthreads, races can happen (another thread might increase the size in between), so return a failure, and let the caller retry.
      assert(requestedSize > oldSize);
  
  
      var PAGE_MULTIPLE = 65536;
  
      // Memory resize rules:
      // 1. When resizing, always produce a resized heap that is at least 16MB (to avoid tiny heap sizes receiving lots of repeated resizes at startup)
      // 2. Always increase heap size to at least the requested size, rounded up to next page multiple.
      // 3a. If MEMORY_GROWTH_LINEAR_STEP == -1, excessively resize the heap geometrically: increase the heap size according to 
      //                                         MEMORY_GROWTH_GEOMETRIC_STEP factor (default +20%),
      //                                         At most overreserve by MEMORY_GROWTH_GEOMETRIC_CAP bytes (default 96MB).
      // 3b. If MEMORY_GROWTH_LINEAR_STEP != -1, excessively resize the heap linearly: increase the heap size by at least MEMORY_GROWTH_LINEAR_STEP bytes.
      // 4. Max size for the heap is capped at 2048MB-PAGE_MULTIPLE, or by MAXIMUM_MEMORY, or by ASAN limit, depending on which is smallest
      // 5. If we were unable to allocate as much memory, it may be due to over-eager decision to excessively reserve due to (3) above.
      //    Hence if an allocation fails, cut down on the amount of excess growth, in an attempt to succeed to perform a smaller allocation.
  
      // A limit was set for how much we can grow. We should not exceed that
      // (the wasm binary specifies it, so if we tried, we'd fail anyhow).
      var maxHeapSize = 2147483648;
      if (requestedSize > maxHeapSize) {
        err('Cannot enlarge memory, asked to go up to ' + requestedSize + ' bytes, but the limit is ' + maxHeapSize + ' bytes!');
        return false;
      }
  
      var minHeapSize = 16777216;
  
      // Loop through potential heap size increases. If we attempt a too eager reservation that fails, cut down on the
      // attempted size and reserve a smaller bump instead. (max 3 times, chosen somewhat arbitrarily)
      for(var cutDown = 1; cutDown <= 4; cutDown *= 2) {
        var overGrownHeapSize = oldSize * (1 + 0.2 / cutDown); // ensure geometric growth
        // but limit overreserving (default to capping at +96MB overgrowth at most)
        overGrownHeapSize = Math.min(overGrownHeapSize, requestedSize + 100663296 );
  
  
        var newSize = Math.min(maxHeapSize, alignUp(Math.max(minHeapSize, requestedSize, overGrownHeapSize), PAGE_MULTIPLE));
  
        var t0 = _emscripten_get_now();
        var replacement = emscripten_realloc_buffer(newSize);
        var t1 = _emscripten_get_now();
        console.log('Heap resize call from ' + oldSize + ' to ' + newSize + ' took ' + (t1 - t0) + ' msecs. Success: ' + !!replacement);
        if (replacement) {
  
          return true;
        }
      }
      err('Failed to grow the heap from ' + oldSize + ' bytes to ' + newSize + ' bytes, not enough memory!');
      return false;
    }

  function _exit(status) {
      // void _exit(int status);
      // http://pubs.opengroup.org/onlinepubs/000095399/functions/exit.html
      exit(status);
    }

  function _fd_close(fd) {try {
  
      var stream = SYSCALLS.getStreamFromFD(fd);
      FS.close(stream);
      return 0;
    } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return e.errno;
  }
  }

  function _fd_fdstat_get(fd, pbuf) {try {
  
      var stream = SYSCALLS.getStreamFromFD(fd);
      // All character devices are terminals (other things a Linux system would
      // assume is a character device, like the mouse, we have special APIs for).
      var type = stream.tty ? 2 :
                 FS.isDir(stream.mode) ? 3 :
                 FS.isLink(stream.mode) ? 7 :
                 4;
      HEAP8[((pbuf)>>0)]=type;
      // TODO HEAP16[(((pbuf)+(2))>>1)]=?;
      // TODO (tempI64 = [?>>>0,(tempDouble=?,(+(Math_abs(tempDouble))) >= 1.0 ? (tempDouble > 0.0 ? ((Math_min((+(Math_floor((tempDouble)/4294967296.0))), 4294967295.0))|0)>>>0 : (~~((+(Math_ceil((tempDouble - +(((~~(tempDouble)))>>>0))/4294967296.0)))))>>>0) : 0)],HEAP32[(((pbuf)+(8))>>2)]=tempI64[0],HEAP32[(((pbuf)+(12))>>2)]=tempI64[1]);
      // TODO (tempI64 = [?>>>0,(tempDouble=?,(+(Math_abs(tempDouble))) >= 1.0 ? (tempDouble > 0.0 ? ((Math_min((+(Math_floor((tempDouble)/4294967296.0))), 4294967295.0))|0)>>>0 : (~~((+(Math_ceil((tempDouble - +(((~~(tempDouble)))>>>0))/4294967296.0)))))>>>0) : 0)],HEAP32[(((pbuf)+(16))>>2)]=tempI64[0],HEAP32[(((pbuf)+(20))>>2)]=tempI64[1]);
      return 0;
    } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return e.errno;
  }
  }

  function _fd_seek(fd, offset_low, offset_high, whence, newOffset) {try {
  
      
      var stream = SYSCALLS.getStreamFromFD(fd);
      var HIGH_OFFSET = 0x100000000; // 2^32
      // use an unsigned operator on low and shift high by 32-bits
      var offset = offset_high * HIGH_OFFSET + (offset_low >>> 0);
  
      var DOUBLE_LIMIT = 0x20000000000000; // 2^53
      // we also check for equality since DOUBLE_LIMIT + 1 == DOUBLE_LIMIT
      if (offset <= -DOUBLE_LIMIT || offset >= DOUBLE_LIMIT) {
        return -61;
      }
  
      FS.llseek(stream, offset, whence);
      (tempI64 = [stream.position>>>0,(tempDouble=stream.position,(+(Math_abs(tempDouble))) >= 1.0 ? (tempDouble > 0.0 ? ((Math_min((+(Math_floor((tempDouble)/4294967296.0))), 4294967295.0))|0)>>>0 : (~~((+(Math_ceil((tempDouble - +(((~~(tempDouble)))>>>0))/4294967296.0)))))>>>0) : 0)],HEAP32[((newOffset)>>2)]=tempI64[0],HEAP32[(((newOffset)+(4))>>2)]=tempI64[1]);
      if (stream.getdents && offset === 0 && whence === 0) stream.getdents = null; // reset readdir state
      return 0;
    } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return e.errno;
  }
  }

  function _fd_write(fd, iov, iovcnt, pnum) {try {
  
      var stream = SYSCALLS.getStreamFromFD(fd);
      var num = SYSCALLS.doWritev(stream, iov, iovcnt);
      HEAP32[((pnum)>>2)]=num
      return 0;
    } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return e.errno;
  }
  }

  function _raise(sig) {
      err('Calling stub instead of raise()');
    setErrNo(ERRNO_CODES.ENOSYS);
      warnOnce('raise() returning an error as we do not support it');
      return -1;
    }

  function _setTempRet0($i) {
      setTempRet0(($i) | 0);
    }
var FSNode = /** @constructor */ function(parent, name, mode, rdev) {
    if (!parent) {
      parent = this;  // root node sets parent to itself
    }
    this.parent = parent;
    this.mount = parent.mount;
    this.mounted = null;
    this.id = FS.nextInode++;
    this.name = name;
    this.mode = mode;
    this.node_ops = {};
    this.stream_ops = {};
    this.rdev = rdev;
  };
  var readMode = 292/*292*/ | 73/*73*/;
  var writeMode = 146/*146*/;
  Object.defineProperties(FSNode.prototype, {
   read: {
    get: /** @this{FSNode} */function() {
     return (this.mode & readMode) === readMode;
    },
    set: /** @this{FSNode} */function(val) {
     val ? this.mode |= readMode : this.mode &= ~readMode;
    }
   },
   write: {
    get: /** @this{FSNode} */function() {
     return (this.mode & writeMode) === writeMode;
    },
    set: /** @this{FSNode} */function(val) {
     val ? this.mode |= writeMode : this.mode &= ~writeMode;
    }
   },
   isFolder: {
    get: /** @this{FSNode} */function() {
     return FS.isDir(this.mode);
    }
   },
   isDevice: {
    get: /** @this{FSNode} */function() {
     return FS.isChrdev(this.mode);
    }
   }
  });
  FS.FSNode = FSNode;
  FS.staticInit();;
if (ENVIRONMENT_IS_NODE) { var fs = require("fs"); var NODEJS_PATH = require("path"); NODEFS.staticInit(); };
embind_init_charCodes();
BindingError = Module['BindingError'] = extendError(Error, 'BindingError');;
InternalError = Module['InternalError'] = extendError(Error, 'InternalError');;
init_ClassHandle();
init_RegisteredPointer();
init_embind();;
UnboundTypeError = Module['UnboundTypeError'] = extendError(Error, 'UnboundTypeError');;
init_emval();;
var ASSERTIONS = true;

/**
 * @license
 * Copyright 2017 The Emscripten Authors
 * SPDX-License-Identifier: MIT
 */

/** @type {function(string, boolean=, number=)} */
function intArrayFromString(stringy, dontAddNull, length) {
  var len = length > 0 ? length : lengthBytesUTF8(stringy)+1;
  var u8array = new Array(len);
  var numBytesWritten = stringToUTF8Array(stringy, u8array, 0, u8array.length);
  if (dontAddNull) u8array.length = numBytesWritten;
  return u8array;
}

function intArrayToString(array) {
  var ret = [];
  for (var i = 0; i < array.length; i++) {
    var chr = array[i];
    if (chr > 0xFF) {
      if (ASSERTIONS) {
        assert(false, 'Character code ' + chr + ' (' + String.fromCharCode(chr) + ')  at offset ' + i + ' not in 0x00-0xFF.');
      }
      chr &= 0xFF;
    }
    ret.push(String.fromCharCode(chr));
  }
  return ret.join('');
}


// Copied from https://github.com/strophe/strophejs/blob/e06d027/src/polyfills.js#L149

// This code was written by Tyler Akins and has been placed in the
// public domain.  It would be nice if you left this header intact.
// Base64 code from Tyler Akins -- http://rumkin.com

/**
 * Decodes a base64 string.
 * @param {string} input The string to decode.
 */
var decodeBase64 = typeof atob === 'function' ? atob : function (input) {
  var keyStr = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';

  var output = '';
  var chr1, chr2, chr3;
  var enc1, enc2, enc3, enc4;
  var i = 0;
  // remove all characters that are not A-Z, a-z, 0-9, +, /, or =
  input = input.replace(/[^A-Za-z0-9\+\/\=]/g, '');
  do {
    enc1 = keyStr.indexOf(input.charAt(i++));
    enc2 = keyStr.indexOf(input.charAt(i++));
    enc3 = keyStr.indexOf(input.charAt(i++));
    enc4 = keyStr.indexOf(input.charAt(i++));

    chr1 = (enc1 << 2) | (enc2 >> 4);
    chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);
    chr3 = ((enc3 & 3) << 6) | enc4;

    output = output + String.fromCharCode(chr1);

    if (enc3 !== 64) {
      output = output + String.fromCharCode(chr2);
    }
    if (enc4 !== 64) {
      output = output + String.fromCharCode(chr3);
    }
  } while (i < input.length);
  return output;
};

// Converts a string of base64 into a byte array.
// Throws error on invalid input.
function intArrayFromBase64(s) {
  if (typeof ENVIRONMENT_IS_NODE === 'boolean' && ENVIRONMENT_IS_NODE) {
    var buf;
    try {
      // TODO: Update Node.js externs, Closure does not recognize the following Buffer.from()
      /**@suppress{checkTypes}*/
      buf = Buffer.from(s, 'base64');
    } catch (_) {
      buf = new Buffer(s, 'base64');
    }
    return new Uint8Array(buf['buffer'], buf['byteOffset'], buf['byteLength']);
  }

  try {
    var decoded = decodeBase64(s);
    var bytes = new Uint8Array(decoded.length);
    for (var i = 0 ; i < decoded.length ; ++i) {
      bytes[i] = decoded.charCodeAt(i);
    }
    return bytes;
  } catch (_) {
    throw new Error('Converting base64 string to bytes failed.');
  }
}

// If filename is a base64 data URI, parses and returns data (Buffer on node,
// Uint8Array otherwise). If filename is not a base64 data URI, returns undefined.
function tryParseAsDataURI(filename) {
  if (!isDataURI(filename)) {
    return;
  }

  return intArrayFromBase64(filename.slice(dataURIPrefix.length));
}


var asmGlobalArg = {};
var asmLibraryArg = { "__handle_stack_overflow": ___handle_stack_overflow, "__sys_fstat64": ___sys_fstat64, "__sys_ftruncate64": ___sys_ftruncate64, "__sys_mmap2": ___sys_mmap2, "__sys_munmap": ___sys_munmap, "__sys_open": ___sys_open, "__sys_read": ___sys_read, "__sys_stat64": ___sys_stat64, "_embind_register_bool": __embind_register_bool, "_embind_register_class": __embind_register_class, "_embind_register_class_constructor": __embind_register_class_constructor, "_embind_register_class_function": __embind_register_class_function, "_embind_register_class_property": __embind_register_class_property, "_embind_register_constant": __embind_register_constant, "_embind_register_emval": __embind_register_emval, "_embind_register_float": __embind_register_float, "_embind_register_function": __embind_register_function, "_embind_register_integer": __embind_register_integer, "_embind_register_memory_view": __embind_register_memory_view, "_embind_register_std_string": __embind_register_std_string, "_embind_register_std_wstring": __embind_register_std_wstring, "_embind_register_void": __embind_register_void, "_emval_decref": __emval_decref, "_emval_incref": __emval_incref, "_emval_new_cstring": __emval_new_cstring, "_emval_new_object": __emval_new_object, "_emval_set_property": __emval_set_property, "_emval_take_value": __emval_take_value, "abort": _abort, "emscripten_get_sbrk_ptr": _emscripten_get_sbrk_ptr, "emscripten_memcpy_big": _emscripten_memcpy_big, "emscripten_resize_heap": _emscripten_resize_heap, "exit": _exit, "fd_close": _fd_close, "fd_fdstat_get": _fd_fdstat_get, "fd_seek": _fd_seek, "fd_write": _fd_write, "memory": wasmMemory, "raise": _raise, "setTempRet0": _setTempRet0, "table": wasmTable };
var asm = createWasm();
Module["asm"] = asm;
/** @type {function(...*):?} */
var ___wasm_call_ctors = Module["___wasm_call_ctors"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__wasm_call_ctors"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _malloc = Module["_malloc"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["malloc"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _free = Module["_free"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["free"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _memset = Module["_memset"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["memset"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___errno_location = Module["___errno_location"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__errno_location"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _fflush = Module["_fflush"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["fflush"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___cxa_demangle = Module["___cxa_demangle"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__cxa_demangle"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___getTypeName = Module["___getTypeName"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__getTypeName"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___embind_register_native_and_builtin_types = Module["___embind_register_native_and_builtin_types"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__embind_register_native_and_builtin_types"].apply(null, arguments)
};

/** @type {function(...*):?} */
var _memalign = Module["_memalign"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["memalign"].apply(null, arguments)
};

/** @type {function(...*):?} */
var ___set_stack_limit = Module["___set_stack_limit"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__set_stack_limit"].apply(null, arguments)
};

/** @type {function(...*):?} */
var stackSave = Module["stackSave"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["stackSave"].apply(null, arguments)
};

/** @type {function(...*):?} */
var stackAlloc = Module["stackAlloc"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["stackAlloc"].apply(null, arguments)
};

/** @type {function(...*):?} */
var stackRestore = Module["stackRestore"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["stackRestore"].apply(null, arguments)
};

/** @type {function(...*):?} */
var __growWasmMemory = Module["__growWasmMemory"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["__growWasmMemory"].apply(null, arguments)
};

/** @type {function(...*):?} */
var dynCall_ii = Module["dynCall_ii"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["dynCall_ii"].apply(null, arguments)
};

/** @type {function(...*):?} */
var dynCall_iiii = Module["dynCall_iiii"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["dynCall_iiii"].apply(null, arguments)
};

/** @type {function(...*):?} */
var dynCall_iii = Module["dynCall_iii"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["dynCall_iii"].apply(null, arguments)
};

/** @type {function(...*):?} */
var dynCall_i = Module["dynCall_i"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["dynCall_i"].apply(null, arguments)
};

/** @type {function(...*):?} */
var dynCall_vi = Module["dynCall_vi"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["dynCall_vi"].apply(null, arguments)
};

/** @type {function(...*):?} */
var dynCall_iiiii = Module["dynCall_iiiii"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["dynCall_iiiii"].apply(null, arguments)
};

/** @type {function(...*):?} */
var dynCall_iiiiii = Module["dynCall_iiiiii"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["dynCall_iiiiii"].apply(null, arguments)
};

/** @type {function(...*):?} */
var dynCall_iiiiiii = Module["dynCall_iiiiiii"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["dynCall_iiiiiii"].apply(null, arguments)
};

/** @type {function(...*):?} */
var dynCall_iij = Module["dynCall_iij"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["dynCall_iij"].apply(null, arguments)
};

/** @type {function(...*):?} */
var dynCall_iijjiii = Module["dynCall_iijjiii"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["dynCall_iijjiii"].apply(null, arguments)
};

/** @type {function(...*):?} */
var dynCall_vii = Module["dynCall_vii"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["dynCall_vii"].apply(null, arguments)
};

/** @type {function(...*):?} */
var dynCall_viii = Module["dynCall_viii"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["dynCall_viii"].apply(null, arguments)
};

/** @type {function(...*):?} */
var dynCall_viiiiii = Module["dynCall_viiiiii"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["dynCall_viiiiii"].apply(null, arguments)
};

/** @type {function(...*):?} */
var dynCall_iijj = Module["dynCall_iijj"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["dynCall_iijj"].apply(null, arguments)
};

/** @type {function(...*):?} */
var dynCall_jiji = Module["dynCall_jiji"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["dynCall_jiji"].apply(null, arguments)
};

/** @type {function(...*):?} */
var dynCall_iidiiii = Module["dynCall_iidiiii"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["dynCall_iidiiii"].apply(null, arguments)
};

/** @type {function(...*):?} */
var dynCall_v = Module["dynCall_v"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["dynCall_v"].apply(null, arguments)
};

/** @type {function(...*):?} */
var dynCall_viiiii = Module["dynCall_viiiii"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["dynCall_viiiii"].apply(null, arguments)
};

/** @type {function(...*):?} */
var dynCall_viiii = Module["dynCall_viiii"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["dynCall_viiii"].apply(null, arguments)
};



/**
 * @license
 * Copyright 2010 The Emscripten Authors
 * SPDX-License-Identifier: MIT
 */

// === Auto-generated postamble setup entry stuff ===

Module['asm'] = asm;

if (!Object.getOwnPropertyDescriptor(Module, "intArrayFromString")) Module["intArrayFromString"] = function() { abort("'intArrayFromString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "intArrayToString")) Module["intArrayToString"] = function() { abort("'intArrayToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "ccall")) Module["ccall"] = function() { abort("'ccall' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "cwrap")) Module["cwrap"] = function() { abort("'cwrap' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "setValue")) Module["setValue"] = function() { abort("'setValue' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "getValue")) Module["getValue"] = function() { abort("'getValue' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "allocate")) Module["allocate"] = function() { abort("'allocate' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "getMemory")) Module["getMemory"] = function() { abort("'getMemory' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you") };
if (!Object.getOwnPropertyDescriptor(Module, "UTF8ArrayToString")) Module["UTF8ArrayToString"] = function() { abort("'UTF8ArrayToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "UTF8ToString")) Module["UTF8ToString"] = function() { abort("'UTF8ToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "stringToUTF8Array")) Module["stringToUTF8Array"] = function() { abort("'stringToUTF8Array' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "stringToUTF8")) Module["stringToUTF8"] = function() { abort("'stringToUTF8' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "lengthBytesUTF8")) Module["lengthBytesUTF8"] = function() { abort("'lengthBytesUTF8' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "stackTrace")) Module["stackTrace"] = function() { abort("'stackTrace' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "addOnPreRun")) Module["addOnPreRun"] = function() { abort("'addOnPreRun' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "addOnInit")) Module["addOnInit"] = function() { abort("'addOnInit' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "addOnPreMain")) Module["addOnPreMain"] = function() { abort("'addOnPreMain' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "addOnExit")) Module["addOnExit"] = function() { abort("'addOnExit' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "addOnPostRun")) Module["addOnPostRun"] = function() { abort("'addOnPostRun' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "writeStringToMemory")) Module["writeStringToMemory"] = function() { abort("'writeStringToMemory' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "writeArrayToMemory")) Module["writeArrayToMemory"] = function() { abort("'writeArrayToMemory' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "writeAsciiToMemory")) Module["writeAsciiToMemory"] = function() { abort("'writeAsciiToMemory' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "addRunDependency")) Module["addRunDependency"] = function() { abort("'addRunDependency' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you") };
if (!Object.getOwnPropertyDescriptor(Module, "removeRunDependency")) Module["removeRunDependency"] = function() { abort("'removeRunDependency' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you") };
if (!Object.getOwnPropertyDescriptor(Module, "FS_createFolder")) Module["FS_createFolder"] = function() { abort("'FS_createFolder' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you") };
if (!Object.getOwnPropertyDescriptor(Module, "FS_createPath")) Module["FS_createPath"] = function() { abort("'FS_createPath' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you") };
if (!Object.getOwnPropertyDescriptor(Module, "FS_createDataFile")) Module["FS_createDataFile"] = function() { abort("'FS_createDataFile' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you") };
if (!Object.getOwnPropertyDescriptor(Module, "FS_createPreloadedFile")) Module["FS_createPreloadedFile"] = function() { abort("'FS_createPreloadedFile' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you") };
if (!Object.getOwnPropertyDescriptor(Module, "FS_createLazyFile")) Module["FS_createLazyFile"] = function() { abort("'FS_createLazyFile' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you") };
if (!Object.getOwnPropertyDescriptor(Module, "FS_createLink")) Module["FS_createLink"] = function() { abort("'FS_createLink' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you") };
if (!Object.getOwnPropertyDescriptor(Module, "FS_createDevice")) Module["FS_createDevice"] = function() { abort("'FS_createDevice' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you") };
if (!Object.getOwnPropertyDescriptor(Module, "FS_unlink")) Module["FS_unlink"] = function() { abort("'FS_unlink' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you") };
if (!Object.getOwnPropertyDescriptor(Module, "dynamicAlloc")) Module["dynamicAlloc"] = function() { abort("'dynamicAlloc' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "loadDynamicLibrary")) Module["loadDynamicLibrary"] = function() { abort("'loadDynamicLibrary' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "loadWebAssemblyModule")) Module["loadWebAssemblyModule"] = function() { abort("'loadWebAssemblyModule' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "getLEB")) Module["getLEB"] = function() { abort("'getLEB' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "getFunctionTables")) Module["getFunctionTables"] = function() { abort("'getFunctionTables' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "alignFunctionTables")) Module["alignFunctionTables"] = function() { abort("'alignFunctionTables' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "registerFunctions")) Module["registerFunctions"] = function() { abort("'registerFunctions' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "addFunction")) Module["addFunction"] = function() { abort("'addFunction' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "removeFunction")) Module["removeFunction"] = function() { abort("'removeFunction' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "getFuncWrapper")) Module["getFuncWrapper"] = function() { abort("'getFuncWrapper' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "prettyPrint")) Module["prettyPrint"] = function() { abort("'prettyPrint' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "makeBigInt")) Module["makeBigInt"] = function() { abort("'makeBigInt' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "dynCall")) Module["dynCall"] = function() { abort("'dynCall' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "getCompilerSetting")) Module["getCompilerSetting"] = function() { abort("'getCompilerSetting' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "print")) Module["print"] = function() { abort("'print' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "printErr")) Module["printErr"] = function() { abort("'printErr' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "getTempRet0")) Module["getTempRet0"] = function() { abort("'getTempRet0' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "setTempRet0")) Module["setTempRet0"] = function() { abort("'setTempRet0' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "callMain")) Module["callMain"] = function() { abort("'callMain' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "abort")) Module["abort"] = function() { abort("'abort' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "stringToNewUTF8")) Module["stringToNewUTF8"] = function() { abort("'stringToNewUTF8' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "emscripten_realloc_buffer")) Module["emscripten_realloc_buffer"] = function() { abort("'emscripten_realloc_buffer' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "ENV")) Module["ENV"] = function() { abort("'ENV' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "setjmpId")) Module["setjmpId"] = function() { abort("'setjmpId' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "ERRNO_CODES")) Module["ERRNO_CODES"] = function() { abort("'ERRNO_CODES' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "ERRNO_MESSAGES")) Module["ERRNO_MESSAGES"] = function() { abort("'ERRNO_MESSAGES' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "setErrNo")) Module["setErrNo"] = function() { abort("'setErrNo' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "DNS")) Module["DNS"] = function() { abort("'DNS' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "GAI_ERRNO_MESSAGES")) Module["GAI_ERRNO_MESSAGES"] = function() { abort("'GAI_ERRNO_MESSAGES' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "Protocols")) Module["Protocols"] = function() { abort("'Protocols' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "Sockets")) Module["Sockets"] = function() { abort("'Sockets' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "UNWIND_CACHE")) Module["UNWIND_CACHE"] = function() { abort("'UNWIND_CACHE' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "readAsmConstArgs")) Module["readAsmConstArgs"] = function() { abort("'readAsmConstArgs' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "jstoi_q")) Module["jstoi_q"] = function() { abort("'jstoi_q' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "jstoi_s")) Module["jstoi_s"] = function() { abort("'jstoi_s' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "reallyNegative")) Module["reallyNegative"] = function() { abort("'reallyNegative' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "formatString")) Module["formatString"] = function() { abort("'formatString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "PATH")) Module["PATH"] = function() { abort("'PATH' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "PATH_FS")) Module["PATH_FS"] = function() { abort("'PATH_FS' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "SYSCALLS")) Module["SYSCALLS"] = function() { abort("'SYSCALLS' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "syscallMmap2")) Module["syscallMmap2"] = function() { abort("'syscallMmap2' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "syscallMunmap")) Module["syscallMunmap"] = function() { abort("'syscallMunmap' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "JSEvents")) Module["JSEvents"] = function() { abort("'JSEvents' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "specialHTMLTargets")) Module["specialHTMLTargets"] = function() { abort("'specialHTMLTargets' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "demangle")) Module["demangle"] = function() { abort("'demangle' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "demangleAll")) Module["demangleAll"] = function() { abort("'demangleAll' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "jsStackTrace")) Module["jsStackTrace"] = function() { abort("'jsStackTrace' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "stackTrace")) Module["stackTrace"] = function() { abort("'stackTrace' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "getEnvStrings")) Module["getEnvStrings"] = function() { abort("'getEnvStrings' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "writeI53ToI64")) Module["writeI53ToI64"] = function() { abort("'writeI53ToI64' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "writeI53ToI64Clamped")) Module["writeI53ToI64Clamped"] = function() { abort("'writeI53ToI64Clamped' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "writeI53ToI64Signaling")) Module["writeI53ToI64Signaling"] = function() { abort("'writeI53ToI64Signaling' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "writeI53ToU64Clamped")) Module["writeI53ToU64Clamped"] = function() { abort("'writeI53ToU64Clamped' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "writeI53ToU64Signaling")) Module["writeI53ToU64Signaling"] = function() { abort("'writeI53ToU64Signaling' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "readI53FromI64")) Module["readI53FromI64"] = function() { abort("'readI53FromI64' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "readI53FromU64")) Module["readI53FromU64"] = function() { abort("'readI53FromU64' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "convertI32PairToI53")) Module["convertI32PairToI53"] = function() { abort("'convertI32PairToI53' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "convertU32PairToI53")) Module["convertU32PairToI53"] = function() { abort("'convertU32PairToI53' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "Browser")) Module["Browser"] = function() { abort("'Browser' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
Module["FS"] = FS;
if (!Object.getOwnPropertyDescriptor(Module, "MEMFS")) Module["MEMFS"] = function() { abort("'MEMFS' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "TTY")) Module["TTY"] = function() { abort("'TTY' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "PIPEFS")) Module["PIPEFS"] = function() { abort("'PIPEFS' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "SOCKFS")) Module["SOCKFS"] = function() { abort("'SOCKFS' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "GL")) Module["GL"] = function() { abort("'GL' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "emscriptenWebGLGet")) Module["emscriptenWebGLGet"] = function() { abort("'emscriptenWebGLGet' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "emscriptenWebGLGetTexPixelData")) Module["emscriptenWebGLGetTexPixelData"] = function() { abort("'emscriptenWebGLGetTexPixelData' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "emscriptenWebGLGetUniform")) Module["emscriptenWebGLGetUniform"] = function() { abort("'emscriptenWebGLGetUniform' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "emscriptenWebGLGetVertexAttrib")) Module["emscriptenWebGLGetVertexAttrib"] = function() { abort("'emscriptenWebGLGetVertexAttrib' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "AL")) Module["AL"] = function() { abort("'AL' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "SDL_unicode")) Module["SDL_unicode"] = function() { abort("'SDL_unicode' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "SDL_ttfContext")) Module["SDL_ttfContext"] = function() { abort("'SDL_ttfContext' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "SDL_audio")) Module["SDL_audio"] = function() { abort("'SDL_audio' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "SDL")) Module["SDL"] = function() { abort("'SDL' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "SDL_gfx")) Module["SDL_gfx"] = function() { abort("'SDL_gfx' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "GLUT")) Module["GLUT"] = function() { abort("'GLUT' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "EGL")) Module["EGL"] = function() { abort("'EGL' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "GLFW_Window")) Module["GLFW_Window"] = function() { abort("'GLFW_Window' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "GLFW")) Module["GLFW"] = function() { abort("'GLFW' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "GLEW")) Module["GLEW"] = function() { abort("'GLEW' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "IDBStore")) Module["IDBStore"] = function() { abort("'IDBStore' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "runAndAbortIfError")) Module["runAndAbortIfError"] = function() { abort("'runAndAbortIfError' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "emval_handle_array")) Module["emval_handle_array"] = function() { abort("'emval_handle_array' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "emval_free_list")) Module["emval_free_list"] = function() { abort("'emval_free_list' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "emval_symbols")) Module["emval_symbols"] = function() { abort("'emval_symbols' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "init_emval")) Module["init_emval"] = function() { abort("'init_emval' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "count_emval_handles")) Module["count_emval_handles"] = function() { abort("'count_emval_handles' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "get_first_emval")) Module["get_first_emval"] = function() { abort("'get_first_emval' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "getStringOrSymbol")) Module["getStringOrSymbol"] = function() { abort("'getStringOrSymbol' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "requireHandle")) Module["requireHandle"] = function() { abort("'requireHandle' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "emval_newers")) Module["emval_newers"] = function() { abort("'emval_newers' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "craftEmvalAllocator")) Module["craftEmvalAllocator"] = function() { abort("'craftEmvalAllocator' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "emval_get_global")) Module["emval_get_global"] = function() { abort("'emval_get_global' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "emval_methodCallers")) Module["emval_methodCallers"] = function() { abort("'emval_methodCallers' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "InternalError")) Module["InternalError"] = function() { abort("'InternalError' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "BindingError")) Module["BindingError"] = function() { abort("'BindingError' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "UnboundTypeError")) Module["UnboundTypeError"] = function() { abort("'UnboundTypeError' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "PureVirtualError")) Module["PureVirtualError"] = function() { abort("'PureVirtualError' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "init_embind")) Module["init_embind"] = function() { abort("'init_embind' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "throwInternalError")) Module["throwInternalError"] = function() { abort("'throwInternalError' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "throwBindingError")) Module["throwBindingError"] = function() { abort("'throwBindingError' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "throwUnboundTypeError")) Module["throwUnboundTypeError"] = function() { abort("'throwUnboundTypeError' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "ensureOverloadTable")) Module["ensureOverloadTable"] = function() { abort("'ensureOverloadTable' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "exposePublicSymbol")) Module["exposePublicSymbol"] = function() { abort("'exposePublicSymbol' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "replacePublicSymbol")) Module["replacePublicSymbol"] = function() { abort("'replacePublicSymbol' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "extendError")) Module["extendError"] = function() { abort("'extendError' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "createNamedFunction")) Module["createNamedFunction"] = function() { abort("'createNamedFunction' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "registeredInstances")) Module["registeredInstances"] = function() { abort("'registeredInstances' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "getBasestPointer")) Module["getBasestPointer"] = function() { abort("'getBasestPointer' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "registerInheritedInstance")) Module["registerInheritedInstance"] = function() { abort("'registerInheritedInstance' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "unregisterInheritedInstance")) Module["unregisterInheritedInstance"] = function() { abort("'unregisterInheritedInstance' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "getInheritedInstance")) Module["getInheritedInstance"] = function() { abort("'getInheritedInstance' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "getInheritedInstanceCount")) Module["getInheritedInstanceCount"] = function() { abort("'getInheritedInstanceCount' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "getLiveInheritedInstances")) Module["getLiveInheritedInstances"] = function() { abort("'getLiveInheritedInstances' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "registeredTypes")) Module["registeredTypes"] = function() { abort("'registeredTypes' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "awaitingDependencies")) Module["awaitingDependencies"] = function() { abort("'awaitingDependencies' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "typeDependencies")) Module["typeDependencies"] = function() { abort("'typeDependencies' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "registeredPointers")) Module["registeredPointers"] = function() { abort("'registeredPointers' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "registerType")) Module["registerType"] = function() { abort("'registerType' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "whenDependentTypesAreResolved")) Module["whenDependentTypesAreResolved"] = function() { abort("'whenDependentTypesAreResolved' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "embind_charCodes")) Module["embind_charCodes"] = function() { abort("'embind_charCodes' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "embind_init_charCodes")) Module["embind_init_charCodes"] = function() { abort("'embind_init_charCodes' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "readLatin1String")) Module["readLatin1String"] = function() { abort("'readLatin1String' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "getTypeName")) Module["getTypeName"] = function() { abort("'getTypeName' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "heap32VectorToArray")) Module["heap32VectorToArray"] = function() { abort("'heap32VectorToArray' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "requireRegisteredType")) Module["requireRegisteredType"] = function() { abort("'requireRegisteredType' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "getShiftFromSize")) Module["getShiftFromSize"] = function() { abort("'getShiftFromSize' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "integerReadValueFromPointer")) Module["integerReadValueFromPointer"] = function() { abort("'integerReadValueFromPointer' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "enumReadValueFromPointer")) Module["enumReadValueFromPointer"] = function() { abort("'enumReadValueFromPointer' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "floatReadValueFromPointer")) Module["floatReadValueFromPointer"] = function() { abort("'floatReadValueFromPointer' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "simpleReadValueFromPointer")) Module["simpleReadValueFromPointer"] = function() { abort("'simpleReadValueFromPointer' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "runDestructors")) Module["runDestructors"] = function() { abort("'runDestructors' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "new_")) Module["new_"] = function() { abort("'new_' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "craftInvokerFunction")) Module["craftInvokerFunction"] = function() { abort("'craftInvokerFunction' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "embind__requireFunction")) Module["embind__requireFunction"] = function() { abort("'embind__requireFunction' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "tupleRegistrations")) Module["tupleRegistrations"] = function() { abort("'tupleRegistrations' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "structRegistrations")) Module["structRegistrations"] = function() { abort("'structRegistrations' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "genericPointerToWireType")) Module["genericPointerToWireType"] = function() { abort("'genericPointerToWireType' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "constNoSmartPtrRawPointerToWireType")) Module["constNoSmartPtrRawPointerToWireType"] = function() { abort("'constNoSmartPtrRawPointerToWireType' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "nonConstNoSmartPtrRawPointerToWireType")) Module["nonConstNoSmartPtrRawPointerToWireType"] = function() { abort("'nonConstNoSmartPtrRawPointerToWireType' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "init_RegisteredPointer")) Module["init_RegisteredPointer"] = function() { abort("'init_RegisteredPointer' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "RegisteredPointer")) Module["RegisteredPointer"] = function() { abort("'RegisteredPointer' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "RegisteredPointer_getPointee")) Module["RegisteredPointer_getPointee"] = function() { abort("'RegisteredPointer_getPointee' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "RegisteredPointer_destructor")) Module["RegisteredPointer_destructor"] = function() { abort("'RegisteredPointer_destructor' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "RegisteredPointer_deleteObject")) Module["RegisteredPointer_deleteObject"] = function() { abort("'RegisteredPointer_deleteObject' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "RegisteredPointer_fromWireType")) Module["RegisteredPointer_fromWireType"] = function() { abort("'RegisteredPointer_fromWireType' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "runDestructor")) Module["runDestructor"] = function() { abort("'runDestructor' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "releaseClassHandle")) Module["releaseClassHandle"] = function() { abort("'releaseClassHandle' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "finalizationGroup")) Module["finalizationGroup"] = function() { abort("'finalizationGroup' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "detachFinalizer_deps")) Module["detachFinalizer_deps"] = function() { abort("'detachFinalizer_deps' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "detachFinalizer")) Module["detachFinalizer"] = function() { abort("'detachFinalizer' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "attachFinalizer")) Module["attachFinalizer"] = function() { abort("'attachFinalizer' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "makeClassHandle")) Module["makeClassHandle"] = function() { abort("'makeClassHandle' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "init_ClassHandle")) Module["init_ClassHandle"] = function() { abort("'init_ClassHandle' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "ClassHandle")) Module["ClassHandle"] = function() { abort("'ClassHandle' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "ClassHandle_isAliasOf")) Module["ClassHandle_isAliasOf"] = function() { abort("'ClassHandle_isAliasOf' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "throwInstanceAlreadyDeleted")) Module["throwInstanceAlreadyDeleted"] = function() { abort("'throwInstanceAlreadyDeleted' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "ClassHandle_clone")) Module["ClassHandle_clone"] = function() { abort("'ClassHandle_clone' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "ClassHandle_delete")) Module["ClassHandle_delete"] = function() { abort("'ClassHandle_delete' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "deletionQueue")) Module["deletionQueue"] = function() { abort("'deletionQueue' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "ClassHandle_isDeleted")) Module["ClassHandle_isDeleted"] = function() { abort("'ClassHandle_isDeleted' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "ClassHandle_deleteLater")) Module["ClassHandle_deleteLater"] = function() { abort("'ClassHandle_deleteLater' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "flushPendingDeletes")) Module["flushPendingDeletes"] = function() { abort("'flushPendingDeletes' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "delayFunction")) Module["delayFunction"] = function() { abort("'delayFunction' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "setDelayFunction")) Module["setDelayFunction"] = function() { abort("'setDelayFunction' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "RegisteredClass")) Module["RegisteredClass"] = function() { abort("'RegisteredClass' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "shallowCopyInternalPointer")) Module["shallowCopyInternalPointer"] = function() { abort("'shallowCopyInternalPointer' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "downcastPointer")) Module["downcastPointer"] = function() { abort("'downcastPointer' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "upcastPointer")) Module["upcastPointer"] = function() { abort("'upcastPointer' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "validateThis")) Module["validateThis"] = function() { abort("'validateThis' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "char_0")) Module["char_0"] = function() { abort("'char_0' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "char_9")) Module["char_9"] = function() { abort("'char_9' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "makeLegalFunctionName")) Module["makeLegalFunctionName"] = function() { abort("'makeLegalFunctionName' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "NODEFS")) Module["NODEFS"] = function() { abort("'NODEFS' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "warnOnce")) Module["warnOnce"] = function() { abort("'warnOnce' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "stackSave")) Module["stackSave"] = function() { abort("'stackSave' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "stackRestore")) Module["stackRestore"] = function() { abort("'stackRestore' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "stackAlloc")) Module["stackAlloc"] = function() { abort("'stackAlloc' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "AsciiToString")) Module["AsciiToString"] = function() { abort("'AsciiToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "stringToAscii")) Module["stringToAscii"] = function() { abort("'stringToAscii' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "UTF16ToString")) Module["UTF16ToString"] = function() { abort("'UTF16ToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "stringToUTF16")) Module["stringToUTF16"] = function() { abort("'stringToUTF16' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "lengthBytesUTF16")) Module["lengthBytesUTF16"] = function() { abort("'lengthBytesUTF16' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "UTF32ToString")) Module["UTF32ToString"] = function() { abort("'UTF32ToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "stringToUTF32")) Module["stringToUTF32"] = function() { abort("'stringToUTF32' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "lengthBytesUTF32")) Module["lengthBytesUTF32"] = function() { abort("'lengthBytesUTF32' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "allocateUTF8")) Module["allocateUTF8"] = function() { abort("'allocateUTF8' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "allocateUTF8OnStack")) Module["allocateUTF8OnStack"] = function() { abort("'allocateUTF8OnStack' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
Module["writeStackCookie"] = writeStackCookie;
Module["checkStackCookie"] = checkStackCookie;
Module["abortStackOverflow"] = abortStackOverflow;
if (!Object.getOwnPropertyDescriptor(Module, "intArrayFromBase64")) Module["intArrayFromBase64"] = function() { abort("'intArrayFromBase64' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Object.getOwnPropertyDescriptor(Module, "tryParseAsDataURI")) Module["tryParseAsDataURI"] = function() { abort("'tryParseAsDataURI' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };if (!Object.getOwnPropertyDescriptor(Module, "ALLOC_NORMAL")) Object.defineProperty(Module, "ALLOC_NORMAL", { configurable: true, get: function() { abort("'ALLOC_NORMAL' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") } });
if (!Object.getOwnPropertyDescriptor(Module, "ALLOC_STACK")) Object.defineProperty(Module, "ALLOC_STACK", { configurable: true, get: function() { abort("'ALLOC_STACK' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") } });
if (!Object.getOwnPropertyDescriptor(Module, "ALLOC_DYNAMIC")) Object.defineProperty(Module, "ALLOC_DYNAMIC", { configurable: true, get: function() { abort("'ALLOC_DYNAMIC' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") } });
if (!Object.getOwnPropertyDescriptor(Module, "ALLOC_NONE")) Object.defineProperty(Module, "ALLOC_NONE", { configurable: true, get: function() { abort("'ALLOC_NONE' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") } });



var calledRun;

// Modularize mode returns a function, which can be called to
// create instances. The instances provide a then() method,
// must like a Promise, that receives a callback. The callback
// is called when the module is ready to run, with the module
// as a parameter. (Like a Promise, it also returns the module
// so you can use the output of .then(..)).
Module['then'] = function(func) {
  // We may already be ready to run code at this time. if
  // so, just queue a call to the callback.
  if (calledRun) {
    func(Module);
  } else {
    // we are not ready to call then() yet. we must call it
    // at the same time we would call onRuntimeInitialized.
    var old = Module['onRuntimeInitialized'];
    Module['onRuntimeInitialized'] = function() {
      if (old) old();
      func(Module);
    };
  }
  return Module;
};

/**
 * @constructor
 * @this {ExitStatus}
 */
function ExitStatus(status) {
  this.name = "ExitStatus";
  this.message = "Program terminated with exit(" + status + ")";
  this.status = status;
}

var calledMain = false;


dependenciesFulfilled = function runCaller() {
  // If run has never been called, and we should call run (INVOKE_RUN is true, and Module.noInitialRun is not false)
  if (!calledRun) run();
  if (!calledRun) dependenciesFulfilled = runCaller; // try this again later, after new deps are fulfilled
};





/** @type {function(Array=)} */
function run(args) {
  args = args || arguments_;

  if (runDependencies > 0) {
    return;
  }

  writeStackCookie();

  preRun();

  if (runDependencies > 0) return; // a preRun added a dependency, run will be called later

  function doRun() {
    // run may have just been called through dependencies being fulfilled just in this very frame,
    // or while the async setStatus time below was happening
    if (calledRun) return;
    calledRun = true;
    Module['calledRun'] = true;

    if (ABORT) return;

    initRuntime();

    preMain();

    if (Module['onRuntimeInitialized']) Module['onRuntimeInitialized']();

    assert(!Module['_main'], 'compiled without a main, but one is present. if you added it from JS, use Module["onRuntimeInitialized"]');

    postRun();
  }

  if (Module['setStatus']) {
    Module['setStatus']('Running...');
    setTimeout(function() {
      setTimeout(function() {
        Module['setStatus']('');
      }, 1);
      doRun();
    }, 1);
  } else
  {
    doRun();
  }
  checkStackCookie();
}
Module['run'] = run;

function checkUnflushedContent() {
  // Compiler settings do not allow exiting the runtime, so flushing
  // the streams is not possible. but in ASSERTIONS mode we check
  // if there was something to flush, and if so tell the user they
  // should request that the runtime be exitable.
  // Normally we would not even include flush() at all, but in ASSERTIONS
  // builds we do so just for this check, and here we see if there is any
  // content to flush, that is, we check if there would have been
  // something a non-ASSERTIONS build would have not seen.
  // How we flush the streams depends on whether we are in SYSCALLS_REQUIRE_FILESYSTEM=0
  // mode (which has its own special function for this; otherwise, all
  // the code is inside libc)
  var print = out;
  var printErr = err;
  var has = false;
  out = err = function(x) {
    has = true;
  }
  try { // it doesn't matter if it fails
    var flush = Module['_fflush'];
    if (flush) flush(0);
    // also flush in the JS FS layer
    ['stdout', 'stderr'].forEach(function(name) {
      var info = FS.analyzePath('/dev/' + name);
      if (!info) return;
      var stream = info.object;
      var rdev = stream.rdev;
      var tty = TTY.ttys[rdev];
      if (tty && tty.output && tty.output.length) {
        has = true;
      }
    });
  } catch(e) {}
  out = print;
  err = printErr;
  if (has) {
    warnOnce('stdio streams had content in them that was not flushed. you should set EXIT_RUNTIME to 1 (see the FAQ), or make sure to emit a newline when you printf etc.');
  }
}

/** @param {boolean|number=} implicit */
function exit(status, implicit) {
  checkUnflushedContent();

  // if this is just main exit-ing implicitly, and the status is 0, then we
  // don't need to do anything here and can just leave. if the status is
  // non-zero, though, then we need to report it.
  // (we may have warned about this earlier, if a situation justifies doing so)
  if (implicit && noExitRuntime && status === 0) {
    return;
  }

  if (noExitRuntime) {
    // if exit() was called, we may warn the user if the runtime isn't actually being shut down
    if (!implicit) {
      err('program exited (with status: ' + status + '), but EXIT_RUNTIME is not set, so halting execution but not exiting the runtime or preventing further async execution (build with EXIT_RUNTIME=1, if you want a true shutdown)');
    }
  } else {

    ABORT = true;
    EXITSTATUS = status;

    exitRuntime();

    if (Module['onExit']) Module['onExit'](status);
  }

  quit_(status, new ExitStatus(status));
}

if (Module['preInit']) {
  if (typeof Module['preInit'] == 'function') Module['preInit'] = [Module['preInit']];
  while (Module['preInit'].length > 0) {
    Module['preInit'].pop()();
  }
}


  noExitRuntime = true;

run();





// {{MODULE_ADDITIONS}}



function ___syscall140(which, varargs) {
  SYSCALLS.varargs = varargs;
  try {
    // llseek
    var stream = SYSCALLS.getStreamFromFD(), offset_high = SYSCALLS.get(), offset_low = SYSCALLS.get(), result = SYSCALLS.get(), whence = SYSCALLS.get();
    // NOTE: offset_high is unused - Emscripten's off_t is 32-bit

    // Ugly workaround for seeking >= 2 ** 31 bytes
    //
    // If whence is SEEK_SET, assume the value cannot be negative. This permits
    // SEEK_SET to seek to offsets >= 2 ** 31 and <= 2 ** 32.
    //
    // This workaround does *not* account for cases where offsets used with
    // SEEK_CUR or SEEK_END are >= 2 ** 31. Such cases will produce unexpected
    // behavior.
    var offset = whence === 0 ? offset_low >>> 0 : offset_low;

    FS.llseek(stream, offset, whence);
    HEAP32[((result)>>2)]=stream.position;
    if (stream.getdents && offset === 0 && whence === 0) stream.getdents = null; // reset readdir state
    return 0;
  } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
}



  return StormLib
}
);
})();
if (typeof exports === 'object' && typeof module === 'object')
      module.exports = StormLib;
    else if (typeof define === 'function' && define['amd'])
      define([], function() { return StormLib; });
    else if (typeof exports === 'object')
      exports["StormLib"] = StormLib;
    
}).call(this)}).call(this,require('_process'),require("buffer").Buffer,"/node_modules/@wowserhq/stormjs/dist/stormlib.debug.js",arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/@wowserhq/stormjs/dist")
},{"_process":159,"buffer":72,"crypto":80,"fs":70,"path":152}],7:[function(require,module,exports){
(function (process){(function (){
let StormLib;

if (process.env.NODE_ENV === 'production') {
  // eslint-disable-next-line import/no-unresolved
  StormLib = require('./stormlib.release.js');
} else {
  // eslint-disable-next-line import/no-unresolved
  StormLib = require('./stormlib.debug.js');
}

let resolveReady, rejectReady;
const ready = new Promise((resolve, reject) => {
  resolveReady = resolve;
  rejectReady = reject;
});
const library = StormLib({
  onRuntimeInitialized: function () {
    // Temporary workaround for emscripten pseudo-promise
    delete library.then; // Add NULLPTR constant

    library.NULLPTR = new library.Ptr();

    if (process.env.NODE_ENV !== 'production') {
      // eslint-disable-next-line no-console
      console.info('Initialized StormLib in debug mode');
    }

    resolveReady(library);
  }
});
library.ready = ready;
module.exports = library;
}).call(this)}).call(this,require('_process'))
},{"./stormlib.debug.js":6,"./stormlib.release.js":8,"_process":159}],8:[function(require,module,exports){
(function (process,Buffer,__filename,__argument0,__argument1,__argument2,__argument3,__dirname){(function (){

var StormLib = (function() {
  var _scriptDir = typeof document !== 'undefined' && document.currentScript ? document.currentScript.src : undefined;
  if (typeof __filename !== 'undefined') _scriptDir = _scriptDir || __filename;
  return (
function(StormLib) {
  StormLib = StormLib || {};

/**
 * @license
 * Copyright 2010 The Emscripten Authors
 * SPDX-License-Identifier: MIT
 */

// The Module object: Our interface to the outside world. We import
// and export values on it. There are various ways Module can be used:
// 1. Not defined. We create it here
// 2. A function parameter, function(Module) { ..generated code.. }
// 3. pre-run appended it, var Module = {}; ..generated code..
// 4. External script tag defines var Module.
// We need to check if Module already exists (e.g. case 3 above).
// Substitution will be replaced with actual code on later stage of the build,
// this way Closure Compiler will not mangle it (e.g. case 4. above).
// Note that if you want to run closure, and also to use Module
// after the generated code, you will need to define   var Module = {};
// before the code. Then that object will be used in the code, and you
// can continue to use Module afterwards as well.
var Module = typeof StormLib !== 'undefined' ? StormLib : {};

// --pre-jses are emitted after the Module integration code, so that they can
// refer to Module (if they choose; they can also define Module)


// Sometimes an existing Module object exists with properties
// meant to overwrite the default module functionality. Here
// we collect those properties and reapply _after_ we configure
// the current environment's defaults to avoid having to be so
// defensive during initialization.
var moduleOverrides = {};
var key;
for (key in Module) {
  if (Module.hasOwnProperty(key)) {
    moduleOverrides[key] = Module[key];
  }
}

var arguments_ = [];
var thisProgram = './this.program';
var quit_ = function(status, toThrow) {
  throw toThrow;
};

// Determine the runtime environment we are in. You can customize this by
// setting the ENVIRONMENT setting at compile time (see settings.js).

var ENVIRONMENT_IS_WEB = false;
var ENVIRONMENT_IS_WORKER = false;
var ENVIRONMENT_IS_NODE = false;
var ENVIRONMENT_IS_SHELL = false;
ENVIRONMENT_IS_WEB = typeof window === 'object';
ENVIRONMENT_IS_WORKER = typeof importScripts === 'function';
// N.b. Electron.js environment is simultaneously a NODE-environment, but
// also a web environment.
ENVIRONMENT_IS_NODE = typeof process === 'object' && typeof process.versions === 'object' && typeof process.versions.node === 'string';
ENVIRONMENT_IS_SHELL = !ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_NODE && !ENVIRONMENT_IS_WORKER;




// `/` should be present at the end if `scriptDirectory` is not empty
var scriptDirectory = '';
function locateFile(path) {
  if (Module['locateFile']) {
    return Module['locateFile'](path, scriptDirectory);
  }
  return scriptDirectory + path;
}

// Hooks that are implemented differently in different runtime environments.
var read_,
    readAsync,
    readBinary,
    setWindowTitle;

var nodeFS;
var nodePath;

if (ENVIRONMENT_IS_NODE) {
  if (ENVIRONMENT_IS_WORKER) {
    scriptDirectory = require('path').dirname(scriptDirectory) + '/';
  } else {
    scriptDirectory = __dirname + '/';
  }


/**
 * @license
 * Copyright 2019 The Emscripten Authors
 * SPDX-License-Identifier: MIT
 */

  read_ = function shell_read(filename, binary) {
    var ret = tryParseAsDataURI(filename);
    if (ret) {
      return binary ? ret : ret.toString();
    }
    if (!nodeFS) nodeFS = require('fs');
    if (!nodePath) nodePath = require('path');
    filename = nodePath['normalize'](filename);
    return nodeFS['readFileSync'](filename, binary ? null : 'utf8');
  };

  readBinary = function readBinary(filename) {
    var ret = read_(filename, true);
    if (!ret.buffer) {
      ret = new Uint8Array(ret);
    }
    assert(ret.buffer);
    return ret;
  };




  if (process['argv'].length > 1) {
    thisProgram = process['argv'][1].replace(/\\/g, '/');
  }

  arguments_ = process['argv'].slice(2);

  // MODULARIZE will export the module in the proper place outside, we don't need to export here

  process['on']('uncaughtException', function(ex) {
    // suppress ExitStatus exceptions from showing an error
    if (!(ex instanceof ExitStatus)) {
      throw ex;
    }
  });

  process['on']('unhandledRejection', abort);

  quit_ = function(status) {
    process['exit'](status);
  };

  Module['inspect'] = function () { return '[Emscripten Module object]'; };



} else
if (ENVIRONMENT_IS_SHELL) {


  if (typeof read != 'undefined') {
    read_ = function shell_read(f) {
      var data = tryParseAsDataURI(f);
      if (data) {
        return intArrayToString(data);
      }
      return read(f);
    };
  }

  readBinary = function readBinary(f) {
    var data;
    data = tryParseAsDataURI(f);
    if (data) {
      return data;
    }
    if (typeof readbuffer === 'function') {
      return new Uint8Array(readbuffer(f));
    }
    data = read(f, 'binary');
    assert(typeof data === 'object');
    return data;
  };

  if (typeof scriptArgs != 'undefined') {
    arguments_ = scriptArgs;
  } else if (typeof arguments != 'undefined') {
    arguments_ = arguments;
  }

  if (typeof quit === 'function') {
    quit_ = function(status) {
      quit(status);
    };
  }

  if (typeof print !== 'undefined') {
    // Prefer to use print/printErr where they exist, as they usually work better.
    if (typeof console === 'undefined') console = /** @type{!Console} */({});
    console.log = /** @type{!function(this:Console, ...*): undefined} */ (print);
    console.warn = console.error = /** @type{!function(this:Console, ...*): undefined} */ (typeof printErr !== 'undefined' ? printErr : print);
  }


} else

// Note that this includes Node.js workers when relevant (pthreads is enabled).
// Node.js workers are detected as a combination of ENVIRONMENT_IS_WORKER and
// ENVIRONMENT_IS_NODE.
if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {
  if (ENVIRONMENT_IS_WORKER) { // Check worker, not web, since window could be polyfilled
    scriptDirectory = self.location.href;
  } else if (document.currentScript) { // web
    scriptDirectory = document.currentScript.src;
  }
  // When MODULARIZE, this JS may be executed later, after document.currentScript
  // is gone, so we saved it, and we use it here instead of any other info.
  if (_scriptDir) {
    scriptDirectory = _scriptDir;
  }
  // blob urls look like blob:http://site.com/etc/etc and we cannot infer anything from them.
  // otherwise, slice off the final part of the url to find the script directory.
  // if scriptDirectory does not contain a slash, lastIndexOf will return -1,
  // and scriptDirectory will correctly be replaced with an empty string.
  if (scriptDirectory.indexOf('blob:') !== 0) {
    scriptDirectory = scriptDirectory.substr(0, scriptDirectory.lastIndexOf('/')+1);
  } else {
    scriptDirectory = '';
  }


  // Differentiate the Web Worker from the Node Worker case, as reading must
  // be done differently.
  {


/**
 * @license
 * Copyright 2019 The Emscripten Authors
 * SPDX-License-Identifier: MIT
 */

  read_ = function shell_read(url) {
    try {
      var xhr = new XMLHttpRequest();
      xhr.open('GET', url, false);
      xhr.send(null);
      return xhr.responseText;
    } catch (err) {
      var data = tryParseAsDataURI(url);
      if (data) {
        return intArrayToString(data);
      }
      throw err;
    }
  };

  if (ENVIRONMENT_IS_WORKER) {
    readBinary = function readBinary(url) {
      try {
        var xhr = new XMLHttpRequest();
        xhr.open('GET', url, false);
        xhr.responseType = 'arraybuffer';
        xhr.send(null);
        return new Uint8Array(/** @type{!ArrayBuffer} */(xhr.response));
      } catch (err) {
        var data = tryParseAsDataURI(url);
        if (data) {
          return data;
        }
        throw err;
      }
    };
  }

  readAsync = function readAsync(url, onload, onerror) {
    var xhr = new XMLHttpRequest();
    xhr.open('GET', url, true);
    xhr.responseType = 'arraybuffer';
    xhr.onload = function xhr_onload() {
      if (xhr.status == 200 || (xhr.status == 0 && xhr.response)) { // file URLs can return 0
        onload(xhr.response);
        return;
      }
      var data = tryParseAsDataURI(url);
      if (data) {
        onload(data.buffer);
        return;
      }
      onerror();
    };
    xhr.onerror = onerror;
    xhr.send(null);
  };




  }

  setWindowTitle = function(title) { document.title = title };
} else
{
}


// Set up the out() and err() hooks, which are how we can print to stdout or
// stderr, respectively.
var out = Module['print'] || console.log.bind(console);
var err = Module['printErr'] || console.warn.bind(console);

// Merge back in the overrides
for (key in moduleOverrides) {
  if (moduleOverrides.hasOwnProperty(key)) {
    Module[key] = moduleOverrides[key];
  }
}
// Free the object hierarchy contained in the overrides, this lets the GC
// reclaim data used e.g. in memoryInitializerRequest, which is a large typed array.
moduleOverrides = null;

// Emit code to handle expected values on the Module object. This applies Module.x
// to the proper local x. This has two benefits: first, we only emit it if it is
// expected to arrive, and second, by using a local everywhere else that can be
// minified.
if (Module['arguments']) arguments_ = Module['arguments'];
if (Module['thisProgram']) thisProgram = Module['thisProgram'];
if (Module['quit']) quit_ = Module['quit'];

// perform assertions in shell.js after we set up out() and err(), as otherwise if an assertion fails it cannot print the message



/**
 * @license
 * Copyright 2017 The Emscripten Authors
 * SPDX-License-Identifier: MIT
 */

// {{PREAMBLE_ADDITIONS}}

var STACK_ALIGN = 16;


function dynamicAlloc(size) {
  var ret = HEAP32[DYNAMICTOP_PTR>>2];
  var end = (ret + size + 15) & -16;
  HEAP32[DYNAMICTOP_PTR>>2] = end;
  return ret;
}

function alignMemory(size, factor) {
  if (!factor) factor = STACK_ALIGN; // stack alignment (16-byte) by default
  return Math.ceil(size / factor) * factor;
}

function getNativeTypeSize(type) {
  switch (type) {
    case 'i1': case 'i8': return 1;
    case 'i16': return 2;
    case 'i32': return 4;
    case 'i64': return 8;
    case 'float': return 4;
    case 'double': return 8;
    default: {
      if (type[type.length-1] === '*') {
        return 4; // A pointer
      } else if (type[0] === 'i') {
        var bits = Number(type.substr(1));
        assert(bits % 8 === 0, 'getNativeTypeSize invalid bits ' + bits + ', type ' + type);
        return bits / 8;
      } else {
        return 0;
      }
    }
  }
}

function warnOnce(text) {
  if (!warnOnce.shown) warnOnce.shown = {};
  if (!warnOnce.shown[text]) {
    warnOnce.shown[text] = 1;
    err(text);
  }
}





/**
 * @license
 * Copyright 2020 The Emscripten Authors
 * SPDX-License-Identifier: MIT
 */


// Wraps a JS function as a wasm function with a given signature.
function convertJsFunctionToWasm(func, sig) {

  // If the type reflection proposal is available, use the new
  // "WebAssembly.Function" constructor.
  // Otherwise, construct a minimal wasm module importing the JS function and
  // re-exporting it.
  if (typeof WebAssembly.Function === "function") {
    var typeNames = {
      'i': 'i32',
      'j': 'i64',
      'f': 'f32',
      'd': 'f64'
    };
    var type = {
      parameters: [],
      results: sig[0] == 'v' ? [] : [typeNames[sig[0]]]
    };
    for (var i = 1; i < sig.length; ++i) {
      type.parameters.push(typeNames[sig[i]]);
    }
    return new WebAssembly.Function(type, func);
  }

  // The module is static, with the exception of the type section, which is
  // generated based on the signature passed in.
  var typeSection = [
    0x01, // id: section,
    0x00, // length: 0 (placeholder)
    0x01, // count: 1
    0x60, // form: func
  ];
  var sigRet = sig.slice(0, 1);
  var sigParam = sig.slice(1);
  var typeCodes = {
    'i': 0x7f, // i32
    'j': 0x7e, // i64
    'f': 0x7d, // f32
    'd': 0x7c, // f64
  };

  // Parameters, length + signatures
  typeSection.push(sigParam.length);
  for (var i = 0; i < sigParam.length; ++i) {
    typeSection.push(typeCodes[sigParam[i]]);
  }

  // Return values, length + signatures
  // With no multi-return in MVP, either 0 (void) or 1 (anything else)
  if (sigRet == 'v') {
    typeSection.push(0x00);
  } else {
    typeSection = typeSection.concat([0x01, typeCodes[sigRet]]);
  }

  // Write the overall length of the type section back into the section header
  // (excepting the 2 bytes for the section id and length)
  typeSection[1] = typeSection.length - 2;

  // Rest of the module is static
  var bytes = new Uint8Array([
    0x00, 0x61, 0x73, 0x6d, // magic ("\0asm")
    0x01, 0x00, 0x00, 0x00, // version: 1
  ].concat(typeSection, [
    0x02, 0x07, // import section
      // (import "e" "f" (func 0 (type 0)))
      0x01, 0x01, 0x65, 0x01, 0x66, 0x00, 0x00,
    0x07, 0x05, // export section
      // (export "f" (func 0 (type 0)))
      0x01, 0x01, 0x66, 0x00, 0x00,
  ]));

   // We can compile this wasm module synchronously because it is very small.
  // This accepts an import (at "e.f"), that it reroutes to an export (at "f")
  var module = new WebAssembly.Module(bytes);
  var instance = new WebAssembly.Instance(module, {
    'e': {
      'f': func
    }
  });
  var wrappedFunc = instance.exports['f'];
  return wrappedFunc;
}

var freeTableIndexes = [];

// Weak map of functions in the table to their indexes, created on first use.
var functionsInTableMap;

// Add a wasm function to the table.
function addFunctionWasm(func, sig) {
  var table = wasmTable;

  // Check if the function is already in the table, to ensure each function
  // gets a unique index. First, create the map if this is the first use.
  if (!functionsInTableMap) {
    functionsInTableMap = new WeakMap();
    for (var i = 0; i < table.length; i++) {
      var item = table.get(i);
      // Ignore null values.
      if (item) {
        functionsInTableMap.set(item, i);
      }
    }
  }
  if (functionsInTableMap.has(func)) {
    return functionsInTableMap.get(func);
  }

  // It's not in the table, add it now.


  var ret;
  // Reuse a free index if there is one, otherwise grow.
  if (freeTableIndexes.length) {
    ret = freeTableIndexes.pop();
  } else {
    ret = table.length;
    // Grow the table
    try {
      table.grow(1);
    } catch (err) {
      if (!(err instanceof RangeError)) {
        throw err;
      }
      throw 'Unable to grow wasm table. Set ALLOW_TABLE_GROWTH.';
    }
  }

  // Set the new value.
  try {
    // Attempting to call this with JS function will cause of table.set() to fail
    table.set(ret, func);
  } catch (err) {
    if (!(err instanceof TypeError)) {
      throw err;
    }
    var wrapped = convertJsFunctionToWasm(func, sig);
    table.set(ret, wrapped);
  }

  functionsInTableMap.set(func, ret);

  return ret;
}

function removeFunctionWasm(index) {
  functionsInTableMap.delete(wasmTable.get(index));
  freeTableIndexes.push(index);
}

// 'sig' parameter is required for the llvm backend but only when func is not
// already a WebAssembly function.
function addFunction(func, sig) {

  return addFunctionWasm(func, sig);
}

function removeFunction(index) {
  removeFunctionWasm(index);
}



var funcWrappers = {};

function getFuncWrapper(func, sig) {
  if (!func) return; // on null pointer, return undefined
  assert(sig);
  if (!funcWrappers[sig]) {
    funcWrappers[sig] = {};
  }
  var sigCache = funcWrappers[sig];
  if (!sigCache[func]) {
    // optimize away arguments usage in common cases
    if (sig.length === 1) {
      sigCache[func] = function dynCall_wrapper() {
        return dynCall(sig, func);
      };
    } else if (sig.length === 2) {
      sigCache[func] = function dynCall_wrapper(arg) {
        return dynCall(sig, func, [arg]);
      };
    } else {
      // general case
      sigCache[func] = function dynCall_wrapper() {
        return dynCall(sig, func, Array.prototype.slice.call(arguments));
      };
    }
  }
  return sigCache[func];
}


/**
 * @license
 * Copyright 2020 The Emscripten Authors
 * SPDX-License-Identifier: MIT
 */




function makeBigInt(low, high, unsigned) {
  return unsigned ? ((+((low>>>0)))+((+((high>>>0)))*4294967296.0)) : ((+((low>>>0)))+((+((high|0)))*4294967296.0));
}

/** @param {Array=} args */
function dynCall(sig, ptr, args) {
  if (args && args.length) {
    return Module['dynCall_' + sig].apply(null, [ptr].concat(args));
  } else {
    return Module['dynCall_' + sig].call(null, ptr);
  }
}

var tempRet0 = 0;

var setTempRet0 = function(value) {
  tempRet0 = value;
};

var getTempRet0 = function() {
  return tempRet0;
};


// The address globals begin at. Very low in memory, for code size and optimization opportunities.
// Above 0 is static memory, starting with globals.
// Then the stack.
// Then 'dynamic' memory for sbrk.
var GLOBAL_BASE = 1024;



/**
 * @license
 * Copyright 2010 The Emscripten Authors
 * SPDX-License-Identifier: MIT
 */

// === Preamble library stuff ===

// Documentation for the public APIs defined in this file must be updated in:
//    site/source/docs/api_reference/preamble.js.rst
// A prebuilt local version of the documentation is available at:
//    site/build/text/docs/api_reference/preamble.js.txt
// You can also build docs locally as HTML or other formats in site/
// An online HTML version (which may be of a different version of Emscripten)
//    is up at http://kripken.github.io/emscripten-site/docs/api_reference/preamble.js.html


var wasmBinary;if (Module['wasmBinary']) wasmBinary = Module['wasmBinary'];
var noExitRuntime;if (Module['noExitRuntime']) noExitRuntime = Module['noExitRuntime'];


if (typeof WebAssembly !== 'object') {
  err('no native wasm support detected');
}


/**
 * @license
 * Copyright 2019 The Emscripten Authors
 * SPDX-License-Identifier: MIT
 */

// In MINIMAL_RUNTIME, setValue() and getValue() are only available when building with safe heap enabled, for heap safety checking.
// In traditional runtime, setValue() and getValue() are always available (although their use is highly discouraged due to perf penalties)

/** @param {number} ptr
    @param {number} value
    @param {string} type
    @param {number|boolean=} noSafe */
function setValue(ptr, value, type, noSafe) {
  type = type || 'i8';
  if (type.charAt(type.length-1) === '*') type = 'i32'; // pointers are 32-bit
    switch(type) {
      case 'i1': HEAP8[((ptr)>>0)]=value; break;
      case 'i8': HEAP8[((ptr)>>0)]=value; break;
      case 'i16': HEAP16[((ptr)>>1)]=value; break;
      case 'i32': HEAP32[((ptr)>>2)]=value; break;
      case 'i64': (tempI64 = [value>>>0,(tempDouble=value,(+(Math_abs(tempDouble))) >= 1.0 ? (tempDouble > 0.0 ? ((Math_min((+(Math_floor((tempDouble)/4294967296.0))), 4294967295.0))|0)>>>0 : (~~((+(Math_ceil((tempDouble - +(((~~(tempDouble)))>>>0))/4294967296.0)))))>>>0) : 0)],HEAP32[((ptr)>>2)]=tempI64[0],HEAP32[(((ptr)+(4))>>2)]=tempI64[1]); break;
      case 'float': HEAPF32[((ptr)>>2)]=value; break;
      case 'double': HEAPF64[((ptr)>>3)]=value; break;
      default: abort('invalid type for setValue: ' + type);
    }
}

/** @param {number} ptr
    @param {string} type
    @param {number|boolean=} noSafe */
function getValue(ptr, type, noSafe) {
  type = type || 'i8';
  if (type.charAt(type.length-1) === '*') type = 'i32'; // pointers are 32-bit
    switch(type) {
      case 'i1': return HEAP8[((ptr)>>0)];
      case 'i8': return HEAP8[((ptr)>>0)];
      case 'i16': return HEAP16[((ptr)>>1)];
      case 'i32': return HEAP32[((ptr)>>2)];
      case 'i64': return HEAP32[((ptr)>>2)];
      case 'float': return HEAPF32[((ptr)>>2)];
      case 'double': return HEAPF64[((ptr)>>3)];
      default: abort('invalid type for getValue: ' + type);
    }
  return null;
}





// Wasm globals

var wasmMemory;

// In fastcomp asm.js, we don't need a wasm Table at all.
// In the wasm backend, we polyfill the WebAssembly object,
// so this creates a (non-native-wasm) table for us.
var wasmTable = new WebAssembly.Table({
  'initial': 246,
  'maximum': 246 + 0,
  'element': 'anyfunc'
});


//========================================
// Runtime essentials
//========================================

// whether we are quitting the application. no code should run after this.
// set in exit() and abort()
var ABORT = false;

// set by exit() and abort().  Passed to 'onExit' handler.
// NOTE: This is also used as the process return code code in shell environments
// but only when noExitRuntime is false.
var EXITSTATUS = 0;

/** @type {function(*, string=)} */
function assert(condition, text) {
  if (!condition) {
    abort('Assertion failed: ' + text);
  }
}

// Returns the C function with a specified identifier (for C++, you need to do manual name mangling)
function getCFunc(ident) {
  var func = Module['_' + ident]; // closure exported function
  assert(func, 'Cannot call unknown function ' + ident + ', make sure it is exported');
  return func;
}

// C calling interface.
/** @param {string|null=} returnType
    @param {Array=} argTypes
    @param {Arguments|Array=} args
    @param {Object=} opts */
function ccall(ident, returnType, argTypes, args, opts) {
  // For fast lookup of conversion functions
  var toC = {
    'string': function(str) {
      var ret = 0;
      if (str !== null && str !== undefined && str !== 0) { // null string
        // at most 4 bytes per UTF-8 code point, +1 for the trailing '\0'
        var len = (str.length << 2) + 1;
        ret = stackAlloc(len);
        stringToUTF8(str, ret, len);
      }
      return ret;
    },
    'array': function(arr) {
      var ret = stackAlloc(arr.length);
      writeArrayToMemory(arr, ret);
      return ret;
    }
  };

  function convertReturnValue(ret) {
    if (returnType === 'string') return UTF8ToString(ret);
    if (returnType === 'boolean') return Boolean(ret);
    return ret;
  }

  var func = getCFunc(ident);
  var cArgs = [];
  var stack = 0;
  if (args) {
    for (var i = 0; i < args.length; i++) {
      var converter = toC[argTypes[i]];
      if (converter) {
        if (stack === 0) stack = stackSave();
        cArgs[i] = converter(args[i]);
      } else {
        cArgs[i] = args[i];
      }
    }
  }
  var ret = func.apply(null, cArgs);

  ret = convertReturnValue(ret);
  if (stack !== 0) stackRestore(stack);
  return ret;
}

/** @param {string=} returnType
    @param {Array=} argTypes
    @param {Object=} opts */
function cwrap(ident, returnType, argTypes, opts) {
  argTypes = argTypes || [];
  // When the function takes numbers and returns a number, we can just return
  // the original function
  var numericArgs = argTypes.every(function(type){ return type === 'number'});
  var numericRet = returnType !== 'string';
  if (numericRet && numericArgs && !opts) {
    return getCFunc(ident);
  }
  return function() {
    return ccall(ident, returnType, argTypes, arguments, opts);
  }
}

var ALLOC_NORMAL = 0; // Tries to use _malloc()
var ALLOC_STACK = 1; // Lives for the duration of the current function call
var ALLOC_DYNAMIC = 2; // Cannot be freed except through sbrk
var ALLOC_NONE = 3; // Do not allocate

// allocate(): This is for internal use. You can use it yourself as well, but the interface
//             is a little tricky (see docs right below). The reason is that it is optimized
//             for multiple syntaxes to save space in generated code. So you should
//             normally not use allocate(), and instead allocate memory using _malloc(),
//             initialize it with setValue(), and so forth.
// @slab: An array of data, or a number. If a number, then the size of the block to allocate,
//        in *bytes* (note that this is sometimes confusing: the next parameter does not
//        affect this!)
// @types: Either an array of types, one for each byte (or 0 if no type at that position),
//         or a single type which is used for the entire block. This only matters if there
//         is initial data - if @slab is a number, then this does not matter at all and is
//         ignored.
// @allocator: How to allocate memory, see ALLOC_*
/** @type {function((TypedArray|Array<number>|number), string, number, number=)} */
function allocate(slab, types, allocator, ptr) {
  var zeroinit, size;
  if (typeof slab === 'number') {
    zeroinit = true;
    size = slab;
  } else {
    zeroinit = false;
    size = slab.length;
  }

  var singleType = typeof types === 'string' ? types : null;

  var ret;
  if (allocator == ALLOC_NONE) {
    ret = ptr;
  } else {
    ret = [_malloc,
    stackAlloc,
    dynamicAlloc][allocator](Math.max(size, singleType ? 1 : types.length));
  }

  if (zeroinit) {
    var stop;
    ptr = ret;
    assert((ret & 3) == 0);
    stop = ret + (size & ~3);
    for (; ptr < stop; ptr += 4) {
      HEAP32[((ptr)>>2)]=0;
    }
    stop = ret + size;
    while (ptr < stop) {
      HEAP8[((ptr++)>>0)]=0;
    }
    return ret;
  }

  if (singleType === 'i8') {
    if (slab.subarray || slab.slice) {
      HEAPU8.set(/** @type {!Uint8Array} */ (slab), ret);
    } else {
      HEAPU8.set(new Uint8Array(slab), ret);
    }
    return ret;
  }

  var i = 0, type, typeSize, previousType;
  while (i < size) {
    var curr = slab[i];

    type = singleType || types[i];
    if (type === 0) {
      i++;
      continue;
    }

    if (type == 'i64') type = 'i32'; // special case: we have one i32 here, and one i32 later

    setValue(ret+i, curr, type);

    // no need to look up size unless type changes, so cache it
    if (previousType !== type) {
      typeSize = getNativeTypeSize(type);
      previousType = type;
    }
    i += typeSize;
  }

  return ret;
}

// Allocate memory during any stage of startup - static memory early on, dynamic memory later, malloc when ready
function getMemory(size) {
  if (!runtimeInitialized) return dynamicAlloc(size);
  return _malloc(size);
}


/**
 * @license
 * Copyright 2019 The Emscripten Authors
 * SPDX-License-Identifier: MIT
 */

// runtime_strings.js: Strings related runtime functions that are part of both MINIMAL_RUNTIME and regular runtime.

// Given a pointer 'ptr' to a null-terminated UTF8-encoded string in the given array that contains uint8 values, returns
// a copy of that string as a Javascript String object.

var UTF8Decoder = typeof TextDecoder !== 'undefined' ? new TextDecoder('utf8') : undefined;

/**
 * @param {number} idx
 * @param {number=} maxBytesToRead
 * @return {string}
 */
function UTF8ArrayToString(heap, idx, maxBytesToRead) {
  var endIdx = idx + maxBytesToRead;
  var endPtr = idx;
  // TextDecoder needs to know the byte length in advance, it doesn't stop on null terminator by itself.
  // Also, use the length info to avoid running tiny strings through TextDecoder, since .subarray() allocates garbage.
  // (As a tiny code save trick, compare endPtr against endIdx using a negation, so that undefined means Infinity)
  while (heap[endPtr] && !(endPtr >= endIdx)) ++endPtr;

  if (endPtr - idx > 16 && heap.subarray && UTF8Decoder) {
    return UTF8Decoder.decode(heap.subarray(idx, endPtr));
  } else {
    var str = '';
    // If building with TextDecoder, we have already computed the string length above, so test loop end condition against that
    while (idx < endPtr) {
      // For UTF8 byte structure, see:
      // http://en.wikipedia.org/wiki/UTF-8#Description
      // https://www.ietf.org/rfc/rfc2279.txt
      // https://tools.ietf.org/html/rfc3629
      var u0 = heap[idx++];
      if (!(u0 & 0x80)) { str += String.fromCharCode(u0); continue; }
      var u1 = heap[idx++] & 63;
      if ((u0 & 0xE0) == 0xC0) { str += String.fromCharCode(((u0 & 31) << 6) | u1); continue; }
      var u2 = heap[idx++] & 63;
      if ((u0 & 0xF0) == 0xE0) {
        u0 = ((u0 & 15) << 12) | (u1 << 6) | u2;
      } else {
        u0 = ((u0 & 7) << 18) | (u1 << 12) | (u2 << 6) | (heap[idx++] & 63);
      }

      if (u0 < 0x10000) {
        str += String.fromCharCode(u0);
      } else {
        var ch = u0 - 0x10000;
        str += String.fromCharCode(0xD800 | (ch >> 10), 0xDC00 | (ch & 0x3FF));
      }
    }
  }
  return str;
}

// Given a pointer 'ptr' to a null-terminated UTF8-encoded string in the emscripten HEAP, returns a
// copy of that string as a Javascript String object.
// maxBytesToRead: an optional length that specifies the maximum number of bytes to read. You can omit
//                 this parameter to scan the string until the first \0 byte. If maxBytesToRead is
//                 passed, and the string at [ptr, ptr+maxBytesToReadr[ contains a null byte in the
//                 middle, then the string will cut short at that byte index (i.e. maxBytesToRead will
//                 not produce a string of exact length [ptr, ptr+maxBytesToRead[)
//                 N.B. mixing frequent uses of UTF8ToString() with and without maxBytesToRead may
//                 throw JS JIT optimizations off, so it is worth to consider consistently using one
//                 style or the other.
/**
 * @param {number} ptr
 * @param {number=} maxBytesToRead
 * @return {string}
 */
function UTF8ToString(ptr, maxBytesToRead) {
  return ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : '';
}

// Copies the given Javascript String object 'str' to the given byte array at address 'outIdx',
// encoded in UTF8 form and null-terminated. The copy will require at most str.length*4+1 bytes of space in the HEAP.
// Use the function lengthBytesUTF8 to compute the exact number of bytes (excluding null terminator) that this function will write.
// Parameters:
//   str: the Javascript string to copy.
//   heap: the array to copy to. Each index in this array is assumed to be one 8-byte element.
//   outIdx: The starting offset in the array to begin the copying.
//   maxBytesToWrite: The maximum number of bytes this function can write to the array.
//                    This count should include the null terminator,
//                    i.e. if maxBytesToWrite=1, only the null terminator will be written and nothing else.
//                    maxBytesToWrite=0 does not write any bytes to the output, not even the null terminator.
// Returns the number of bytes written, EXCLUDING the null terminator.

function stringToUTF8Array(str, heap, outIdx, maxBytesToWrite) {
  if (!(maxBytesToWrite > 0)) // Parameter maxBytesToWrite is not optional. Negative values, 0, null, undefined and false each don't write out any bytes.
    return 0;

  var startIdx = outIdx;
  var endIdx = outIdx + maxBytesToWrite - 1; // -1 for string null terminator.
  for (var i = 0; i < str.length; ++i) {
    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! So decode UTF16->UTF32->UTF8.
    // See http://unicode.org/faq/utf_bom.html#utf16-3
    // For UTF8 byte structure, see http://en.wikipedia.org/wiki/UTF-8#Description and https://www.ietf.org/rfc/rfc2279.txt and https://tools.ietf.org/html/rfc3629
    var u = str.charCodeAt(i); // possibly a lead surrogate
    if (u >= 0xD800 && u <= 0xDFFF) {
      var u1 = str.charCodeAt(++i);
      u = 0x10000 + ((u & 0x3FF) << 10) | (u1 & 0x3FF);
    }
    if (u <= 0x7F) {
      if (outIdx >= endIdx) break;
      heap[outIdx++] = u;
    } else if (u <= 0x7FF) {
      if (outIdx + 1 >= endIdx) break;
      heap[outIdx++] = 0xC0 | (u >> 6);
      heap[outIdx++] = 0x80 | (u & 63);
    } else if (u <= 0xFFFF) {
      if (outIdx + 2 >= endIdx) break;
      heap[outIdx++] = 0xE0 | (u >> 12);
      heap[outIdx++] = 0x80 | ((u >> 6) & 63);
      heap[outIdx++] = 0x80 | (u & 63);
    } else {
      if (outIdx + 3 >= endIdx) break;
      heap[outIdx++] = 0xF0 | (u >> 18);
      heap[outIdx++] = 0x80 | ((u >> 12) & 63);
      heap[outIdx++] = 0x80 | ((u >> 6) & 63);
      heap[outIdx++] = 0x80 | (u & 63);
    }
  }
  // Null-terminate the pointer to the buffer.
  heap[outIdx] = 0;
  return outIdx - startIdx;
}

// Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',
// null-terminated and encoded in UTF8 form. The copy will require at most str.length*4+1 bytes of space in the HEAP.
// Use the function lengthBytesUTF8 to compute the exact number of bytes (excluding null terminator) that this function will write.
// Returns the number of bytes written, EXCLUDING the null terminator.

function stringToUTF8(str, outPtr, maxBytesToWrite) {
  return stringToUTF8Array(str, HEAPU8,outPtr, maxBytesToWrite);
}

// Returns the number of bytes the given Javascript string takes if encoded as a UTF8 byte array, EXCLUDING the null terminator byte.
function lengthBytesUTF8(str) {
  var len = 0;
  for (var i = 0; i < str.length; ++i) {
    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! So decode UTF16->UTF32->UTF8.
    // See http://unicode.org/faq/utf_bom.html#utf16-3
    var u = str.charCodeAt(i); // possibly a lead surrogate
    if (u >= 0xD800 && u <= 0xDFFF) u = 0x10000 + ((u & 0x3FF) << 10) | (str.charCodeAt(++i) & 0x3FF);
    if (u <= 0x7F) ++len;
    else if (u <= 0x7FF) len += 2;
    else if (u <= 0xFFFF) len += 3;
    else len += 4;
  }
  return len;
}



/**
 * @license
 * Copyright 2020 The Emscripten Authors
 * SPDX-License-Identifier: MIT
 */

// runtime_strings_extra.js: Strings related runtime functions that are available only in regular runtime.

// Given a pointer 'ptr' to a null-terminated ASCII-encoded string in the emscripten HEAP, returns
// a copy of that string as a Javascript String object.

function AsciiToString(ptr) {
  var str = '';
  while (1) {
    var ch = HEAPU8[((ptr++)>>0)];
    if (!ch) return str;
    str += String.fromCharCode(ch);
  }
}

// Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',
// null-terminated and encoded in ASCII form. The copy will require at most str.length+1 bytes of space in the HEAP.

function stringToAscii(str, outPtr) {
  return writeAsciiToMemory(str, outPtr, false);
}

// Given a pointer 'ptr' to a null-terminated UTF16LE-encoded string in the emscripten HEAP, returns
// a copy of that string as a Javascript String object.

var UTF16Decoder = typeof TextDecoder !== 'undefined' ? new TextDecoder('utf-16le') : undefined;

function UTF16ToString(ptr) {
  var endPtr = ptr;
  // TextDecoder needs to know the byte length in advance, it doesn't stop on null terminator by itself.
  // Also, use the length info to avoid running tiny strings through TextDecoder, since .subarray() allocates garbage.
  var idx = endPtr >> 1;
  while (HEAP16[idx]) ++idx;
  endPtr = idx << 1;

  if (endPtr - ptr > 32 && UTF16Decoder) {
    return UTF16Decoder.decode(HEAPU8.subarray(ptr, endPtr));
  } else {
    var i = 0;

    var str = '';
    while (1) {
      var codeUnit = HEAP16[(((ptr)+(i*2))>>1)];
      if (codeUnit == 0) return str;
      ++i;
      // fromCharCode constructs a character from a UTF-16 code unit, so we can pass the UTF16 string right through.
      str += String.fromCharCode(codeUnit);
    }
  }
}

// Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',
// null-terminated and encoded in UTF16 form. The copy will require at most str.length*4+2 bytes of space in the HEAP.
// Use the function lengthBytesUTF16() to compute the exact number of bytes (excluding null terminator) that this function will write.
// Parameters:
//   str: the Javascript string to copy.
//   outPtr: Byte address in Emscripten HEAP where to write the string to.
//   maxBytesToWrite: The maximum number of bytes this function can write to the array. This count should include the null
//                    terminator, i.e. if maxBytesToWrite=2, only the null terminator will be written and nothing else.
//                    maxBytesToWrite<2 does not write any bytes to the output, not even the null terminator.
// Returns the number of bytes written, EXCLUDING the null terminator.

function stringToUTF16(str, outPtr, maxBytesToWrite) {
  // Backwards compatibility: if max bytes is not specified, assume unsafe unbounded write is allowed.
  if (maxBytesToWrite === undefined) {
    maxBytesToWrite = 0x7FFFFFFF;
  }
  if (maxBytesToWrite < 2) return 0;
  maxBytesToWrite -= 2; // Null terminator.
  var startPtr = outPtr;
  var numCharsToWrite = (maxBytesToWrite < str.length*2) ? (maxBytesToWrite / 2) : str.length;
  for (var i = 0; i < numCharsToWrite; ++i) {
    // charCodeAt returns a UTF-16 encoded code unit, so it can be directly written to the HEAP.
    var codeUnit = str.charCodeAt(i); // possibly a lead surrogate
    HEAP16[((outPtr)>>1)]=codeUnit;
    outPtr += 2;
  }
  // Null-terminate the pointer to the HEAP.
  HEAP16[((outPtr)>>1)]=0;
  return outPtr - startPtr;
}

// Returns the number of bytes the given Javascript string takes if encoded as a UTF16 byte array, EXCLUDING the null terminator byte.

function lengthBytesUTF16(str) {
  return str.length*2;
}

function UTF32ToString(ptr) {
  var i = 0;

  var str = '';
  while (1) {
    var utf32 = HEAP32[(((ptr)+(i*4))>>2)];
    if (utf32 == 0) return str;
    ++i;
    // Gotcha: fromCharCode constructs a character from a UTF-16 encoded code (pair), not from a Unicode code point! So encode the code point to UTF-16 for constructing.
    // See http://unicode.org/faq/utf_bom.html#utf16-3
    if (utf32 >= 0x10000) {
      var ch = utf32 - 0x10000;
      str += String.fromCharCode(0xD800 | (ch >> 10), 0xDC00 | (ch & 0x3FF));
    } else {
      str += String.fromCharCode(utf32);
    }
  }
}

// Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',
// null-terminated and encoded in UTF32 form. The copy will require at most str.length*4+4 bytes of space in the HEAP.
// Use the function lengthBytesUTF32() to compute the exact number of bytes (excluding null terminator) that this function will write.
// Parameters:
//   str: the Javascript string to copy.
//   outPtr: Byte address in Emscripten HEAP where to write the string to.
//   maxBytesToWrite: The maximum number of bytes this function can write to the array. This count should include the null
//                    terminator, i.e. if maxBytesToWrite=4, only the null terminator will be written and nothing else.
//                    maxBytesToWrite<4 does not write any bytes to the output, not even the null terminator.
// Returns the number of bytes written, EXCLUDING the null terminator.

function stringToUTF32(str, outPtr, maxBytesToWrite) {
  // Backwards compatibility: if max bytes is not specified, assume unsafe unbounded write is allowed.
  if (maxBytesToWrite === undefined) {
    maxBytesToWrite = 0x7FFFFFFF;
  }
  if (maxBytesToWrite < 4) return 0;
  var startPtr = outPtr;
  var endPtr = startPtr + maxBytesToWrite - 4;
  for (var i = 0; i < str.length; ++i) {
    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! We must decode the string to UTF-32 to the heap.
    // See http://unicode.org/faq/utf_bom.html#utf16-3
    var codeUnit = str.charCodeAt(i); // possibly a lead surrogate
    if (codeUnit >= 0xD800 && codeUnit <= 0xDFFF) {
      var trailSurrogate = str.charCodeAt(++i);
      codeUnit = 0x10000 + ((codeUnit & 0x3FF) << 10) | (trailSurrogate & 0x3FF);
    }
    HEAP32[((outPtr)>>2)]=codeUnit;
    outPtr += 4;
    if (outPtr + 4 > endPtr) break;
  }
  // Null-terminate the pointer to the HEAP.
  HEAP32[((outPtr)>>2)]=0;
  return outPtr - startPtr;
}

// Returns the number of bytes the given Javascript string takes if encoded as a UTF16 byte array, EXCLUDING the null terminator byte.

function lengthBytesUTF32(str) {
  var len = 0;
  for (var i = 0; i < str.length; ++i) {
    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! We must decode the string to UTF-32 to the heap.
    // See http://unicode.org/faq/utf_bom.html#utf16-3
    var codeUnit = str.charCodeAt(i);
    if (codeUnit >= 0xD800 && codeUnit <= 0xDFFF) ++i; // possibly a lead surrogate, so skip over the tail surrogate.
    len += 4;
  }

  return len;
}

// Allocate heap space for a JS string, and write it there.
// It is the responsibility of the caller to free() that memory.
function allocateUTF8(str) {
  var size = lengthBytesUTF8(str) + 1;
  var ret = _malloc(size);
  if (ret) stringToUTF8Array(str, HEAP8, ret, size);
  return ret;
}

// Allocate stack space for a JS string, and write it there.
function allocateUTF8OnStack(str) {
  var size = lengthBytesUTF8(str) + 1;
  var ret = stackAlloc(size);
  stringToUTF8Array(str, HEAP8, ret, size);
  return ret;
}

// Deprecated: This function should not be called because it is unsafe and does not provide
// a maximum length limit of how many bytes it is allowed to write. Prefer calling the
// function stringToUTF8Array() instead, which takes in a maximum length that can be used
// to be secure from out of bounds writes.
/** @deprecated
    @param {boolean=} dontAddNull */
function writeStringToMemory(string, buffer, dontAddNull) {
  warnOnce('writeStringToMemory is deprecated and should not be called! Use stringToUTF8() instead!');

  var /** @type {number} */ lastChar, /** @type {number} */ end;
  if (dontAddNull) {
    // stringToUTF8Array always appends null. If we don't want to do that, remember the
    // character that existed at the location where the null will be placed, and restore
    // that after the write (below).
    end = buffer + lengthBytesUTF8(string);
    lastChar = HEAP8[end];
  }
  stringToUTF8(string, buffer, Infinity);
  if (dontAddNull) HEAP8[end] = lastChar; // Restore the value under the null character.
}

function writeArrayToMemory(array, buffer) {
  HEAP8.set(array, buffer);
}

/** @param {boolean=} dontAddNull */
function writeAsciiToMemory(str, buffer, dontAddNull) {
  for (var i = 0; i < str.length; ++i) {
    HEAP8[((buffer++)>>0)]=str.charCodeAt(i);
  }
  // Null-terminate the pointer to the HEAP.
  if (!dontAddNull) HEAP8[((buffer)>>0)]=0;
}



// Memory management

var PAGE_SIZE = 16384;
var WASM_PAGE_SIZE = 65536;
var ASMJS_PAGE_SIZE = 16777216;

function alignUp(x, multiple) {
  if (x % multiple > 0) {
    x += multiple - (x % multiple);
  }
  return x;
}

var HEAP,
/** @type {ArrayBuffer} */
  buffer,
/** @type {Int8Array} */
  HEAP8,
/** @type {Uint8Array} */
  HEAPU8,
/** @type {Int16Array} */
  HEAP16,
/** @type {Uint16Array} */
  HEAPU16,
/** @type {Int32Array} */
  HEAP32,
/** @type {Uint32Array} */
  HEAPU32,
/** @type {Float32Array} */
  HEAPF32,
/** @type {Float64Array} */
  HEAPF64;

function updateGlobalBufferAndViews(buf) {
  buffer = buf;
  Module['HEAP8'] = HEAP8 = new Int8Array(buf);
  Module['HEAP16'] = HEAP16 = new Int16Array(buf);
  Module['HEAP32'] = HEAP32 = new Int32Array(buf);
  Module['HEAPU8'] = HEAPU8 = new Uint8Array(buf);
  Module['HEAPU16'] = HEAPU16 = new Uint16Array(buf);
  Module['HEAPU32'] = HEAPU32 = new Uint32Array(buf);
  Module['HEAPF32'] = HEAPF32 = new Float32Array(buf);
  Module['HEAPF64'] = HEAPF64 = new Float64Array(buf);
}

var STATIC_BASE = 1024,
    STACK_BASE = 5301776,
    STACKTOP = STACK_BASE,
    STACK_MAX = 58896,
    DYNAMIC_BASE = 5301776,
    DYNAMICTOP_PTR = 58736;




var TOTAL_STACK = 5242880;

var INITIAL_INITIAL_MEMORY = Module['INITIAL_MEMORY'] || 16777216;




/**
 * @license
 * Copyright 2019 The Emscripten Authors
 * SPDX-License-Identifier: MIT
 */




// In standalone mode, the wasm creates the memory, and the user can't provide it.
// In non-standalone/normal mode, we create the memory here.

/**
 * @license
 * Copyright 2019 The Emscripten Authors
 * SPDX-License-Identifier: MIT
 */

// Create the main memory. (Note: this isn't used in STANDALONE_WASM mode since the wasm
// memory is created in the wasm, not in JS.)

  if (Module['wasmMemory']) {
    wasmMemory = Module['wasmMemory'];
  } else
  {
    wasmMemory = new WebAssembly.Memory({
      'initial': INITIAL_INITIAL_MEMORY / WASM_PAGE_SIZE
      ,
      'maximum': 2147483648 / WASM_PAGE_SIZE
    });
  }


if (wasmMemory) {
  buffer = wasmMemory.buffer;
}

// If the user provides an incorrect length, just use that length instead rather than providing the user to
// specifically provide the memory length with Module['INITIAL_MEMORY'].
INITIAL_INITIAL_MEMORY = buffer.byteLength;
updateGlobalBufferAndViews(buffer);

HEAP32[DYNAMICTOP_PTR>>2] = DYNAMIC_BASE;




/**
 * @license
 * Copyright 2019 The Emscripten Authors
 * SPDX-License-Identifier: MIT
 */




/**
 * @license
 * Copyright 2019 The Emscripten Authors
 * SPDX-License-Identifier: MIT
 */




function callRuntimeCallbacks(callbacks) {
  while(callbacks.length > 0) {
    var callback = callbacks.shift();
    if (typeof callback == 'function') {
      callback(Module); // Pass the module as the first argument.
      continue;
    }
    var func = callback.func;
    if (typeof func === 'number') {
      if (callback.arg === undefined) {
        Module['dynCall_v'](func);
      } else {
        Module['dynCall_vi'](func, callback.arg);
      }
    } else {
      func(callback.arg === undefined ? null : callback.arg);
    }
  }
}

var __ATPRERUN__  = []; // functions called before the runtime is initialized
var __ATINIT__    = []; // functions called during startup
var __ATMAIN__    = []; // functions called when main() is to be run
var __ATEXIT__    = []; // functions called during shutdown
var __ATPOSTRUN__ = []; // functions called after the main() is called

var runtimeInitialized = false;
var runtimeExited = false;


function preRun() {

  if (Module['preRun']) {
    if (typeof Module['preRun'] == 'function') Module['preRun'] = [Module['preRun']];
    while (Module['preRun'].length) {
      addOnPreRun(Module['preRun'].shift());
    }
  }

  callRuntimeCallbacks(__ATPRERUN__);
}

function initRuntime() {
  runtimeInitialized = true;
  if (!Module["noFSInit"] && !FS.init.initialized) FS.init();
TTY.init();
  callRuntimeCallbacks(__ATINIT__);
}

function preMain() {
  FS.ignorePermissions = false;
  callRuntimeCallbacks(__ATMAIN__);
}

function exitRuntime() {
  runtimeExited = true;
}

function postRun() {

  if (Module['postRun']) {
    if (typeof Module['postRun'] == 'function') Module['postRun'] = [Module['postRun']];
    while (Module['postRun'].length) {
      addOnPostRun(Module['postRun'].shift());
    }
  }

  callRuntimeCallbacks(__ATPOSTRUN__);
}

function addOnPreRun(cb) {
  __ATPRERUN__.unshift(cb);
}

function addOnInit(cb) {
  __ATINIT__.unshift(cb);
}

function addOnPreMain(cb) {
  __ATMAIN__.unshift(cb);
}

function addOnExit(cb) {
}

function addOnPostRun(cb) {
  __ATPOSTRUN__.unshift(cb);
}

/** @param {number|boolean=} ignore */
function unSign(value, bits, ignore) {
  if (value >= 0) {
    return value;
  }
  return bits <= 32 ? 2*Math.abs(1 << (bits-1)) + value // Need some trickery, since if bits == 32, we are right at the limit of the bits JS uses in bitshifts
                    : Math.pow(2, bits)         + value;
}
/** @param {number|boolean=} ignore */
function reSign(value, bits, ignore) {
  if (value <= 0) {
    return value;
  }
  var half = bits <= 32 ? Math.abs(1 << (bits-1)) // abs is needed if bits == 32
                        : Math.pow(2, bits-1);
  if (value >= half && (bits <= 32 || value > half)) { // for huge values, we can hit the precision limit and always get true here. so don't do that
                                                       // but, in general there is no perfect solution here. With 64-bit ints, we get rounding and errors
                                                       // TODO: In i64 mode 1, resign the two parts separately and safely
    value = -2*half + value; // Cannot bitshift half, as it may be at the limit of the bits JS uses in bitshifts
  }
  return value;
}


/**
 * @license
 * Copyright 2019 The Emscripten Authors
 * SPDX-License-Identifier: MIT
 */

// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/imul

// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/fround

// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/clz32

// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/trunc


var Math_abs = Math.abs;
var Math_cos = Math.cos;
var Math_sin = Math.sin;
var Math_tan = Math.tan;
var Math_acos = Math.acos;
var Math_asin = Math.asin;
var Math_atan = Math.atan;
var Math_atan2 = Math.atan2;
var Math_exp = Math.exp;
var Math_log = Math.log;
var Math_sqrt = Math.sqrt;
var Math_ceil = Math.ceil;
var Math_floor = Math.floor;
var Math_pow = Math.pow;
var Math_imul = Math.imul;
var Math_fround = Math.fround;
var Math_round = Math.round;
var Math_min = Math.min;
var Math_max = Math.max;
var Math_clz32 = Math.clz32;
var Math_trunc = Math.trunc;



// A counter of dependencies for calling run(). If we need to
// do asynchronous work before running, increment this and
// decrement it. Incrementing must happen in a place like
// Module.preRun (used by emcc to add file preloading).
// Note that you can add dependencies in preRun, even though
// it happens right before run - run will be postponed until
// the dependencies are met.
var runDependencies = 0;
var runDependencyWatcher = null;
var dependenciesFulfilled = null; // overridden to take different actions when all run dependencies are fulfilled

function getUniqueRunDependency(id) {
  return id;
}

function addRunDependency(id) {
  runDependencies++;

  if (Module['monitorRunDependencies']) {
    Module['monitorRunDependencies'](runDependencies);
  }

}

function removeRunDependency(id) {
  runDependencies--;

  if (Module['monitorRunDependencies']) {
    Module['monitorRunDependencies'](runDependencies);
  }

  if (runDependencies == 0) {
    if (runDependencyWatcher !== null) {
      clearInterval(runDependencyWatcher);
      runDependencyWatcher = null;
    }
    if (dependenciesFulfilled) {
      var callback = dependenciesFulfilled;
      dependenciesFulfilled = null;
      callback(); // can add another dependenciesFulfilled
    }
  }
}

Module["preloadedImages"] = {}; // maps url to image data
Module["preloadedAudios"] = {}; // maps url to audio data


/** @param {string|number=} what */
function abort(what) {
  if (Module['onAbort']) {
    Module['onAbort'](what);
  }

  what += '';
  out(what);
  err(what);

  ABORT = true;
  EXITSTATUS = 1;

  what = 'abort(' + what + '). Build with -s ASSERTIONS=1 for more info.';

  // Throw a wasm runtime error, because a JS error might be seen as a foreign
  // exception, which means we'd run destructors on it. We need the error to
  // simply make the program stop.
  throw new WebAssembly.RuntimeError(what);
}


var memoryInitializer = null;


/**
 * @license
 * Copyright 2015 The Emscripten Authors
 * SPDX-License-Identifier: MIT
 */







/**
 * @license
 * Copyright 2017 The Emscripten Authors
 * SPDX-License-Identifier: MIT
 */

function hasPrefix(str, prefix) {
  return String.prototype.startsWith ?
      str.startsWith(prefix) :
      str.indexOf(prefix) === 0;
}

// Prefix of data URIs emitted by SINGLE_FILE and related options.
var dataURIPrefix = 'data:application/octet-stream;base64,';

// Indicates whether filename is a base64 data URI.
function isDataURI(filename) {
  return hasPrefix(filename, dataURIPrefix);
}

var fileURIPrefix = "file://";

// Indicates whether filename is delivered via file protocol (as opposed to http/https)
function isFileURI(filename) {
  return hasPrefix(filename, fileURIPrefix);
}



var wasmBinaryFile = 'data:application/octet-stream;base64,AGFzbQEAAAABpQMzYAN/f38Bf2ACf38Bf2ABfwF/YAABf2AEf39/fwF/YAJ/fwBgAX8AYAV/f39/fwF/YAN/f38AYAR/f39/AGAGf39/f39/AGAFf39/f38AYAZ/f39/f38Bf2ACf34Bf2AAAGAGf35+f39/AX9gCX9/f39/f39/fwF/YAd/f39/f39/AGADf35/AGAHf39/f39/fwF/YAR/fn9/AX9gA39+fgF/YAZ/fH9/f38Bf2ADf35/AX5gCH9/f39/f39/AX9gCn9/f39/f39/f38Bf2AHf39+f39/fwF/YAN/fn8Bf2AGf35/f39/AX9gAn5/AX9gAX8BfmABfwF8YAh/f39/f39/fwBgCn9/f39/f39/f38AYA1/f39/f39/f39/f39/AGAEf39+fwBgA39/fABgC39/f39/f39/f39/AX9gBn9/f39/fgF/YAN/f34Bf2AEf39+fgF/YAd/f35+f39/AX9gB39/fH9/f38Bf2AFf35/f38Bf2AFf35+f38Bf2ADfn9/AX9gAn9/AX5gBH9/fn8BfmACf34BfmABfAF+YAJ8fwF8AqkIKQNlbnYFcmFpc2UAAgNlbnYEZXhpdAAGA2VudhFfZW12YWxfbmV3X29iamVjdAADA2VudhNfZW12YWxfc2V0X3Byb3BlcnR5AAgDZW52El9lbXZhbF9uZXdfY3N0cmluZwACA2Vudg1fZW12YWxfZGVjcmVmAAYDZW52Fl9lbWJpbmRfcmVnaXN0ZXJfY2xhc3MAIgNlbnYfX2VtYmluZF9yZWdpc3Rlcl9jbGFzc19wcm9wZXJ0eQAhA2VudhlfZW1iaW5kX3JlZ2lzdGVyX2Z1bmN0aW9uAAoDZW52GV9lbWJpbmRfcmVnaXN0ZXJfY29uc3RhbnQAJANlbnYRX2VtdmFsX3Rha2VfdmFsdWUAAQNlbnYYX19jeGFfYWxsb2NhdGVfZXhjZXB0aW9uAAIDZW52C19fY3hhX3Rocm93AAgDZW52Il9lbWJpbmRfcmVnaXN0ZXJfY2xhc3NfY29uc3RydWN0b3IACgNlbnYfX2VtYmluZF9yZWdpc3Rlcl9jbGFzc19mdW5jdGlvbgAgA2Vudg1fZW12YWxfaW5jcmVmAAYDZW52Cl9fc3lzX29wZW4AAANlbnYLX19zeXNfbW1hcDIADANlbnYMX19zeXNfbXVubWFwAAEDZW52DV9fc3lzX2ZzdGF0NjQAAQNlbnYMX19zeXNfc3RhdDY0AAEWd2FzaV9zbmFwc2hvdF9wcmV2aWV3MQhmZF93cml0ZQAEFndhc2lfc25hcHNob3RfcHJldmlldzEIZmRfY2xvc2UAAgNlbnYRX19zeXNfZnRydW5jYXRlNjQABANlbnYKX19zeXNfcmVhZAAAFndhc2lfc25hcHNob3RfcHJldmlldzENZmRfZmRzdGF0X2dldAABA2VudgVhYm9ydAAOA2VudhVfZW1iaW5kX3JlZ2lzdGVyX3ZvaWQABQNlbnYVX2VtYmluZF9yZWdpc3Rlcl9ib29sAAsDZW52G19lbWJpbmRfcmVnaXN0ZXJfc3RkX3N0cmluZwAFA2VudhxfZW1iaW5kX3JlZ2lzdGVyX3N0ZF93c3RyaW5nAAgDZW52Fl9lbWJpbmRfcmVnaXN0ZXJfZW12YWwABQNlbnYYX2VtYmluZF9yZWdpc3Rlcl9pbnRlZ2VyAAsDZW52Fl9lbWJpbmRfcmVnaXN0ZXJfZmxvYXQACANlbnYcX2VtYmluZF9yZWdpc3Rlcl9tZW1vcnlfdmlldwAIA2VudhZlbXNjcmlwdGVuX3Jlc2l6ZV9oZWFwAAIDZW52FWVtc2NyaXB0ZW5fbWVtY3B5X2JpZwAAA2VudgtzZXRUZW1wUmV0MAAGFndhc2lfc25hcHNob3RfcHJldmlldzEHZmRfc2VlawAHA2VudgZtZW1vcnkCAYACgIACA2VudgV0YWJsZQFwAPYBA5gIlggDDggCAAUBAwICAAUBAwIBBgkCAQEGAQYBBgABAgEBAQICAQAAAAABAAUFBAEABAUAAgEAAAAAAAEBAQUAAAQEAAEBAQEBBAABAAAABAAFAAAAAQEAAAIBBAQAAQAHAgIFAAEABwQBAAABBQMGAAcEBwwCBAcFDAIBBgEBAQIBAgEBAgIBAAACAQAAAAAAAAABBAEAAAAEAAABAQAGBAEJAwYBAgECBg0GAQEEDwIjDwYPDQYPAgQEBAENAQEABgYBAQ0EBAYGBAAGBgQAGwICGwUCAgABAgEFCAEHBAAFAAAGBgkGCQUICBgCAgEGAQEBAQwFAAEBAgkEDAEIBAIBAgYGBQwGGQYFAQUBBQEFAQUGAQYGBgYIBAAECgEAECUGDAsJCxEFBQYCBgQFAQIGAgABAgIMAAAQDAcKBAoECgQEAAgKBAQTCgoKChUBBAQEBAQEBAAEAQIwLiwBKwQGAQYEAQAECAQBBAYBAgICAgICAhoICA4BAQIeAQgIABQCAgEAAB4CAQEcAgEBAQICAhwIFAYGAQAHBwcHAQQCBAACAAABBAEEAQQCAAICAAQCAgAEBAIAAAEBAAQHAAACBxAAAAAEBAQEBAQABAEEAQcYGQYBAgIABwEAAQEGBBoEAgEEAQcBAgIBAQQFBwECAgIEAgICAgIEAgICBQEAAgUFBgEIAggIAQEBAQEBAQQEBAcEDgIOAwMDAwMCAwMGAgYFBQUDAwMCBgMGBQIFAwMDAgYFBQUDAwMDAwMCAwYDAwMDAwIDBgIFAwMDAgMGAwMBAgMBAgMIBQUFBQUFBQUFBQUFBQUFCAEBAgICAgIBAgIDBwICAwACAgACAAIHAgcCBwICAwwCBwMfHwABAwIFBQMBAgUDAgICAgICAgICAgICBQICAgEAAgUFBQAFAgIGAQEICAICCAgFAQMCAgMDAwECAQMCAQIDAgECAwIDAwMCAgMCAwIBAwIDAwMCAwIDAgMCAwMDAgIDAgMDAwICAwIDAgMDAwIDAgEDAwMFAgMAAwMDAwMDAwMDAw4CAgMAAiYBBQEXAAIAAAEAAgMAAwEyBxMIAgkLHS0dFjEAAAAEAAkLBREFAggAAAICAQEBAQEBAAINFwAAAgICAgIBAgEGCAIDAwMDAwICAgICBgIGBgAAAQIABAkJCQkJAAABAQsJCwoLCwsKCgoCAg4DAwYGBgYGBgYGBgYGAwMDAwMGBgYGBgYGBgYGBgMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMOAgMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDDgIGAQEBAQEFAgAAAAIBAAQCBQMCBgIBBAACBQcMEycpCAkRKC8qCgsEEAwHFAYQAn8BQZDMwwILfwBB8MoDCweQBCARX193YXNtX2NhbGxfY3RvcnMAKAZtYWxsb2MAkAgEZnJlZQCRCAZtZW1zZXQAmggQX19lcnJub19sb2NhdGlvbgC4BghzZXRUaHJldwChCA1fX2dldFR5cGVOYW1lAKYHKl9fZW1iaW5kX3JlZ2lzdGVyX25hdGl2ZV9hbmRfYnVpbHRpbl90eXBlcwCnBwhtZW1hbGlnbgCVCApfX2RhdGFfZW5kAwEJc3RhY2tTYXZlAKIICnN0YWNrQWxsb2MAowgMc3RhY2tSZXN0b3JlAKQIEF9fZ3Jvd1dhc21NZW1vcnkApQgKZHluQ2FsbF9paQCmCAxkeW5DYWxsX2lpaWkApwgLZHluQ2FsbF9paWkAqAgJZHluQ2FsbF9pAKkICmR5bkNhbGxfdmkAqggNZHluQ2FsbF9paWlpaQCrCA5keW5DYWxsX2lpaWlpaQCsCA9keW5DYWxsX2lpaWlpaWkArQgLZHluQ2FsbF9paWoAuAgPZHluQ2FsbF9paWpqaWlpALkIC2R5bkNhbGxfdmlpALAIDGR5bkNhbGxfdmlpaQCxCA9keW5DYWxsX3ZpaWlpaWkAsggMZHluQ2FsbF9paWpqALoIDGR5bkNhbGxfamlqaQC7CA9keW5DYWxsX2lpZGlpaWkAtQgOZHluQ2FsbF92aWlpaWkAtggNZHluQ2FsbF92aWlpaQC3CAnnAwEAQQEL9QEqKy0uMDEzNIEBgwF7fIgBigGeAZ8BoAGhAaIBowGkAaUBpgGnAagBqQGqAasBrAGtAa4BrwGwAbEBsgGzAbQBtQG2AbcBuAG5AboBuwG8Ab0BvgG/AcABwQHCAcMBxAHFAZUBlwGWAZQBmAGbAZ0BzgHPAdAB0QHSAdMB1gHXAdgB2QHaAdsB5gHnAegB6QHqAesB5AHKAe0B7gHvAfEB8gHzAeUB7AHwAfEBngOfA4QChQKVApYCmAKlAqcCpgKsArACsQKyArMCtAK1ArYCtwLAAoQC0wLpAuoC5gLvAvAC4gLkAusC8QLyAvMC0wL0AvcC4wLnAuUC+AL5AvoC7QL0A/YDkATDBMYExwSlAsoEzwTQBNEEpQLUBNkExgTHBKUC3ATkBNAE5QTsBNAE7QTvBPQE0AT1BPkEowSnBPwE/wSoBMcBnASdBJ4EnwSyBLMEtAS1BLYEtwS4BLkEugTsBe8F8wX7Be8FgAbsBe8F8wX9Af0B+wX9Af0B+wXvBfsFowaUBZcFmwWfBZ8FogWkBaYFqAWqBa4FsAWEB8EGwAa/BtUG2Qb9AcMBgweIB4kHigfHBYsH8QHxAYwHiweQB6QHoQeTB4sHowegB5QHiweiB50HlgeLB5gH9AcK/eQSlggGAEHwygMLCAAQtQYQjwgLPgEBfyMAQRBrIgMkACADIAE2AgggAyACNgIEIAMgADYCAEG0qgIoAgBBgAggAxDCBhpBBhAAGiADQRBqJAALQQAgAEUEQEGcCUGnCUHrARApCyAAQoHGlLqW8ermbzcDCCAAQgA3AwAgAEEANgIYIABC/rnrxemOlZkQNwMQQQAL8gEBA38gAEUEQEGcCUGnCUH8ARApCyABRQRAQZcKQacJQfwBECkLQRAhBCAAKAIYIgNBwABNBH8CQCACRQ0AIABBHGohBQNAAkACQCACQcAASQ0AIAMNACAAIAEQLCAAIAApAwBCgAR8NwMAIAJBQGohAiABQUBrIQEMAQsgAyAFaiABIAJBwAAgA2siAyACIANJGyIDEJkIGiAAIAAoAhggA2oiBDYCGCACIANrIQIgASADaiEBIARBwABHDQAgACAFECwgAEEANgIYIAAgACkDAEKABHw3AwALIAJFDQEgACgCGCEDDAAACwALQQAFIAQLC44QARt/IwBBQGohA0EAIQUDQCADIAVBAnQiAmogASACaigAADYCACAFQQFqIgVBEEcNAAsgACADKAIQIgggAygCICIJIAMoAjAiCiADKAIAIgsgAygCJCIMIAMoAjQiDSADKAIEIg4gAygCFCIPIA0gDCAPIA4gCiAJIAggCyAAKAIIIhlqIABBDGoiGigCACIFIABBFGoiGygCACIQIABBEGoiHCgCACIGc3EgEHNqQfjIqrt9akEHdyAFaiICaiAFIAMoAgwiEWogBiADKAIIIhJqIA4gEGogAiAFIAZzcSAGc2pB1u6exn5qQQx3IAJqIgEgAiAFc3EgBXNqQdvhgaECakERdyABaiIAIAEgAnNxIAJzakHunfeNfGpBFncgAGoiAiAAIAFzcSABc2pBr5/wq39qQQd3IAJqIgRqIAMoAhwiEyACaiADKAIYIhQgAGogASAPaiAEIAAgAnNxIABzakGqjJ+8BGpBDHcgBGoiASACIARzcSACc2pBk4zBwXpqQRF3IAFqIgIgASAEc3EgBHNqQYGqmmpqQRZ3IAJqIgAgASACc3EgAXNqQdixgswGakEHdyAAaiIEaiADKAIsIhUgAGogAygCKCIWIAJqIAEgDGogBCAAIAJzcSACc2pBr++T2nhqQQx3IARqIgIgACAEc3EgAHNqQbG3fWpB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ACEIQQAhAQNAIAMgACgCACAGKAIAayABaiIBQf////8AcTYCACADQQRqIQMgBkEEaiEGIABBBGohACABQR91IQEgCEEBaiIIIARHDQALCyAEIAVIBEADQCADIAEgACgCAGoiAUH/////AHE2AgAgA0EEaiEDIABBBGohACABQR91IQEgBEEBaiIEIAVHDQALCyAHIAVKBEAgA0EAIAcgBWtBAnQQmggaCyACEEBBACEDCyADC1EBAn8gACgCCCIDIAEoAggiBEYEQCACIAM2AgggACABIAIQWw8LIAAgARBEQX9GBEAgAiAENgIIIAEgACACEFwPCyACIAM2AgggACABIAIQXAtQAQF/IAAoAggiAyABKAIIRwRAIAIgAzYCCCAAIAEgAhBbDwsgACABEERBf0cEQCACIAM2AgggACABIAIQXA8LIAIgA0U2AgggASAAIAIQXAuSAQEEfyMAQRBrIgIkACACIAE2AgxBACEFAkAgAEUNACAAIQNBACEEA0AgAxA5BEAgAiABNgIIIAQEQANAIAAQPCACIAIoAggiA0EEajYCCCADKAIAIQAgBEF/aiIEDQALC0F+IQUMAgsgAiACKAIMIgNBBGo2AgwgBEEBaiEEIAMoAgAiAw0ACwsgAkEQaiQAIAUL5QEBCH8CQCABKAIEIAAoAgAiAkwEQCABIAJBAWoQOiIDDQEgACgCACECCyABKAIAIQYgASACNgIAIAEoAgwhBwJAIAAoAgAiCUEBSA0AIAAoAgwhBUEAIQQgByEDQQAhCANAIAMgBCAFKAIAIgRBAXRB/v///wBxcjYCACADQQRqIQMgBUEEaiEFIARBG3YhBCAIQQFqIgggCUcNAAsgBEUNACADQQE2AgAgASACQQFqIgI2AgALIAYgAkoEQCAHIAJBAnRqQQAgBiACa0ECdBCaCBoLIAEgACgCCDYCCEEAIQMLIAMLygEBCH8CQCABKAIEIAAoAgAiAkgEQCABIAIQOiIDDQEgACgCACECCyABKAIAIQUgASACNgIAIAJBAnQiAyABKAIMaiEGIAJBAU4EQCAAKAIMIANqIQdBACEIIAYhCSACIQMDQCAJQXxqIgkgCEEbdCAHQXxqIgcoAgAiBEEBdnI2AgAgBEEBcSEIIANBAUohBCADQX9qIQMgBA0ACwsgBSACSgRAIAZBACAFIAJrQQJ0EJoIGgsgASAAKAIINgIIIAEQQEEAIQMLIAMLPwEBfyMAQRBrIgIkACACIAE2AgwgAARAA0AgABA8IAIgAigCDCIAQQRqNgIMIAAoAgAiAA0ACwsgAkEQaiQAC/EMAQR/IwBB0AJrIgMkACADQQA2AnAgAyADQdABajYCUCADIANBwAFqNgJUIAMgA0GwAWo2AlggAyADQaABajYCXCADIANBkAFqNgJgIAMgA0GAAWo2AmQgAyADQfABajYCaCADIANB4AFqNgJsIAMgA0GwAmo2AkAgAyADQaACajYCRCADIANBkAJqNgJIIAMgA0GAAmo2AkwgA0HAAmogA0FAaxBfIgRFBEACQCAAIAAoAgAiBCABKAIAIgUgBCAFSBtBA20iBUEcbCIGIANB0AFqEE8iBA0AIAAgA0HAAWoQOyIEDQAgA0HAAWogBRBQIANBwAFqIAYgA0HAAWoQTxogACADQbABahA7IgQNACADQbABaiAFQQF0IgAQUCABIAYgA0GgAWoQTyIEDQAgASADQZABahA7IgQNACADQZABaiAFEFAgA0GQAWogBiADQZABahBPGiABIANBgAFqEDsiBA0AIANBgAFqIAAQUCADQdABaiADQaABaiADQcACahBnIgQNACADQbABaiADQYABaiADQYACahBnIgQNACADQdABaiADQfABahBgIgQNACADQfABaiADQcABaiADQfABahBdIgQNACADQfABaiADQfABahBgIgQNACADQfABaiADQbABaiADQfABahBdIgQNACADQaABaiADQeABahBgIgQNACADQeABaiADQZABaiADQeABahBdIgQNACADQeABaiADQeABahBgIgQNACADQeABaiADQYABaiADQeABahBdIgQNACADQfABaiADQeABaiADQbACahBnIgQNACADQbABaiADQfABahBgIgQNACADQfABaiADQcABaiADQfABahBdIgQNACADQfABaiADQfABahBgIgQNACADQfABaiADQdABaiADQfABahBdIgQNACADQYABaiADQeABahBgIgQNACADQeABaiADQZABaiADQeABahBdIgQNACADQeABaiADQeABahBgIgQNACADQeABaiADQaABaiADQeABahBdIgQNACADQfABaiADQeABaiADQZACahBnIgQNACADQbABaiADQcABaiADQfABahBdIgQNACADQfABaiADQdABaiADQfABahBdIgQNACADQYABaiADQZABaiADQeABahBdIgQNACADQeABaiADQaABaiADQeABahBdIgQNACADQfABaiADQeABaiADQaACahBnIgQNACADQbACaiADQYACaiADQbACahBeIgQNACADQZACaiADQcACaiADQZACahBeIgQNACADQbACaiADQbACahBhIgQNACADQZACaiADQZACahBhIgQNACADQaACaiADQcACaiADQaACahBeIgQNACADQaACaiADQYACaiADQaACahBeIgQNACADQbACaiADQaACaiADQbACahBeIgQNACADQZACaiADQaACaiADQZACahBeIgQNACADQcACakEDIANB8AFqEEEiBA0AIANBsAJqIANB8AFqIANBsAJqEF4iBA0AIANBgAJqQQMgA0HwAWoQQSIEDQAgA0GQAmogA0HwAWogA0GQAmoQXiIEDQAgA0GgAmpBAyADQaACahBKIgQNACADQaACaiADQbACaiADQaACahBeIgQNACADQaACaiADQZACaiADQaACahBeIgQNACADQbACaiADQaACaiADQbACahBeIgQNACADQZACaiADQaACaiADQZACahBeIgQNACADQbACaiADQbACakEAEFQiBA0AIANBkAJqIANBkAJqQQAQVCIEDQAgA0GwAmogBRA/IgQNACADQaACaiAAED8iBA0AIANBkAJqIAVBA2wQPyIEDQAgA0GAAmogBUECdBA/IgQNACADQcACaiADQbACaiACEF0iBA0AIANBoAJqIANBkAJqIANB8AFqEF0iBA0AIANBgAJqIANB8AFqIANB8AFqEF0iBA0AIANB8AFqIAIgAhBdIQQLIANBADYCMCADIANB4AFqNgIsIAMgA0HwAWo2AiggAyADQYABajYCJCADIANBkAFqNgIgIAMgA0GgAWo2AhwgAyADQbABajYCGCADIANBwAFqNgIUIAMgA0HQAWo2AhAgAyADQYACajYCDCADIANBkAJqNgIIIAMgA0GgAmo2AgQgAyADQbACajYCACADQcACaiADEGILIANB0AJqJAAgBAvQBQEJfyMAQfAAayIDJABBfiEEIANB4ABqIAAoAgAiBSABKAIAIgYgBSAGSBsiBkEBdSIFEFNFBEBB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AGogBEEBdCIAEFAgAkGAAWogAkHgAWoQbCIDDQAgAkHgAGogAkGgAWoQbCIDDQAgAkGAAWogAkGQAWoQYCIDDQAgAkGQAWogAkHwAGogAkGQAWoQXSIDDQAgAkGQAWogAkGQAWoQYCIDDQAgAkGQAWogAkHgAGogAkGQAWoQXSIDDQAgAkGQAWogAkHQAWoQbCIDDQAgAkHgAGogAkGQAWoQYCIDDQAgAkGQAWogAkHwAGogAkGQAWoQXSIDDQAgAkGQAWogAkGQAWoQYCIDDQAgAkGQAWogAkGAAWogAkGQAWoQXSIDDQAgAkGQAWogAkGwAWoQbCIDDQAgAkHgAGogAkHwAGogAkGQAWoQXSIDDQAgAkGQAWogAkGAAWogAkGQAWoQXSIDDQAgAkGQAWogAkHAAWoQbCIDDQAgAkHQAWogAkGgAWogAkHQAWoQXiIDDQAgAkGwAWogAkHgAWogAkGwAWoQXiIDDQAgAkHQAWogAkHQAWoQYSIDDQAgAkGwAWogAkGwAWoQYSIDDQAgAkHAAWogAkHgAWogAkHAAWoQXiIDDQAgAkHAAWogAkGgAWogAkHAAWoQXiIDDQAgAkHQAWogAkHAAWogAkHQAWoQXiIDDQAgAkGwAWogAkHAAWogAkGwAWoQXiIDDQAgAkHgAWpBAyACQZABahBBIgMNACACQdABaiACQZABaiACQdABahBeIgMNACACQaABakEDIAJBkAFqEEEiAw0AIAJBsAFqIAJBkAFqIAJBsAFqEF4iAw0AIAJBwAFqQQMgAkHAAWoQSiIDDQAgAkHAAWogAkHQAWogAkHAAWoQXiIDDQAgAkHAAWogAkGwAWogAkHAAWoQXiIDDQAgAkHQAWogAkHAAWogAkHQAWoQXiIDDQAgAkGwAWogAkHAAWogAkGwAWoQXiIDDQAgAkHQAWogAkHQAWpBABBUIgMNACACQbABaiACQbABakEAEFQiAw0AIAJB0AFqIAQQPyIDDQAgAkHAAWogABA/IgMNACACQbABaiAEQQNsED8iAw0AIAJBoAFqIARBAnQQPyIDDQAgAkHgAWogAkHQAWogARBdIgMNACACQcABaiACQbABaiACQZABahBdIgMNACACQaABaiACQZABaiACQZABahBdIgMNACACQZABaiABIAEQXSEDCyACQQA2AiAgAiACQZAB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PAsgBEHQAGokACAFCwwAIAAgAUEAIAIQVQskAAJAIAAgAUcEQCAAIAEQOyIADQELQQAhACABQQA2AggLIAALygIBA38jAEEgayIDJAACQCAAKAIARQRAIAEgAhBvIQAMAQsgASgCAEUEQCAAIAIQbyEADAELIANBEGogABBOIgANACADIAEQTiIARQRAIANBADYCGCADQQA2AggCQCADQRBqEEgiASADEEgiBSABIAVIGyIEQQFOBEAgA0EQaiAEIANBEGpBABBSIgANASADIAQgA0EAEFIiAA0BCyABIAVKBEAgA0EQaiABIARrIANBEGpBABBSIgANAQsgASAFSARAIAMgBSAEayADQQAQUiIADQELA0AgAygCAARAIANBEGogAxBEQQFGBEAgA0EQaiADEFELIAMgA0EQaiADEFwiAA0CIAMgAxBIIANBABBSIgBFDQEMAgsLIANBEGogBCACEEEiAA0AQQAhACACQQA2AggLIANBEGoQPAsgAxA8CyADQSBqJAAgAAu5AQECfyMAQUBqIgMkACADQQA2AhQgAyADQSBqNgIQIANBMGogA0EQahBfIgRFBEACQCAAIAEgA0EwahBwIgQNAAJAIAAgARBEQX9GBEAgACADQTBqIANBIGpBABBtIgRFDQEMAgsgASADQTBqIANBIGpBABBtIQQgACEBIAQNAQsgASADQSBqIAIQZyEEIAJBADYCCAsgA0EANgIEIAMgA0EgajYCACADQTBqIAMQYgsgA0FAayQAIAQLWQECfyMAQRBrIgMkACADEDkiBEUEQAJAIAAgAUEAIAMQbSIEDQAgAygCCCABKAIIRwRAIAEgAyACEF0hBAwBCyADIAIQUUEAIQQLIAMQPAsgA0EQaiQAIAQLPAECfyMAQRBrIgQkACAEEDkiBUUEQCAAIAEgBBBnIgVFBEAgBCACIAMQciEFCyAEEDwLIARBEGokACAFCzoBAn8jAEEQayIDJAAgAxA5IgRFBEAgACADEGwiBEUEQCADIAEgAhByIQQLIAMQPAsgA0EQaiQAIAQLIwAgABA+IAAoAgwgAUH/////AHEiATYCACAAIAFBAEc2AgAL0QUBAn8jAEGgAWsiAyQAAkAgASgCAEEBTgRAQX0hBCABKAIMLQAAQQFxRQ0BCyADQQA2AjQgAyADQUBrNgIwIAMgA0HQAGo2AiwgAyADQeAAajYCKCADIANB8ABqNgIkIAMgA0GAAWo2AiAgA0GQAWogA0EgahBfIgQNAAJAIAEgA0GQAWoQOyIEDQAgACABIANBgAFqEHIiBA0AIANBkAFqIANB8ABqEDsiBA0AIANBgAFqIANB4ABqEDsiBA0AIANBQGtBARB1A0ACQCADKAJwQQBMDQAgAygCfC0AAEEBcQ0AIANB8ABqIANB8ABqEGEiBA0CAkAgAygCUEEBSA0AIAMoAlwtAABBAXFFDQAgA0HQAGogA0GQAWogA0HQAGoQXiIEDQMLIANB0ABqIANB0ABqEGEiBEUNAQwCCwNAAkAgAygCYEEBSA0AIAMoAmwtAABBAXENACADQeAAaiADQeAAahBhIgQNAwJAIAMoAkBBAUgNACADKAJMLQAAQQFxRQ0AIANBQGsgA0GQAWogA0FAaxBeIgQNBAsgA0FAayADQUBrEGEiBEUNAQwDCwsCQCADQfAAaiADQeAAahBFQX9HBEAgA0HwAGogA0HgAGogA0HwAGoQXiIEDQMgA0HQAGogA0FAayADQdAAahBeIgRFDQEMAwsgA0HgAGogA0HwAGogA0HgAGoQXiIEDQIgA0FAayADQdAAaiADQUBrEF4iBA0CCyADKAJwDQALQX0hBCADQeAAakEBEEYNACAAKAIIIQADQCADKAJIQQFGBEAgA0FAayABIANBQGsQXSIERQ0BDAILCyADQUBrIAIQUSACIAA2AghBACEECyADQQA2AhQgAyADQUBrNgIQIAMgA0HQAGo2AgwgAyADQeAAajYCCCADIANB8ABqNgIEIAMgA0GAAWo2AgAgA0GQAWogAxBiCyADQaABaiQAIAQLnQgBAn8jAEHAAWsiAyQAQX0hBAJAIAEoAghBAUYNACABKAIARQ0AIANBADYCPCADIANBQGs2AjggAyADQdAAajYCNCADIANB4ABqNgIwIAMgA0HwAGo2AiwgAyADQYABajYCKCADIANBkAFqNgIkIAMgA0GgAWo2AiAgA0GwAWogA0EgahBfIgQNAAJAIAAgASADQbABahByIgQNACABIANBoAFqEDsiBA0AAkAgAygCsAFBAUgNACADKAK8AS0AAEEBcQ0AIAMoAqABQQFIDQBBfSEEIAMoAqwBLQAAQQFxRQ0BCyADQbABaiADQZABahA7IgQNACADQaABaiADQYABahA7IgQNACADQfAAakEBEHUgA0FAa0EBEHUDQAJAIAMoApABQQBMDQAgAygCnAEtAABBAXENACADQZABaiADQZABahBhIgQNAgJAAkAgAygCcEEBTgRAIAMoAnwtAABBAXENAQsgAygCYEEBSA0BIAMoAmwtAABBAXFFDQELIANB8ABqIANBoAFqIANB8ABqEF0iBA0DIANB4ABqIANBsAFqIANB4ABqEF4iBA0DCyADQfAAaiADQfAAahBhIgQNAiADQeAAaiADQeAAahBhIgRFDQEMAgsDQAJAIAMoAoABQQFIDQAgAygCjAEtAABBAXENACADQYABaiADQYABahBhIgQNAwJAAkAgAygCUEEBTgRAIAMoAlwtAABBAXENAQsgAygCQEEBSA0BIAMoAkwtAABBAXFFDQELIANB0ABqIANBoAFqIANB0ABqEF0iBA0EIANBQGsgA0GwAWogA0FAaxBeIgQNBAsgA0HQAGogA0HQAGoQYSIEDQMgA0FAayADQUBrEGEiBEUNAQwDCwsCQCADQZABaiADQYABahBFQX9HBEAgA0GQAWogA0GAAWogA0GQAWoQXiIEDQMgA0HwAGogA0HQAGogA0HwAGoQXiIEDQMgA0HgAGogA0FAayADQeAAahBeIgRFDQEMAwsgA0GAAWogA0GQAWogA0GAAWoQXiIEDQIgA0HQAGogA0HwAGogA0HQAGoQXiIEDQIgA0FAayADQeAAaiADQUBrEF4iBA0CCyADKAKQAQ0AC0F9IQQgA0GAAWpBARBGDQADQCADQdAAakEAEEZBf0cEQANAIANB0ABqIAEQREF/RwRAIANB0ABqIAEgA0HQAGoQXiIERQ0BDAQLCyADQdAAaiACEFFBACEEDAILIANB0ABqIAEgA0HQAGoQXSIERQ0ACwsgA0EANgIcIAMgA0FAazYCGCADIANB0ABqNgIUIAMgA0HgAGo2AhAgAyADQfAAajYCDCADIANBgAFqNgIIIAMgA0GQAWo2AgQgAyADQaABajYCACADQbABaiADEGILIANBwAFqJAAgBAtMAQJ/QX0hAwJAIAEoAghBAUYNACABKAIAIgRFDQACQCAEQQFIDQAgASgCDC0AAEEBcUUNACAAIAEgAhB2DwsgACABIAIQdyEDCyADC1gBAX9BfSECIAAoAgwoAgAi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IQAMAQtBAiEACyAAQQN0QcQoaigCACECCyACCxcAIABFBEBBuCdBwidB4wAQKQsgABBDCz8BAX8gAEUEQEG4J0HCJ0HqABApC0EAIQICQCABQQBIDQAgACgCACABTA0AIAAoAgwgAUECdGooAgAhAgsgAgsYACAARQRAQbgnQcInQfIAECkLIAAoAgALNwAgAEUEQEG4J0HCJ0H6ABApCyABRQRAQegoQcInQfsAECkLIAAgARBFIgBBACAAQQFqQQNJGwsmACAARQRAQbgnQcInQYgBECkLIAAgARBGIgBBACAAQQFqQQNJGwsXACAARQRAQbgnQcInQZQBECkLIAAQRwsXACAARQRAQbgnQcInQZoBECkLIAAQSAtcAQF/IABFBEBBuCdBwidBoQEQKQtBASECAkAgACABEEkiAEEDaiIBQQNLDQACQAJAAkAgAUEBaw4DAAMCAQtBASEADAELQQIhAAsgAEEDdEHEKGooAgAhAgsgAgtvAQF/IABFBEBBuCdBwidBqgEQKQsgAUUEQEHoKEHCJ0GrARApC0EBIQMCQCAAIAEgAhBNIgBBA2oiAUEDSw0AAkACQAJAIAFBAWsOAwADAgELQQEhAAwBC0ECIQALIABBA3RBxChqKAIAIQMLIAMLbwEBfyAARQRAQbgnQcInQbIBECkLIAFFBEBB6ChBwidBswEQKQtBASEDAkAgACABIAIQVyIAQQNqIgFBA0sNAAJAAkACQCABQQFrDgMAAwIBC0EBIQAMAQtBAiEACyAAQQN0QcQoaigCACEDCyADCxcAIABFBEBBuCdBwidBugEQKQsgABBYC20BAX8gAEUEQEG4J0HCJ0HBARApCyABRQRAQegoQcInQcIBECkLQQEhAgJAIAAgARBZIgBBA2oiAUEDSw0AAkACQAJAIAFBAWsOAwADAgELQQEhAAwBC0ECIQALIABBA3RBxChqKAIAIQILIAILbwEBfyAARQRAQbgnQcInQckBECkLIAFFBEBB6ChBwidBygEQKQtBASEDAkAgACABIAIQWiIAQQNqIgFBA0sNAAJAAkACQCABQQFrDgMAAwIBC0EBIQAMAQtBAiEACyAAQQN0QcQoaigCACEDCyADC4ABAQF/IABFBEBBuCdBwidB0QEQKQsgAUUEQEHoKEHCJ0HSARApCyACRQRAQfIoQcInQdMB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AAsgAiAEKAIANgIAIAEgBCgCACIDKAIENgIAIAMgAjYCBCAEIAI2AgALIAVBAWoiBUGAAkcNAAsgACAAKALIYCIBQQFqIgU2AshgIAAgAUEYbGoiAigCACIDBEAgAigCBCIEIAM2AgAgAigCACAENgIEIAJBADYCBCACQQA2AgALIAIgBjYCACACIAAoAtBgIgM2AgQgAyACNgIAIAAgAjYC0GAgAkIANwIQIAJCgIKAgBA3AgggACABQQJqIgE2AshgIABB1OgAaiACNgIAIAAgBUEYbGoiAygCACIEBEAgACAFQRhsaiICKAIEIgcgBDYCACADKAIAIAc2AgQgAkEANgIEIANBADYCACAAKALQYCECCyADIAY2AgAgACAFQRhsaiIFIAI2AgQgAiADNgIAIAAgAzYC0GAgBUIANwIQIAVCgYKAgBA3AgggAEHY6ABqIAM2AgACQCAAKALQYCIKIAZGDQAgCiECA0AgAigCBCIFIAZGDQEgAigCDCEDIAUoAgwhBCAAIAFBAWoiBzYCyGAgAyAEaiEDIAAgAUEYbGoiASgCACIEBEAgASgCBCIIIAQ2AgAgASgCACAINgIEIAFBADYCBCABQQA2AgALIAEgACgCzGAiBDYCACABIAQoAgQ2AgQgBCABNgIEIAAgATYCzGAgAUEANgIQIAEgAzYCDCABQQA2AgggAiABNgIQIAUgATYCECABIAI2AhQCQCADIAlPBEAgAyEJDAELAkAgCiICBEADQCACKAIMIANPDQIgAigCBCICIAZHDQALCyAGIQILIAFBBGohAyAEBEAgAygCACIIIAQ2AgAgASgCACAINgIEIANBADYCACABQQA2AgALIAEgAigCADYCACADIAIoAgAiBCgCBDYCACAEIAE2AgQgAiABNgIACyAHIQEgBSgCBCICIAZHDQALCyAAQQE2Atx0QQEFIAILC9UCAQV/IAEEQCAAQczgAGohBQNAIAEgASgCDEEBaiIDNgIMAkAgASgCBCICBEAgAiAFIgRGDQEDQCACKAIMIANPBEAgAiEEDAMLIAIoAgQiAiAFRw0ACwsgBSEECyABIAQoAgAiAkcEQCACKAIAIgMEQCACKAIEIgYgAzYCACACKAIAIAY2AgQgAkIANwIACyACIAEoAgA2AgAgAiABKAIAIgMoAgQ2AgQgAyACNgIEIAEg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BCAEIAZLGyICBEAgACgCOCAHaiAFaiEFIAEgBCACazYCBAJAIAEoAhwoAhhBf2oiBEEBSw0AIARBAWsEQCABIAEoAjAgASgCACACEIcCNgIwDAELIAEgASgCMCABKAIAIAIQhgI2AjALIAUgASgCACACEJkIGiABIAEoAgAgAmo2AgAgASABKAIIIAJqNgIIIAAoAnQhBQsgACACIAVqIgE2AnQCQCABQQNPBEAgACAAKAI4IAAoAmxqIgItAAAiBDYCSCAAIAAoAlQgAi0AASAEIAAoAlh0c3E2AkggAUGFAksNAQsgACgCACgCBEUNACAAKAIsIQIMAQsLIAAoAjwiAiAAKALALSIDTQ0AIAMgACgCbCABaiIBSQRAIAAoAjggAWpBACACIAFrIgNBggIgA0GCAkkbIgMQmggaIAAgASADajYCwC0PCyABQYICaiIBIANNDQAgACgCOCADakEAIAIgA2siAiABIANrIgEgASACSxsiARCaCBogACAAKALALSABajYCwC0LC5MGAQV/IAAoAgxBe2oiAkH//wMgAkH//wNJGyEFAkADQCAAKAJ0IgJBAU0EQCAAEJQCIAAoAnQiAiABckUEQEEADwsgAkUNAgsgAEEANgJ0IAAgACgCbCACaiICNgJsIAJBACACIAAoAlwiAyAFaiIESRsEfyACBSAAIAQ2AmwgACACIARrNgJ0QQAhAiAAIANBAE4EfyAAKAI4IANqBSACCyAFQQAQjAIgACAAKAJsNgJcAkAgACgCACICKAIQIgMgAigCHCIGKAIUIgQgBCADSxsiA0UNACACKAIMIAYoAhAgAxCZCBogAiACKAIMIANqNgIMIAIoAhwiBCAEKAIQIANqNgIQIAIgAigCFCADajYCFCACIAIoAhAgA2s2AhAgBCAEKAIUIANrIgI2AhQgAg0AIAQgBCgCCDYCEAsgACgCACgCEEUEQEEADwsgACgCXCEDIAAoAmwLIANrIgIgACgCLEH6fWpJDQBBACEEIAAgA0EATgR/IAAoAjggA2oFIAQLIAJBABCMAiAAIAAoAmw2AlwCQCAAKAIAIgIoAhAiAyACKAIcIgYoAhQiBCAEIANLGyIDRQ0AIAIoAgwgBigCECADEJkIGiACIAIoAgwgA2o2AgwgAigCHCIEIAQoAhAgA2o2AhAgAiACKAIUIANqNgIUIAIgAigCECADazYCECAEIAQoAhQgA2siAjYCFCACDQAgBCAEKAIINgIQCyAAKAIAKAIQDQALQQAPC0EAIQIgACAAKAJcIgNBAE4EfyAAKAI4IANqBSACCyAAKAJsIANrIAFBBEYQjAIgACAAKAJsNgJcAkAgACgCACICKAIQIgMgAigCHCIFKAIUIgQgBCADSxsiA0UNACACKAIMIAUoAhAgAxCZCBogAiACKAIMIANqNgIMIAIoAhwiBCAEKAIQIANqNgIQIAIgAigCFCADajYCFCACIAIoAhAgA2s2AhAgBCAEKAIUIANrIgI2AhQgAg0AIAQgBCgCCDYCEAsgACgCACgCEEUEQCABQQRGQQF0DwtBA0EBIAFBBEYbC98JAQx/AkADQAJAAkAgACgCdEGFAk0EQCAAEJQCIAAoAnQhAgJAIAENACACQYYCTw0AQQAPCyACRQ0EIAJBA0kNAQsgACAAKAJUIAAoAmwiAiAAKAI4ai0AAiAAKAJIIAAoAlh0c3EiAzYCSCAAKAJAIAIgACgCNHFBAXRqIAAoAkQgA0EBdGoiBC8BACIDOwEAIAQgAjsBACADRQ0AIAIgA2sgACgCLEH6fWpLDQAgACAAIAMQlwIiAjYCYAwBCyAAKAJgIQILAkAgAkEDTwRAIAAoAqQtIAAoAqAtIgNBAXRqIAAoAmwgACgCcGsiBDsBACAAIANBAWo2AqAtIAMgACgCmC1qIAJBfWoiAjoAACACQf8BcUHg+wBqLQAAQQJ0QYAIciAAakGYAWoiAiACLwEAQQFqOwEAIAAgBEF/akH//wNxIgIgAkEHdkGAAmogAkGAAkkbQeD3AGotAABBAnRqQYgTaiICIAIvAQBBAWo7AQAgACAAKAJ0IAAoAmAiAmsiAzYCdCAAKAKgLSAAKAKcLUF/akYhBgJAIANBA0kNACACIAAoAoABSw0AIAAgAkF/aiIDNgJgIAAoAkghBCAAKAJsIQIgACgCNCEHIAAoAkAhCCAAKAJEIQkgACgCVCEKIAAoAjghCyAAKAJYIQwDQCAAIAIiBUEBaiICNgJsIAAgBSALai0AAyAEIAx0cyAKcSIENgJIIAggAiAHcUEBdGogCSAEQQF0aiINLwEAOwEAIA0gAjsBACAAIANBf2oiAzYCYCADDQALIAAgBUECaiICNgJsDAILIABBADYCYCAAIAAoAmwgAmoiAjYCbCAAIAAoAjggAmoiAy0AACIENgJIIAAgACgCVCADLQABIAQgACgCWHRzcTYCSAwBCyAAKAI4IAAoAmxqLQAAIQIgACgCpC0gACgCoC0iA0EBdGpBADsBACAAIANBAWo2AqAtIAMgACgCmC1qIAI6AAAgACACQQJ0akGUAWoiAiACLwEAQQFqOwEAIAAgACgCdEF/ajYCdCAAIAAoAmxBAWoiAjYCbCAAKAKgLSAAKAKcLUF/akYhBgsgBkUNAEEAIQQgACAAKAJcIgNBAE4EfyAAKAI4IANqBSAECyACIANrQQAQjAIgACAAKAJsNgJcAkAgACgCACICKAIQIgMgAigCHCIFKAIUIgQgBCADSxsiA0UNACACKAIMIAUoAhAgAxCZCBogAiACKAIMIANqNgIMIAIoAhwiBCAEKAIQIANqNgIQIAIgAigCFCADajYCFCACIAIoAhAgA2s2AhAgBCAEKAIUIANrIgI2AhQgAg0AIAQgBCgCCDYCEAsgACgCACgCEA0AC0EADwtBACECIAAgACgCXCIDQQBOBH8gACgCOCADagUgAgsgACgCbCADayABQQRGEIwCIAAgACgCbDYCXAJAIAAoAgAiAigCECIDIAIoAhwiBSgCFCIEIAQgA0sbIgNFDQAgAigCDCAFKAIQIAMQmQgaIAIgAigCDCADajYCDCACKAIcIgQgBCgCECADajYCECACIAIoAhQgA2o2AhQgAiACKAIQIANrNgIQIAQgBCgCFCADayICNgIUIAINACAEIAQoAgg2AhALIAAoAgAoAhBFBEAgAUEERkEBdA8LQQNBASABQQRGGwujBAEQfyAAKAJ8IgMgA0ECdiAAKAJ4IgQgACgCjAFJGyEJQQAgACgCbCIDIAAoAixrQYYCaiICIAIgA0sbIQwgACgCdCIHIAAoApABIgIgAiAHSxshDSAAKAI4Ig4gA2oiBUGCAmohDyAEIAVqIgMtAAAhCiADQX9qLQAAIQsgACgCNCEQIAAoAkAhEQNAAkACQCABIA5qIgMgBGoiAi0AACAKRw0AIAJBf2otAAAgC0cNACADLQAAIAUtAABHDQBBAiEGIAMtAAEgBS0AAUcNAAJAAkACQAJAAkACQAJAA0AgBSAGaiICLQABIAMtAANGBEAgAi0AAiADLQAERw0CIAItAAMgAy0ABUcNAyACLQAEIAMtAAZHDQQgAi0ABSADLQAHRw0FIAItAAYgAy0ACEcNBiACLQAHIAMtAAlHDQcgBkH5AUshCCAFIAZBCGoiBmohAiAIDQggAy0ACiEIIANBCGohAyACLQAAIAhGDQEMCAsLIAJBAWohAgwGCyACQQJqIQIMBQsgAkEDaiECDAQLIAJBBGohAgwDCyACQQVqIQIMAgsgAkEGaiECDAELIAJBB2ohAgsgAiAPayICQYICaiIDIARMDQAgACABNgJwIAMgDU4EQCADIQQMAgsgAyAFai0AACEKIAIgBWotAIECIQsgAyEECyAMIBEgASAQcUEBdGovAQAiAU8NACAJQX9qIgkNAQsLIAcgBCAEIAdLGwuWDQEHfwNAAkACQAJAIAAoAnRBhQJLDQAgABCUAiAAKAJ0IQICQCABDQAgAkGGAk8NAEEADwsgAkUNAiACQQJLDQAgACAAKAJgIgI2AnggACAAKAJwNgJkQQIhAyAAQQI2AmAMAQtBAiEDIAAgACgCVCAAKAJsIgIgACgCOGotAAIgACgCSCAAKAJYdHNxIgQ2AkggACgCQCACIAAoAjRxQQF0aiAAKAJEIARBAXRqIgUvAQAiBDsBACAFIAI7AQAgACAAKAJgIgI2AnggACAAKAJwNgJkIABBAjYCYCAERQ0AQQIhAwJAIAIgACgCgAFPDQAgACgCbCAEayAAKAIsQfp9aksNACAAIAAgBBCXAiIDNgJgIANBBUsNACAAKAKIAUEBRwRAIANBA0cNAUEDIQMgACgCbCAAKAJwa0GBIEkNAQtBAiEDIABBAjYCYAsgACgCeCECCwJAIAJBA0kNACADIAJLDQAgACgCdCEEIAAoAqQtIAAoAqAtIgNBAXRqIAAoAmwiBSAAKAJkQf//A3NqIgY7AQAgACADQQFqNgKgLSADIAAoApgtaiACQX1qIgI6AAAgAkH/AXFB4PsAai0AAEECdEGACHIgAGpBmAFqIgIgAi8BAEEBajsBACAAIAZBf2pB//8DcSICIAJBB3ZBgAJqIAJBgAJJG0Hg9wBqLQAAQQJ0akGIE2oiAiACLwEAQQFqOwEAIAAgACgCeCICQX5qIgM2AnggACAAKAJ0IAJrQQFqNgJ0IAQgBWpBfWohBSAAKAKcLUF/aiEHIAAoAmwhAiAAKAKgLSEIA0AgACACIgRBAWoiAjYCbCACIAVNBEAgACAAKAJUIAQgACgCOGotAAMgACgCSCAAKAJYdHNxIgY2AkggACgCQCAAKAI0IAJxQQF0aiAAKAJEIAZBAXRqIgYvAQA7AQAgBiACOwEACyAAIANBf2oiAzYCeCADDQALIABBAjYCYCAAQQA2AmggACAEQQJqIgI2AmwgByAIRw0CQQAhAyAAIAAoAlwiBEEATgR/IAAoAjggBGoFIAMLIAIgBGtBABCMAiAAIAAoAmw2AlwCQCAAKAIAIgIoAhAiAyACKAIcIgUoAhQiBCAEIANLGyIDRQ0AIAIoAgwgBSgCECADEJkIGiACIAIoAgwgA2o2AgwgAigCHCIEIAQoAhAgA2o2AhAgAiACKAIUIANqNgIUIAIgAigCECADazYCECAEIAQoAhQgA2siAjYCFCACDQAgBCAEKAIINgIQCyAAKAIAKAIQDQJBAA8LIAAoAmgEQCAAKAJsIAAoAjhqQX9qLQAAIQIgACgCpC0gACgCoC0iA0EBdGpBADsBACAAIANBAWo2AqAtIAMgACgCmC1qIAI6AAAgACACQQJ0akGUAWoiAiACLwEAQQFqOwEAAkAgACgCoC0gACgCnC1Bf2pHDQBBACECIAAgACgCXCIDQQBOBH8gACgCOCADagUgAgsgACgCbCADa0EAEIwCIAAgACgCbDYCXCAAKAIAIgIoAhAiAyACKAIcIgUoAhQiBCAEIANLGyIDRQ0AIAIoAgwgBSgCECADEJkIGiACIAIoAgwgA2o2AgwgAigCHCIEIAQoAhAgA2o2AhAgAiACKAIUIANqNgIUIAIgAigCECADazYCECAEIAQoAhQgA2siAjYCFCACDQAgBCAEKAIINgIQCyAAIAAoAmxBAWo2AmwgACAAKAJ0QX9qNgJ0IAAoAgAoAhANAkEADwUgAEEBNgJoIAAgACgCbEEBajYCbCAAIAAoAnRBf2o2AnQMAgsACwsgACgCaARAIAAoAmwgACgCOGpBf2otAAAhAiAAKAKkLSAAKAKgLSIDQQF0akEAOwEAIAAgA0EBajYCoC0gAyAAKAKYLWogAjoAACAAIAJBAnRqQZQBaiICIAIvAQBBAWo7AQAgAEEANgJoC0EAIQIgACAAKAJcIgNBAE4EfyAAKAI4IANqBSACCyAAKAJsIANrIAFBBEYQjAIgACAAKAJsNgJcAkAgACgCACICKAIQIgMgAigCHCIFKAIUIgQgBCADSxsiA0UNACACKAIMIAUoAhAgAxCZCBogAiACKAIMIANqNgIMIAIoAhwiBCAEKAIQIANqNgIQIAIgAigCFCADajYCFCACIAIoAhAgA2s2AhAgBCAEKAIUIANrIgI2AhQgAg0AIAQgBCgCCDYCEAsgACgCACgCEEUEQCABQQRGQQF0DwtBA0EBIAFBBEYbC/0NARZ/IwBBQGoiBkIANwMwIAZCADcDOCAGQgA3AyAgBkIANwMoAkACQAJAAkACQCACBEBBACEIA0AgBkEgaiABIAhBAXRqLwEAQQF0aiIKIAovAQBBAWo7AQAgCEEBaiIIIAJHDQALIAQoAgAhCEEPIQogBi8BPiIMDQIMAQsgBCgCACEIC0EOIQpBACEMIAYvATwNAEENIQogBi8BOg0AQQwhCiAGLwE4DQBBCyEKIAYvATYNAEEKIQogBi8BNA0AQQkhCiAGLwEyDQBBCCEKIAYvATANAEEHIQogBi8BLg0AQQYhCiAGLwEsDQBBBSEKIAYvASoNAEEEIQogBi8BKA0AQQMhCiAGLwEmDQBBAiEKIAYvASQNACAGLwEiRQRAIAMgAygCACIIQQRqNgIAIAhBwAI2AQAgAyADKAIAIghBBGo2AgAgCEHAAjYBACAEQQE2AgAMAwtBACEMIAhBAEchD0EBIQpBASEIDAELIAogCCAIIApLGyEPQQEhCANAIAZBIGogCEEBdGovAQANASAIQQFqIgggCkcNAAsgCiEIC0F/IQkgBi8BIiIHQQJLDQFBBCAGLwEkIhogB0EBdGprIgtBAEgNASALQQF0IAYvASYiEGsiC0EASA0BIAtBAXQgBi8BKCIRayILQQBIDQEgC0EBdCAGLwEqIg1rIgtBAEgNASALQQF0IAYvASwiEmsiC0EASA0BIAtBAXQgBi8BLiIOayILQQBIDQEgC0EBdCAGLwEwIhdrIgtBAEgNASALQQF0IAYvATIiFGsiC0EASA0BIAtBAXQgBi8BNCIYayILQQBIDQEgC0EBdCAGLwE2IhVrIgtBAEgNASALQQF0IAYvATgiFmsiC0EASA0BIAtBAXQgBi8BOiITayILQQBIDQEgC0EBdCAGLwE8IhlrIgtBAEgNASALQQF0IAxrIgxBAEgNASAMBEAgAEUNAiAKQQFHDQILIA8gCEkhDEEAIQkgBkEAOwECIAYgBzsBBCAGIAcgGmoiBzsBBiAGIAcgEGoiBzsBCCAGIAcgEWoiBzsBCiAGIAcgDWoiBzsBDCAGIAcgEmoiBzsBDiAGIAcgDmoiBzsBECAGIAcgF2oiBzsBEiAGIAcgFGoiBzsBFCAGIAcgGGoiBzsBFiAGIAcgFWoiBzsBGCAGIAcgFmoiBzsBGiAGIAcgE2oiBzsBHCAGIAcgGWo7AR4gAgRAA0AgASAJQQF0ai8BACIHBEAgBiAHQQF0aiIHIAcvAQAiB0EBajsBACAFIAdBAXRqIAk7AQALIAlBAWoiCSACRw0ACwsgCCAPIAwbIQ5BASEJQQAhGQJAIABBAU0EQEETIRJBACEbIAUhFSAFIRYgAEEBaw0BQQEhCSAOQQlLDQNBgAIhEkGOigEhFkHOiQEhFUEAIRtBASEZDAELIABBAkYhG0F/IRJBkI8BIRZB0I4BIRUgAEECRw0AIA5BCUsNAgtBASAOdCITQX9qIRggAygCACEQQQAhESAOIQxBACENQQAhB0F/IRQDQEEBIAx0IRcDQCAIIA1rIQwCf0EAIBIgBSARQQF0ai8BACIASg0AGiASIABOBEBBACEAQeAADAELIBUgAEEBdCICai8BACEAIAIgFmotAAALIQ8gByANdiELQX8gDHQhGiAXIQIDQCAQIAIgGmoiAiALakECdGoiCSAAOwECIAkgDDoAASAJIA86AAAgAg0AC0EBIAhBf2p0IQkDQCAJIgJBAXYhCSACIAdxDQALIAZBIGogCEEBdGoiCSAJLwEAQX9qIgk7AQAgAkF/aiAHcSACakEAIAIbIQcgEUEBaiERIAlB//8DcUUEQCAIIApGBEAgBwRAA0ACQCANRQRAQQAhDQwBCyAHIBhxIBRGDQAgAygCACEQQQAhDSAOIgohDAsgECAHIA12QQJ0aiIIQQA7AQIgCCAMOgABIAhBwAA6AABBASAKQX9qdCEGA0AgBiIIQQF2IQYgByAIcQ0ACyAIQX9qIAdxIAhqQQAgCBsiBw0ACwsgAyADKAIAIBNBAnRqNgIAIAQgDjYCAAwECyABIAUgEUEBdGovAQBBAXRqLwEAIQgLIAggDk0NACAHIBhxIgIgFEYNAAtBASAIIA0gDiANGyINayIMdCEAIAggCkkEQCAKIA1rIQ8gCCEJAkADQCAAIAZBIGogCUEBdGovAQBrIglBAUgNASAJQQF0IQAgDEEBaiIMIA1qIgkgCkkNAAsgDyEMC0EBIAx0IQALQQEhCSAZIAAgE2oiE0HTBktxDQIgGyATQc8ES3ENAiADKAIAIgAgAkECdGoiCSAOOgABIAkgDDoAACAJIBAgF0ECdGoiECAAa0ECdjsBAiACIRQMAAALAAtBACEJCyAJC9QLARV/IAAoAgxBf2oiBCAAKAIQIgUgAWtqIREgACgCHCIJKAIwIgogCSgCKCISaiETIAkoAjRBf2ohDEF/IAkoAlh0QX9zIRRBfyAJKAJUdEF/cyEVIAQgBWpB/31qIQ0gACgCAEF/aiIIIAAoAgRqQXtqIQ4gCSgCUCEPIAkoAkwhECAJKAI8IQUgCSgCOCEBIAkoAiwhFgNAIAVBDk0EQCAILQABIAV0IAFqIAgtAAIgBUEIanRqIQEgBUEQaiEFIAhBAmohCAsgBSAQIAEgFXFBAnRqIgItAAEiA2shBSABIAN2IQEgAi8BAiEGAkACQAJAIAItAAAiAkUNACAJAn8CQAJAA0AgAkH/AXEhAyACQRBxBEAgBkH//wNxIQYCfyADQQ9xIgNFBEAgCCEHIAEMAQsCfyAFIANPBEAgBSECIAgMAQsgBUEIaiECIAgtAAEgBXQgAWohASAIQQFqCyEHIAIgA2shBSABQX8gA3RBf3NxIAZqIQYgASADdgshAiAFQQ5NBEAgBy0AASAFdCACaiAHLQACIAVBCGp0aiECIAVBEGohBSAHQQJqIQcLIAUgDyACIBRxQQJ0aiIILQABIgFrIQUgAiABdiEBIAgvAQIhAyAILQAAIgJBEHENAgNAIAJBwABxRQRAIAUgDyABQX8gAnRBf3NxIANB//8DcWpBAnRqIgItAAEiA2shBSABIAN2IQEgAi8BAiEDIAItAAAiAkEQcUUNAQwECwtB7o8BIQYgByEIDAMLIANBwABxRQRAIAUgECABQX8gA3RBf3NxIAZB//8DcWpBAnRqIgItAAEiA2shBSABIAN2IQEgAi8BAiEGIAItAAAiAkUNBQwBCwtBhJABIQZBCyADQSBxDQIaDAELIANB//8DcSELAn8gBSACQQ9xIgJPBEAgBSEDIAcMAQsgBy0AASAFdCABaiEBIAdBAWogBUEIaiIDIAJPDQAaIActAAIgA3QgAWohASAFQRBqIQMgB0ECagshCCABQX8gAnRBf3NxIQcgAyACayEFIAEgAnYhAQJAIAcgC2oiCyAEIBFrIgJLBEACQCALIAJrIgcgFk0NACAJKALAN0UNAEHQjwEhBgwDCwJAAkAgCkUEQCAMIBIgB2tqIQIgBiAHIgNNDQIDQCAEIAItAAE6AAEgBEEBaiEEIAJBAWohAiADQX9qIgMNAAsMAQsgCiAHSQRAIAwgEyAHa2ohAiAHIAprIgchAyAGIAdNDQIDQCAEIAItAAE6AAEgBEEBaiEEIAJBAWohAiADQX9qIgMNAAsgDCECIAYgB2siBiAKIgNNBEAgDCECDAMLA0AgBCACLQABOgABIARBAWohBCACQQFqIQIgA0F/aiIDDQALIAQgC2shAiAGIAprIQYMAgsgDCAKIAdraiECIAYgByIDTQ0BA0AgBCACLQABOgABIARBAWohBCACQQFqIQIgA0F/aiIDDQALCyAEIAtrIQIgBiAHayEGCyAGQQNPBEADQCAEIAItAAE6AAEgBCACLQACOgACIAQgAi0AAzoAAyAEQQNqIQQgAkEDaiECIAZBfWoiBkECSw0ACwsgBkUNBSAEIAItAAE6AAEgBkEBRw0BIARBAWohBAwFCyAEIAtrIQcDQCAEIgIgByIDLQABOgABIAIgAy0AAjoAAiACIAMtAAM6AAMgAkEDaiEEIANBA2ohByAGQX1qIgZBAksNAAsgBkUNBCACIAMtAAQ6AAQgBkEBRgRAIAJBBGohBAwFCyACIAMtAAU6AAUgAkEFaiEEDAQLIAQgAi0AAjoAAiAEQQJqIQQMAwsgACAGNgIYQR0LNgIADAILIAQgBjoAASAEQQFqIQQLIAQgDU8NACAIIA5JDQELCyAAIARBAWo2AgwgACANIARrQYECajYCECAAIAggBUEDdmsiAkEBajYCACAAIA4gAmtBBWo2AgQgCSAFQQdxIgU2AjwgCSABQX8gBXRBf3NxNgI4C5ECAQF/QXohAwJAIAFFDQAgAkE4Rw0AIAEtAABBMUcNACAARQRAQX4PCyAAQQA2AhggACgCICIBRQRAIABBADYCKCAAQd4ANgIgQd4AIQELIAAoAiRFBEAgAEHfADYCJAsgACgCKEEBQcw3IAERAAAiAUUEQEF8DwsgACABNgIcIAFBDzYCJCABQQE2AghBACEDIAFBADYCNCABQQA2AhwgAEEBNgIwIABBADYCCCAAQgA3AhQgAUKBgICAcDcCwDcgASABQbAKaiIANgJQIAFBADYCDCABQYCAAjYCFCABQQA2AiAgAUEANgIwIAEgADYCbCABQgA3AgAgAUIANwIoIAFCADcCOCABIAA2AkwLIAML7DgBHn8jAEEQayITJABBfiEWAkAgAEUNACAAKAIcIgJFDQAgACgCDCIQRQ0AIAAoAgAiB0UEQCAAKAIEDQELIAIoAgAiA0ELRgRAIAJBDDYCAEEMIQMLIAFBe2ohHCACQdgAaiEdIAJB8AVqIRggAkHwAGohGiACQdQAaiEbIAJB7ABqIRkgAkGwCmohFyACKAI8IQQgAigCOCEFQQAhEiAAKAIEIh4hBiAAKAIQIg0hFAJAAkADQCADQR5LDQNBfSEIQQEhCQJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIANBAWsOHgQFCAszNDU2Dg8QERITFBUWAhobASgAKhwdHjk+PwMLIAIoAkghCQwoCyACKAJIIQkMJQsgAigCaCEIDBYLIAIoAggiCEUNGyAEQRBJBEADQCAGRQ06IAZBf2ohBiAHLQAAIAR0IAVqIQUgBEEISSEDIARBCGohBCAHQQFqIQcgAw0ACwsCQCAIQQJxRQ0AIAVBn5YCRw0AQQAhBSACQQBBAEEAEIYCIgQ2AhggE0GflgI7AAwgBCATQQxqQQIQhgIhBCACQQE2AgAgAiAENgIYQQAhBCACKAIAIQMMOgsgAkEANgIQIAIoAiAiAwRAIANBfzYCMAsCQCAIQQFxBEAgBUEIdEGA/gNxIAVBCHZqQR9wRQ0BCyAAQcaQATYCGCACQR02AgAgAigCACEDDDoLIAVBD3FBCEcEQCAAQd2QATYCGCACQR02AgAgAigCACEDDDoLIAVBBHYiCkEPcSIIQQhqIQMgAigCJCIJRQRAIAIgAzYCJAw4CyADIAlNDTcgBEF8aiEEIABB+JABNgIYIAJBHTYCACAKIQUgAigCACEDDDkLIARBEEkEQANAIAZFDTkgBkF/aiEGIActAAAgBHQgBWohBSAEQQhJIQMgBEEIaiEEIAdBAWohByADDQALCyACIAU2AhAgBUH/AXFBCEcEQCAAQd2QATYCGCACQR02AgAgAigCACEDDDkLIAVBgMADcQRAIABBjJEBNgIYIAJBHTYCACACKAIAIQMMOQsgAigCICIEBEAgBCAFQQh2QQFxNgIACyAFQYAEcQRAIBMgBTsADCACIAIoAhggE0EMakECEIYCNgIYCyACQQI2AgBBACEEQQAhBQwBCyAEQR9LDQELIAchAwNAIAZFBEBBACEGIAMhByASIQgMOQsgBkF/aiEGIAMtAAAgBHQgBWohBSAEQRhJIQggBEEIaiEEIANBAWoiByEDIAgNAAsLIAIoAiAiBARAIAQgBTYCBAsgAi0AEUECcQRAIBMgBTYADCACIAIoAhggE0EMakEEEIYCNgIYCyACQQM2AgBBACEEQQAhBQwBCyAEQQ9LDQELIAchAwNAIAZFBEBBACEGIAMhByASIQgMNgsgBkF/aiEGIAMtAAAgBHQgBWohBSAEQQhJIQggBEEIaiEEIANBAWoiByEDIAgNAAsLIAIoAiAiBARAIAQgBUEIdjYCDCAEIAVB/wFxNgIICyACLQARQQJxBEAgEyAFOwAMIAIgAigCGCATQQxqQQIQhgI2AhgLIAJBBDYCAEEAIQNBACEEQQAhBSACKAIQIglBgAhxDQEMJgsgAigCECIJQYAIcUUEQCAEIQMMJgsgBSEDIARBD0sNAQsDQCAGRQRAQQAhBiADIQUgEiEIDDMLIAZBf2ohBiAHLQAAIAR0IANqIQMgBEEISSEFIARBCGohBCAHQQFqIgghByAFDQALIAghByADIQULIAIgBTYCQCACKAIgIgQEQCAEIAU2AhQLQQAhBCAJQYAEcQRAIBMgBTsADCACIAIoAhggE0EMakECEIYCNgIYC0EAIQUMJAsgBEEgSQRAA0AgBkUNLyAGQX9qIQYgBy0AACAEdCAFaiEFIARBGEkhAyAEQQhqIQQgB0EBaiEHIAMNAAsLIAIgBUEIdEGAgPwHcSAFQRh0ciAFQQh2QYD+A3EgBUEYdnJyIgQ2AhggACAENgIwIAJBCjYCAEEAIQVBACEECyACKAIMRQRAIAAgDTYCECAAIBA2AgwgACAGNgIEIAAgBzYCACACIAQ2AjwgAiAFNgI4QQIhFgwxCyACQQBBAEEAEIcCIgM2AhggACADNgIwIAJBCzYCAAsgHEECSQ0nCwJ/AkAgAigCBEUEQCAEIARBAksNAhogBg0BDCgLIAJBGjYCACAFIARBB3F2IQUgBEF4cSEEIAIoAgAhAwwtCyAGQX9qIQYgBy0AACAEdCAFaiEFIAdBAWohByAEQQhqCyEDIAIgBUEBcTYCBEENIQQCQAJAAkACQAJAIAVBAXZBA3FBAWsOAwABAgMLIAJBoJQBNgJMIAJCiYCAgNAANwJUIAJBoKQBNgJQIAJBEzYCACABQQZHDQMgA0F9aiEEIAVBA3YhBSASIQgMMAtBECEEDAELIABBuZEBNgIYQR0hBAsgAiAENgIACyADQX1qIQQgBUEDdiEFIAIoAgAhAwwrCyAFIARBB3F2IQUgBEF4cSIEQR9NBEADQCAGRQ0rIAZBf2ohBiAHLQAAIAR0IAVqIQUgBEEYSSEDIARBCGohBCAHQQFqIQcgAw0ACwsgBUH//wNxIgMgBUF/c0EQdkcEQCAAQcyRATYCGCACQR02AgAgAigCACEDDCsLIAJBDjYCACACIAM2AkBBACEFQQAhBCABQQZHDQBBACEEDCULIAJBDzYCAAsgAigCQCIDBEAgDSAGIAMgAyAGSxsiAyADIA1LGyIDRQ0kIBAgByADEJkIIRAgAiACKAJAIANrNgJAIAMgEGohECANIANrIQ0gAyAHaiEHIAYgA2shBiACKAIAIQMMKQsgAkELNgIAIAIoAgAhAwwoCyAEQQ5JBEADQCAGRQ0oIAZBf2ohBiAHLQAAIAR0IAVqIQUgBEEGSSEDIARBCGohBCAHQQFqIQcgAw0ACwsgAiAFQR9xIgNBgQJqNgJgIAIgBUEFdkEfcSIIQQFqNgJkIAIgBUEKdkEPcUEEaiIKNgJcIARBcmohBCAFQQ52IQUgA0EdTUEAIAhBHkkbRQRAIABB6ZEBNgIYIAJBHTYCACACKAIAIQMMKAsgAkERNgIAQQAhAyACQQA2AmgMAQsgAigCaCIDIAIoAlwiCk8NAQsgAyEIA0AgBEECSwR/IAQFIAZFDSYgBkF/aiEGIActAAAgBHQgBWohBSAHQQFqIQcgBEEIagshCSACIAhBAWoiAzYCaCACIAhBAXRBoJABai8BAEEBdGogBUEHcTsBcCAJQX1qIQQgBUEDdiEFIAMhCCADIApJDQALCyADQRNJBEADQCACIANBAXRBoJABai8BAEEBdGpBADsBcCADQQFqIgNBE0cNAAsgAkETNgJoCyACQQc2AlQgAiAXNgJMIAIgFzYCbEEAIQhBACAaQRMgGSAbIBgQmQIiEgRAIABBjZIBNgIYIAJBHTYCACACKAIAIQMMJQsgAkESNgIAIAJBADYCaEEAIRILIAggAigCYCIfIAIoAmRqIhVJBEBBfyACKAJUdEF/cyEOIAIoAkwhDwNAIAQhCyAGIQkgByEKAkAgBCAPIAUgDnEiEUECdGotAAEiDE8EQCAEIQMMAQsDQCAJRQ0KIAotAAAgC3QhDCAKQQFqIQogCUF/aiEJIAtBCGoiAyELIAMgDyAFIAxqIgUgDnEiEUECdGotAAEiDEkNAAsgCiEHIAkhBgsCQCAPIBFBAnRqLwECIgRBD00EQCADIAxJBEADQCAGRQ0cIAZBf2ohBiAHLQAAIAN0IAVqIQUgB0EBaiEHIANBCGoiAyAMSQ0ACwsgAiAIQQFqIgk2AmggAiAIQQF0aiAEOwFwIAMgDGshBCAFIAx2IQUgCSEIDAELAn8CfyAEQXBqIgRBAU0EQCAEQQFrBEAgAyAMQQJqIgRJBEADQCAGRQ0fIAZBf2ohBiAHLQAAIAN0IAVqIQUgB0EBaiEHIANBCGoiAyAESQ0ACwsgAyAMayEEIAUgDHYhAyAIRQRAIABBppIBNgIYIAJBHTYCACADIQUgAigCACEDDCsLIARBfmohBCADQQJ2IQUgA0EDcUEDaiEDIAhBAXQgAmovAW4MAwsgAyAMQQNqIgRJBEADQCAGRQ0eIAZBf2ohBiAHLQAAIAN0IAVqIQUgB0EBaiEHIANBCGoiAyAESQ0ACwsgAyAMa0F9aiEEIAUgDHYiA0EDdiEFIANBB3FBA2oMAQsgAyAMQQdqIgRJBEADQCAGRQ0dIAZBf2ohBiAHLQAAIAN0IAVqIQUgB0EBaiEHIANBCGoiAyAESQ0ACwsgAyAMa0F5aiEEIAUgDHYiA0EHdiEFIANB/wBxQQtqCyEDQQALIQkgAyAIaiAVSwRAIABBppIBNgIYIAJBHTYCACACKAIAIQMMJwsDQCACIAhBAXRqIAk7AXAgCEEBaiEIIANBf2oiAw0ACyACIAg2AmgLIAggFUkNAAsLIAIvAfAERQRAIABBwJIBNgIYIAJBHTYCACACKAIAIQMMJAsgAkEJNgJUIAIgFzYCTCACIBc2AmxBASAaIB8gGSAbIBgQmQIiEgRAIABB5ZIBNgIYIAJBHTYCACACKAIAIQMMJAsgAkEGNgJYIAIgAigCbDYCUEECIAIgAigCYEEBdGpB8ABqIAIoAmQgGSAdIBgQmQIiEgRAIABBgZMBNgIYIAJBHTYCACACKAIAIQMMJAsgAkETNgIAQQAhEkEAIQkgAUEGRg0fCyACQRQ2AgALAkAgDUGCAkkNACAGQQZJDQAgACANNgIQIAAgEDYCDCAAIAY2AgQgACAHNgIAIAIgBDYCPCACIAU2AjggACAUEJoCIAIoAjwhBCACKAI4IQUgACgCBCEGIAAoAgAhByAAKAIQIQ0gACgCDCEQIAIoAgBBC0cNECACQX82AsQ3IAIoAgAhAwwiCyACQQA2AsQ3IAQhCSAGIQMgByEIAkAgBCACKAJMIgwgBUF/IAIoAlR0QX9zIhFxIg9BAnRqLQABIgtPBEAgByEIIAYhAyAEIQoMAQsDQCADRQ0IIAgtAAAgCXQhCyAIQQFqIQggA0F/aiEDIAlBCGoiCiEJIAogDCAFIAtqIgUgEXEiD0ECdGotAAEiC0kNAAsLIAshBCAMIA9BAnRqIgYvAQIhESAGLQAAIg5FDQkgDkHwAXENCSADIQYgCCEHAkAgBCAMIAVBfyAEIA5qdEF/cyIVcSAEdiARaiIOQQJ0ai0AASILaiAKIglNBEAgCCEHIAMhBiAKIQ8MAQsDQCAGRQ0HIActAAAgCXQhCyAHQQFqIQcgBkF/aiEGIAlBCGoiDyEJIAQgDCAFIAtqIgUgFXEgBHYgEWoiDkECdGotAAEiC2ogD0sNAAsLIAwgDkECdGoiAy0AACEOIAMvAQIhESACIAQ2AsQ3IA8gBGshCiAFIAR2IQUMCgsgDUUNGyAQIAIoAkA6AAAgAkEUNgIAIA1Bf2ohDSAQQQFqIRAgAigCACEDDCALIAIoAggEQCAEQR9NBEADQCAGRQ0hIAZBf2ohBiAHLQAAIAR0IAVqIQUgBEEYSSEDIARBCGohBCAHQQFqIQcgAw0ACwsgACAUIA1rIgMgACgCFGo2AhQgAiACKAIcIANqNgIcAkAgA0UEQCACKAIYIQMMAQsgECADayEIIAIoAhghCSACAn8gAigCEARAIAkgCCADEIYCDAELIAkgCCADEIcCCyIDNgIYIAAgAzYCMAsgBSAFQQh0QYCA/AdxIAVBGHRyIAVBCHZBgP4DcSAFQRh2cnIgAigCEBsgA0cNBkEAIQUgDSEUQQAhBAsgAkEbNgIACwJAIAIoAghFDQAgAigCEEUNACAEQR9NBEADQCAGRQ0gIAZBf2ohBiAHLQAAIAR0IAVqIQUgBEEYSSEDIARBCGohBCAHQQFqIQcgAw0ACwsgBSACKAIcRw0GQQAhBUEAIQQLIAJBHDYCAEEBIQgMHwsgAkEMNgIADAsLIAYgB2ohByAEIAZBA3RqIQQMGwsgAyAIaiEHIAogA0EDdGohBAwaCyAGIAdqIQcgBCAGQQN0aiEEDBkLIABB55MBNgIYIAJBHTYCACANIRQgAigCACEDDBkLIABB/JMBNgIYIAJBHTYCACACKAIAIQMMGAtBACEEIAghByADIQYLIAIgEUH//wNxNgJAIAIgBCALajYCxDcgCiALayEEIAUgC3YhBSAORQRAIAJBGTYCACACKAIAIQMMFwsgDkEgcQRAIAJBCzYCACACQX82AsQ3IAIoAgAhAwwXCyAOQcAAcQRAIABBl5MBNgIYIAJBHTYCACACKAIAIQMMFwsgAkEVNgIAIAIgDkEPcSIJNgJICyAHIQsgBiEKAkAgCUUEQCACKAJAIQggCyEHIAohBgwBCyAKIQYgCyEIAkAgBCIDIAlPBEAgCyEHIAohBiAEIQMMAQsDQCAGRQ0KIAZBf2ohBiAILQAAIAN0IAVqIQUgCEEBaiIHIQggA0EIaiIDIAlJDQALCyACIAIoAsQ3IAlqNgLENyACIAIoAkAgBUF/IAl0QX9zcWoiCDYCQCADIAlrIQQgBSAJdiEFCyACQRY2AgAgAiAINgLINwsgBCEJIAYhAyAHIQgCQCAEIAIoAlAiDCAFQX8gAigCWHRBf3MiEXEiD0ECdGotAAEiC08EQCAHIQggBiEDIAQhCgwBCwNAIANFDQcgCC0AACAJdCELIAhBAWohCCADQX9qIQMgCUEIaiIKIQkgCiAMIAUgC2oiBSARcSIPQQJ0ai0AASILSQ0ACwsgDCAPQQJ0aiIGLwECIRECQCAGLQAAIg5B8AFxBEAgAigCxDchBCAIIQcgAyEGIAshCQwBCyADIQYgCCEHAkAgCyAMIAVBfyALIA5qdEF/cyIVcSALdiARaiIOQQJ0ai0AASIJaiAKIgRNBEAgCCEHIAMhBiAKIQ8MAQsDQCAGRQ0HIActAAAgBHQhCSAHQQFqIQcgBkF/aiEGIARBCGoiDyEEIAsgDCAFIAlqIgUgFXEgC3YgEWoiDkECdGotAAEiCWogD0sNAAsLIAwgDkECdGoiBC0AACEOIAQvAQIhESACIAIoAsQ3IAtqIgQ2AsQ3IA8gC2shCiAFIAt2IQULIAIgBCAJajYCxDcgCiAJayEEIAUgCXYhBSAOQcAAcQRAIABBs5MBNgIYIAJBHTYCACACKAIAIQMMFQsgAkEXNgIAIAIgDkEPcSIJNgJIIAIgEUH//wNxNgJECyAHIQsgBiEKAkAgCUUEQCALIQcgCiEGDAELIAohBiALIQgCQCAEIgMgCU8EQCALIQcgCiEGIAQhAwwBCwNAIAZFDQUgBkF/aiEGIAgtAAAgA3QgBWohBSAIQQFqIgchCCADQQhqIgMgCUkNAAsLIAIgAigCxDcgCWo2AsQ3IAIgAigCRCAFQX8gCXRBf3NxajYCRCADIAlrIQQgBSAJdiEFCyACQRg2AgALIA1FDQ0CfyACKAJEIgMgFCANayIISwRAAkAgAyAIayIDIAIoAixNDQAgAigCwDdFDQAgAEHJkwE2AhggAkEdNgIAIAIoAgAhAwwVCwJ/IAMgAigCMCIISwRAIAIoAiggAyAIayIDawwBCyAIIANrCyEJIAIoAkAiCiADIAMgCksbIQggAigCNCAJagwBCyACKAJAIgohCCAQIANrCyEDIAIgCiANIAggCCANSxsiCWs2AkAgCSEIA0AgECADLQAAOgAAIBBBAWohECADQQFqIQMgCEF/aiIIDQALIA0gCWshDSACKAJADQAgAkEUNgIAIAIoAgAhAwwSCyACKAIAIQMMEQsgCiALaiEHIAQgCkEDdGohBAwPCyADIAhqIQcgCiADQQN0aiEEDA4LIAYgB2ohByAEIAZBA3RqIQQMDQsgCiALaiEHIAQgCkEDdGohBAwMC0EAIQYgAyEEIBIhCAwNCyACKAIgIgQEQCAEQQA2AhALIAMhBAsgAkEFNgIACyACKAIQIglBgAhxBEAgBiACKAJAIgMgAyAGSxsiCARAAkAgAigCICIKRQ0AIAooAhAiC0UNACALIAooAhQgA2siA2ogByAKKAIYIgkgA2sgCCADIAhqIAlLGxCZCBogAigCECEJCyAJQYAEcQRAIAIgAigCGCAHIAgQhgI2AhgLIAIgAigCQCAIayIDNgJAIAYgCGshBiAHIAhqIQcLIAMNBQsgAkEGNgIAIAJBADYCQAsCQCACLQARQQhxBEBBACEDIAZFDQQDQCADIAdqLQAAIQgCQCACKAIgIglFDQAgCSgCHCIKRQ0AIAIoAkAiCyAJKAIgTw0AIAIgC0EBajYCQCAKIAtqIAg6AAALIAhB/wFxQQAgBiADQQFqIgNLGw0ACyACLQARQQJxBEAgAiACKAIYIAcgAxCGAjYCGAsgAyAHaiEHIAYgA2shBiAIQf8BcUUNAQwFCyACKAIgIgNFDQAgA0EANgIcCyACQQc2AgAgAkEANgJACwJAIAItABFBEHEEQEEAIQMgBkUNAwNAIAMgB2otAAAhCAJAIAIoAiAiCUUNACAJKAIkIgpFDQAgAigCQCILIAkoAihPDQAgAiALQQFqNgJAIAogC2ogCDoAAAsgCEH/AXFBACAGIANBAWoiA0sbDQALIAItABFBAnEEQCACIAIoAhggByADEIYCNgIYCyADIAdqIQcgBiADayEGIAhB/wFxRQ0BDAQLIAIoAiAiA0UNACADQQA2AiQLIAJBCDYCAAsgAigCECIIQYAEcQRAIARBD00EQANAIAZFDQggBkF/aiEGIActAAAgBHQgBWohBSAEQQhJIQMgBEEIaiEEIAdBAWohByADDQALCyAFIAIvARhHDQRBACEFQQAhBAsgAigCICIDBEAgA0EBNgIwIAMgCEEJdkEBcTYCLAsgAkEAQQBBABCGAiIDNgIYIAAgAzYCMCACQQs2AgAgAigCACEDDAYLQQAhBgsgEiEJCyAJIQgMBAsgAEGlkQE2AhggAkEdNgIAIAIoAgAhAwwCCyACQYACIAh0NgIUQQAhBCACQQBBAEEAEIcCIgM2AhggACADNgIwIAJBCUELIAVBgMAAcRs2AgBBACEFIAIoAgAhAwwBCwtBACEGIBIhCAsgACANNgIQIAAgEDYCDCAAIAY2AgQgACAHNgIAIAIgBDYCPCACIAU2AjgCQAJAIAIoAihFBEAgDSAURg0BIAIoAgBBGUsNAQsgACAUEJ0CDQEgACgCECENIAAoAgQhBgsgACAeIAZrIgcgACgCCGo2AgggACAUIA1rIgYgACgCFGo2AhQgAiACKAIcIAZqNgIcAkAgBkUNACACKAIIRQ0AIAAoAgwgBmshBCACKAIYIQUgAgJ/IAIoAhAEQCAFIAQgBhCGAgwBCyAFIAQgBhCHAgsiBDYCGCAAIAQ2AjALIAAgAigCPCACKAIEQQBHQQZ0aiACKAIAIgRBC0ZBB3RqQYACIARBDkZBCHQgBEETRhtqNgIsIAhBeyAIQXsgBiAHchsgAUEERhsgCBshFgwCCyACQR42AgALQXwhFgsgE0EQaiQAIBYLowIBBH8CQCAAKAIcIgIoAjQiBEUEQEEBIQMgAiAAKAIoQQEgAigCJHRBASAAKAIgEQAAIgQ2AjQgBEUNAQsgAigCKCIDRQRAIAJCADcCLCACQQEgAigCJHQiAzYCKAsgASAAKAIQayIBIANPBEAgBCAAKAIMIANrIAMQmQgaIAJBADYCMCACIAIoAig2AixBAA8LIAQgAigCMCIFaiAAKAIMIAFrIAEgAyAFayIDIAMgAUsbIgQQmQgaIAEgBGsiAwRAIAIoAjQgACgCDCADayADEJkIGiACIAM2AjAgAiACKAIoNgIsQQAPC0EAIQMgAkEAIAIoAjAgBGoiACAAIAIoAigiAUYbNgIwIAIoAiwiACABTw0AIAIgACAEajYCLAsgAwthAQN/QX4hAQJAIABFDQAgACgCHCICRQ0AIAAoAiQiA0UNACACKAI0IgEEQCAAKAIoIAEgAxEFACAAKAIkIQMgACgCHCECCyAAKAIoIAIgAxEFAEEAIQEgAEEANgIcCyABC4EFAQd/AkAgA0EFSA0AIAAgASgCAGohBiAAIANBCHRBgID8B3EgA0EYdHIgA0EIdkGA/gNxIANBGHZycjYAACAAQQRqIQQCQCACIANqIghBfWoiCiACSwRAQQEhCQNAIAIhByACIQVBACEDAkAgCUEBcUUNAANAAn8gA0EBaiAFLQAARQ0AGiADQQJLDQIgBUEBaiEHQQALIQMgBUEBaiIFIAhJDQALCyAHIAJrIgUEQCAFQYIBTwRAA0AgBEGBAWoiByAGTw0GIARB/wE6AAAgBEEBaiACQYABEJkIGiACQYABaiECIAchBCAFQYB/aiIFQYEBSw0ACwsCQCAFQYEBRwRAIAQhBwwBCyAEQQJqIgcgBk8NBUGAASEFIARBgAE6AAAgBCACLQAAOgABIAJBAWohAgsgB0EBaiIJIAVqIgQgBk8NBCAHIAVBf2pBgAFyOgAAIAkgAiAFEJkIGiACIAVqIQILIANBhgFPBEADQCAEQQFqIgUgBk8NBSAEQf8AOgAAIAJBggFqIQIgBSEEIANB/n5qIgNBhQFLDQALCwJAAkAgA0GDAU8EQCAEQQFqIgUgBk8NBiAEQQA6AAAgAkEDaiECIANBfWohAyAFIQQMAQsgA0EDSQ0BCyAEQQFqIgUgBk8NBCAEIANBfWo6AAAgAiADaiECIAUhBAsgAiAISSEJIAIgCkkNAAsgAiAITw0BCyACIQMDQCADLQAABEAgBCAIIAJrIgNqQQFqIAZPDQMgBEH/AToAACAEQQFqIAIgAxCZCCADaiEEDAILIANBAWoiAyAISQ0ACyAEQQFqIgIgBk8NASAEQf8AOgAAIAIhBAsgASAEIABrNgIACwvTAQEDf0EAIQUCQCADQQVIDQAgAigAACIEQRh0IARBCHRBgID8B3FyIARBCHZBgP4DcSAEQRh2cnIiBCABKAIASw0AIAIgA2ohBiABIAQ2AgAgAkEEaiEDA0AgA0EBaiECIAMtAAAiA0H/AHEhBQJ/IANBgAFxBEAgACACIAVBAWoiAyAEIAMgBEkbIgUQmQgaIAIgBWoMAQsgAEEAIAVBA2oiAyAEIAMgBEkbIgUQmggaIAILIQMgBCAFayEEIAAgBWohACADIAZJDQALQQEhBQsgBQv4EQELfyMAQRBrIgokACACIAE2ArgTIAIgADYCtBMgAiAFKAIANgIYIAQoAgAhACACIAM2ArATIAIgADYCFCACQoSAgIDwATcCDAJ/IAUoAgAiBUGACEcEQCACAn8gBUGAEEYEQEEFIQVBHwwBC0EBIAVBgCBHDQIaIAJChYCAgPAFNwIMQQYhBUE/CzYCECACIAU2AgwLQQIgBCgCACIFQQFLDQAaAkAgBUEBawRAIAJBnAFqQQlBgAIQmggaIAJBogdqIQNBACEFQQAhBANAIAMgBUEBdGogBDsBACAEQf//A3FBAmohBCAFQQFqIgVBgAJHDQALDAELIAJBogdqIQMgAkGcAWohAEEAIQUDQCAAIAVqIAVBoKUBai0AAEEBajoAACADIAVBAXQiBGogBEGgpwFqLwEAQQF0OwEAIAVBAWoiBUGAAkcNAAsLIAJBnAFqIQtBgAIhBUEAIQcDQEEBIAdBoKsBai0AACIEdCIAQQEgAEEBShshACAEIAdBsKsBai0AACIJakEBaiEBIAdBwKsBai0AAEEBdCEGIAlBAWohCUEAIQQDQCAFIAtqIAE6AAAgAyAFQQF0aiAGIAQgCXRyQQFyOwEAIAVBAWohBSAEQQFqIgQgAEcNAAsgB0EBaiIHQRBHDQALIAJBiKwBKQMANwKUASACQYCsASkDADcCjAEgAkH4qwEpAwA3AoQBIAJB8KsBKQMANwJ8IAJB6KsBKQMANwJ0IAJB4KsBKQMANwJsIAJB2KsBKQMANwJkIAJB0KsBKQMANwJcIAJBkKwBKQMANwIcIAJBmKwBKQMANwIkIAJBoKwBKQMANwIsIAJBqKwBKQMANwI0IAJBsKwBKQMANwI8IAJBuKwBKQMANwJEIAJBwKwBKQMANwJMIAJByKwBKQMANwJUIAIgAigCFDoAyj8gAkECNgIEIAIoAhghAyACIAIoAgw6AMs/IAJBzD9qQQBBgBAQmggaIAJBADYCCCACQczvAGohDiACQcg/aiELIAJByBtqIQwgAkEEaiENIAJByj9qIQ8gAyACQczPAGoiB2pBhARqIQRBACEIA0ACQCAKQYAgNgIMQQAhBQJAAkAgAiADakHQ0wBqIApBDGogAigCsBMgAigCtBMRAAAiA0UNAANAAkAgCiAKKAIMIANrIgA2AgwgAyAFaiEFIABFDQAgAiACKAIYaiAFakHQ0wBqIApBDGogAigCsBMgAigCtBMRAAAiAw0BDAILC0EAIQkMAQtBASEJIAUgCHJFDQELIAIgAigCGCIGaiAFaiIFQdDTAGogBUHMzwBqIAkbIQECQAJAAkACQAJAAkACQCAIQQFNBEAgCEEBawRAIAxBAEGAJBCaCCEIIAQiBSABQQFqIgBJDQIMBwsgDEEAQYAkEJoIIQggBCAGa0GEBGoiBiEFIAYgAUEBaiIASQ0CDAULIAxBAEGAJBCaCCEQIAQgBmsiBiEFIAYgAUEBaiIASQ0CDAMLA0AgAiAFLQABQQVsIAUtAABBAnRqQQF0akHIG2oiAyADLwEAQQFqOwEAIAEgBUYhAyAFQQFqIQUgA0UNAAsMBAsDQCACIAUtAAFBBWwgBS0AAEECdGpBAXRqQcgbaiIDIAMvAQBBAWo7AQAgASAFRiEDIAVBAWohBSADRQ0ACwwCCwNAIAIgBS0AAUEFbCAFLQAAQQJ0akEBdGpByBtqIgMgAy8BAEEBajsBACABIAVGIQMgBUEBaiEFIANFDQALC0EAIQMgECEFA0AgBSAFLwEAIANB//8DcWoiAzsBACAFQQJqIgUgC0kNAAsgASIFIAZJDQIDQCACIAAtAABBBWwgBS0AAEECdGpBAXRqQcgbaiIDIAMvAQBBf2oiAzsBACACIANB//8DcUEBdGpB0JMBaiAFIAdrOwEAIAUhACAFQX9qIgUgBk8NAAsMAgtBACEDIAghBQNAIAUgBS8BACADQf//A3FqIgM7AQAgBUECaiIFIAtJDQALQQIhCCABIgUgBkkNAQNAQQIhCCACIAAtAABBBWwgBS0AAEECdGpBAXRqQcgbaiIDIAMvAQBBf2oiAzsBACACIANB//8DcUEBdGpB0JMBaiAFIAdrOwEAIAUhACAFQX9qIgUgBk8NAAsMAQtBACEDIAghBQNAIAUgBS8BACADQf//A3FqIgM7AQAgBUECaiIFIAtJDQALIAEiBSAETwRAA0AgAiAALQAAQQVsIAUtAABBAnRqQQF0akHIG2oiAyADLwEAQX9qIgM7AQAgAiADQf//A3FBAXRqQdCTAWogBSAHazsBACAFIQAgBUF/aiIFIARPDQALC0EBQQIgBkGAIEYbIQgLIAQgAUkEQANAIAIgBBCiAiEFAkACQANAAkACQAJAAkACQCAFQQJLDQAgBUEBaw4CAAEDCyAJQQAgBCAFaiABSxsNASAFQQdLDQUMAwsgAigCAEH/AUsNASAJRQ0CIARBAmogAU0NAgsgASAEayIFQQJJDQAgBUECRw0DQQIhBSACKAIAQf8BTQ0DC0EBIQUgAiACIAQtAAAiA2otAJwBIAIgA0EBdGovAaIHEKMCDAMLIARBAWoiAyABTw0BIAIoAgAhBgJAIAIgAxCiAiIAIAVNDQAgBkGAAU1BACAAIAVBAWpNGw0AIAIgAiAELQAAIgVqLQCcASACIAVBAXRqLwGiBxCjAiADIQQgACEFDAELCyACIAY2AgALIAIgAiAFQf4BaiIDai0AnAEgAiADQQF0ai8BogcQowIgAigCACEDIAICfyAFQQJGBEAgAiACIANBAnZqIgMtABwgAy0AXBCjAkEDIQNBAgwBCyACIAIgAyACKAIMdmoiAy0AHCADLQBcEKMCIAIoAhAhAyACKAIMCyACKAIAIANxEKMCCyAEIAVqIgQgAUkNAAsLIAkNACAHIA4gAigCGCIDQYQEahCbCBogBEGAYGohBAwBCwsgAiACLQChByACLwGsExCjAiACKAIIBEAgDSANKAIAQQFqNgIACyAPIA0gAigCsBMgAigCuBMRCABBAAshAyAKQRBqJAAgAwvfCQEOfwJAIAEgAGsgACgCGGtBtbB/akH//wNxIgQgACAAIAEtAAFBBWwgAS0AAEECdGpBAXRqQcgbaiIFLwEAIgZBAXRqQdCTAWoiAi8BACIDTQRAIAYhBAwBCwNAIAZBAWohBiACLwECIQMgAkECaiECIAQgA0sNAAsgBSAGOwEAIAAgBkH//wNxIgRBAXRqQdCTAWovAQAhAwtBACEFAkAgACADakHMzwBqIgIgAUF/aiIKTw0AIAFBAWohDSAAIARBAXRqQdCTAWohA0EBIQcCQANAIAMhCAJAIAEtAAAgAi0AAEcNACABIAdBf2oiA2otAAAgAiADai0AAEcNACACQYMEaiELIAJBAWohAkECIQQgDSEDAn8DQCACQQFqIgUgAi0AASADLQABRw0BGiADQQFqIQMgBSECIARBAWoiBEGEBEcNAAtBhAQhBCALCyEFIAQgB0kNACAAIAEgBWsgBGoiAkF/ajYCACAEQQpLDQIgBCEHCyAIQQJqIQMgBkEBaiEGIAAgCC8BAmpBzM8AaiICIApJDQALIAdBACAHQQFLGw8LQYQEIQUgBEGEBEYEQCAAIAJBfmo2AgAMAQsgACAAIAZB//8DcUEBdGoiAkHSkwFqLwEAakHMzwBqIApPBEAgBA8LIAJB0JMBaiEHIABB//8DOwG8E0EAIQxBASECQQEhCQNAIAAgAkEBdGpBvBNqIAw7AQAgASAJQf//A3EiBWohCCAMIQICQANAIAQgBU0NASACIQMgCC0AACABIAJB//8DcSICai0AAEcEQEH//wMhAyAAIAJBAXRqQbwTai8BACICQf//A0cNAQsLIANBAWohDCAJQQFqIglB//8DcSECDAELCyAAIAcvAQBqIARqQczPAGohCCAEIQIDQCABIARBfmoiDWohDgNAQQAgACACQQF0akG8E2ovAQAiAiACQf//A0YbIQcgACAGQf//A3FBAXRqQdCTAWohAgNAIAYh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aiQAC6cIAQR/IABBfzYCsPUOIABBvK4MakIANwIAIABBuPUOakIANwMAIABBxK4MakIANwIAQQAhAiAAQcyuDGpBADYCACAAQcD1DmpCATcDACAAQbT1DmpBADoAACAAQeD1DmpBADYCACAAQdj1DmpCADcDACAAQcj1DmogAEHQ9Q5qKAIANgIAA0AgACACQQV0aiIBQZDLDGpBgIiAIDYBACABQbDHDGpBgIiAIDYBACABQZTLDGpCgIiAoICAgYAENwEAIAFBtMcMakKAiICggICBgAQ3AQAgAUG8xwxqQoCIgKCAgIGABDcBACABQZzLDGpCgIiAoICAgYAENwEAIAFBxMcMakKAiICggICBgAQ3AQAgAUGkywxqQoCIgKCAgIGABDcBACABQczHDGpBgIiAIDYBACABQazLDGpBgIiAIDYBACAAIAJBAXRqIgFB+MoMakGACDsBACABQeDKDGpBgAg7AQAgAUHIygxqQYAIOwEAIAFBsMoMakGACDsBACACQQFqIgJBDEcNAAsgACgCnMcMIgMgACgCmMcMaiIBQRdNBEBBgAYgAXQiAUEBIAFBAUsbIQIgACgCrMcMIQRBACEBA0AgBCABQQF0akGACDsBACABQQFqIgEgAkcNAAsLQQAhAUEAIQIDQCAAIAJBAXRqQZDODGpBgAg7AQAgAkEBaiICQcAARw0ACwNAIAAgAUEBdGpBkM8MakGACDsBACABQQFqIgFBwABHDQALQQAhAQNAIAAgAUEBdGpBkNAMakGACDsBACABQQFqIgFBwABHDQALQQAhAQNAIAAgAUEBdGpBkNEMakGACDsBACABQQFqIgFBwABHDQALQQAhAQNAIAAgAUEBdGpBkNIMakGACDsBACABQQFqIgFB8gBHDQALIABBgIiAIDYBlNQMQQAhAUEAIQIDQCAAIAJBAXRqQZjUDGpBgAg7AQAgAkEBaiICQYABRw0ACwNAIAAgAUEBdGpBmNYMakGACDsBACABQQFqIgFBgAFHDQALQQAhAQNAIAAgAUEBdGpBmNgMakGACDsBACABQQFqIgFBgAJHDQALIABBgIiAIDYB3OQNQQAhAUEAIQIDQCAAIAJBAXRqQeDkDWpBgAg7AQAgAkEBaiICQYABRw0ACwNAIAAgAUEBdGpB4OYNakGACDsBACABQQFqIgFBgAFHDQAL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IAggAUFAay8BAEEEdGoiIygCACFYIAggAS8BPkEEdGoiJCgCACFZIAggAS8BPEEEdGoiJSgCACFaIAggAS8BOkEEdGoiJigCACFbIAggAS8BOEEEdGoiJygCACFcIAggAS8BNkEEdGoiKCgCACFdIAggAS8BNEEEdGoiKSgCACFeIAggAS8BMkEEdGoiKigCACFfIAggAS8BMEEEdGoiKygCACFgIAggAS8BLkEEdGoiLCgCACFhIAggAS8BLEEEdGoiLSgCACFiIAggAS8BKkEEdGoiLigCACFjIAggAS8BKEEEdGoiLygCACFkIAggAS8BJkEEdGoiMCgCACFlIAggAS8BJEEEdGoiMSgCACFmIAggAS8BIkEEdGoiMigCACFnIAggAS8BIEEEdGoiMygCACFoIAggAS8BHkEEdGoiNCgCACFpIAggAS8BHEEEdGoiNSgCACFqIAggAS8BGkEEdGoiNigCACFrIAggAS8BGEEEdGoiNygCACFsIAggAS8BFkEEdGoiOCgCACFtIAggAS8BFEEEdGoiOSgCACFuIAggAS8BEkEEdGoiOigCACFvIAggAS8BEEEEdGoiOygCACFwIAggAS8BDkEEdGoiPCgCACFxIAggAS8BDEEEdGoiPSgCACFyIAggAS8BCkEEdGoiPigCACFzIAggAS8BCEEEdGoiPygCACF0IAggAS8BBkEEdGoiQCgCACF1IAggAS8BBEEEdGoiQSgCACF2IAggAS8BAEEEdGoiQigCACF3IAggAS8BAkEEdGoiASgCACF4IAcoAgQheSACKAIEIXogBSgCBCF7IA4oAgQhfCAVKAIEIX0gEigCBCF+IBcoAgQhfyAMKAIEIYABIBooAgQhgQEgGygCBCGCASAcKAIEIYMBIB0oAgQhhAEgHigCBCGFASAfKAIEIYYBICAoAgQhhwEgISgCBCGIASAiKAIEIYkBICMoAgQhigEgJCgCBCGLASAlKAIEIYwBICYoAgQhjQEgJygCBCGOASAoKAIEIY8BICkoAgQhkAEgKigCBCGRASArKAIEIZIBICwoAgQhkwEgLSgCBCGUASAuKAIEIZUBIC8oAgQhlgEgMCgCBCGXASAxKAIEIZgBIDIoAgQhmQEgMygCBCGaASA0KAIEIZsBIDUoAgQhnAEgNigCBCGdASA3KAIEIZ4BIDgoAgQhnwEgOSgCBCGgASA6KAIEIaEBIDsoAgQhogEgPCgCBCGjASA9KAIEIaQBID4oAgQhpQEgPygCBCGmASBAKAIEIacBIEEoAgQhqAEgQigCBCGpASABKAIEIaoBIA8gBygCCCACKAIIIAUoAgggDigCCCAVKAIIIBIoAgggFygCCCAMKAIIIBooAgggGygCCCAcKAIIIB0oAgggHigCCCAfKAIIICAoAgggISgCCCAiKAIIICMoAgggJCgCCCAlKAIIICYoAgggJygCCCAoKAIIICkoAgggKigCCCArKAIIICwoAgggLSgCCCAuKAIIIC8oAgggMCgCCCAxKAIIIDIoAgggMygCCCA0KAIIIDUoAgggNigCCCA3KAIIIDgoAgggOSgCCCA6KAIIIDsoAgggPCgCCCA9KAIIID4oAgggPygCCCBAKAIIIEEoAgggASgCCCBCKAIIampqampqampqampqampqampqampqampqampqampqampqampqampqampqampqampqaiIBOwHMASAPIAFBEHY7Ac4BIA8geSB6IHsgfCB9IH4gfyCAASCBASCCASCDASCEASCFASCGASCHASCIASCJASCKASCLASCMASCNASCOASCPASCQASCRASCSASCTASCUASCVASCWASCXASCYASCZASCaASCbASCcASCdASCeASCfASCgASChASCiASCjASCkASClASCmASCnASCoASCpASCqAWpqampqampqampqampqampqampqampqampqampqampqampqampqampqampqampqamoiATsByAEgDyABQRB2OwHKASAPIEcgSCBJIEogSyBMIE0gTiBPIFAgUSBSIFMgVCBVIFYgVyBYIFkgWiBbIFwgXSBeIF8gYCBhIGIgYyBkIGUgZiBnIGggaSBqIGsgbCBtIG4gbyBwIHEgciBzIHQgdSB2IHcgeGpqampqampqampqampqampqampqampqampqampqampqampqampqampqampqampqamoiATsBxAEgDyABQRB2OwHGAQtB/5Pr3AMhB0F/IQJBACEBA0AgD0HEAWogAUEBdGovAQAiBSAHIAcgBUoiBRshByABIAIgBRshAiABQQFqIgEgEEcNAAsgD0GgAWogAkECdGoiASABKAIAQQFqNgIAIAAgE2pBgA1qIAI6AAACQCAJ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BUEBaiIFIApHDQALIAJBEk4EQEG8FxDRAgsgB0EATARAQb0XENECCyACIQELIAAgDUGICGxqQbCyAmogACANQYICbGpBpKYCaiAHIAEgBBDLAiANQQFqIg0gEEcNAAsgAEHYAGohB0EAIQUDQCAPQZABaiAFaiIBQQA6AAAgASAHIAVBBHQiAmotAAAiDUEARzoAACABIA0gByACQQFyai0AAHIiDUH/AXFBAEc6AAAgASAHIAJBAnJqLQAAIA1yIg1B/wFxQQBHOgAAIAEgByACQQNyai0AACANciINQf8BcUEARzoAACABIAcgAkEEcmotAAAgDXIiDUH/AXFBAEc6AAAgASAHIAJBBXJqLQAAIA1yIg1B/wFxQQBHOgAAIAEgByACQQZyai0AACANciINQf8BcUEARzoAACABIAcgAkEHcmotAAAgDXIiDUH/AXFBAEc6AAAgASAHIAJBCHJqLQAAIA1yIg1B/wFxQQBHOgAAIAEgByACQQlyai0AACANciINQf8BcUEARzoAACABIAcgAkEKcmotAAAgDXIiDUH/AXFBAEc6AAAgASAHIAJBC3JqLQAAIA1yIg1B/wFxQQBHOgAAIAEgByACQQxyai0AACANciINQf8BcUEARzoAACABIAcgAkENcmotAAAgDXIiDUH/AXFBAEc6AAAgASAHIAJBDnJqLQAAIA1yIg1B/wFxQQBHOgAAIAEgByACQQ9yai0AACANckH/AXFBAEc6AAAgBUEBaiIFQRBHDQALIABBLGohDiAAQdgEaiEBIABB3ARqIQcgAEHMAGohAiAAKALYBCEFIAAoAtwEIQhBACEGIAAoAkwiBCENA0ACQCAPQZABaiAGai0AAARAIAhBCE4EQANAIA4oAgAgDWogBUEYdjoAACACIAIoAgBBAWoiDTYCACABIAEoAgBBCHQiBTYCACAHIAcoAgAiC0F4aiIINgIAIAtBD0oNAAsLQYCAgIB4IAh2IAVyIQUMAQsgCEEISA0AA0AgDigCACANaiAFQRh2OgAAIAIgAigCAEEBaiINNgIAIAEgASgCAEEIdCIFNgIAIAcgBygCACILQXhqIgg2AgAgC0EPSg0ACwsgASAFNgIAIAcgCEEBaiIINgIAIAZBAWoiBkEQRw0AC0EAIQkDQCAPQZABaiAJai0AAARAIAlBBHQhA0EAIQYDQAJAIAAgAyAGamotAFgEQCAIQQhOBEADQCAOKAIAIA1qIAVBGHY6AAAgAiACKAIAQQFqIg02AgAgASABKAIAQQh0IgU2AgAgByAHKAIAIgtBeGoiCDYCACALQQ9KDQALC0GAgICAeCAIdiAFciEFDAELIAhBCEgNAANAIA4oAgAgDWogBUEYdjoAACACIAIoAgBBAWoiDTYCACABIAEoAgBBCHQiBTYCACAHIAcoAgAiC0F4aiIINgIAIAtBD0oNAAsLIAEgBTYCACAHIAhBAWoiCDYCACAGQQFqIgZBEEcNAAsLIAlBAWoiCUEQRw0ACyAAKALoBEEDTgRAIA8gDSAEazYCMEG0qgIoAgBB8roBIA9BMGoQwgYaIAIoAgAhDSAHKAIAIQgLIAEoAgAhBQJAIAhBCEgEQCANIQQMAQsgDSEEA0AgDigCACAEaiAFQRh2OgAAIAIgAigCAEEBaiIENgIAIAEgASgCAEEIdCIFNgIAIAcgBygCACILQXhqIgg2AgAgC0EPSg0ACwsgASAQQR0gCGt0IAVyIgU2AgAgByAIQQNqIgs2AgAgCEEFTgRAA0AgDigCACAEaiAFQRh2OgAAIAIgAigCAEEBaiIENgIAIAEgASgCAEEIdCIFNgIAIAcgBygCACIIQXhqIgs2AgAgCEEPSg0ACwsgASATQREgC2t0IAVyIgU2AgAgByALQQ9qIgg2AgAgE0EBTgRAQQAhEQNAIAhBB0ohC0EAIQYgACARakHSmQFqIgktAAAEQANAIAtBAXEEQANAIA4oAgAgBGogBUEYdjoAACACIAIoAgBBAWoiBDYCACABIAEoAgBBCHQiBTYCACAHIAcoAgAiC0F4aiIINgIAIAtBD0oNAAsLIAFBgICAgHggCHYgBXIiBTYCACAHIAhBAWoiAzYCACAIQQZKIQsgAyEIIAZBAWoiBiAJLQAASQ0ACwsgCwRAA0AgDigCACAEaiAFQRh2OgAAIAIgAigCAEEBaiIENgIAIAEgASgCAEEIdCIFNgIAIAcgBygCACILQXhqIgg2AgAgC0EPSg0ACwsgASAFNgIAIAcgCEEBaiIINgIAIBFBAWoiESATRw0ACwsgACgC6ARBA04EQCAPIAQgDWs2AiBBtKoCKAIAQYy7ASAPQSBqEMIGGiABKAIAIQUgAigCACEEIAcoAgAhCAtBACESIBZBf0ghFyAEIQ0DQCAAIBJBggJsaiIVQaSmAmotAAAhBiAIQQhOBEADQCAOKAIAIA1qIAVBGHY6AAAgAiACKAIAQQFqIg02AgAgASABKAIAQQh0IgU2AgAgByAHKAIAIgtBeGoiCDYCACALQQ9KDQALCyABIAZBGyAIa3QgBXIiBTYCACAHIAhBBWoiCDYCAEEAIREgF0UEQANAIAYgESAVakGkpgJqIgMtAAAiCUgEQANAIAhBCE4EQANAIA4oAgAgDWogBUEYdjoAACACIAIoAgBBAWoiDTYCACABIAEoAgBBCHQiBTYCACAHIAcoAgAiC0F4aiIINgIAIAtBD0oNAAsLIAFBAkEeIAhrdCAFciIFNgIAIAcgCEECaiIINgIAIAZBAWoiBiADLQAAIglIDQALCyAIQQdKIQsgBiAJSgRAA0AgC0EBcQRAA0AgDigCACANaiAFQRh2OgAAIAIgAigCAEEBaiINNgIAIAEgASgCAEEIdCIFNgIAIAcgBygCACILQXhqIgg2AgAgC0EPSg0ACwsgAUEDQR4gCGt0IAVyIgU2AgAgByAIQQJqIgk2AgAgCEEFSiELIAkhCCAGQX9qIgYgAy0AAEoNAAsLIAsEQANAIA4oAgAgDWogBUEYdjoAACACIAIoAgBBAWoiDTYCACABIAEoAgBBCHQiBTYCACAHIAcoAgAiC0F4aiIINgIAIAtBD0oNAAsLIAEgBTYCACAHIAhBAWoiCDYCACARQQFqIhEgCkcNAAsLIBJBAWoiEiAQRw0ACyAAKALoBEEDTgRAIA8gDSAEazYCEEG0qgIoAgBBm7sBIA9BEGoQwgYaIAIoAgAhDQtBACEDAkAgACgC9AQiBUEBSARAQQAhEgwBCyAQQQZHIRdBACESA0AgBUF/aiEIIANBMWoiESAFSCEFIBAgACASakGADWoiCi0AAE0EQEG+FxDRAgsCQCAXRUEAIBEgCCAFGyIVIANrQTFGG0UEQCAVIANIDQEgFSADIBUgA0obIREgASgCACEFIAcoAgAhBgNAIBQgA0EBdGovAQAiCyAAIAotAAAiCEGCAmxqakGkpgJqLQAAIQkgACAIQYgIbGogC0ECdGpBsLICaigCACEEIAZBCE4EQCACKAIAIQgDQCAOKAIAIAhqIAVBGHY6AAAgAiACKAIAQQFqIgg2AgAgASABKAIAQQh0IgU2AgAgByAHKAIAIgtBeGoiBjYCACALQQ9KDQALCyABIARBICAGIAlqIgZrdCAFciIFNgIAIAcgBjYCACADIBFHIQggA0EBaiEDIAgNAAsMAQsgACAKLQAAIghBggJsaiIFIBQgA0EBdGoiCy8BACIGakGkpgJqLQAAIQogACAIQYgIbGoiCCAGQQJ0akGwsgJqKAIAIQwgACgC2AQhBiAAKALcBCIEQQhOBEAgAigCACEDA0AgDigCACADaiAGQRh2OgAAIAIgAigCAEEBaiIDNgIAIAEgASgCAEEIdCIGNgIAIAcgBygCACIJQXhqIgQ2AgAgCUEPSg0ACwsgACAEIApqIgQ2AtwEIAAgDEEgIARrdCAGciIGNgLYBCAFIAsvAQIiA2pBpKYCai0AACEKIAggA0ECdGpBsLICaigCACEMIARBCE4EQCACKAIAIQMDQCAOKAIAIANqIAZBGHY6AAAgAiACKAIAQQFqIgM2AgAgASABKAIAQQh0IgY2AgAgByAHKAIAIglBeGoiBDYCACAJQQ9KDQALCyAAIAQgCmoiBDYC3AQgACAMQSAgBGt0IAZyIgY2AtgEIAUgCy8BBCIDakGkpgJqLQAAIQogCCADQQJ0akGwsgJqKAIAIQwgBEEITgRAIAIoAgAhAwNAIA4oAgAgA2ogBkEYdjoAACACIAIoAgBBAWoiAzYCACABIAEoAgBBCHQiBjYCACAHIAcoAgAiCUF4aiIENgIAIAlBD0oNAAsLIAAgBCAKaiIENgLcBCAAIAxBICAEa3QgBnIiBjYC2AQgBSALLwEGIgNqQaSmAmotAAAhCiAIIANBAnRqQbCyAmooAgAhDCAEQQhOBEAgAigCACEDA0AgDigCACADaiAGQRh2OgAAIAIgAigCAEEBaiIDNgIAIAEgASgCAEEIdCIGNgIAIAcgBygCACIJQXhqIgQ2AgAgCUEPSg0ACwsgACAEIApqIgQ2AtwEIAAgDEEgIARrdCAGciIGNgLYBCAFIAsvAQgiA2pBpKYCai0AACEKIAggA0ECdGpBsLICaigCACEMIARBCE4EQCACKAIAIQMDQCAOKAIAIANqIAZBGHY6AAAgAiACKAIAQQFqIgM2AgAgASABKAIAQQh0IgY2AgAgByAHKAIAIglBeGoiBDYCACAJQQ9KDQALCyAAIAQgCmoiBDYC3AQgACAMQSAgBGt0IAZyIgY2AtgEIAUgCy8BCiIDakGkpgJqLQAAIQogCCADQQJ0akGwsgJqKAIAIQwgBEEITgRAIAIoAgAhAwNAIA4oAgAgA2ogBkEYdjoAACACIAIoAgBBAWoiAzYCACABIAEoAgBBCHQiBjYCACAHIAcoAgAiCUF4aiIENgIAIAlBD0oNAAsLIAAgBCAKaiIENgLcBCAAIAxBICAEa3QgBnIiBjYC2AQgBSALLwEMIgNqQaSmAmotAAAhCiAIIANBAnRqQbCyAmooAgAhDCAEQQhOBEAgAigCACEDA0AgDigCACADaiAGQRh2OgAAIAIgAigCAEEBaiIDNgIAIAEgASgCAEEIdCIGNgIAIAcgBygCACIJQXhqIgQ2AgAgCUEPSg0ACwsgACAEIApqIgQ2AtwEIAAgDEEgIARrdCAGciIGNgLYBCAFIAsvAQ4iA2pBpKYCai0AACEKIAggA0ECdGpBsLICaigCACEMIARBCE4EQCACKAIAIQMDQCAOKAIAIANqIAZBGHY6AAAgAiACKAIAQQFqIgM2AgAgASABKAIAQQh0IgY2AgAgByAHKAIAIglBeGoiBDYCACAJQQ9KDQALCyAAIAQgCmoiBDYC3AQgACAMQSAgBGt0IAZyIgY2AtgEIAUgCy8BECIDakGkpgJqLQAAIQogCCADQQJ0akGwsgJqKAIAIQwgBEEITgRAIAIoAgAhAwNAIA4oAgAgA2ogBkEYdjoAACACIAIoAgBBAWoiAzYCACABIAEoAgBBCHQiBjYCACAHIAcoAgAiCUF4aiIENgIAIAlBD0oNAAsLIAAgBCAKaiIENgLcBCAAIAxBICAEa3QgBnIiBjYC2AQgBSALLwESIgNqQaSmAmotAAAhCiAIIANBAnRqQbCyAmooAgAhDCAEQQhOBEAgAigCACEDA0AgDigCACADaiAGQRh2OgAAIAIgAigCAEEBaiIDNgIAIAEgASgCAEEIdCIGNgIAIAcgBygCACIJQXhqIgQ2AgAgCUEPSg0ACwsgACAEIApqIgQ2AtwEIAAgDEEgIARrdCAGciIGNgLYBCAFIAsvARQiA2pBpKYCai0AACEKIAggA0ECdGpBsLICaigCACEMIARBCE4EQCACKAIAIQMDQCAOKAIAIANqIAZBGHY6AAAgAiACKAIAQQFqIgM2AgAgASABKAIAQQh0IgY2AgAgByAHKAIAIglBeGoiBDYCACAJQQ9KDQALCyAAIAQgCmoiBDYC3AQgACAMQSAgBGt0IAZyIgY2AtgEIAUgCy8BFiIDakGkpgJqLQAAIQogCCADQQJ0akGwsgJqKAIAIQwgBEEITgRAIAIoAgAhAwNAIA4oAgAgA2ogBkEYdjoAACACIAIoAgBBAWoiAzYCACABIAEoAgBBCHQiBjYCACAHIAcoAgAiCUF4aiIENgIAIAlBD0oNAAsLIAAgBCAKaiIENgLcBCAAIAxBICAEa3QgBnIiBjYC2AQgBSALLwEYIgNqQaSmAmotAAAhCiAIIANBAnRqQbCyAmooAgAhDCAEQQhOBEAgAigCACEDA0AgDigCACADaiAGQRh2OgAAIAIgAigCAEEBaiIDNgIAIAEgASgCAEEIdCIGNgIAIAcgBygCACIJQXhqIgQ2AgAgCUEPSg0ACwsgACAEIApqIgQ2AtwEIAAgDEEgIARrdCAGciIGNgLYBCAFIAsvARoiA2pBpKYCai0AACEKIAggA0ECdGpBsLICaigCACEMIARBCE4EQCACKAIAIQMDQCAOKAIAIANqIAZBGHY6AAAgAiACKAIAQQFqIgM2AgAgASABKAIAQQh0IgY2AgAgByAHKAIAIglBeGoiBDYCACAJQQ9KDQALCyAAIAQgCmoiBDYC3AQgACAMQSAgBGt0IAZyIgY2AtgEIAUgCy8BHCIDakGkpgJqLQAAIQogCCADQQJ0akGwsgJqKAIAIQwgBEEITgRAIAIoAgAhAwNAIA4oAgAgA2ogBkEYdjoAACACIAIoAgBBAWoiAzYCACABIAEoAgBBCHQiBjYCACAHIAcoAgAiCUF4aiIENgIAIAlBD0oNAAsLIAAgBCAKaiIENgLcBCAAIAxBICAEa3QgBnIiBjYC2AQgBSALLwEeIgNqQaSmAmotAAAhCiAIIANBAnRqQbCyAmooAgAhDCAEQQhOBEAgAigCACEDA0AgDigCACADaiAGQRh2OgAAIAIgAigCAEEBaiIDNgIAIAEgASgCAEEIdCIGNgIAIAcgBygCACIJQXhqIgQ2AgAgCUEPSg0ACwsgACAEIApqIgQ2AtwEIAAgDEEgIARrdCAGciIGNgLYBCAFIAsvASAiA2pBpKYCai0AACEKIAggA0ECdGpBsLICaigCACEMIARBCE4EQCACKAIAIQMDQCAOKAIAIANqIAZBGHY6AAAgAiACKAIAQQFqIgM2AgAgASABKAIAQQh0IgY2AgAgByAHKAIAIglBeGoiBDYCACAJQQ9KDQALCyAAIAQgCmoiBDYC3AQgACAMQSAgBGt0IAZyIgY2AtgEIAUgCy8BIiIDakGkpgJqLQAAIQogCCADQQJ0akGwsgJqKAIAIQwgBEEITgRAIAIoAgAhAwNAIA4oAgAgA2ogBkEYdjoAACACIAIoAgBBAWoiAzYCACABIAEoAgBBCHQiBjYCACAHIAcoAgAiCUF4aiIENgIAIAlBD0oNAAsLIAAgBCAKaiIENgLcBCAAIAxBICAEa3QgBnIiBjYC2AQgBSALLwEkIgNqQaSmAmotAAAhCiAIIANBAnRqQbCyAmooAgAhDCAEQQhOBEAgAigCACEDA0AgDigCACADaiAGQRh2OgAAIAIgAigCAEEBaiIDNgIAIAEgASgCAEEIdCIGNgIAIAcgBygCACIJQXhqIgQ2AgAgCUEPSg0ACwsgACAEIApqIgQ2AtwEIAAgDEEgIARrdCAGciIGNgLYBCAFIAsvASYiA2pBpKYCai0AACEKIAggA0ECdGpBsLICaigCACEMIARBCE4EQCACKAIAIQMDQCAOKAIAIANqIAZBGHY6AAAgAiACKAIAQQFqIgM2AgAgASABKAIAQQh0IgY2AgAgByAHKAIAIglBeGoiBDYCACAJQQ9KDQALCyAAIAQgCmoiBDYC3AQgACAMQSAgBGt0IAZyIgY2AtgEIAUgCy8BKCIDakGkpgJqLQAAIQogCCADQQJ0akGwsgJqKAIAIQwgBEEITgRAIAIoAgAhAwNAIA4oAgAgA2ogBkEYdjoAACACIAIoAgBBAWoiAzYCACABIAEoAgBBCHQiBjYCACAHIAcoAgAiCUF4aiIENgIAIAlBD0oNAAsLIAAgBCAKaiIENgLcBCAAIAxBICAEa3QgBnIiBjYC2AQgBSALLwEqIgNqQaSmAmotAAAhCiAIIANBAnRqQbCyAmooAgAhDCAEQQhOBEAgAigCACEDA0AgDigCACADaiAGQRh2OgAAIAIgAigCAEEBaiIDNgIAIAEgASgCAEEIdCIGNgIAIAcgBygCACIJQXhqIgQ2AgAgCUEPSg0ACwsgACAEIApqIgQ2AtwEIAAgDEEgIARrdCAGciIGNgLYBCAFIAsvASwiA2pBpKYCai0AACEKIAggA0ECdGpBsLICaigCACEMIARBCE4EQCACKAIAIQMDQCAOKAIAIANqIAZBGHY6AAAgAiACKAIAQQFqIgM2AgAgASABKAIAQQh0IgY2AgAgByAHKAIAIglBeGoiBDYCACAJQQ9KDQALCyAAIAQgCmoiBDYC3AQgACAMQSAgBGt0IAZyIgY2AtgEIAUgCy8BLiIDakGkpgJqLQAAIQogCCADQQJ0akGwsgJqKAIAIQwgBEEITgRAIAIoAgAhAwNAIA4oAgAgA2ogBkEYdjoAACACIAIoAgBBAWoiAzYCACABIAEoAgBBCHQiBjYCACAHIAcoAgAiCUF4aiIENgIAIAlBD0oNAAsLIAAgBCAKaiIENgLcBCAAIAxBICAEa3QgBnIiBjYC2AQgBSALLwEwIgNqQaSmAmotAAAhCiAIIANBAnRqQbCyAmooAgAhDCAEQQhOBEAgAigCACEDA0AgDigCACADaiAGQRh2OgAAIAIgAigCAEEBaiIDNgIAIAEgASgCAEEIdCIGNgIAIAcgBygCACIJQXhqIgQ2AgAgCUEPSg0ACwsgACAEIApqIgQ2AtwEIAAgDEEgIARrdCAGciIGNgLYBCAFIAsvATIiA2pBpKYCai0AACEKIAggA0ECdGpBsLICaigCACEMIARBCE4EQCACKAIAIQMDQCAOKAIAIANqIAZBGHY6AAAgAiACKAIAQQFqIgM2AgAgASABKAIAQQh0IgY2AgAgByAHKAIAIglBeGoiBDYCACAJQQ9KDQALCyAAIAQgCmoiBDYC3AQgACAMQSAgBGt0IAZyIgY2AtgEIAUgCy8BNCIDakGkpgJqLQAAIQogCCADQQJ0akGwsgJqKAIAIQwgBEEITgRAIAIoAgAhAwNAIA4oAgAgA2ogBkEYdjoAACACIAIoAgBBAWoiAzYCACABIAEoAgBBCHQiBjYCACAHIAcoAgAiCUF4aiIENgIAIAlBD0oNAAsLIAAgBCAKaiIENgLcBCAAIAxBICAEa3QgBnIiBjYC2AQgBSALLwE2IgNqQaSmAmotAAAhCiAIIANBAnRqQbCyAmooAgAhDCAEQQhOBEAgAigCACEDA0AgDigCACADaiAGQRh2OgAAIAIgAigCAEEBaiIDNgIAIAEgASgCAEEIdCIGNgIAIAcgBygCACIJQXhqIgQ2AgAgCUEPSg0ACwsgACAEIApqIgQ2AtwEIAAgDEEgIARrdCAGciIGNgLYBCAFIAsvATgiA2pBpKYCai0AACEKIAggA0ECdGpBsLICaigCACEMIARBCE4EQCACKAIAIQMDQCAOKAIAIANqIAZBGHY6AAAgAiACKAIAQQFqIgM2AgAgASABKAIAQQh0IgY2AgAgByAHKAIAIglBeGoiBDYCACAJQQ9KDQALCyAAIAQgCmoiBDYC3AQgACAMQSAgBGt0IAZyIgY2AtgEIAUgCy8BOiIDakGkpgJqLQAAIQogCCADQQJ0akGwsgJqKAIAIQwgBEEITgRAIAIoAgAhAwNAIA4oAgAgA2ogBkEYdjoAACACIAIoAgBBAWoiAzYCACABIAEoAgBBCHQiBjYCACAHIAcoAgAiCUF4aiIENgIAIAlBD0oNAAsLIAAgBCAKaiIENgLcBCAAIAxBICAEa3QgBnIiBjYC2AQgBSALLwE8IgNqQaSmAmotAAAhCiAIIANBAnRqQbCyAmooAgAhDCAEQQhOBEAgAigCACEDA0AgDigCACADaiAGQRh2OgAAIAIgAigCAEEBaiIDNgIAIAEgASgCAEEIdCIGNgIAIAcgBygCACIJQXhqIgQ2AgAgCUEPSg0ACwsgACAEIApqIgQ2AtwEIAAgDEEgIARrdCAGciIGNgLYBCAFIAsvAT4iA2pBpKYCai0AACEKIAggA0ECdGpBsLICaigCACEMIARBCE4EQCACKAIAIQMDQCAOKAIAIANqIAZBGHY6AAAgAiACKAIAQQFqIgM2AgAgASABKAIAQQh0IgY2AgAgByAHKAIAIglBeGoiBDYCACAJQQ9KDQALCyAAIAQgCmoiBDYC3AQgACAMQSAgBGt0IAZyIgY2AtgEIAUgC0FAay8BACIDakGkpgJqLQAAIQogCCADQQJ0akGwsgJqKAIAIQwgBEEITgRAIAIoAgAhAwNAIA4oAgAgA2ogBkEYdjoAACACIAIoAgBBAWoiAzYCACABIAEoAgBBCHQiBjYCACAHIAcoAgAiCUF4aiIENgIAIAlBD0oNAAsLIAAgBCAKaiIENgLcBCAAIAxBICAEa3QgBnIiBjYC2AQgBSALLwFCIgNqQaSmAmotAAAhCiAIIANBAnRqQbCyAmooAgAhDCAEQQhOBEAgAigCACEDA0AgDigCACADaiAGQRh2OgAAIAIgAigCAEEBaiIDNgIAIAEgASgCAEEIdCIGNgIAIAcgBygCACIJQXhqIgQ2AgAgCUEPSg0ACwsgACAEIApqIgQ2AtwEIAAgDEEgIARrdCAGciIGNgLYBCAFIAsvAUQiA2pBpKYCai0AACEKIAggA0ECdGpBsLICaigCACEMIARBCE4EQCACKAIAIQMDQCAOKAIAIANqIAZBGHY6AAAgAiACKAIAQQFqIgM2AgAgASABKAIAQQh0IgY2AgAgByAHKAIAIglBeGoiBDYCACAJQQ9KDQALCyAAIAQgCmoiBDYC3AQgACAMQSAgBGt0IAZyIgY2AtgEIAUgCy8BRiIDakGkpgJqLQAAIQogCCADQQJ0akGwsgJqKAIAIQwgBEEITgRAIAIoAgAhAwNAIA4oAgAgA2ogBkEYdjoAACACIAIoAgBBAWoiAzYCACABIAEoAgBBCHQiBjYCACAHIAcoAgAiCUF4aiIENgIAIAlBD0oNAAsLIAAgBCAKaiIENgLcBCAAIAxBICAEa3QgBnIiBjYC2AQgBSALLwFIIgNqQaSmAmotAAAhCiAIIANBAnRqQbCyAmooAgAhDCAEQQhOBEAgAigCACEDA0AgDigCACADaiAGQRh2OgAAIAIgAigCAEEBaiIDNgIAIAEgASgCAEEIdCIGNgIAIAcgBygCACIJQXhqIgQ2AgAgCUEPSg0ACwsgACAEIApqIgQ2AtwEIAAgDEEgIARrdCAGciIGNgLYBCAFIAsvAUoiA2pBpKYCai0AACEKIAggA0ECdGpBsLICaigCACEMIARBCE4EQCACKAIAIQMDQCAOKAIAIANqIAZBGHY6AAAgAiACKAIAQQFqIgM2AgAgASABKAIAQQh0IgY2AgAgByAHKAIAIglBeGoiBDYCACAJQQ9KDQALCyAAIAQgCmoiBDYC3AQgACAMQSAgBGt0IAZyIgY2AtgEIAUgCy8BTCIDakGkpgJqLQAAIQogCCADQQJ0akGwsgJqKAIAIQwgBEEITgRAIAIoAgAhAwNAIA4oAgAgA2ogBkEYdjoAACACIAIoAgBBAWoiAzYCACABIAEoAgBBCHQiBjYCACAHIAcoAgAiCUF4aiIENgIAIAlBD0oNAAsLIAAgBCAKaiIENgLcBCAAIAxBICAEa3QgBnIiBjYC2AQgBSALLwFOIgNqQaSmAmotAAAhCiAIIANBAnRqQbCyAmooAgAhDCAEQQhOBEAgAigCACEDA0AgDigCACADaiAGQRh2OgAAIAIgAigCAEEBaiIDNgIAIAEgASgCAEEIdCIGNgIAIAcgBygCACIJQXhqIgQ2AgAgCUEPSg0ACwsgACAEIApqIgQ2AtwEIAAgDEEgIARrdCAGciIGNgLYBCAFIAsvAVAiA2pBpKYCai0AACEKIAggA0ECdGpBsLICaigCACEMIARBCE4EQCACKAIAIQMDQCAOKAIAIANqIAZBGHY6AAAgAiACKAIAQQFqIgM2AgAgASABKAIAQQh0IgY2AgAgByAHKAIAIglBeGoiBDYCACAJQQ9KDQALCyAAIAQgCmoiBDYC3AQgACAMQSAgBGt0IAZyIgY2AtgEIAUgCy8BUiIDakGkpgJqLQAAIQogCCADQQJ0akGwsgJqKAIAIQwgBEEITgRAIAIoAgAhAwNAIA4oAgAgA2ogBkEYdjoAACACIAIoAgBBAWoiAzYCACABIAEoAgBBCHQiBjYCACAHIAcoAgAiCUF4aiIENgIAIAlBD0oNAAsLIAAgBCAKaiIENgLcBCAAIAxBICAEa3QgBnIiBjYC2AQgBSALLwFUIgNqQaSmAmotAAAhCiAIIANBAnRqQbCyAmooAgAhDCAEQQhOBEAgAigCACEDA0AgDigCACADaiAGQRh2OgAAIAIgAigCAEEBaiIDNgIAIAEgASgCAEEIdCIGNgIAIAcgBygCACIJQXhqIgQ2AgAgCUEPSg0ACwsgACAEIApqIgQ2AtwEIAAgDEEgIARrdCAGciIGNgLYBCAFIAsvAVYiA2pBpKYCai0AACEKIAggA0ECdGpBsLICaigCACEMIARBCE4EQCACKAIAIQMDQCAOKAIAIANqIAZBGHY6AAAgAiACKAIAQQFqIgM2AgAgASABKAIAQQh0IgY2AgAgByAHKAIAIglBeGoiBDYCACAJQQ9KDQALCyAAIAQgCmoiBDYC3AQgACAMQSAgBGt0IAZyIgY2AtgEIAUgCy8BWCIDakGkpgJqLQAAIQogCCADQQJ0akGwsgJqKAIAIQwgBEEITgRAIAIoAgAhAwNAIA4oAgAgA2ogBkEYdjoAACACIAIoAgBBAWoiAzYCACABIAEoAgBBCHQiBjYCACAHIAcoAgAiCUF4aiIENgIAIAlBD0oNAAsLIAAgBCAKaiIENgLcBCAAIAxBICAEa3QgBnIiBjYC2AQgBSALLwFaIgNqQaSmAmotAAAhCiAIIANBAnRqQbCyAmooAgAhDCAEQQhOBEAgAigCACEDA0AgDigCACADaiAGQRh2OgAAIAIgAigCAEEBaiIDNgIAIAEgASgCAEEIdCIGNgIAIAcgBygCACIJQXhqIgQ2AgAgCUEPSg0ACwsgACAEIApqIgQ2AtwEIAAgDEEgIARrdCAGciIGNgLYBCAFIAsvAVwiA2pBpKYCai0AACEKIAggA0ECdGpBsLICaigCACEMIARBCE4EQCACKAIAIQMDQCAOKAIAIANqIAZBGHY6AAAgAiACKAIAQQFqIgM2AgAgASABKAIAQQh0IgY2AgAgByAHKAIAIglBeGoiBDYCACAJQQ9KDQALCyAAIAQgCmoiBDYC3AQgACAMQSAgBGt0IAZyIgY2AtgEIAUgCy8BXiIDakGkpgJqLQAAIQogCCADQQJ0akGwsgJqKAIAIQwgBEEITgRAIAIoAgAhAwNAIA4oAgAgA2ogBkEYdjoAACACIAIoAgBBAWoiAzYCACABIAEoAgBBCHQiBjYCACAHIAcoAgAiCUF4aiIENgIAIAlBD0oNAAsLIAAgBCAKaiIJNgLcBCAAIAxBICAJa3QgBnIiBjYC2AQgBSALLwFgIgtqQaSmAmotAAAhBCAIIAtBAnRqQbCyAmooAgAhCiAJQQhOBEAgAigCACELA0AgDigCACALaiAGQRh2OgAAIAIgAigCAEEBaiILNgIAIAEgASgCAEEIdCIGNgIAIAcgBygCACIDQXhqIgk2AgAgA0EPSg0ACwsgACAEIAlqIgM2AtwEIAAgCkEgIANrdCAGciILNgLYBCAFIBQgEUEBdGovAQAiBmpBpKYCai0AACEJIAggBkECdGpBsLICaigCACEGIANBCE4EQCACKAIAIQUDQCAOKAIAIAVqIAtBGHY6AAAgAiACKAIAQQFqIgU2AgAgASABKAIAQQh0Igs2AgAgByAHKAIAIghBeGoiAzYCACAIQQ9KDQALCyABIAZBICADIAlqIgVrdCALcjYCACAHIAU2AgALIBJBAWohEiAVQQFqIgMgACgC9AQiBUgNAAsLIBIgE0cEQEG/FxDRAgsgACgC6ARBA04EQCAPIAIoAgAgDWs2AgBBtKoCKAIAQa27ASAPEMIGGgsgD0HQAWokAAvTbwEkfyMAQRBrIhkkACAAKAIAIQECfyAAKAIEIgNBCkcEQCAAKALw9AMhGiAAKALs9AMhGyAAKALo9AMhHCAAKALk9AMhGCAAKALg9AMhHSAAKALc9AMhISAAKALY9AMhECAAKALU9AMhDSAAKALQ9AMhJCAAKALM9AMhHyAAKALI9AMhIyAAKALE9AMhEiAAKALA9AMhCyAAKAK89AMhHiAAKAK49AMhDyAAKAK09AMhESAAKAKw9AMhFCAAKAKs9AMhFSAAKAKk9AMhEyAAKAKg9AMhICAAKAKc9AMhFiAAKAKY9AMhDiAAKAKU9AMhCSAAKAKo9AMMAQtBACEaIABBlPQDakEAQeAAEJoIGkEAIRtBACEcQQAhGEEAIR1BACEhQQAhEEEAIQ1BACEkQQAhH0EAISNBACESQQAhC0EAIR5BACEPQQAhEUEAIRRBACEVQQAhE0EAISBBACEWQQAhDkEAIQlBAAshFwJAAkACQAJAAn8CQAJ/AkACQAJAAkACfwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgA0F2aiIDQShNBEACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgA0EBaw4oBAUGKgcICQoLOgwNDg8QERIhIkQTIyQlFEgAHwEgAhUWFxgZGhscHQMLIAAoAiAhBkEADEgLIAAoAiAhDEEAIQEMSAsgACgCICEKQQEhAQxHCyAAQQo2AgQgACgCICICQQhOBEAgACgCHCEIDCMLIAEoAgQhAyACIQQDQCADRQ1IIAEoAgAiBS0AACEHIAAgBEEIaiICNgIgIAAgByAAKAIcQQh0ciIINgIcIAEgA0F/aiIDNgIEIAEgBUEBajYCACABIAEoAggiBUEBaiIHNgIIIAcgBUkEQCABIAEoAgxBAWo2AgwLIARBf0ohBSACIQQgBUUNAAsMIgsgACgCICEFDCILIAAoAiAhBQwiCyAAKAIgIQUMIgsgACgCICEDDCMLIAAoAiAhBQwtCyAAKAIgIQUMLQsgACgCICEFDC0LIAAoAiAhBQwtCyAAKAIgIQIMLgsgACgCICECDC4LIAAoAiAhAgwuCyAAKAIgIQIMLgsgACgCICECDC4LIAAoAiAhAgwuCyAAKAIgIQIMLgsgACgCICEFDDELIAAoAiAhBkEDDDILIAAoAiAhAwwWCyAAKAIgIQYMFgsgACgCICEGDBYLIAAoAiAhBgwWCyAAKAIgIQYMFgsgACgCICEGDBYLIAAoAiAhAgwWCyAAKAIgIQIMFgsgACgCICECDBYLQaEfENECQaIfENECDCwLQQMhAQwqC0EEIQEMKQtBAQwgC0EBIQEMIAtBASEBDCILQQEMIgtBAgwhCyAAIAJBeGoiBTYCIEF7IQIgCCAFdkH/AXFBwgBHDSULIABBCzYCBAJAIAVBCE4EQCAAKAIcIQgMAQsgASgCBCEDIAUhBANAIANFDSUgASgCACICLQAAIQcgACAEQQhqIgU2AiAgACAHIAAoAhxBCHRyIgg2AhwgASADQX9qIgM2AgQgASACQQFqNgIAIAEgASgCCCICQQFqIgc2AgggByACSQRAIAEgASgCDEEBajYCDAsgBEF/SiECIAUhBCACRQ0ACwsgACAFQXhqIgU2AiBBeyECIAggBXZB/wFxQdoARw0kCyAAQQw2AgQCQCAFQQhOBEAgACgCHCEIDAELIAEoAgQhAyAFIQQDQCADRQ0kIAEoAgAiAi0AACEHIAAgBEEIaiIFNgIgIAAgByAAKAIcQQh0ciIINgIcIAEgA0F/aiIDNgIEIAEgAkEBajYCACABIAEoAggiAkEBaiIHNgIIIAcgAkkEQCABIAEoAgxBAWo2AgwLIARBf0ohAiAFIQQgAkUNAAsLIAAgBUF4aiIFNgIgQXshAiAIIAV2Qf8BcUHoAEcNIwsgAEENNgIEAkAgBUEITgRAIAAoAhwhCAwBCyABKAIEIQMgBSEEA0AgA0UNIyABKAIAIgItAAAhByAAIARBCGoiBTYCICAAIAcgACgCHEEIdHIiCDYCHCABIANBf2oiAzYCBCABIAJBAWo2AgAgASABKAIIIgJBAWoiBzYCCCAHIAJJBEAgASABKAIMQQFqNgIMCyAEQX9KIQIgBSEEIAJFDQALCyAAIAVBeGoiAzYCICAAIAggA3ZB/wFxIgM2AiRBeyECIANBT2pBCEsNIiAAIANBUGoiAzYCJCABKAIsIQQgASgCJCECIAAtACgEQCAAIAQgA0HAmgxsQQEgAhEAADYC0BggACABKAIsIAAoAiRBoI0GbEEBdUEBIAEoAiQRAAAiATYC1BhBfSECIAFFDSMgACgC0BhFDSMMAQsgACAEIANBgLUYbEEBIAIRAAAiATYCzBggAQ0AQX0hAgwiCyAAQQ42AgQCQCAAKAIgIgJBCE4EQCAAKAIcIQgMAQsgACgCACIBKAIEIQMgAiEEA0AgA0UNIiABKAIAIgUtAAAhByAAIARBCGoiAjYCICAAIAcgACgCHEEIdHIiCDYCHCABIANBf2oiAzYCBCABIAVBAWo2AgAgASABKAIIIgVBAWoiBzYCCCAHIAVJBEAgASABKAIMQQFqNgIMCyAEQX9KIQUgAiEEIAVFDQALCyAAIAJBeGoiAzYCICAIIAN2Qf8BcSIBQRdGDQFBfCECIAFBMUcNIQsgAEEPNgIEIANBCE4EQCAAKAIcIQgMCgsgACgCACIBKAIEIQQgAyECA0AgBEUNICABKAIAIgUtAAAhByAAIAJBCGoiAzYCICAAIAcgACgCHEEIdHIiCDYCHCABIARBf2oiBDYCBCABIAVBAWo2AgAgASABKAIIIgVBAWoiBzYCCCAHIAVJBEAgASABKAIMQQFqNgIMCyACQX9KIQUgAyECIAVFDQALDAkLIABBKjYCBAJAIANBCE4EQCAAKAIcIQwMAQsgACgCACIBKAIEIQQgAyECA0AgBEUNICABKAIAIgYtAAAhCiAAIAJBCGoiAzYCICAAIAogACgCHEEIdHIiDDYCHCABIARBf2oiBDYCBCABIAZBAWo2AgAgASABKAIIIgZBAWoiCjYCCCAKIAZJBEAgASABKAIMQQFqNgIMCyACQX9KIQYgAyECIAZFDQALCyAAIANBeGoiBjYCIEF8IQIgDCAGdkH/AXFB8gBHDR8LIABBKzYCBAJAIAZBCE4EQCAAKAIcIQwMAQsgACgCACIBKAIEIQMgBiEEA0AgA0UNHyABKAIAIgItAAAhCiAAIARBCGoiBjYCICAAIAogACgCHEEIdHIiDDYCHCABIANBf2oiAzYCBCABIAJBAWo2AgAgASABKAIIIgJBAWoiCjYCCCAKIAJJBEAgASABKAIMQQFqNgIMCyAEQX9KIQIgBiEEIAJFDQALCyAAIAZBeGoiBjYCIEF8IQIgDCAGdkH/AXFBxQBHDR4LIABBLDYCBAJAIAZBCE4EQCAAKAIcIQwMAQsgACgCACIBKAIEIQMgBiEEA0AgA0UNHiABKAIAIgItAAAhCiAAIARBCGoiBjYCICAAIAogACgCHEEIdHIiDDYCHCABIANBf2oiAzYCBCABIAJBAWo2AgAgASABKAIIIgJBAWoiCjYCCCAKIAJJBEAgASABKAIMQQFqNgIMCyAEQX9KIQIgBiEEIAJFDQALCyAAIAZBeGoiBjYCIEF8IQIgDCAGdkH/AXFBOEcNHQsgAEEtNgIEAkAgBkEITgRAIAAoAhwhDAwBCyAAKAIAIgEoAgQhAyAGIQQDQCADRQ0dIAEoAgAiAi0AACEKIAAgBEEIaiIGNgIgIAAgCiAAKAIcQQh0ciIMNgIcIAEgA0F/aiIDNgIEIAEgAkEBajYCACABIAEoAggiAkEBaiIKNgIIIAogAkkEQCABIAEoAgxBAWo2AgwLIARBf0ohAiAGIQQgAkUNAAsLIAAgBkF4aiIGNgIgQXwhAiAMIAZ2Qf8BcUHQAEcNHAsgAEEuNgIEAkAgBkEITgRAIAAoAhwhDAwBCyAAKAIAIgEoAgQhAyAGIQQDQCADRQ0cIAEoAgAiAi0AACEKIAAgBEEIaiIGNgIgIAAgCiAAKAIcQQh0ciIMNgIcIAEgA0F/aiIDNgIEIAEgAkEBajYCACABIAEoAggiAkEBaiIKNgIIIAogAkkEQCABIAEoAgxBAWo2AgwLIARBf0ohAiAGIQQgAkUNAAsLIAAgBkF4aiIGNgIgQXwhAiAMIAZ2Qf8BcUGQAUcNGyAAQQA2AtwYCyAAQS82AgQCQCAGQQhOBEAgACgCHCEMDAELIAAoAgAiASgCBCEDIAYhBANAIANFDRsgASgCACICLQAAIQogACAEQQhqIgY2AiAgACAKIAAoAhxBCHRyIgw2AhwgASADQX9qIgM2AgQgASACQQFqNgIAIAEgASgCCCICQQFqIgo2AgggCiACSQRAIAEgASgCDEEBajYCDAsgBEF/SiECIAYhBCACRQ0ACwsgACAGQXhqIgI2AiAgACAMIAJ2Qf8BcSAAKALcGEEIdHI2AtwYCyAAQTA2AgQCQCACQQhOBEAgACgCHCEMDAELIAAoAgAiASgCBCEDIAIhBANAIANFDRogASgCACIGLQAAIQogACAEQQhqIgI2AiAgACAKIAAoAhxBCHRyIgw2AhwgASADQX9qIgM2AgQgASAGQQFqNgIAIAEgASgCCCIGQQFqIgo2AgggCiAGSQRAIAEgASgCDEEBajYCDAsgBEF/SiEGIAIhBCAGRQ0ACwsgACACQXhqIgI2AiAgACAMIAJ2Qf8BcSAAKALcGEEIdHI2AtwYCyAAQTE2AgQCQCACQQhOBEAgACgCHCEMDAELIAAoAgAiASgCBCEDIAIhBANAIANFDRkgASgCACIGLQAAIQogACAEQQhqIgI2AiAgACAKIAAoAhxBCHRyIgw2AhwgASADQX9qIgM2AgQgASAGQQFqNgIAIAEgASgCCCIGQQFqIgo2AgggCiAGSQRAIAEgASgCDEEBajYCDAsgBEF/SiEGIAIhBCAGRQ0ACwsgACACQXhqIgI2AiAgACAMIAJ2Qf8BcSAAKALcGEEIdHI2AtwYCyAAQTI2AgQCQCACQQhOBEAgACgCHCEMDAELIAAoAgAiASgCBCEDIAIhBANAIANFDRggASgCACIGLQAAIQogACAEQQhqIgI2AiAgACAKIAAoAhxBCHRyIgw2AhwgASADQX9qIgM2AgQgASAGQQFqNgIAIAEgASgCCCIGQQFqIgo2AgggCiAGSQRAIAEgASgCDEEBajYCDAsgBEF/SiEGIAIhBCAGRQ0ACwsgAEEBNgIEIAAgAkF4aiIBNgIgIAAgDCABdkH/AXEgACgC3BhBCHRyNgLcGEEEIQIMFwsgACADQXhqIgU2AiBBfCECIAggBXZB/wFxQcEARw0WCyAAQRA2AgQCQCAFQQhOBEAgACgCHCEIDAELIAAoAgAiASgCBCEDIAUhBANAIANFDRYgASgCACICLQAAIQcgACAEQQhqIgU2AiAgACAHIAAoAhxBCHRyIgg2AhwgASADQX9qIgM2AgQgASACQQFqNgIAIAEgASgCCCICQQFqIgc2AgggByACSQRAIAEgASgCDEEBajYCDAsgBEF/SiECIAUhBCACRQ0ACwsgACAFQXhqIgU2AiBBfCECIAggBXZB/wFxQdkARw0VCyAAQRE2AgQCQCAFQQhOBEAgACgCHCEIDAELIAAoAgAiASgCBCEDIAUhBANAIANFDRUgASgCACICLQAAIQcgACAEQQhqIgU2AiAgACAHIAAoAhxBCHRyIgg2AhwgASADQX9qIgM2AgQgASACQQFqNgIAIAEgASgCCCICQQFqIgc2AgggByACSQRAIAEgASgCDEEBajYCDAsgBEF/SiECIAUhBCACRQ0ACwsgACAFQXhqIgU2AiBBfCECIAggBXZB/wFxQSZHDRQLIABBEjYCBAJAIAVBCE4EQCAAKAIcIQgMAQsgACgCACIBKAIEIQMgBSEEA0AgA0UNFCABKAIAIgItAAAhByAAIARBCGoiBTYCICAAIAcgACgCHEEIdHIiCDYCHCABIANBf2oiAzYCBCABIAJBAWo2AgAgASABKAIIIgJBAWoiBzYCCCAHIAJJBEAgASABKAIMQQFqNgIMCyAEQX9KIQIgBSEEIAJFDQALCyAAIAVBeGoiBTYCIEF8IQIgCCAFdkH/AXFB0wBHDRMLIABBEzYCBAJAIAVBCE4EQCAAKAIcIQgMAQsgACgCACIBKAIEIQMgBSEEA0AgA0UNEyABKAIAIgItAAAhByAAIARBCGoiBTYCICAAIAcgACgCHEEIdHIiCDYCHCABIANBf2oiAzYCBCABIAJBAWo2AgAgASABKAIIIgJBAWoiBzYCCCAHIAJJBEAgASABKAIMQQFqNgIMCyAEQX9KIQIgBSEEIAJFDQALCyAAIAVBeGoiATYCIEF8IQIgCCABdkH/AXFB2QBHDRIgACAAKAIsQQFqIgE2AiwgACgCMEECTgRAIBkgATYCAEG0qgIoAgBBt7sBIBkQwgYaCyAAQQA2AtgYCyAAQRQ2AgQCQCAAKAIgIgJBCE4EQCAAKAIcIQgMAQsgACgCACIBKAIEIQMgAiEEA0AgA0UNEiABKAIAIgUtAAAhByAAIARBCGoiAjYCICAAIAcgACgCHEEIdHIiCDYCHCABIANBf2oiAzYCBCABIAVBAWo2AgAgASABKAIIIgVBAWoiBzYCCCAHIAVJBEAgASABKAIMQQFqNgIMCyAEQX9KIQUgAiEEIAVFDQALCyAAIAJBeGoiAjYCICAAIAggAnZB/wFxIAAoAtgYQQh0cjYC2BgLIABBFTYCBAJAIAJBCE4EQCAAKAIcIQgMAQsgACgCACIBKAIEIQMgAiEEA0AgA0UNESABKAIAIgUtAAAhByAAIARBCGoiAjYCICAAIAcgACgCHEEIdHIiCDYCHCABIANBf2oiAzYCBCABIAVBAWo2AgAgASABKAIIIgVBAWoiBzYCCCAHIAVJBEAgASABKAIMQQFqNgIMCyAEQX9KIQUgAiEEIAVFDQALCyAAIAJBeGoiAjYCICAAIAggAnZB/wFxIAAoAtgYQQh0cjYC2BgLIABBFjYCBAJAIAJBCE4EQCAAKAIcIQgMAQsgACgCACIBKAIEIQMgAiEEA0AgA0UNECABKAIAIgUtAAAhByAAIARBCGoiAjYCICAAIAcgACgCHEEIdHIiCDYCHCABIANBf2oiAzYCBCABIAVBAWo2AgAgASABKAIIIgVBAWoiBzYCCCAHIAVJBEAgASABKAIMQQFqNgIMCyAEQX9KIQUgAiEEIAVFDQALCyAAIAJBeGoiAjYCICAAIAggAnZB/wFxIAAoAtgYQQh0cjYC2BgLIABBFzYCBAJAIAJBCE4EQCAAKAIcIQgMAQsgACgCACIBKAIEIQMgAiEEA0AgA0UNDyABKAIAIgUtAAAhByAAIARBCGoiAjYCICAAIAcgACgCHEEIdHIiCDYCHCABIANBf2oiAzYCBCABIAVBAWo2AgAgASABKAIIIgVBAWoiBzYCCCAHIAVJBEAgASABKAIMQQFqNgIMCyAEQX9KIQUgAiEEIAVFDQALCyAAIAJBeGoiAjYCICAAIAggAnZB/wFxIAAoAtgYQQh0cjYC2BgLIABBGDYCBAJAIAJBAU4EQCAAKAIcIQgMAQsgACgCACIBKAIEIQMgAiEEA0AgA0UNDiABKAIAIgUtAAAhByAAIARBCGoiAjYCICAAIAcgACgCHEEIdHIiCDYCHCABIANBf2oiAzYCBCABIAVBAWo2AgAgASABKAIIIgVBAWoiBzYCCCAHIAVJBEAgASABKAIMQQFqNgIMCyAEQXhKIQUgAiEEIAVFDQALCyAAQQA2AjQgACACQX9qIgI2AiAgACAIIAJ2QQFxOgAQCyAAQRk2AgQCQCACQQhOBEAgACgCHCEIDAELIAAoAgAiASgCBCEDIAIhBANAIANFDQ0gASgCACIFLQAAIQcgACAEQQhqIgI2AiAgACAHIAAoAhxBCHRyIgg2AhwgASADQX9qIgM2AgQgASAFQQFqNgIAIAEgASgCCCIFQQFqIgc2AgggByAFSQRAIAEgASgCDEEBajYCDAsgBEF/SiEFIAIhBCAFRQ0ACwsgACACQXhqIgI2AiAgACAIIAJ2Qf8BcSAAKAI0QQh0cjYCNAsgAEEaNgIEAkAgAkEITgRAIAAoAhwhCAwBCyAAKAIAIgEoAgQhAyACIQQDQCADRQ0MIAEoAgAiBS0AACEHIAAgBEEIaiICNgIgIAAgByAAKAIcQQh0ciIINgIcIAEgA0F/aiIDNgIEIAEgBUEBajYCACABIAEoAggiBUEBaiIHNgIIIAcgBUkEQCABIAEoAgxBAWo2AgwLIARBf0ohBSACIQQgBUUNAAsLIAAgAkF4aiICNgIgIAAgCCACdkH/AXEgACgCNEEIdHI2AjQLIABBGzYCBAJAIAJBCE4EQCAAKAIcIQgMAQsgACgCACIBKAIEIQMgAiEEA0AgA0UNCyABKAIAIgUtAAAhByAAIARBCGoiAjYCICAAIAcgACgCHEEIdHIiCDYCHCABIANBf2oiAzYCBCABIAVBAWo2AgAgASABKAIIIgVBAWoiBzYCCCAHIAVJBEAgASABKAIMQQFqNgIMCyAEQX9KIQUgAiEEIAVFDQALCyAAIAJBeGoiATYCICAAIAggAXZB/wFxIAAoAjRBCHRyIgE2AjRBACEEQXwhAiABQQBIDQogASAAKAIkQaCNBmxBCnJKDQpBAAshAQNAAkACQAJAIAFFBEAgBCEJIARBEEgNAUEAIQkgAEHsGGpBAEGAAhCaCBogDiEFDAILIABBHDYCBCAAKAIgIgJBAU4EQCAAKAIcIQgMAwsgACgCACIBKAIEIQMgAiEEA0AgA0UNDSABKAIAIgUtAAAhByAAIARBCGoiAjYCICAAIAcgACgCHEEIdHIiCDYCHCABIANBf2oiAzYCBCABIAVBAWo2AgAgASABKAIIIgVBAWoiBzYCCCAHIAVJBEAgASABKAIMQQFqNgIMCyAEQXhKIQUgAiEEIAVFDQALDAILQQEhAQwCC0EAIQEMAgsgACACQX9qIgE2AiAgACAJakHsGmogCCABdkEBcToAACAJQQFqIQRBACEBDAAACwALA0ACQAJAAkACQAJAIAFFBEAgCUEPSg0BQQAhDiAAIAlqQewaai0AAEUNBAwDCyAAQR02AgQgACgCICICQQFOBEAgACgCHCEIDAILIAAoAgAiASgCBCEDIAIhBANAIANFDQ4gASgCACIFLQAAIQcgACAEQQhqIgI2AiAgACAHIAAoAhxBCHRyIgg2AhwgASADQX9qIgM2AgQgASAFQQFqNgIAIAEgASgCCCIFQQFqIgc2AgggByAFSQRAIAEgASgCDEEBajYCDAsgBEF4SiEFIAIhBCAFRQ0ACwwBC0EAIQMgAEEANgLoGEEAIQEDQCAAIAFqQewYai0AAARAIAAgA2pB/BpqIAE6AAAgACAAKALoGEEBaiIDNgLoGAsgAUEBaiIBQYACRw0ACyADRQRAQXwhAiAFIQ4MDgsgA0ECaiEgIAUhDgwFCyAAIAJBf2oiATYCICAIIAF2QQFxBEAgACAJQQR0IA5qakHsGGpBAToAAAsgDkEBaiEOCyAOIgVBD0wNAQsgCUEBaiEJQQAhAQwBC0EBIQEMAAALAAsgAEEeNgIEAkAgACgCICICQQNOBEAgACgCHCEIDAELIAAoAgAiASgCBCEDIAIhBANAIANFDQggASgCACIFLQAAIQcgACAEQQhqIgI2AiAgACAHIAAoAhxBCHRyIgg2AhwgASADQX9qIgM2AgQgASAFQQFqNgIAIAEgASgCCCIFQQFqIgc2AgggByAFSQRAIAEgASgCDEEBajYCDAsgBEF6SiEFIAIhBCAFRQ0ACwsgACACQX1qIgU2AiAgCCAFdkEHcSITQQdLDQBBfCECQQEgE3RBgwFxDQcLIABBHzYCBAJAIAVBD04EQCAAKAIcIQgMAQsgACgCACIBKAIEIQMgBSEEA0AgA0UNByABKAIAIgItAAAhByAAIARBCGoiBTYCICAAIAcgACgCHEEIdHIiCDYCHCABIANBf2oiAzYCBCABIAJBAWo2AgAgASABKAIIIgJBAWoiBzYCCCAHIAJJBEAgASABKAIMQQFqNgIMCyAEQQZKIQIgBSEEIAJFDQALCyAAIAVBcWoiATYCIEEAIRcgCCABdkH//wFxIggEQEEAIQlBACEBDAELQXwhAgwGCwNAAkAgAUUEQCAJIAhODQEgCCEXQQAhDkEBIQEMAgsDQCAAQSA2AgQCQCAAKAIgIgJBAU4EQCAAKAIcIQgMAQsgACgCACIBKAIEIQMgAiEEA0AgA0UNCSABKAIAIgUtAAAhByAAIARBCGoiAjYCICAAIAcgACgCHEEIdHIiCDYCHCABIANBf2oiAzYCBCABIAVBAWo2AgAgASABKAIIIgVBAWoiBzYCCCAHIAVJBEAgASABKAIMQQFqNgIMCyAEQXhKIQUgAiEEIAVFDQALCyAAIAJBf2oiATYCICAIIAF2QQFxBEBBfCECIA5BAWoiDiATSA0BDAkLCyAAIAlqQY7KAWogDjoAACAJQQFqIQkgFyEIQQAhAQwBCwtBACEDIBNBAEoEQEEAIQEDQCAZQQpqIANqIAE6AAAgEyABQQFqIgFB/wFxIgNKDQALC0EAIRZBACEJIAhBAEoEQEEAIQQDQCAAIARqIgVBjsoBai0AACIBIBlBCmpqLQAAIQIgAQRAA0AgGUEKaiABaiABQX9qIgMgGUEKamotAAA6AAAgAUH/AXEhCSADIQEgCUEBRw0ACwsgGSACOgAKIAVBvD1qIAI6AAAgBEEBaiIEIAhHDQALIAghCQtBAAshAQNAAkACQAJAAn8CQAJAAkACQAJAAkACQAJAAkACQCABDgMAAQQFCyAWIBNODQEgCCEXQQEhAQwNCyAAQSE2AgQgACgCICICQQVIDQEgACgCHCEiDAcLQQAhFiATQQFOBEBBACELICBBAUghAgNAQSAhA0EAIQlBACEEIAJFBEADQCAAIAtBggJsaiAEakHg1gJqLQAAIgEgAyADIAFKGyEDIAEgCSAJIAFJGyEJIARBAWoiBCAgRw0ACwsgACALQYgIbGoiAUHs4gJqIAFBnJMDaiABQczDA2ogACALQYICbGpB4NYCaiADIAkgIBDMAiAAIAtBAnRqQfzzA2ogAzYCACALQQFqIgsgE0cNAAsgEyEWCyAAKALoGCEBIAAoAiQhAyAAQUBrQQBBgAgQmggaIANBoI0GbCEeIAFBAWohFUH/HyEJIABB/BxqIQtBDyEBA0AgCSALaiIDIAEiBEEEdCIBQQ9yOgAAIAsgCUFxaiICaiABOgAAIANBf2ogAUEOcjoAACADQX5qIAFBDXI6AAAgA0F9aiABQQxyOgAAIANBfGogAUELcjoAACADQXtqIAFBCnI6AAAgA0F6aiABQQlyOgAAIANBeWogAUEIcjoAACADQXhqIAFBB3I6AAAgA0F3aiABQQZyOgAAIANBdmogAUEFcjoAACADQXVqIAFBBHI6AAAgA0F0aiABQQNyOgAAIANBc2ogAUECcjoAACADQXJqIAFBAXI6AAAgACAEQQJ0akH8PGogAjYCACAEQX9qIQEgCUFwaiEJIAQNAAsgCEEBTg0DQXwhAkGAAiEJQQAhC0EAIRFBACEUIAghFwwQCyAAKAIAIgEoAgQhAyACIQQDQCADRQ0PIAEoAgAiBS0AACEHIAAgBEEIaiICNgIgIAAgByAAKAIcQQh0ciIiNgIcIAEgA0F/aiIDNgIEIAEgBUEBajYCACABIAEoAggiBUEBaiIHNgIIIAcgBUkEQCABIAEoAgxBAWo2AgwLIARBfEohBSACIQQgBUUNAAsMBQsgAEEiNgIEIAAoAiAiAkEBTgRAIAAoAhwhBwwECyAAKAIAIgEoAgQhAyACIQQDQCADRQ0OIAEoAgAiBi0AACEFIAAgBEEIaiICNgIgIAAgBSAAKAIcQQh0ciIHNgIcIAEgA0F/aiIDNgIEIAEgBkEBajYCACABIAEoAggiBkEBaiIFNgIIIAUgBkkEQCABIAEoAgxBAWo2AgwLIARBeEohBiACIQQgBkUNAAsMAwsgAEEjNgIEIAZBAU4EQCAAKAIcIQcMAgsgACgCACIBKAIEIQMgBiEEA0AgA0UNDSABKAIAIgItAAAhBSAAIARBCGoiBjYCICAAIAUgACgCHEEIdHIiBzYCHCABIANBf2oiAzYCBCABIAJBAWo2AgAgASABKAIIIgJBAWoiBTYCCCAFIAJJBEAgASABKAIMQQFqNgIMCyAEQXhKIQIgBiEEIAJFDQALDAELIAAgAC0AvD0iHUGICGxqIgFB7OICaiEcIAFBzMMDaiEaIAFBnJMDaiEbQYACIQlBMSERQQAhCyAAIB1BAnRqQfzzA2ooAgAiGCENQQAhFCAIIRcMCAsgACAGQX9qIgE2AiBBf0EBIAcgAXZBAXEbIB9qIR8MAwsgACACQX9qIgY2AiAgByAGdkEBcUUEQCAAIBZBggJsaiAJakHg1gJqIB86AAAgCUEBagwCC0EDIQEMBQsgACACQXtqIgE2AiAgIiABdkEfcSEfQQALIgkgIE4NAQsgH0F/akETTQ0BQXwhAgwHCyAWQQFqIRYgFyEIQQAhAQwBC0ECIQEMAAALAAsgAEEkNgIEAkAgACgCICIDIA1OBEAgACgCHCEFDAELIAAoAgAiASgCBCEEA0AgBEUNBCABKAIAIgItAAAhBiAAIANBCGoiAzYCICAAIAYgACgCHEEIdHIiBTYCHCABIARBf2oiBDYCBCABIAJBAWo2AgAgASABKAIIIgJBAWoiBjYCCCAGIAJJBEAgASABKAIMQQFqNgIMCyADIA1IDQALCyAAIAMgDWsiBjYCIEF/IA10QX9zIAUgBnZxIRBBAQshAQNAAkACQAJAAkACQCABRQRAIABBJTYCBCAGQQFIDQEgACgCHCEHDAILQXwhAiANQRRKDQggECAcIA1BAnQiAWooAgBMDQIgDUEBaiENDAMLIAAoAgAiASgCBCEDIAYhBANAIANFDQcgASgCACICLQAAIQUgACAEQQhqIgY2AiAgACAFIAAoAhxBCHRyIgc2AhwgASADQX9qIgM2AgQgASACQQFqNgIAIAEgASgCCCICQQFqIgU2AgggBSACSQRAIAEgASgCDEEBajYCDAsgBEF4SiECIAYhBCACRQ0ACwsgACAGQX9qIgY2AiAgByAGdkEBcSIhIBBBAXRyIRAMAgsgECABIBtqKAIAayIBQYECSw0FIBogAUECdGooAgAhD0ECIQEMAwtBACEBDAELQQEhAQwAAAsACwNAAkACQAJAAkACfwJAAn8CQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgAQ4EAAECAwcLIABBJzYCBCAMQQFIDQMgACgCHCEFDAQLIABBKTYCBCAKQQFIDQYgACgCHCEFDAcLIA8gFUYNB0EBIQFBfyEDIA9BAUsNAwwSCyAAQSY2AgQgACgCICIDIA1OBEAgACgCHCEFDBALIAAoAgAiASgCBCEEA0AgBEUNFyABKAIAIgItAAAhBiAAIANBCGoiAzYCICAAIAYgACgCHEEIdHIiBTYCHCABIARBf2oiBDYCBCABIAJBAWo2AgAgASABKAIIIgJBAWoiBjYCCCAGIAJJBEAgASABKAIMQQFqNgIMCyADIA1IDQALDA8LIAAoAgAiASgCBCEDIAwhBANAIANFDRYgASgCACICLQAAIQYgACAEQQhqIgw2AiAgACAGIAAoAhxBCHRyIgU2AhwgASADQX9qIgM2AgQgASACQQFqNgIAIAEgASgCCCICQQFqIgY2AgggBiACSQRAIAEgASgCDEEBajYCDAsgBEF4SiECIAwhBCACRQ0ACwsgACAMQX9qIgw2AiAgBSAMdkEBcSIhIBBBAXRyDA4LQXwhAiALIB5ODRQgD0F/aiIBQQ9NBEAgACAAKAL8PCIEIAFqakH8HGotAAAhCAJAIAFBA0sEQANAIAAgASAEamoiA0H5HGogA0H4HGooAAA2AAAgAUF8aiIBQQNLDQALIAFFDQELA0AgACABIARqaiIDQfwcaiADQfscai0AADoAACABQX9qIgENAAsLIAAgBGpB/BxqIAg6AAAMCAsgACAAIAFBBHYiIkECdGpB/DxqIgUoAgAiBiABQQ9xIgRqIgNqQfwcai0AACEIIARFDQQgAEH8HGohBgNAIAMgBmogBiADQX9qIgRqLQAAOgAAIAQiAyAFKAIAIgdKDQALIAUgB0EBaiIDNgIAICJFDQYMBQsgAEEoNgIEIAAoAiAiAyANTgRAIAAoAhwhBQwKCyAAKAIAIgEoAgQhBANAIARFDRMgASgCACICLQAAIQYgACADQQhqIgM2AiAgACAGIAAoAhxBCHRyIgU2AhwgASAEQX9qIgQ2AgQgASACQQFqNgIAIAEgASgCCCICQQFqIgY2AgggBiACSQRAIAEgASgCDEEBajYCDAsgAyANSA0ACwwJCyAAKAIAIgEoAgQhAyAKIQQDQCADRQ0SIAEoAgAiAi0AACEGIAAgBEEIaiIKNgIgIAAgBiAAKAIcQQh0ciIFNgIcIAEgA0F/aiIDNgIEIAEgAkEBajYCACABIAEoAggiAkEBaiIGNgIIIAYgAkkEQCABIAEoAgxBAWo2AgwLIARBeEohAiAKIQQgAkUNAAsLIAAgCkF/aiIKNgIgIAUgCnZBAXEiISAQQQF0cgwIC0F8IQIgACgCNCIBQQBIBEAgDyEVDBELIAEgC04EQCAPIRUMEQsgAEEANgLECCAAQcQIaiEGQQEhAQNAIAAgAUECdGoiA0HECGogAygCPDYCACABQQFqIgFBgQJHDQALIAYoAgAhA0EBIQEDQCAAIAFBAnRqQcQIaiIJIAkoAgAgA2oiAzYCACABQQFqIgFBgQJHDQALQQAhCQNAIAAgCUECdGpBxAhqKAIAIgFBAEgEQCAPIRUMEgsgASALSgRAIA8hFQwSCyAJQQFqIglBgQJHDQALIABBfzYC4BhBACEBIABBADoACCAAQQA2AgwgAEECNgIEIAAoAjBBAk4EQEHLuwFBBkEBQbSqAigCABCfCBoLIAAtAChFDQQDQCAAIAFBAnRqIgNByBBqIANBxAhqKAIANgIAIAFBAWoiAUGBAkcNAAsgC0EBTgRAQQAhAQNAIAAoAtAYIAFBAXRqIgMgACADLQAAQQJ0akHIEGoiAygCACIEOwEAIAAoAtQYIAFBAXZqIgktAAAhDiAJIAFBAXEEfyAOQQ9xIARBEHVBBHRyBSAOQfABcSAEQRB1cgs6AAAgAyADKAIAQQFqNgIAIAFBAWoiASALRw0ACwsgACgC1BgiAyAAKAI0IgFBAXVqLQAAIAFBAnRBBHF2QRB0QYCAPHEgACgC0BgiBCABQQF0ai8BAHIhDgNAIAQgDiIJQQF0aiIELwEAIQ4gAyAJQQF1aiIDLQAAIQIgBCABOwEAIAIgCUECdEEEcXZBEHRBgIA8cSEEIAMtAAAhAiAEIA5yIQ4gAyAJQQFxBH8gAkEPcSABQRB1QQR0cgUgAkHwAXEgAUEQdXILOgAAIAAoAjQgCUcEQCAAKALUGCEDIAAoAtAYIQQgCSEBDAELCyAAQQA2AsAIIAAgCTYCOCAALQAQBEAgAEIANwIUQQEhAiAJIAAoAiRBoI0GbE8NEiAAIAkgBhDZAiIDNgI8IAAoAtAYIAAoAjgiAUEBdGovAQAhBCAAKALUGCABQQF2ai0AACECIAAgACgCwAhBAWo2AsAIIAAgBCACIAFBAnRBBHF2QRB0QYCAPHFyNgI4IAAoAhQiAUUEQCAAKAIYIgRBAnRBwN8CaigCACEBIABBACAEQQFqIgQgBEGABEYbNgIYIAAgATYCFAsgACABQX9qIgE2AhQgACADIAFBAUZzNgI8DAYLQQEhAiAJIAAoAiRBoI0GbE8NESAAIAkgBhDZAjYCPCAAKALQGCAAKAI4IgFBAXRqLwEAIQMgACgC1BggAUEBdmotAAAhBCAAIAAoAsAIQQFqNgLACCAAIAMgBCABQQJ0QQRxdkEQdEGAgDxxcjYCOAwFCyAFIAZBAWoiAzYCAAsgBSADQX9qIgM2AgAgAEH8HGoiBCADaiAAICJBf2oiA0ECdGpB/DxqIgYoAgAgBGotAA86AAAgAUEgSQ0AIABB/DxqIQEDQCABIANBAnRqIAYoAgBBf2oiBjYCACAEIAZqIAEgA0F/aiIFQQJ0aiIGKAIAIARqLQAPOgAAIANBAUohByAFIQMgBw0ACwsgACAAKAL8PEF/aiIBNgL8PCAAIAFqQfwcaiAIOgAAIAAoAvw8DQBBDyEDQf8fIQYgAEH8HGohAQNAIAEgBmoiBCAAIAMiBUECdGpB/DxqIgMoAgAgAWotAA86AAAgBEF/aiADKAIAIAFqLQAOOgAAIARBfmogAygCACABai0ADToAACAEQX1qIAMoAgAgAWotAAw6AAAgBEF8aiADKAIAIAFqLQALOgAAIARBe2ogAygCACABai0ACjoAACAEQXpqIAMoAgAgAWotAAk6AAAgBEF5aiADKAIAIAFqLQAIOgAAIARBeGogAygCACABai0ABzoAACAEQXdqIAMoAgAgAWotAAY6AAAgBEF2aiADKAIAIAFqLQAFOgAAIARBdWogAygCACABai0ABDoAACAEQXRqIAMoAgAgAWotAAM6AAAgBEFzaiADKAIAIAFqLQACOgAAIARBcmogAygCACABai0AAToAACABIAZBcWoiBGogASADKAIAai0AADoAACADIAQ2AgAgBUF/aiEDIAZBcGohBiAFDQALCyAAIAAgCEH/AXFqQfwaaiIBLQAAQQJ0akFAayIDIAMoAgBBAWo2AgAgAS0AACEBAkAgAC0AKARAIAAoAtAYIAtBAXRqIAE7AQAMAQsgACgCzBggC0ECdGogATYCAAsgC0EBaiELIBFFBEAgFEEBaiIUIBdOBEBBACERDA4LIAAgACAUakG8PWotAAAiHUGICGxqIgFBnJMDaiEbIAFBzMMDaiEaIAFB7OICaiEcQTIhESAAIB1BAnRqQfzzA2ooAgAhGAsgEUF/aiERIBghDUEEIQEMCgsgACgCzBghBEEAIQkgC0EASgRAQQAhAQNAIAQgACAEIAFBAnRqLQAAQQJ0akHECGoiAygCAEECdGoiCSAJKAIAIAFBCHRyNgIAIAMgAygCAEEBajYCACABQQFqIgEgC0cNAAsgCyEJCyAEIAAoAjRBAnRqKAIAIQEgAEEANgLACCAAIAFBCHYiATYCOCAALQAQBEAgAEIANwIUQQEhAiABIAAoAiRBoI0GbE8NDSAEIAFBAnRqKAIAIQEgAEEBNgLACCAAIAFBCHY2AjhBACECQcDfAigCACEDIABBATYCGCAAIANBf2oiAzYCFCAAIAFB/wFxIANBAUZzNgI8IA8hFQwMC0EBIQIgASAAKAIkQaCNBmxPDQwgBCABQQJ0aigCACEBIABBATYCwAggACABQQh2NgI4IAAgAUH/AXE2AjwLQQAhAiAPIRUMCgsgACADIA1rIgo2AiBBfyANdEF/cyAFIAp2cQshEEF8IQIgDUEUSg0IAkAgECAcIA1BAnQiAWooAgBKBEAgDUEBaiENDAELIBAgASAbaigCAGsiAUGBAksNCSAaIAFBAnRqKAIAIQ8MBgtBASEBDAYLIAAgAyANayIMNgIgQX8gDXRBf3MgBSAMdnELIRBBfCECIA1BFEoNBiAQIBwgDUECdCIBaigCAEoEQCANQQFqIQ0MAwsgECABIBtqKAIAayIBQYECSw0GIBogAUECdGooAgAiD0ECTw0BICMhASASIQMLAn8gAyAPQQFLDQAaIAEgA2ogD0EBaw0AGiADIAFBAXRqCyESIAFBAXQhIyARRQRAIBRBAWoiFCAXTgRAQXwhAkEAIREMBwsgACAAIBRqQbw9ai0AACIdQYgIbGoiAUGckwNqIRsgAUHMwwNqIRogAUHs4gJqIRxBMiERIAAgHUECdGpB/PMDaigCACEYCyARQX9qIREgGCENQQMhAQwDCyAAIAAgACAAKAL8PGpB/BxqLQAAakH8GmotAAAiBEECdGpBQGsiASABKAIAIBJBAWoiAWo2AgACQAJAIAAtACgEQCASQQBODQEgASESDAQLIBJBAE4NASABIRIMAwsgCyAeIAsgHkobIQYDQCAGIAtGBEAgASESIAYhCwwHCyAAKALQGCALQQF0aiAEOwEAIAtBAWohCyABQQFKIQMgAUF/aiISIQEgAw0ACwwCCyALIB4gCyAeShshBgNAIAYgC0YEQCABIRIgBiELDAYLIAAoAswYIAtBAnRqIAQ2AgAgC0EBaiELIAFBAUohAyABQX9qIhIhASADDQALDAELQQAhAQwBC0ECIQEMAAALAAtBACECCyAAIBo2AvD0AyAAIBs2Auz0AyAAIBw2Auj0AyAAIBg2AuT0AyAAIB02AuD0AyAAICE2Atz0AyAAIBA2Atj0AyAAIA02AtT0AyAAICQ2AtD0AyAAIB82Asz0AyAAICM2Asj0AyAAIBI2AsT0AyAAIAs2AsD0AyAAIB42Arz0AyAAIA82Arj0AyAAIBE2ArT0AyAAIBQ2ArD0AyAAIBU2Aqz0AyAAIBc2Aqj0AyAAIBM2AqT0AyAAICA2AqD0AyAAIBY2Apz0AyAAIA42Apj0AyAAIAk2ApT0AwsgGUEQaiQAIAILTQECfyMAQRBrIgEkACABQffHATYCBCABIAA2AgBBtKoCKAIAIgJB0rsBIAEQwgYaIABB7wdGBEBBjb8BQaAIQQEgAhCfCBoLQQMQAQAL4gMBBH9BfiEFAkAgA0H6AUsNACAARQ0AIAFBf2pBCEsNACAAKAIkIgRFBEAgAEHwADYCJEHwACEECyAAKAIoRQRAIABB8QA2AigLQX0hBSAAKAIsQbCzA0EBIAQRAAAiBEUNACAEQQA2AhggBEIANwIQIAQgADYCACAEIAAoAiwgAUGAtRhsIgVBASAAKAIkEQAANgIQIAQgACgCLCAFQYgBakEBIAAoAiQRAAA2AhQgBCAAKAIsQYSAEEEBIAAoAiQRAAAiBTYCGAJAIAQoAhAiBgRAIAUEQCAEKAIUIgcNAgsgACgCLCAGIAAoAigRBQALIAQoAhQiBQRAIAAoAiwgBSAAKAIoEQUACyAEKAIYIgUEQCAAKAIsIAUgACgCKBEFAAsgACgCLCAEIAAoAigRBQBBfQ8LIAQgATYC8ARBACEFIARBADYC5AQgBEKCgICAIDcCBCAEIAI2AugEIAQgA0EeIAMbNgIwIARBADYCLCAEIAY2AiggBCAHNgIkIAQgBjYCICAEIAFBoI0GbEFtajYCSCAAQgA3AgggAEIANwIYIAAgBDYCICAEQX82AuAEIARCgAI3AjQgBEIANwJMIARBADYCRCAEQdgAakEAQYACEJoIGiAEQQE2AuwECyAFCwwAIAEEQCABEJEICwvdAgEEf0F+IQQCQCAARQ0AIAAoAiAiAkUNACACKAIAIABHDQAgAigCBCEDQQAhBAJAA0ACQAJAAkAgA0ECRwRAIANBf2oiBUEDSw0GQX8hAyAFQQFrDgMGAwUBCyABQQJNDQFBfiEDCyADDwtBAyEDAkACQAJAIAFBAWsOAgIBAAtBAUF+IAAQ1QIbDwtBBCEDCyAAKAIEIQUgAiADNgIEIAIgBTYCDAwBCwtBfyEEIAFBAUcNASACKAIMIAAoAgRHDQEgABDVAhpBAiEEIAIoAgwNASACKAI0Qf8BTQRAIAIoAjhBAEoNAgsgAigCUCACKAJMSA0BIAJBAjYCBEEBDwtBfyEEIAFBAkcNACACKAIMIAAoAgRHDQAgABDVAkUNAEEDIQQgAigCDA0AIAIoAjRB/wFNBEAgAigCOEEASg0BCyACKAJQIAIoAkxIDQAgAkEBNgIEQQQhBAsgBAurCQEKfyAAKAIgIgBB2ABqIQlBACEHQQAhCANAIAAoAgghAQNAIAFBf2oiA0EBSw0ACwJAAkACQCADQQFrRQ0AIAAoAlAhA0EAIQECQCAAKAIAIgIoAhRFDQAgAyAAKAJMTg0AIAIoAhAhAgNAIAIgACgCLCADai0AADoAACAAIAAoAlBBAWoiAzYCUCAAKAIAIgEgASgCGCIEQQFqIgU2AhggASABKAIQQQFqIgI2AhAgASABKAIUQX9qIgY2AhQgBSAESQRAIAEgASgCHEEBajYCHAtBASEBIAZFDQEgAyAAKAJMSA0ACwsgASAHciEHIAMgACgCTEgNAgJAIAAoAgQiAUEERw0AIAAoAgwNACAAKAI0Qf8BSw0DIAAoAjhBAUgNAwsgAEF/NgLgBCAAQgA3AkwgAEEANgJEIAlBAEGAAhCaCBogAEECNgIIIAAgACgC7ARBAWo2AuwEIAFBA0cNASAAKAIMDQAgACgCNEH/AUsNAiAAKAI4QQFIDQILIAAoAgQhAQsgACgCSCECIAAoAkQhBAJAIAFBAkcEQEEAIQYgBCACTg0BIAAoAgAiASgCBEUNASAAKAIMRQ0BA0AgACgCOCEDAkACQAJAIAAoAjQiAiABKAIALQAAIgFHBEAgA0EBRw0BIAAgACgC4AQiA0EIdCACQf8BcSADQRh2c0ECdEHA1wJqKAIAczYC4AQgACACakEBOgBYIAAoAiQgACgCRGogAjoAACAAIAE2AjQgACAAKAJEQQFqNgJEDAMLIANB/wFHDQELIAJB/wFNBEAgABDWAgsgAEEBNgI4IAAgATYCNAwBCyAAIANBAWo2AjgLIAAoAgAiASABKAIAQQFqNgIAIAEgASgCBEF/aiIFNgIEIAEgASgCCCIDQQFqIgI2AgggAiADSQRAIAEgASgCDEEBajYCDAsgACAAKAIMQX9qIgM2AgxBASEGIAAoAkQiBCAAKAJIIgJODQIgBUUNAiADDQALDAELQQAhBiAEIAJODQAgACgCACIDKAIERQ0AIAAoAjQhASADKAIAIQUDQCAAKAI4IQICQAJAAkAgBS0AACIDIAFHBEAgAkEBRw0BIAAgACgC4AQiAkEIdCABQf8BcSACQRh2c0ECdEHA1wJqKAIAczYC4AQgACABakEBOgBYIAAoAiQgACgCRGogAToAACAAIAM2AjQgACAAKAJEQQFqNgJEDAMLIAJB/wFHDQELIAFB/wFNBEAgABDWAgsgAEEBNgI4IAAgAzYCNAwBCyAAIAJBAWo2AjgLIAAoAgAiASABKAIAQQFqIgU2AgAgASABKAIEQX9qIgo2AgQgASABKAIIIgJBAWoiBDYCCCAEIAJJBEAgASABKAIMQQFqNgIMC0EBIQYgACgCRCIEIAAoAkgiAk4NASADIQEgCg0ACwsgBiAIciEIAkAgACgCBCIBQQJGDQAgACgCDA0AIAAoAjRB/wFNBEAgABDWAiAAKAIEIQELIABCgAI3AjQgACABQQRGEM0CIABBATYCCAwCCyAEIAJOBEAgAEEAEM0CIABBATYCCAwCCyAAKAIAKAIEDQELCyAHIAhyQf8BcUEARwvOAwEFfyAAKAI0IQMgACgCOCIEQQFOBEAgA0H/AXEhBSAAKALgBCEBQQAhAgNAIAAgAUEYdiAFc0ECdEHA1wJqKAIAIAFBCHRzIgE2AuAEIAJBAWoiAiAERw0ACwsgACADakEBOgBYAn8gACgCOCICQX9qIgFBAk0EQAJAAkACQCABQQFrDgIBAgALIAAoAiQgACgCRGohAiAAQcQAagwDCyAAKAIkIAAoAkRqIAM6AAAgACAAKAJEQQFqIgI2AkQgACgCJCACaiECIABBxABqDAILIAAoAiQgACgCRGogAzoAACAAIAAoAkRBAWoiATYCRCAAKAIkIAFqIAM6AAAgACAAKAJEQQFqIgI2AkQgACgCJCACaiECIABBxABqDAELIAAgAmpBAToAVCAAKAIkIAAoAkRqIAM6AAAgACAAKAJEQQFqIgE2AkQgACgCJCABaiADOgAAIAAgACgCREEBaiIBNgJEIAAoAiQgAWogAzoAACAAIAAoAkRBAWoiATYCRCAAKAIkIAFqIAM6AAAgACAAKAJEQQFqIgI2AkQgAC0AOEF8aiEDIAAoAiQgAmohAiAAQcQAagshASACIAM6AAAgASABKAIAQQFqNgIAC44BAQJ/QX4hAQJAIABFDQAgACgCICICRQ0AIAIoAgAgAEcNACACKAIQIgEEQCAAKAIsIAEgACgCKBEFAAsgAigCFCIBBEAgACgCLCABIAAoAigRBQALIAIoAhgiAQRAIAAoAiwgASAAKAIoEQUACyAAKAIsIAAoAiAgACgCKBEFAEEAIQEgAEEANgIgCyABC70BAQJ/QX4hBAJAIAFBBEsNACAARQ0AIAJBAUsNACAAKAIkIgNFBEAgAEHwADYCJEHwACEDCyAAKAIoRQRAIABB8QA2AigLIAAoAixB9PQDQQEgAxEAACIDRQRAQX0PCyADIAA2AgAgACADNgIgIANBCjYCBEEAIQQgA0EANgLkGCADQgA3AhwgAEIANwIYIABCADcCCCADIAE2AjAgA0IANwLMGCADQQA2AtQYIAMgAjoAKCADQQA2AiwLIAQLQAEEf0EAIQJBgAIhAwNAIAIgA2pBAXUiBCADIAEgBEECdGooAgAgAEoiBRsiAyACIAQgBRsiAmtBAUcNAAsgAgvXJAEUfyMAQSBrIhAkAEF+IQoCQCAARQ0AIAAoAiAiAUUNACABKAIAIABHDQAgASgCBCEAQbSqAigCACETA0BBfyEKAkACQAJAAkAgAEF/aiICQQFNBEAgAkEBaw0GIAEtABAhACABLQAoRQ0BIAEoAgAiBigCFCECIABB/wFxRQ0CIAJFDQMgASgCDCEDA0AgAwRAIAYoAhAgAS0ACDoAACABLQAIIAEoAuAYIgBBGHZzQQJ0QcDXAmooAgAhAiABIAEoAgxBf2oiAzYCDCABIAIgAEEIdHM2AuAYIAEoAgAiBiAGKAIYIgBBAWoiAjYCGCAGIAYoAhBBAWo2AhAgBiAGKAIUQX9qIgU2AhQgAiAASQRAIAYgBigCHEEBajYCHAsgBQ0BDAULIAEoAsAIIgcgASgCwPQDIghBAWoiAEYNBEF8IQogByAASg0HIAFBATYCDCABIAEoAjwiCzoACCABKAI4IgQgASgCJEGgjQZsIgxPDQdBACEAQYACIQIDQCAAIAJqQQF1IgMgAiABIANBAnRqQcQIaigCACAESiIFGyICIAAgAyAFGyIAa0EBRw0ACyABIAEoAtAYIg0gBEEBdGovAQAiDyABKALUGCIOIARBAXZqLQAAIARBAnRBBHF2QRB0QYCAPHFyIgQ2AjggASgCFCICRQRAIAEoAhgiA0ECdEHA3wJqKAIAIQIgAUEAIANBAWoiAyADQYAERhs2AhggASACNgIUC0EBIQMgASAHQQFqIhI2AsAIIAEgAkF/aiIJNgIUAkAgByAIRg0AIAsgAEH/AXEgCUEBRnMiAEcEQCABIAA2AjwMAQsgAUECNgIMIAQgDE8NCEEAIQBBgAIhAgNAIAAgAmpBAXUiAyACIAEgA0ECdGpBxAhqKAIAIARKIgUbIgIgACADIAUbIgBrQQFHDQALIAEgDiAEQQF2ai0AACAPQQJ0QQRxdkEQdEGAgDxxIA0gBEEBdGovAQAiD3IiBDYCOCAJRQRAIAEoAhgiAkECdEHA3wJqKAIAIQkgAUEAIAJBAWoiAiACQYAERhs2AhggASAJNgIUC0ECIQMgASAHQQJqIhE2AsAIIAEgCUF/aiIJNgIUIAggEkYNACALIABB/wFxIAlBAUZzIgBHBEAgASAANgI8DAELIAFBAzYCDCAEIAxPDQhBACEAQYACIQIDQCAAIAJqQQF1IgMgAiABIANBAnRqQcQIaigCACAESiIFGyICIAAgAyAFGyIAa0EBRw0ACyABIA4gBEEBdmotAAAgD0ECdEEEcXZBEHRBgIA8cSANIARBAXRqLwEAIg9yIgQ2AjggCUUEQCABKAIYIgJBAnRBwN8CaigCACEJIAFBACACQQFqIgIgAkGABEYbNgIYIAEgCTYCFAtBAyEDIAEgB0EDajYCwAggASAJQX9qIgk2AhQgCCARRg0AIAsgAEH/AXEgCUEBRnMiAEcEQCABIAA2AjwMAQsgBCAMTw0IQQAhAEGAAiECA0AgACACakEBdSIDIAIgASADQQJ0akHECGooAgAgBEoiBRsiAiAAIAMgBRsiAGtBAUcNAAsgASANIARBAXRqLwEAIgsgDiAEQQF2ai0AACAPQQJ0QQRxdkEQdEGAgDxxciIENgI4IAlFBEAgASgCGCICQQJ0QcDfAmooAgAhCSABQQAgAkEBaiICIAJBgARGGzYCGCABIAk2AhQLIAEgB0EEajYCwAggASAJQX9qIgg2AhQgASAAQf8BcSAIQQFGc0EEaiIDNgIMIAQgDE8NCEEAIQBBgAIhAgNAIAAgAmpBAXUiBSACIAEgBUECdGpBxAhqKAIAIARKIgobIgIgACAFIAobIgBrQQFHDQALIAEgADYCPCABIA0gBEEBdGovAQAgDiAEQQF2ai0AACALQQJ0QQRxdkEQdEGAgDxxcjYCOCAIRQRAIAEoAhgiAkECdEHA3wJqKAIAIQggAUEAIAJBAWoiAiACQYAERhs2AhggASAINgIUCyABIAdBBWo2AsAIIAEgCEF/aiICNgIUIAEgACACQQFGczYCPAsgBigCFA0ACwwDCyAAQQpIDQQMAwsgAEH/AXEEQCABKAIAIgcoAhRFDQIgASgCDCEDA0AgAwRAIAcoAhAgAS0ACDoAACABLQAIIAEoAuAYIgBBGHZzQQJ0QcDXAmooAgAhAiABIAEoAgxBf2oiAzYCDCABIAIgAEEIdHM2AuAYIAEoAgAiByAHKAIYIgBBAWoiAjYCGCAHIAcoAhBBAWo2AhAgByAHKAIUQX9qIgU2AhQgAiAASQRAIAcgBygCHEEBajYCHAsgBUUNBAwBCyABKALACCIAIAEoAsD0AyIFQQFqIgJGDQNBfCEKIAAgAkoNBiABQQE2AgwgASABKAI8IgQ6AAggASgCOCICIAEoAiRBoI0GbCIJTw0GIAEgASgCzBgiCyACQQJ0aigCACIIQQh2IgY2AjggASgCFCICRQRAIAEoAhgiA0ECdEHA3wJqKAIAIQIgAUEAIANBAWoiAyADQYAERhs2AhggASACNgIUC0EBIQMgASAAQQFqIgw2AsAIIAEgAkF/aiICNgIUAkAgACAFRg0AIAQgCEH/AXEgAkEBRnMiCEcEQCABIAg2AjwMAQsgAUECNgIMIAYgCU8NByABIAsgBkECdGooAgAiCEEIdiIGNgI4IAJFBEAgASgCGCIDQQJ0QcDfAmooAgAhAiABQQAgA0EBaiIDIANBgARGGzYCGCABIAI2AhQLQQIhAyABIABBAmoiDjYCwAggASACQX9qIgI2AhQgBSAMRg0AIAQgCEH/AXEgAkEBRnMiCEcEQCABIAg2AjwMAQsgAUEDNgIMIAYgCU8NByABIAsgBkECdGooAgAiCEEIdiIGNgI4IAJFBEAgASgCGCIDQQJ0QcDfAmooAgAhAiABQQAgA0EBaiIDIANBgARGGzYCGCABIAI2AhQLQQMhAyABIABBA2o2AsAIIAEgAkF/aiICNgIUIAUgDkYNACAEIAhB/wFxIAJBAUZzIgVHBEAgASAFNgI8DAELIAYgCU8NByABIAsgBkECdGooAgAiA0EIdiIFNgI4IAJFBEAgASgCGCIEQQJ0QcDfAmooAgAhAiABQQAgBEEBaiIEIARBgARGGzYCGCABIAI2AhQLIAEgAEEEajYCwAggASACQX9qIgI2AhQgASADQf8BcSACQQFGc0EEaiIDNgIMIAUgCU8NByABIAsgBUECdGooAgAiBUEIdjYCOCABIAVB/wFxIgU2AjwgAkUEQCABKAIYIgpBAnRBwN8CaigCACECIAFBACAKQQFqIgogCkGABEYbNgIYIAEgAjYCFAsgASAAQQVqNgLACCABIAJBf2oiADYCFCABIAUgAEEBRnM2AjwLIAcoAhQNAAsMAgsgASgCJEGgjQZsIQ4gASgCwPQDIg9BAWohCyABKAI4IQggASgCzBghDCABKAI8IQkgASgCwAghDSABKAIMIQMgAS0ACCEEIAEoAuAYIQAgASgCACIFKAIQIQIgBSgCFCISIQUCQANAAkACfwJAIANBAUgEQCANIQcMAQsgBUUNAiAEQf8BcSEKA0AgA0EBRgRAIA0hB0EADAMLIAIgBDoAACAAQRh2IApzQQJ0QcDXAmooAgAgAEEIdHMhACACQQFqIQIgA0F/aiEDIAVBf2oiBQ0ACwwCC0EBCyEDA0AgA0UEQCAFRQRAQQAhBUEBIQMMBQsgAiAEOgAAIARB/wFxIABBGHZzQQJ0QcDXAmooAgAgAEEIdHMhACAFQX9qIQUgAkEBaiECQQEhAwwBCyAJIQZBfCEKIAcgC0oNCCAHIAtGBEBBACEDIAshByAGIQkMBAsgCCAOTw0IIAdBAWohBCAMIAhBAnRqKAIAIgNBCHYhCAJAIAYgA0H/AXEiCUcEQCAEIQcgBiEEDAELIAcgD0YEQCAEIQcgBiEJIAYhBAwBCyAIIA5PDQlBAiEDIAwgCEECdGooAgAiEUEIdiEIIAshDSAGIQkgBiEEIAdBAmoiFCALRg0DIBQhDSAGIgQgEUH/AXEiCUcNAyAIIA5PDQkgDCAIQQJ0aigCACIRQQh2IQhBAyEDIAshDSAGIQkgBiEEIAdBA2oiFCALRg0DIBQhDSAGIgQgEUH/AXEiCUcNAyAIIA5PDQkgDCAIQQJ0aigCACIDQQh2IgQgDk8NCSAHQQVqIQ0gA0H/AXFBBGohAyAMIARBAnRqKAIAIgpBCHYhCCAKQf8BcSEJIAYhBAwDC0EAIQMMAAALAAsLIA0hB0EAIQULIAEoAgAiCiAKKAIYIgYgEiAFa2oiCzYCGCALIAZJBEAgCiAKKAIcQQFqNgIcCyABIAc2AsAIIAEgAzYCDCABIAQ6AAggASAANgLgGCABIAw2AswYIAEgCTYCPCABIAg2AjggCiAFNgIUIAogAjYCEAwBCyACRQ0AIAEoAgwhAgNAIAIEQCAGKAIQIAEtAAg6AAAgAS0ACCABKALgGCIAQRh2c0ECdEHA1wJqKAIAIQMgASABKAIMQX9qIgI2AgwgASADIABBCHRzNgLgGCABKAIAIgYgBigCGCIAQQFqIgM2AhggBiAGKAIQQQFqNgIQIAYgBigCFEF/aiIFNgIUIAMgAEkEQCAGIAYoAhxBAWo2AhwLIAVFDQIMAQsgASgCwAgiByABKALA9AMiCEEBaiIARg0BQXwhCiAHIABKDQQgAUEBNgIMIAEgASgCPCILOgAIIAEoAjgiBCABKAIkQaCNBmwiDE8NBEEAIQBBgAIhAgNAIAAgAmpBAXUiAyACIAEgA0ECdGpBxAhqKAIAIARKIgUbIgIgACADIAUbIgBrQQFHDQALQQEhAiABKALQGCIOIARBAXRqLwEAIQkgASgC1BgiDSAEQQF2ai0AACEDIAEgB0EBaiIPNgLACCABIAkgAyAEQQJ0QQRxdkEQdEGAgDxxciIENgI4AkAgByAIRg0AIAsgAEH/AXEiAEcEQCABIAA2AjwMAQsgAUECNgIMIAQgDE8NBUEAIQBBgAIhAgNAIAAgAmpBAXUiAyACIAEgA0ECdGpBxAhqKAIAIARKIgUbIgIgACADIAUbIgBrQQFHDQALIA4gBEEBdGovAQAhEiANIARBAXZqLQAAIQNBAiECIAEgB0ECaiIRNgLACCABIBIgAyAJQQJ0QQRxdkEQdEGAgDxxciIENgI4IAggD0YNACALIABB/wFxIgBHBEAgASAANgI8DAELIAFBAzYCDCAEIAxPDQVBACEAQYACIQIDQCAAIAJqQQF1IgMgAiABIANBAnRqQcQIaigCACAESiIFGyICIAAgAyAFGyIAa0EBRw0ACyAOIARBAXRqLwEAIQkgDSAEQQF2ai0AACEDQQMhAiABIAdBA2o2AsAIIAEgCSADIBJBAnRBBHF2QRB0QYCAPHFyIgQ2AjggCCARRg0AIAsgAEH/AXEiAEcEQCABIAA2AjwMAQsgBCAMTw0FQQAhAEGAAiECA0AgACACakEBdSIDIAIgASADQQJ0akHECGooAgAgBEoiBRsiAiAAIAMgBRsiAGtBAUcNAAsgDiAEQQF0ai8BACEIIA0gBEEBdmotAAAhAyABIAdBBGo2AsAIIAEgAEH/AXFBBGoiAjYCDCABIAggAyAJQQJ0QQRxdkEQdEGAgDxxciIENgI4IAQgDE8NBUEAIQBBgAIhAwNAIAAgA2pBAXUiBSADIAEgBUECdGpBxAhqKAIAIARKIgobIgMgACAFIAobIgBrQQFHDQALIAEgADYCPCAOIARBAXRqLwEAIQAgDSAEQQF2ai0AACEDIAEgB0EFajYCwAggASAAIAMgCEECdEEEcXZBEHRBgIA8cXI2AjgLIAYoAhQNAAsLQQAhCiABKALACCABKALA9ANBAWpHDQIgASgCDA0CIAEgASgC4BhBf3MiAjYC4BggASgCMCIAQQNOBH8gASgC2BghACAQIAI2AhQgECAANgIQIBNBrscBIBBBEGoQwgYaIAEoAjAFIAALQQJOBEBB3QAgExDEBhoLIAEoAuAYIgAgASgC2BhHBEBBfCEKDAMLIAFBDjYCBCABIAEoAuQYQQF3IABzNgLkGAsgARDQAiIKQQRGBEAgASgCMEEDTgRAIAEoAtwYIQAgECABKALkGDYCBCAQIAA2AgAgE0HAxwEgEBDCBhoLQQRBfCABKALkGCABKALcGEYbIQoMAgtBAiEAIAEoAgRBAkYNAAsLIBBBIGokACAKC5EBAQJ/QX4hAQJAIABFDQAgACgCICICRQ0AIAIoAgAgAEcNACACKALMGCIBBEAgACgCLCABIAAoAigRBQALIAIoAtAYIgEEQCAAKAIsIAEgACgCKBEFAAsgAigC1BgiAQRAIAAoAiwgASAAKAIoEQUACyAAKAIsIAAoAiAgACgCKBEFAEEAIQEgAEEANgIgCyABC64IAQl/IAMoAgAhCCADQQA2AgAgACgCSCIKQX9qQZACTQRAIAEgACgCJCIGayIHIAogByAKSRshByAAKAI4IQkgACgCKCELIAAoAhQhDAJAIAAoAjAEQCAAKAIsIQ0MAQsgACgCDCIOIAAoAiwiDWsgB0sNACAAIA42AjALIAAgCiAHazYCSCAAIAcgDWo2AiwgBwRAA0AgBiAMaiAMIAYgCWsgC0EAIAYgCUkbamotAAA6AAAgBkEBaiEGIAdBf2oiBw0ACwsgACAGNgIkCyAFQQA2AgACQCAAKAJIQZICRwRAIABB3ABqIQsDQCAAKAJMBEACQCAIBEADQCAAKAJYIgZBBEsNAiACLQAAIQcgACAGQQFqNgJYIAAgBmogBzoAXCADIAMoAgBBAWo2AgAgAkEBaiECIAhBf2oiCA0ACwtBACEIIAAoAlhBBEsNACAFQQM2AgBBAA8LIAstAAAEQEEBDwsgAEEANgJYIABBADYCTCAAQX82AhwgACAAKABdIgZBGHQgBkEIdEGAgPwHcXIgBkEIdkGA/gNxIAZBGHZycjYCIAtBACEKIAAoAiQgAU8EQAJAIAAoAkhFBEAgACgCIA0BIAVBBDYCAEEADwsgBEUNBCAFQQI2AgBBAQ8LQQEhCiAERQ0DCyAAKAJQBEBBgAYgACgCBCAAKAIAanRBtg5qIgcEQCAAKAIQIQlBACEGA0AgCSAGQQF0akGACDsBACAGQQFqIgYgB0cNAAsLIABBATYCRCAAQoGAgIAQNwI8IABBADYCUCAAQoCAgIAQNwI0CwJ/AkACQCAAKAJYIgYEQCAGQRRJIQxBACEHIAZBE00NASAGIQkMAgsCf0EAIAhBFE8gChtFBEAgACACIAgQ3QIiB0UEQCALIAIgCBCZCBogACAINgJYIAMgAygCACAIajYCACAFQQM2AgBBAA8LIAIgCkUNARogAiAHQQJGDQEaIAVBAjYCAEEBDwsgAiAIakFsagshBiAAIAI2AhggACABIAYQ3gIEQEEBDwsgAyAAKAIYIgcgAmsiBiADKAIAajYCACAHDAILIAYhCSAIRQ0AA0AgACAGaiACIAdqLQAAOgBcIAZBE0khDCAGQQFqIQkgB0EBaiEHIAZBEksNASAJIQYgByAISQ0ACwsgACAJNgJYAkBBACAKRSAMGw0AIAAgCyAJEN0CIgZFBEAgAyADKAIAIAdqNgIAIAVBAzYCAEEADwsgCkUNACAGQQJGDQAgBUECNgIAQQEPCyAAIAs2AhggACABIAsQ3gIEQEEBDwsgAyAAKAIYIAcgCSALamtqIgYgAygCAGo2AgAgAEEANgJYIAIgBmoLIQIgCCAGayEIIAAoAkhBkgJHDQALCyAAKAIgIgYEfyAGBSAFQQE2AgAgACgCIAtBAEcPCyAFQQI2AgBBAAutDwELfyAAKAIQIgogACgCNCIHQQV0aiAAKAIsIglBfyAAKAIIdEF/c3EiDEEBdGovAQAhBiAAKAIgIQMCfwJAAn8gASAAKAIcIgRB////B0sNABogAkEBSA0BIARBCHQhBCABLQAAIANBCHRyIQMgAUEBagshBSABIAJqIQgCQCADIARBC3YgBmwiAUkEQCAKQewcaiEGIAAoAjAgCXIEQCAGIAlBfyAAKAIEdEF/c3EgACgCACICdCAAKAIkIgQEfyAEBSAAKAIoCyAAKAIUakF/ai0AAEEIIAJrdmpBgAxsaiEGCyAHQQZNBEBBASEAA0AgBiAAQQF0IgBqLwEAIQIgAUH///8HSwR/IAEFIAUgCE8NBSAFLQAAIANBCHRyIQMgBUEBaiEFIAFBCHQLIQQgAyAEQQt2IAJsIgFPBEAgAyABayEDIAQgAWshASAAQQFyIQALIABBgAJJDQALQQEhCQwCCyAAKAIUIQlBACEEIAkgACgCJCICIAAoAjgiB2sgAiAHSQR/IAAoAigFIAQLamotAAAhB0GAAiEEQQEhAANAIABBAXQiACAGIARBAXRqIAdBAXQiByAEcSIJQQF0amovAQAhCiABQf///wdLBH8gAQUgBSAITw0EIAUtAAAgA0EIdHIhAyAFQQFqIQUgAUEIdAshAgJ/IAQgCXMgAyACQQt2IApsIgFJDQAaIAMgAWshAyACIAFrIQEgAEEBciEAIAkLIQQgAEGAAkkNAAtBASEJDAELIAMgAWshAyAKIAdBAXRqLwGAAyEAAn8gBSAEIAFrIgRB////B0sNABpBACAFIAhPDQMaIARBCHQhBCAFLQAAIANBCHRyIQMgBUEBagshAgJAIAMgBEELdiAAbCIASQRAQQIhCUEAIQ1BsgYhBQwBCyADIABrIQMgCiAHQQF0ai8BmAMhBgJ/IAIgBCAAayIFQf///wdLDQAaQQAgAiAITw0EGiAFQQh0IQUgAi0AACADQQh0ciEDIAJBAWoLIQQgAyAFQQt2IAZsIgBJBEAgCiAHQQV0aiAMQQF0ai8B4AMhBSAAQf///wdLBH8gBAVBACAEIAhPDQUaIABBCHQhACAELQAAIANBCHRyIQMgBEEBagshAiADIABBC3YgBWwiBUkEQEEDIAVB////B0sNBRpBA0EAIAIgCEkbDwsgAyAFayEDIAAgBWshAEEDIQlBDCENQbQKIQUMAQsgAyAAayEDIAogB0EBdGovAbADIQYCfyAEIAUgAGsiAkH///8HSw0AGkEAIAQgCE8NBBogAkEIdCECIAQtAAAgA0EIdHIhAyAEQQFqCyELQQMhCUEMIQ1BtAohBSADIAJBC3YgBmwiAEkEQCALIQIMAQsgAyAAayEDIAogB0EBdGovAcgDIQYCfyALIAIgAGsiBEH///8HSw0AGkEAIAsgCE8NBBogBEEIdCEEIAstAAAgA0EIdHIhAyALQQFqCyECIAMgBEELdiAGbCIASQ0AIAMgAGshAyAEIABrIQALIAogBUEBdGoiBC8BACEGIABB////B0sEfyACBUEAIAIgCE8NAxogAEEIdCEAIAItAAAgA0EIdHIhAyACQQFqCyEFAn8gAyAAQQt2IAZsIgFJBEAgBCAMQQR0akEEaiEGQQAhDEEIDAELIAMgAWshAyAELwECIQICfyAFIAAgAWsiAEH///8HSw0AGkEAIAUgCE8NBBogAEEIdCEAIAUtAAAgA0EIdHIhAyAFQQFqCyELIAMgAEELdiACbCIBSQRAIAQgDEEEdGpBhAJqIQYgCyEFQQghDEEIDAELIARBhARqIQYgAyABayEDIAAgAWshAUEQIQwgCyEFQYACCyEHQQEhAANAIAYgAEEBdCIAai8BACECIAFB////B0sEfyABBSAFIAhPDQMgBS0AACADQQh0ciEDIAVBAWohBSABQQh0CyEEIAMgBEELdiACbCIBTwRAIAMgAWshAyAEIAFrIQEgAEEBciEACyAAIAdJDQALIA0NACAKIAAgB2sgDGoiAEEDIABBA0kbQQd0akHgBmohBkEBIQADQCAGIABBAXQiAGovAQAhAiABQf///wdLBH8gAQUgBSAITw0DIAUtAAAgA0EIdHIhAyAFQQFqIQUgAUEIdAshBCADIARBC3YgAmwiAU8EQCADIAFrIQMgBCABayEBIABBAXIhAAsgAEHAAEkNAAsgAEFAaiIAQQRJDQAgAEEBdiEEAn8gAEENTQRAIAogAEEBcUECciAEQX9qIgJ0QQF0aiAAQQF0a0HeCmoMAQsgBEF7aiEAA0AgAUH///8HTQRAIAUgCE8NBCAFLQAAIANBCHRyIQMgBUEBaiEFIAFBCHQhAQsgAyADIAFBAXYiAWtBH3ZBf2ogAXFrIQMgAEF/aiIADQALQQQhAiAKQcQMagshB0EBIQADQCAHIABBAXQiAGovAQAhBiABQf///wdLBH8gAQUgBSAITw0DIAUtAAAgA0EIdHIhAyAFQQFqIQUgAUEIdAshBCADIARBC3YgBmwiAU8EQCADIAFrIQMgBCABayEBIABBAXIhAAsgAkF/aiICDQALCyAJIAlBACAFIAhJGyABQf///wdLGw8LQQALC6QiASd/AkADQAJ/IAAoAjAiGQRAIAAoAiwhESAAKAIkIQogAQwBCyAAKAIkIgogACgCDCAAKAIsIhFrIgNqIAEgASAKayADSxsLIRpBCCAAKAIAIh1rIR4gACgCECISQewcaiEcIBJB3gpqIR8gEkHEDGohGyASQeAGaiEgIBJB5AxqISEgEkHoFGohIiASQeADaiEjIBJByANqISQgEkGwA2ohJSASQZgDaiEmIBJBgANqISdBfyAAKAIEdEF/cyEoQX8gACgCCHRBf3MhKSAAKAIgIQUgACgCHCEDIAAoAhghByAAKAIoIRcgACgCFCEWIAAoAkQhEyAAKAJAIRggACgCPCEVIAAoAjghECAAKAI0IQ5BACEUA0AgESApcSILQQF0IgkgEiAOQQV0amoiCC8BACEGAn8gA0H///8HSwRAIAMhBCAHDAELIANBCHQhBCAHLQAAIAVBCHRyIQUgB0EBagshDwJAAkACQCAFIARBC3YgBmwiA0kEQCAIIAZBgBAgBmtBBXZqOwEAIBwhCSARIBlyBEAgHCARIChxIB10IAogFyAKGyAWakF/ai0AACAedmpBgAxsaiEJC0EBIQYCfyAOQQZNBEAgDyEHA0AgCSAGQQF0IgZqIgsvAQAhBCADQf///wdLBH8gAwUgBy0AACAFQQh0ciEFIAdBAWohByADQQh0CyEIAkAgBSAIQQt2IARsIgNJBEAgCyAEQYAQIARrQQV2ajsBAAwBCyALIAQgBEEFdms7AQAgBSADayEFIAggA2shAyAGQQFyIQYLIAZBgAJJDQALQQAgDkF9aiIEIAQgDksbDAELIAAoAhQgCiAQayAXQQAgCiAQSRtqai0AACELQYACIQdBASEGA0AgBkEBdCIGIAkgB0EBdGogC0EBdCILIAdxIg1BAXRqaiIMLwEAIQQgA0H///8HSwR/IAMFIA8tAAAgBUEIdHIhBSAPQQFqIQ8gA0EIdAshCAJ/IAUgCEELdiAEbCIDSQRAIAwgBEGAECAEa0EFdmo7AQAgByANcwwBCyAMIAQgBEEFdms7AQAgBSADayEFIAggA2shAyAGQQFyIQYgDQshByAGQYACSQ0ACyAPIQdBfUF6IA5BCkkbIA5qCyEOIAogFmogBjoAAAwBCyAIIAYgBkEFdms7AQAgBSADayEFICcgDkEBdCIMaiINLwEAIQgCfyAPIAQgA2siA0H///8HSw0AGiADQQh0IQMgDy0AACAFQQh0ciEFIA9BAWoLIQcCfyAFIANBC3YgCGwiBkkEQCANIAhBgBAgCGtBBXZqOwEAIA5BDGohDiATIQ8gECETICEMAQsgDSAIIAhBBXZrOwEAIBEgGXJFBEBBAQ8LIAUgBmshBSAMICZqIg0vAQAhBAJ/IAcgAyAGayIDQf///wdLDQAaIANBCHQhAyAHLQAAIAVBCHRyIQUgB0EBagshCAJ/IAUgA0ELdiAEbCIGSQRAIA0gBEGAECAEa0EFdmo7AQAgIyAOQQV0aiAJaiIJLwEAIQQgBkH///8HSwR/IAgFIAZBCHQhBiAILQAAIAVBCHRyIQUgCEEBagshByAFIAZBC3YgBGwiA0kEQCAJIARBgBAgBGtBBXZqOwEAIAogFmogFiAKIBBrIBdBACAKIBBJG2pqLQAAOgAAQQlBCyAOQQdJGyEODAQLIAkgBCAEQQV2azsBACAFIANrIQUgBiADayEGIBMhDyAQIRMgFQwBCyANIAQgBEEFdms7AQAgBSAGayEFIAwgJWoiCS8BACEEAn8gCCADIAZrIgNB////B0sNABogA0EIdCEDIAgtAAAgBUEIdHIhBSAIQQFqCyEHIAUgA0ELdiAEbCIGSQRAIAkgBEGAECAEa0EFdmo7AQAgEyEPIBUhEyAQDAELIAkgBCAEQQV2azsBACAFIAZrIQUgDCAkaiIILwEAIQQgAyAGayIDQf///wdNBEAgA0EIdCEDIActAAAgBUEIdHIhBSAHQQFqIQcLIAgCfyAFIANBC3YgBGwiBkkEQCATIQ8gGCETIARBgBAgBGtBBXZqDAELIAUgBmshBSADIAZrIQYgGCEPIAQgBEEFdmsLOwEAIBUhGCAQCyEVQQhBCyAOQQdJGyEOICILIgQvAQAhCCAGQf///wdLBH8gBwUgBkEIdCEGIActAAAgBUEIdHIhBSAHQQFqCyEJAn8gBSAGQQt2IAhsIgNJBEAgBCAIQYAQIAhrQQV2ajsBACAEIAtBBHRqQQRqIQ1BACEMQQgMAQsgBCAIIAhBBXZrOwEAIAUgA2shBSAELwECIQcCfyAJIAYgA2siBkH///8HSw0AGiAGQQh0IQYgCS0AACAFQQh0ciEFIAlBAWoLIQggBSAGQQt2IAdsIgNJBEAgBCAHQYAQIAdrQQV2ajsBAiAEIAtBBHRqQYQCaiENIAghCUEIIQxBCAwBCyAEIAcgB0EFdms7AQIgBEGEBGohDSAFIANrIQUgBiADayEDQRAhDCAIIQlBgAILIQtBASEGA0AgDSAGQQF0IgZqIggvAQAhBCADQf///wdLBH8gAwUgCS0AACAFQQh0ciEFIAlBAWohCSADQQh0CyEHAkAgBSAHQQt2IARsIgNJBEAgCCAEQYAQIARrQQV2ajsBAAwBCyAIIAQgBEEFdms7AQAgBSADayEFIAcgA2shAyAGQQFyIQYLIAYgC0kNAAsgBiALayAMaiEUAkACQAJ/IA5BDEkEQCAJIQcgEyEQIBUMAQsgICAUQQMgFEEDSRtBB3RqIgYvAQIhByADQf///wdLBH8gCQUgA0EIdCEDIAktAAAgBUEIdHIhBSAJQQFqCyELAn8gBSADQQt2IAdsIgRJBEAgB0GAECAHa0EFdmohA0ECDAELIAUgBGshBSADIARrIQQgByAHQQV2ayEDQQMLIQcgBiADOwECIAYgB0EBdCIIaiINLwEAIQcgBEH///8HSwR/IAsFIARBCHQhBCALLQAAIAVBCHRyIQUgC0EBagshCQJAIAUgBEELdiAHbCIDSQRAIA0gB0GAECAHa0EFdmo7AQAMAQsgDSAHIAdBBXZrOwEAIAUgA2shBSAEIANrIQMgCEEBciEICyAGIAhBAXQiCGoiDS8BACEHIANB////B0sEfyAJBSADQQh0IQMgCS0AACAFQQh0ciEFIAlBAWoLIQsCQCAFIANBC3YgB2wiBEkEQCANIAdBgBAgB2tBBXZqOwEADAELIA0gByAHQQV2azsBACAFIARrIQUgAyAEayEEIAhBAXIhCAsgBiAIQQF0IghqIg0vAQAhByAEQf///wdLBH8gCwUgBEEIdCEEIAstAAAgBUEIdHIhBSALQQFqCyEJAkAgBSAEQQt2IAdsIgNJBEAgDSAHQYAQIAdrQQV2ajsBAAwBCyANIAcgB0EFdms7AQAgBSADayEFIAQgA2shAyAIQQFyIQgLIAYgCEEBdCIIaiINLwEAIQcgA0H///8HSwR/IAkFIANBCHQhAyAJLQAAIAVBCHRyIQUgCUEBagshCwJAIAUgA0ELdiAHbCIESQRAIA0gB0GAECAHa0EFdmo7AQAMAQsgDSAHIAdBBXZrOwEAIAUgBGshBSADIARrIQQgCEEBciEICyAGIAhBAXQiCGoiCS8BACEGIARB////B0sEfyALBSAEQQh0IQQgCy0AACAFQQh0ciEFIAtBAWoLIQcCQCAFIARBC3YgBmwiA0kEQCAJIAZBgBAgBmtBBXZqOwEADAELIAkgBiAGQQV2azsBACAFIANrIQUgBCADayEDIAhBAXIhCAsCQCAIQUBqIgxBBEkNACAMQQFxQQJyIQYgDEEBdiEEIAxBDU0EQEEBIQggDEEBdCEJIB8gBiAEQX9qIgt0IgxBAXRqIAlrIQ9BASEEA0AgDyAEQQF0IgRqIg0vAQAhBiADQf///wdLBH8gAwUgBy0AACAFQQh0ciEFIAdBAWohByADQQh0CyEJAkAgBSAJQQt2IAZsIgNJBEAgDSAGQYAQIAZrQQV2ajsBAAwBCyANIAYgBkEFdms7AQAgCCAMciEMIAUgA2shBSAJIANrIQMgBEEBciEECyAIQQF0IQggC0F/aiILDQALDAELIARBe2ohBANAIANB////B0sEfyADBSAHLQAAIAVBCHRyIQUgB0EBaiEHIANBCHQLIQggBSAIQQF2IgNrIgVBH3UiCSAGQQF0QQFyaiEGIAMgCXEgBWohBSAEQX9qIgQNAAsgEi8BxgwhBCAIQf///w9LBH8gBwUgA0EIdCEDIActAAAgBUEIdHIhBSAHQQFqCyEIIAZBBHQhDCAbAn8gBSADQQt2IARsIgZJBEAgEiAEQYAQIARrQQV2ajsBxgxBAgwBCyASIAQgBEEFdms7AcYMIAxBAXIhDCAFIAZrIQUgAyAGayEGQQMLQQF0IgdqIgsvAQAhBCAGQf///wdLBH8gCAUgBkEIdCEGIAgtAAAgBUEIdHIhBSAIQQFqCyEJAkAgBSAGQQt2IARsIgNJBEAgCyAEQYAQIARrQQV2ajsBAAwBCyALIAQgBEEFdms7AQAgDEECciEMIAUgA2shBSAGIANrIQMgB0EBciEHCyAbIAdBAXQiB2oiCy8BACEEIANB////B0sEfyAJBSADQQh0IQMgCS0AACAFQQh0ciEFIAlBAWoLIQgCQCAFIANBC3YgBGwiBkkEQCALIARBgBAgBGtBBXZqOwEADAELIAsgBCAEQQV2azsBACAMQQRyIQwgBSAGayEFIAMgBmshBiAHQQFyIQcLIBsgB0EBdGoiCS8BACEEIAZB////B0sEfyAIBSAGQQh0IQYgCC0AACAFQQh0ciEFIAhBAWoLIQcCQCAFIAZBC3YgBGwiA0kEQCAJIARBgBAgBGtBBXZqOwEADAELIAkgBCAEQQV2azsBACAMQQhyIQwgBSADayEFIAYgA2shAwsgDEF/Rg0CCwJAIBlFBEAgDCARSQ0BQQEPCyAMIBlJDQBBAQ8LIAxBAWohEEEHQQogDkETSRshDiAYIQ8gFSEYIBMLIRUgCiAaRgRAQQEPCyAUQQJqIgYgGiAKayIEIAYgBCAGSRsiBGshFCAEIBFqIREgCiAQayAXQQAgCiAQSRtqIgYgBGogF00EQCAGIAprIQggCiAWaiIGIARqIQkDQCAGIAYgCGotAAA6AAAgBkEBaiIGIAlHDQALIAQgCmohCgwCCwNAIAogFmogBiAWai0AADoAAEEAIAZBAWoiBiAGIBdGGyEGIApBAWohCiAEQX9qIgQNAAsMAQsgDkF0aiEOIBRBkgJqIRQgEyEQIA8hEwwDCyAPIRMMAQsgEUEBaiERIApBAWohCgsgByACTw0AIAogGkkNAQsLIANB////B0sEfyAHBSADQQh0IQMgBy0AACAFQQh0ciEFIAdBAWoLIQYgACAUNgJIIAAgBTYCICAAIAM2AhwgACAGNgIYIAAgEzYCRCAAIBg2AkAgACAVNgI8IAAgEDYCOCAAIBE2AiwgACAKNgIkIAAgDjYCNCAAKAIMIgQgEU0EQCAAIAQ2AjALIBRBf2pBkAJNBEAgASAKayIDIBQgAyAUSRshAyAAKAIoIQYgACgCFCEFAkAgACgCMA0AIAQgEWsgA0sNACAAIAQ2AjALIAAgFCADazYCSCAAIAMgEWo2AiwgAwRAA0AgBSAKaiAFIAogEGsgBkEAIAogEEkbamotAAA6AAAgCkEBaiEKIANBf2oiAw0ACwsgACAKNgIkCwJAIAogAU8NACAAKAIYIAJPDQAgACgCSCIDQZICSQ0BDAILCyAAKAJIIQMLIANBkwJPBEAgAEGSAjYCSAtBAAvxAgEIfyMAQfAAayIJJAAgASgCACELIAMoAgAhDCABQQA2AgAgA0EANgIAQQYhCgJAIAxBBUkNACAJQgA3AxBBBCEKIAVBBUkNACAELQAAIgVB4AFLDQAgBCgAASENIAhBACAIKAIEEQUAQQEhCiAIQYAGIAVB/wFxQQluIgRBBXAiDiAFIARBCWxrQf8BcSIPanRBtg5qIhBBAXQgCCgCABEBACEEIAkgEDYCVCAJIAQ2AhAgBEUEQEECIQoMAQsgCSALNgIoIAkgADYCFCAJIA1BgCAgDUGAIEsbNgIMIAkgDjYCBCAJIA82AgAgCUEANgIkIAlBADYCWCAJQoCAgIAQNwNIIAlBATYCUCAJQgA3AiwgCSAFQS1uNgIIIAMgDDYCACAJIAsgAiADIAYgBxDcAkUEQEEGQQAgBygCAEEDRhshCgsgASAJKAIkNgIAIAggCSgCECAIKAIEEQUAIAlBADYCEAsgCUHwAGokACAKC/sFAQ5/IwBBEGshCSAAIAFqIQogACEGIAFBAU4EQCAAQQA6AAAgAEEBaiEGC0ECIQEgBiAKSQR/IAIgA2ohDSAGIAVBf2oiCzoAAEEAIQEgCUEANgEMIAlBrICwATYBCCAGQQFqIQcCQCAEQQFOBEADQCANIAJrQQFNDQIgCUEMaiABQQF0aiACLQAAIgggAi0AASIDQQh0cjsBACAKIAdrQQFNDQIgByAIOgAAIAYgAzoAAiAGQQNqIQcgBkECaiEGIAJBAmohAiABQQFqIgEgBEcNAAsLIA0gAmtBAkkNAEEBIAtB/wFxIhJBf2p0IgZBICAGQSBIGyEPIARBf2ohEANAAkACQAJ/AkAgAi4AACAQQQFqIARvIhBBAXQiBiAJQQxqaiIRLgEAayIDIANBH3UiAWogAXMiDiAJQQhqIAZqIgwuAQAiAUECdEGQyAFqKAIAIgYgBXVOBEAgA0EZdiEDAkAgDiAGQQF0TA0AIAFB1wBKDQADQCAMIAFB0AAgAUEQdEEQdUHQAEgbQQhqIgY7AQAgBkEQdEEQdUECdEGQyAFqKAIAIQYgCiAHSwRAIAdBgQE6AAAgB0EBaiEHCyAOIAZBAXRMDQEgDC4BACIBQdgASA0ACwsgA0HAAHEhCCAGIBJ1IRNBACEBQQEhAyAPQQBKBEADQCABIAEgBmoiCyALIA5KIgsbIQEgBkEBdSEGQQAgAyALGyAIciEIIANBAXQiAyAPTA0ACwsgASATaiEGIBEuAQAhASAIQcAAcUUNASABIAZrIgZBgIB+IAZBgIB+ShsMAgsgAQRAIAwgAUF/ajsBAAsgCiAHTQ0DIAdBgAE6AAAMAgsgASAGaiIGQf//ASAGQf//AUgbCyEGIBEgBjsBACAKIAdNDQMgByAIOgAAIAwgCEEfcUECdEGAywFqKAIAIAwuAQBqIgZB2AAgBkHYAEgbIgZBACAGQQBKGzsBAAsgB0EBaiEHCyANIAJBAmoiAmtBAUsNAAsLIAcgAGsFIAELC64FAQp/IwBBEGsiCEEANgEMIAhBrICwATYBCCACIANqIQkCfwJ/IANBAU4EQCACLQAAIQcgAkEBaiECCyACIAlPCwRAIAIMAQsgAi0AACEHIAJBAWoLIQMgACABaiEKAkACQCAEQQFIBEAgACECDAELQQAhASAAIQIDQCAJIANrQQJJDQIgCEEMaiABQQF0aiADLQAAIgUgAy0AASIGQQh0cjsBACAKIAJrQQJJDQIgAiAGOgABIAIgBToAACACQQJqIQIgA0ECaiEDIAFBAWoiASAERw0ACwsgAyAJTw0AIAdB/wFxIQwgBEF/aiEBA0AgAUEBaiAEbyEBAkACQCADLQAAIgZBgH9qIgVBAU0EQCAFQQFrBEAgAUEBdCIGIAhBCGpqIgUvAQAiBwRAIAUgB0F/ajsBAAsgCiACa0ECSQ0FIAIgCEEMaiAGai8BADsAAAwCCyAIQQhqIAFBAXRqIgYgBi8BAEEIaiIGQdgAIAZBEHRBEHVB2ABIGzsBACABQQFqIARvIQEMAgsgAUEBdCIHIAhBCGpqIg0uAQAiDkECdEGQyAFqKAIAIgVBACAGQQFxa3EgBSAMdWogBkEedEEfdSAFQQF1cWogBkEddEEfdSAFQQJ1cWogBkEcdEEfdSAFQQN1cWogBkEbdEEfdSAFQQR1cWogBkEadEEfdSAFQQV1cWohBSAIQQxqIAdqIgcuAQAhCyAHAn8gBkHAAHEEQCALIAVrIgVBgIB+IAVBgIB+ShsMAQsgBSALaiIFQf//ASAFQf//AUgbCyIFOwEAIAogAmtBAkkNAyACIAU7AAAgDSAGQR9xQQJ0QYDLAWooAgAgDmoiBkHYACAGQdgASBsiBkEAIAZBAEobOwEACyACQQJqIQILIANBAWoiAyAJRw0ACwsgAiAAawtKAQF/IwBBgPUAayIFJAAgASAFQRhqQQEQ/AEiBiAFQQhqIAAgASgCABD7ASACIAMgBCgCABCCAjYCACAGEP0BGiAFQYD1AGokAAtSAQJ/IwBBgPUAayIEJAAgBEEYakEAEPwBIQUgBEEIaiACIAMQ+wEhAiABIAUgACABKAIAIAIQgwIiADYCACAFEP0BGiAEQYD1AGokACAAQQBHC9kBACMAQUBqIgQkACAEIAA2AhQgBCADNgIQIAQgAzYCDCAEIAI2AgggASgCACECIARCADcDKCAEQQA2AhwgBCACNgIYIARBCGpBBkEIAn9BCCADQYECSA0AGkEJIANBgQRIDQAaQQogA0GBCEgNABpBCyADQYEQSA0AGkEMIANBgSBIDQAaQQ0gA0GBwABIDQAaQQ5BDyADQYGAAUgbC0EIQQBBgMwBQTgQkAJFBEAgBEEIakEEEJMCQQFNBEAgASAEKAIcNgIACyAEQQhqEJECGgsgBEFAayQAC4EBAQF/IwBBQGoiBCQAIAQgADYCFCAEIAM2AhAgBCADNgIMIAQgAjYCCCABKAIAIQMgBEIANwMoIARBADYCHCAEIAM2AhggBEEIakGAzAFBOBCbAiIDRQRAIARBCGpBBBCcAiEDIAEgBCgCHDYCACAEQQhqEJ4CGgsgBEFAayQAIAMLDQAgACABIAIgAxCfAgsNACAAIAEgAiADEKACC6ACAQV/IwBBIGsiBCQAAn8CQAJAIAFFDQAgAkUNACAARQ0AIAEoAgAiBiADTg0BC0EcEMgBQQAMAQtB2JsCEJAIIQUgBEEANgIIAkAgBUUEQCAGIQUMAQsgBUEAQdibAhCaCCEFIAQgADYCGCAEIAAgBmo2AhwgBCACNgIQIAQgAiADajYCFAJAIANB/wtMBEAgBEGACDYCDAwBCyADQf8XTARAIARBgBA2AgwMAQsgBEGAIDYCDAtB8gBB8wAgBSAEQRBqIARBCGogBEEMahChAiEHIAQoAhghCCAFEJEIIAYgCCAAayAHGyEFIAEoAgAhBgsgASAFIAZOBH8gACACIAMQmQgaIAEoAgAFIAULNgIAQQELIQEgBEEgaiQAIAELNwAgACACKAIAIgAgAigCBCAAayIAIAEoAgAiASABIABLGyIBEJkIGiACIAIoAgAgAWo2AgAgAQs3AQF/IAIoAggiAyAAIAIoAgwgA2siAyABKAIAIgEgASADSxsiARCZCBogAiACKAIIIAFqNgIIC7oBACMAQSBrIgQkAEHYmwIQkAghBSAEQQA2AgggBQRAIAVBAEHYmwIQmgghBSAEIAI2AhAgBCACIANqNgIUIAQgADYCGCAEIAAgASgCAGo2AhwCQCADQf8LTARAIARBgAg2AgwMAQsgA0H/F0wEQCAEQYAQNgIMDAELIARBgCA2AgwLQfIAQfMAIAUgBEEQaiAEQQhqIARBDGoQoQJFBEAgASAEKAIYIABrNgIACyAFEJEICyAEQSBqJAAL4AEBA38jAEEQayIEJAACQAJAAkAgAUUNACACRQ0AIABFDQAgASgCACIGIANODQELQRwQyAFBACEBDAELIAMgBkYEQEEBIQEgACACRg0BIAAgAiADEJkIGgwBCwJAQbTiABCQCCIFBEAgBUEAQbTiABCaCCEFIAQgADYCCCAEIAAgBmo2AgwgBCACNgIAIAQgAiADajYCBEHyAEHzACAFIAQQpAIaIAQoAggiAiAARw0BIAUQkQgLQewHEMgBQQAhAQwBCyAFEJEIIAEgAiAAazYCAEEBIQELIARBEGokACABC5ABAQN/IwBBEGsiBCQAAkBBtOIAEJAIIgVFBEBBACEGDAELQQAhBiAFQQBBtOIAEJoIIQUgBCACNgIAIAQgAiADajYCBCAEIAA2AgggBCAAIAEoAgBqNgIMQfIAQfMAIAUgBBCkAhogACAEKAIIIgJHBEAgASACIABrNgIAQQEhBgsgBRCRCAsgBEEQaiQAIAYLwAYBB38jAEHwAGsiCCQAIAggBTYCbEEAIQkgCEEANgIMAkACQAJAIAFFDQAgAkUNACAARQ0AIAEoAgAiBSADTg0BC0EcEMgBDAELIANFBEAgAUEANgIAQQEhCQwBC0ESIQoCQAJAAkACQAJAAn8gBEESRwRAQQAhBwJ/An8CfwJ/An8CfyAEQSBxBEAgCEEgOgAQIAhB9AA2AiBBASEHIARBX3EhBAsgBEHAAHELBEAgCEEQaiAHckHAADoAACAIQSBqIAdBAnRyQfUANgIAIAdBAWohByAEQb9/cSEECyAEQYABcQsEQCAIQRBqIAdyQYABOgAAIAhBIGogB0ECdHJB9gA2AgAgB0EBaiEHIARB/35xIQQLIARBAXELBEAgCEEQaiAHckEBOgAAIAhBIGogB0ECdGpB9wA2AgAgB0EBaiEHIARBfnEhBAsgBEECcQsEQCAIQRBqIAdyQQI6AAAgCEEgaiAHQQJ0akH4ADYCACAHQQFqIQcgBEF9cSEECyAEQQhxCwRAIAhBEGogB2pBCDoAACAIQSBqIAdBAnRqQfkANgIAIAdBAWohByAEQXdxIQQLIARBEHELBH8gCEEQaiAHakEQOgAAIAhBIGogB0ECdGpB+gA2AgAgB0EBaiEHIARBb3EFIAQLDQRBASEJIAdBAUgNAkEAIQpBACELQQEgB0EBRg0BGkEAIQogByAFEJAIIgsNARpBMBDIAUEAIQkMBwsgCEESOgAQIAhB+wA2AiBBACELQQELIQxBACEEIAwhB0EAIQkDQCAIIAVBf2o2AgwgCyAAIAdBf2oiB0EBcRsiBUEBaiAIQQxqIAIgAyAIQewAaiAGIAhBIGogBEECdGooAgARCgACQCAIKAIMIg0gA0F+akoEQCAFIAlqIAIgAxCZCBogCCADNgIMDAELIAogCEEQaiAEai0AAHIhCkEBIQkgDSEDCyAEQQFqIgQgDEYNAiAFIAlqIQIgASgCACEFDAAACwALIAAgAiADEJkIGiABIAM2AgAMBAsgCQ0BDAILQYoBEMgBQQAhCQwCCyAAIAo6AAALIAEgAyAJajYCAEEBIQkgC0UNACALEJEICyAIQfAAaiQAIAkLQQAgBEEGQQhBByAFQQNGIgQbIAVBf2pBAkkiBRs2AgAgASAAIAEoAgAgAiADQQFBBEEGQQUgBBsgBRsQ4AI2AgALQQAgBEEGQQhBByAFQQNGIgQbIAVBf2pBAkkiBRs2AgAgASAAIAEoAgAgAiADQQJBBEEGQQUgBBsgBRsQ4AI2AgALoQEAIwBBMGsiBCQAIARBADYCLCAEQgA3AiQCQCAEQQlBAEEeENICDQAgBCAANgIQIAQgAjYCACAEIAM2AgQgBCABKAIANgIUAkAgBCADRUEBdBDUAiIDQQRGDQAgA0EASA0AA0AgBCAEKAIERUEBdBDUAiIDQQRGDQEgA0F/Sg0ACwsgBBDXAhogA0EBSA0AIAEgBCgCGDYCAAsgBEEwaiQAC98BACMAQdAAayIEJAAgBEH8ADYCSCAEQf0ANgIUIARB/gA2AhAgBEEFNgIAIARBGGoQuAIgBCABKAIAQXJqNgIMAkAgAEEOaiAEQQxqIAIgAyAEQRhqIARBB2ogBEEAIARByABqIARBEGogBEEQahDGAg0AIAQoAgwiAiABKAIAQXJqTw0AIABBADoAACAAIARBB2ogBCgCACIAEJkIIABqIgBBADYABSAAIANBGHY6AAQgACADQRB2OgADIAAgA0EIdjoAAiAAIAM6AAEgASACQQ5qNgIACyAEQdAAaiQACwQAQQALBwAgARCQCAu5AwEKfyMAQRBrIgYkACAGIAEoAgAiBTYCDEEAIQcCQCADQQFIDQAgBSADSA0AIAMgBUYEQEEBIQcgACACRg0BIAAgAiADEJkIGgwBCwJAIAItAAAiBEEQcSIKQX9zIARxIARBCHEiC0F/c3EgBEECcSIMQX9zcSAEQQFxIghBf3NxIARBf3NB/35ycSAEQcAAcSIJQX9zcSAEQSBxIg1Bf3NxRQRAIApBBHYgC0EDdmogDEEBdmogCGogBEEHdmogCUEGdmogDUEFdmoiCA0BC0GKARDIAQwBC0EAIQpBACEJAkAgCEECSQ0AIAUQkAgiCQ0AQTAQyAFBACEHDAELIANBf2ohCyACQQFqIQwgCEF/aiEDQQEhBwNAAkAgCkEDdCICQZDMAWooAgAgBHEEQCAGIAEoAgA2AgwCQCAJIAAgA0EBcRsiCCAGQQxqIAwgCyACQZTMAWooAgARBAAiBwRAIAYoAgwiBQ0BC0HsBxDIAUEAIQcgBigCDCEFDAILIAghDCAFIQsgA0F/aiEDCyAKQQFqIgpBB0cNAQsLIAEgBTYCACAJRQ0AIAkQkQgLIAZBEGokACAHC78DAQV/IwBBEGsiBCQAIAQgASgCACIFNgIMQQAhBgJAIANBAUgNACAFIANIDQAgAyAFRgRAQQEhBiAAIAJGDQEgACACIAMQmQgaDAELIANBf2ohByACQQFqIQgCQAJAAkACQAJAAkACQCACLQAAIgNBfmoiBkE/SwRAIANBgQFHDQFB/wAhAkGAASEDDAULQYEBIQJBggEhAwJAAkACQAJAIAZBAWsOPwQEBAQEBQQEBAQEBAQABAEEBAQEBAQEBAQEBAQEAgQIBAQEBAQEBAQEBAQEBAcEBAQEBAQEBAQEBAQEBAQEAwYLQYMBIQMMBQtBhAEhAwwEC0GBASEDDAMLQYUBIQJBgAEhAwwEC0HsBxDIAQwFC0GGASEDCyAAIARBDGogCCAHIAMRBAAhBiABIAQoAgw2AgAMAgtBgwEhAwsgBRCQCCIFRQRAQTAQyAEMAgsCf0EAIAUgBEEMaiAIIAcgAxEEAEUNABogBCgCDCEDIAQgASgCADYCDCAAIARBDGogBSADIAIRBAALIQYgASAEKAIMNgIAIAAgBUYNACAFEJEICyAGDQFB7AcQyAELQQAhBgsgBEEQaiQAIAYLGQAgASAAIAEoAgAgAiADQQIQ4QI2AgBBAQuLAQEBfyMAQTBrIgQkACAEQQA2AiwgBEIANwIkIAECf0EAIARBAEEAENgCDQAaIAQgADYCECAEIAM2AgQgBCACNgIAIAQgASgCADYCFEEAIQACQANAIABBBEYNASAEENoCIgBBf0oNAAsgBBDbAhpBAAwBCyAEENsCGiAEKAIYCzYCACAEQTBqJABBAQuNAQECfyMAQSBrIgQkACAEIAEoAgA2AgwgBCADNgIIQQAhBQJAIANBD0kNACACLQAADQAgBEH9ADYCFCAEQf4ANgIQIAQgA0FyajYCCCAAIARBDGogAkEOaiAEQQhqIAJBAWpBBUEBIARBHGogBEEQahDfAg0AIAEgBCgCDDYCAEEBIQULIARBIGokACAFCxkAIAEgACABKAIAIAIgA0EBEOECNgIAQQELkAEBAn8jAEEgayIEJAAgBCABKAIANgIMIAQgAzYCCEEAIQUCQCADQQZJDQAgAkHIzAFBBRDkBg0AIARB/QA2AhQgBEH+ADYCECAEIANBe2o2AgggACAEQQxqIAJBBWogBEEIaiACQQVBASAEQRxqIARBEGoQ3wINACABIAQoAgw2AgBBASEFCyAEQSBqJAAgBQvDAwEGfyMAQZAIayIFJAAgBUEANgKMCAJ/AkAgAARAIAFBCWohB0EAIQQDQCABIQMgACAALQDMAkGAAXEEfyABQc3MAUEJEO0GIQYgBSAAKAIoIgNBBGogAygCABCZCCIIIAMoAgBqIAEgByAGGxDsBhogCAUgAwtBAEEAEIwDIgMEQCAEIAAgAy0AIkEQcRshBAsgACgCICIADQALIAQNAQtBLBDIAUEADAELIAEhAAJAIAQgBC0AzAJBgAFxBH8gAUHNzAFBCRDtBiEDIAUgBCgCKCIAQQRqIAAoAgAQmQgiBiAAKAIAaiABIAcgAxsQ7AYaIAYFIAALQX0gBUGMCGoQ/QJFDQAgBCgCICIARQ0AIAUoAowIIQQDQCABIQMgACAALQDMAkGAAXEEfyABQc3MAUEJEO0GIQYgBSAAKAIoIgNBBGogAygCABCZCCIIIAMoAgBqIAEgByAGGxDsBhogCAUgAwtBfSAFQYgIahD9AgRAIAQgBSgCiAgiAzYCMCADIQQLIAAoAiAiAA0ACwsCQCACRQRAIAUoAowIIQAMAQsgAiAFKAKMCCIANgIACyAAQQBHCyEAIAVBkAhqJAAgAAvSBQEJfyMAQZAIayIFJAAgABCnAyEGIAVBfzYCDEEAIQQgBUEANgIIAkAgAQRAIAEtAAANAQtBHCEEC0EAIQcCQAJAIARBCCAGGyAEIAJBf0cbIgRBHCADGyAEIAJBfEcbIgQNACACQQRqIgRBBEsEQEEcIQQMAQsCfwJAAkACQCAEQQJrDgICAQALIAEgBUEIahC9AwRAQSwhBCAFKAIIIgAgBigCsAJLDQRBASEKIAYoAjwgAEEGdGoMAwsCQCACQX1HBEAgBigCIA0BC0EAIQogBiABQZSeAygCACAFQQxqEIkDDAMLIAAgASADEPwCIQQMBAsgBUEQakGACCABEJsDIAVBEGpBgAIQyQEiAkUEQEEAIQQgA0EANgIADAQLQQAhBEEAQQAQrgMiAQRAIAEgAjYCAEEBIQQgAyABNgIADAQLIAIQzQFBMBDIASADQQA2AgAMAwtBACEKIAYgAUEAIAVBDGoQiQMLIgBFBEBBLCEEDAELQQAhB0EsQQAgACgCIEF/SiILGyEEIAsNACACQXxGDQAgBiAAEK4DIghFBEBBMCEEDAELIAUoAgwhAgJAIAYoAjQiCUUNACACQX9HDQACQCAGKAIwKAAYIgRBAUgEQEF/IQIMAQsgCSAEQQR0aiELIAUoAgghB0F/IQIgCSEEA0AgByAEKAIMQf////8AcUYEQCACQX9HIQxBfyECIAwNAiAEIAlrQQR1IQILIARBEGoiBCALSQ0ACwsgBSACNgIMCyACQX9HBEAgCCAJIAJBBHRqNgIICyAIIAI2AiAgBi0AzAJBIHEEQCAIQQE6AM0BC0EAIQQCQCAKDQAgBiAAIAEQjQMgACgCICICQYCABHFFDQAgCCABIAApAwggACgCGCACEKYDNgIkCyAIIQcLIAMEQCADIAc2AgALIARFBEBBASEEDAELIAQQyAFBACEECyAFQZAIaiQAIAQLDQAgACABQXxBABD9Ags+AQF/IwBBEGsiASQAIAEgADYCDAJ/IAAQqANFBEBBCBDIAUEADAELIAFBDGoQuwNBAQshACABQRBqJAAgAAseACAAKQMQIAF8IgEgAUL/////D4MgACgCMC8ADBsLTQIBfwF+An4gACgCBCICKAIwLwAMBEAgACkDECABrXwMAQsgACgCDCgCCCACKAIQIAFqaq0LIQMgACgCNCIABH4gAyAANQIAfAUgAwsL1wkCA38EfiMAQRBrIgYkACAALwBgIQUCfwJAAkACQAJAAkACQAJAAkACQAJAIANBgIAgcQ0AIAQNACAFQQNLDQYgBUEBaw4DAwQFAQsgBQ0BCyAAKABYQSBGDQYLIABBADsAYAwECyAAKABYQSxHBEAgAEEAOwBgDAQLIABBgAFqQQBBpAEQmggaIAAgACgAbEEEdK03AJgBIAAgACgAcEEEdCIDrTcAoAEgACgAaCIFrSAAMwB+QiCGhCIJIAA1AGQgADMAfEIghoQiCFoEQCAAIAkgCH03AJgBIAApAHQiCFBFBEAgACAIIAl9NwCgASAAAn4CQCACQv////8PVg0AIAAoAFwiBCAFTQ0AIAStIAQgBWsgA00NARogBCACIAF9p0sNACAErQwBCyACIAF9CyICNwCAASAAIAIgCH03AKgBIAEgCXwhCAwHCyAAAn4CQCACQv////8PVg0AIAAoAFwiBCAFTQ0AIAStIAQgBWsgA00NARogBCACIAF9p0sNACAErQwBCyACIAF9CyIINwCAASAAIAggCX03AKABIAEgCXwhCAwGCyAAIAA1AFw3AIABIAAgACgCzAJBBHI2AswCIAEgCXwhCAwFCwJAIAAoAFhBxABPBEAgACkAgAEhCgwBCyAAQgA3AIgBIABCADcAkAEgACAANQBcIgo3AIABCyAAQZgBakEAQYwBEJoIIQUgADMAfEIghiECIAA1AGQhCyAANQBoIAAzAH5CIIaEIQkCQCAAKQB0IghQBEAgCiEIDAELIAAgCiAIfTcAqAELIAIgC4QhAiAJUEUEQCAAIAggCX03AKABIAkhCAsCQCACUARAIAghAgwBCyAFIAggAn03AAALAkAgACkAiAEiCFAEQCACIQgMAQsgACACIAh9NwC4AQsgACkAkAEiAlBFBEAgACAIIAJ9NwCwAQsgASAJfCEIDAQLIABB1ABqQcABIABBlAJqEL4DIQUgADUAaCAAMwB+QiCGhCABfCEIQQBB7AcgBRsMBAsgACACIAMQ9AEEQCAAQQA7AGAMAQsgADUAaCAAMwB+QiCGhCABfCEIDAILIABBIDYAWCAAIAAoAswCQQRyNgLMAgsCQCAAKABwIgRBAkkNACAAKABkIgVBAE5BACAFQSBLG0UEQCAAIAAoAswCQQRyNgLMAgsgACgAaCIFQSFPQQAgBUF/ShsNACAAIAAoAswCQQRyNgLMAgsgACgCzAIhAyAALwBiIgVBgAJPBEAgACADQQRyIgM2AswCCyAAIAVB/wFxOwBiIABB9ABqQQBBsAEQmggaIAAgBEEEdCIHrTcAoAEgACAAKABcIgStIgk3AIABIAAgACgAbEEEdK03AJgBIAAoAGgiBSABp2qtIQhBACADQQRxRQ0BGiAGQQA2AgQCQAJAIAQgBU0EQCACIAF9IQkMAQsgBCAFayAHRg0BIAQgAiABfSIJp0cNACAJQv////8PgyEJDAELIAlChQJUDQAgBiACQvx9fCIJNwMIIAAoAgAgBkEIaiAGQQRqQQQQ3gEhBSAJIAIgBigCBEHOjqWaBUYbIAIgBRsgAX0hCQsgACAJPgBcIAAgCTcAgAELQQALIQUgCCABVARAIAAgACgCzAJBBHI2AswCCyAGQRBqJAAgBQs0AQF/QQAhAiABKAIMQf////8AcSIBIAAoArACSQR/IAAoAjwgAUEGdGooAiBBH3YFIAILC/wBAQN/IwBBEGsiBiQAIAYgATcDCAJAIAFQBEBBACEFDAELIAJFBEBBACEFDAELIAIQkAgiBUUEQEEAIQUMAQsgBiAAKQMQIAF8NwMIAkAgACgCACAGQQhqIAUgAhDeAUUNACAFKAIAIANHDQAgBUEMaiIHIAJBdGogBBCkAyAFKAIIIgNBDGoiACACTQ0BAkAgABCQCCIABEAgBiADNgIEIAAgBSgCADYCACAFKAIEIQQgACADNgIIIAAgBDYCBCAAQQxqIAZBBGogByACEPYCDQEgABCRCAtBACEACyAFEJEIIAAhBQwBCyAFEJEIQQAhBQsgBkEQaiQAIAULpAIBBH9BMBCQCCIERQRAQQAPCyAEQgA3AwAgBEIANwMoIARCADcDICAEQgA3AxggBEIBIAJBf2qthjcDECAEQn9CfyACrYZCf4UgAkHAAEYbNwMIIAFFBEAgAEECdEEDbiEBCyAEQQA2AiggBCACNgIgIAQgATYCHCAEIAA2AhggBEHAACAArXmna0EAIAAbIgI2AiwgBCACNgIkIAQgARCQCCIANgIEIAAEQCAAQQAgARCaCCEFIAEgAmwiBkEHakEDdiIAQQxqIgIQkAgiBwRAIAdB/wEgAhCaCCICIAY2AgQgAiAANgIAIAQgAjYCACADRQRAIAQPCyAFIAMgARCZCBogAkEIaiABIANqIAAQmQgaIAQPCyAFEJEICyAEEJEIQQALLAEBfyAABEAgACgCBCIBBEAgARCRCAsgACgCACIBBEAgARCRCAsgABCRCAsL2xICHn8CfiMAQYAgayICJAAgACgCsAIhEiAAKAI8IQwgAkHMAUGAEBCaCCIPQYAQakHMAUGAEBCaCBogDCAAKAIwKAAcIgpBBnRqIRRBASECQQAhDUEAIQVBACEIAkAgCkEBSA0AQgAhIEEAIQVBACEIQQAhByAMIQYDQCAGKAIcIgIgBSACIAVLGyEFIAYoAhgiAiAIIAIgCEsbIQggBikDCCIhICAgISAgVhshICAGKAIgIQNBACECAkACQANAIA9BgBBqIAJBAnRqIgQoAgAiCUHMmbPmfEYNASADIAlGDQEgAkEBaiICQYAERw0AC0F/IQIMAQsgBCADNgIACyACIAcgAiAHSxshByAGQUBrIgYgFEkNAAsgB0EBaiECICBQDQBBwAAgIHmnayENCwJAQcAAIAiteadrQQAgCBsiFSANaiIaQcAAIAWteadrQQAgBRsiFmoiG0HAACACrXmna0EAIAIbIhNqIhggCmwiBEEHakEDdiIDIAJBAnQiHCAAKAI4KAIgQXhqIhAgCmwiHUEHakEDdiIXamoiCUHYAGoiHhCQCCILRQ0AIAsgAjYCVCALIBc2AlAgCyAQNgJMIAtBADYCSCALIBA2AkQgC0EANgJAIAsgEzYCPCALIBY2AjggCyAVNgI0IAsgDTYCMCALIBg2AiwgCyAbNgIoIAsgGjYCJCALIA02AiAgC0EANgIcIAsgGDYCGCALQRA2AhQgCyAKNgIQIAsgCUHMAGoiAjYCDCALIAI2AgggC0LCitHSETcCACALQdgAaiEZAkAgA0EMaiICEJAIIgkEQEEAIQ4gCUEAIAIQmggiCSAENgIEIAkgAzYCACAPQQA2AoAQIApBAU4EQCAPQYAQaiATQXdqQQN2aiERIA1BCUkhHwNAIA5BB3EhByAOQQN2IQIgDEEIaiEDAkACfyAfRQRAQf8BIAd0IQpBACEEQQAhBSANIQYDQCACIAlqQQhqIgggAy0AACAHdCAFciIFIAgtAAAgBCAKciIEQX9zcUH/AHFyOgAAIAJBAWohAiADQQFqIQMgBEEIdSEEIAVBCHUhBSAGQXhqIgZBCEsNAAsgBUH//wNxDAELIA1FDQFBACEEIA0hBkEACyEIIAIgCWoiCkEIaiIFIAMtAAAgB3QgCHIiAyAFLQAAIAZBAXRB4MwBai8BACAHdCAEciICQX9zcXI6AAAgAkGA/gNxRQ0AIApBCWoiBCAELQAAIAJBCHZBf3NxIANBCHZyOgAACyAMQRhqIQIgDSAOaiIDQQdxIQcgA0EDdiEDAkACfyAVQQlPBEBB/wEgB3QhCkEAIQRBACEFIBUhBgNAIAMgCWpBCGoiCCACLQAAIAd0IAVyIgUgCC0AACAEIApyIgRBf3NxQf8AcXI6AAAgA0EBaiEDIAJBAWohAiAEQQh1IQQgBUEIdSEFIAZBeGoiBkEISw0ACyAFQf//A3EMAQsgFUUNAUEAIQQgFSEGQQALIQggAyAJaiIKQQhqIgUgAi0AACAHdCAIciICIAUtAAAgBkEBdEHgzAFqLwEAIAd0IARyIgNBf3NxcjoAACADQYD+A3FFDQAgCkEJaiIEIAQtAAAgA0EIdkF/c3EgAkEIdnI6AAALIAxBHGohAiAOIBpqIgNBB3EhByADQQN2IQMCQAJ/IBZBCU8EQEH/ASAHdCEKQQAhBEEAIQUgFiEGA0AgAyAJakEIaiIIIAItAAAgB3QgBXIiBSAILQAAIAQgCnIiBEF/c3FB/wBxcjoAACADQQFqIQMgAkEBaiECIARBCHUhBCAFQQh1IQUgBkF4aiIGQQhLDQALIAVB//8DcQwBCyAWRQ0BQQAhBCAWIQZBAAshCCADIAlqIgpBCGoiBSACLQAAIAd0IAhyIgIgBS0AACAGQQF0QeDMAWovAQAgB3QgBHIiA0F/c3FyOgAAIANBgP4DcUUNACAKQQlqIgQgBC0AACADQQh2QX9zcSACQQh2cjoAAAsgDCgCICEEQQAhAgJAAkADQCAPIAJBAnRqIgYoAgAiA0HMmbPmfEYNASADIARGDQEgAkEBaiICQYAERw0AC0F/IQIMAQsgBiAENgIACyAPIAI2AoAQIA4gG2oiA0EHcSEKIANBA3YhAwJAAn8gE0EJTwRAQf8BIAp0IRJBACEFIA9BgBBqIQRBACEHIBMhCANAIAMgCWpBCGoiBiACQf8BcSAKdCAHciICIAYtAAAgBSASciIFQX9zcUH/AHFyOgAAIAhBeGohCCADQQFqIQMgBEEBaiEGIAVBCHUhBSACQQh1IQcgBCARRkUEQCAGLQAAIQIgBiEEDAELCyAGLQAAIQIgB0H//wNxDAELIBNFDQFBACEFIBMhCEEACyEHIAMgCWoiBkEIaiIEIAJB/wFxIAp0IAdyIgIgBC0AACAIQQF0QeDMAWovAQAgCnQgBXIiA0F/c3FyOgAAIANBgP4DcUUNACAGQQlqIgQgBC0AACADQQh2QX9zcSACQQh2cjoAAAsgDiAYaiEOIAxBQGsiDCAUSQ0ACyAJKAIEQQdqQQN2IQMLIBkgDyAcEJkIIBxqIAlBCGogAxCZCCECIAkQkQggAiADaiEZDAELIAwgEkEGdGohFAsgF0EMaiIJEJAIIgMEQEEAIQIgA0EAIAkQmggiByAdNgIEIAcgFzYCACAZIAdBCGogACgCPCIRIBRJBH8gFCARQX9zakEGdiEOIBBBCUkhDANAIAIiEiAQbCICQQdxIQggAkEDdiECAkACfyAMRQRAQf8BIAh0IQpBACEDQQAhBiAQIQQgESEJA0AgAiAHakEIaiIFIAktAAAgCHQgBnIiBiAFLQAAIAMgCnIiA0F/c3FB/wBxcjoAACACQQFqIQIgCUEBaiEJIANBCHUhAyAGQQh1IQYgBEF4aiIEQQhLDQALIAZB//8DcQwBCyAQRQ0BQQAhAyAQIQQgESEJQQALIQUgAiAHaiIKQQhqIgYgCS0AACAIdCAFciIJIAYtAAAgBEEBdEHgzAFqLwEAIAh0IANyIgJBf3NxcjoAACACQYD+A3FFDQAgCkEJaiIDIAMtAAAgAkEIdkF/c3EgCUEIdnI6AAALIBFBQGshESASQQFqIQIgDiASRw0ACyAHKAIEQQdqQQN2BSAXCxCZCBogBxCRCAsgAUUNACABIB6tNwMACyAPQYAgaiQAIAsLOwEBfyAABEAgACgCBCIBBEAgARCRCAsgACgCCCIBBEAgARCRCAsgACgCACIBBEAgARCRCAsgABCRCAsL6gEBBH8CQCAAKAI0RQ0AIAAgARCpAyIHRQ0AQQAhBSAHIQQCQANAIAQvAQghBgJAIAJFDQAgAiAGRw0AIAQtAAoNACAEIQUMAgsgBkEAIAIgBkcbRQRAIAUgBCAELQAKGyEFCyAAIAcgBBCqAyIEDQALIAVFDQELIAUoAgxB/////wBxIgQgACgCsAJPDQAgAwRAIAMgBSAAKAI0a0EEdTYCACAFKAIMQf////8AcSEECyAAKAI8IARBBnRqDwtBACEEAkAgACgCOEUNACAAIAEQigMiBkF/Rg0AIAAoAjwgBkEGdGohBAsgBAuwAwIMfwF+IwBBEGsiBiQAAkACQCAAKAI4IgQoAhhFDQAgARChAyAEKQMIgyAEKQMQhCIOIAQoAiBBeGqtiKdB/wFxIQsgDiAEKAIcIgOtgqciDCECA0AgBCgCBCACai0AACIBRQ0BIAJBAWoCfyABIAtGBEAgBkEANgIMIAQoAiQgAmwiAUEHcSEFIAFBA3YiAkEBaiEHIAQoAgAhCAJAIAQoAiwiDUEDdiIJRQRAIAZBDGohAwwBC0EIIAVrIQogBkEMaiEDA0AgAiAIai0ACCEBIAMgBQR/IAcgCGotAAggCnQgASAFdnIFIAELOgAAIAdBAWohByACQQFqIQIgA0EBaiEDIAlBf2oiCQ0ACwsgDUEHcSIBBEAgAyACIAhqQQhqIgktAAAgBXYiAjoAACABQQggBWsiCksEQCADIAcgCGotAAggCnQgCS0AACAFdnIiAjoAAAsgAyACQX8gAXRBf3NxOgAACyAGKAIMIgEgACgCsAJNBEAgACgCPCABQQZ0aikDACAOUQ0FCyAEKAIcIQMLIAMLcCICIAxHDQALC0F/IQELIAZBEGokACABCw0AIAAgASACQQAQiQMLvAEBAn8CQAJAIAAoAjRFDQAgACABEKkDIgVFDQAgBSEEA0AgAiAELwEIRwRAIAAgBSAEEKoDIgQNAQwCCwsgBCgCDEH/////AHEiAiAAKAKwAk8NACADBEAgAyAEIAAoAjRrQQR1NgIAIAQoAgxB/////wBxIQILIAAoAjwgAkEGdGohBAwBC0EAIQQgACgCOEUNACAAIAEQigMiAkF/Rg0AIAMEQCADQX82AgALIAAoAjwgAkEGdGoPCyAEC3gBAn8gASgCOEEAEL0DIQQgASgCOCEDAkACQCAEBEAgAwRAIAMQkQgLIAFBADYCOAwBCyADDQELIAEgAhCgCEEBahCQCCIDNgI4IANFDQAgAyACEOwGGgsgACgCOCIDBEAgASADKQMQIAMpAwggAhChA4OENwMACwuMAgEFfyAAKAKwAiEEIAAoAjwhBUEAIQZBACEHIAAtAMwCQcAAcUUEQCAAKAK0AiEHCyAEQQFIBEBBAA8LIAUgBEEGdGohCEEAIQQDQAJAIAUoAiBBAE4EQCAEIAUgBBshBCAGQQFqIgYgB0sNAQsgBUFAayIFIAhJDQELC0EAIQUCQCAERQ0AIAYgB00NACAEQgA3AwAgBEIANwM4IARCADcDMCAEQgA3AyggBEIANwMgIARCADcDGCAEQgA3AxAgBEIANwMIIAAgBCABEI0DIAAoAjQEQCAAIAQgAhCrAyIGRQ0BIAYgBCAAKAI8a0EGdTYCDCADIAYgACgCNGtBBHU2AgALIAQhBQsgBQtkAQF/IAEoAgwhAiAAKAI0BEAgASgCCCIBRQRAQYoBDwsgAUJ/NwIAIAFC/////283AggLIAIoAjgiAQRAIAEQkQgLIAJBADYCOCACQgA3AwAgAiACKAIgQf////8HcTYCIEEAC9EBAQN/IwBBEGsiBCQAQQAhBiAEQQA2AgwgACABQX0gBEEMahD9AgRAIAQoAgwiBSgCDCIBKAIgIQYCQCAAKAI0BEAgBSgCCCIFRQ0BIAVCfzcCACAFQv////9vNwIICyABKAI4IgIEQCACEJEIC0EAIQIgAUEANgI4IAFCADcDACABIAEoAiBB/////wdxNgIgIAAgACgCzAIgA3I2AswCIAAgACgCtAJBAWo2ArQCCyAEQQxqELsDCyAAIAAoAswCIAJyNgLMAiAEQRBqJAAgBgucAQEBfyAAKALMAiIBQcAAcUUEQCAAAn8CfyABQYAMcUUEQCAAIABB8swBQYAEQYAIEJADNgK8AiAAKALMAiEBCyABQYAwcUULBEAgACAAQf3MAUGAEEGAIBCQAzYCwAIgACgCzAIhAQsgAUGAwAFxRQsEfyAAIABBis0BQYDAAEGAgAEQkAM2AsQCIAAoAswCBSABC0ECcjYCzAILC88BAgR/AX4jAEEQayIDJAAgACgCMCEBQQAhAiADQQA6AA8CQCABKAAcIgRFDQAgACgC0AIiBUECSw0AAkACQAJAIAVBAWsOAgECAAsgACAAKQMQIAE1ABQgATMAKkIghoR8IgYgBkL/////D4MgAS8ADBsgASgATCAEQQR0QaPnjuR+IANBD2oQsAMiAUUNAiADLQAPRQRAIAEhAgwDCyAAIAAoAswCQRRyNgLMAiABIQIMAgsgABD2ASECDAELIAAQ+gEhAgsgA0EQaiQAIAILmQECAn8CfkEAIQICQCAAKAIwIgEpADwiA1ANACABKQBcIgRQDQAgACADIASnQciK0dIBQfDuvJ18EIQDIgBFDQBBACECAkAgACgCCCIBQSBJDQAgACgCDCABRw0AIAAoAhAgACgCFCAAKAIYIABBLGoQhQMiAUUNACABIAAoAiA2AiggASAAKAIkNgIsIAEhAgsgABCRCAsgAguJBAIHfwJ+QQAhAQJAIAAoAjAiAikANCIIUA0AIAIpAGQiCVANACAAIAggCadBworR0gFBo+eO5H4QhAMiAEUNAEEAIQECQCAAKAIIIgJBzABJDQAgACgCDCACRw0AIAAoAhAhAkHMABCQCCIDRQ0AIABB2ABqIQUgA0EAQcwAEJoIIgEgAjYCRCABIAAoAhgiBDYCDCABIAAoAhw2AhAgASAAKAIgNgIUIAEgACgCJDYCGCABIAAoAig2AhwgASAAKAIsNgIgIAEgACgCMDYCJCABIAAoAjQ2AiggASAAKAI4NgIsIAEgACgCPDYCMCABIABBQGsoAgA2AjQgACgCVCIDBEAgASADQQJ0IgcQkAgiBjYCCCAGBEAgBiAFIAcQmQgaIAUgB2ohBQsgASADNgJICwJAIAIgBGwiBkEHakEDdiIDQQxqIgQQkAgiBwRAIAdBACAEEJoIIgQgBjYCBCAEIAM2AgAgASAENgIEIARBCGogBSADEJkIGiADIAVqIQUMAQsgAUEANgIECyABIAAoAkQiAzYCOCABIAAoAkg2AjwgASAAKAJMNgJAAkAgAiADbCIEQQdqQQN2IgNBDGoiAhCQCCIGBEAgBkEAIAIQmggiAiAENgIEIAIgAzYCACABIAI2AgAgAkEIaiAFIAMQmQgaDAELIAFBADYCAAsLIAAQkQgLIAELhAMCBn8BfiMAQRBrIgQkAAJ/AkACQCAAKAIwIgIoABgiAQ0AIAIpAFxCAFINAEEwQYCABBCQCCIBRQ0CGiABQf8BQYCABBCaCCEBIAJBgCA2ABggACABNgI0IABBgCA2AqwCDAELIAIpADxQBH8gAQUgACAAEJMDNgI4IAIoABgLBEAgACgCMCEBQQAhAyAEQQA6AA8CQCABKAAYIgVFDQAgACgC0AIiBkECSw0AAkACQAJAIAZBAWsOAgECAAsgACAAKQMQIAE1ABAgATMAKEIghoR8IgcgB0L/////D4MgAS8ADBsgASgARCAFQQR0QfDuvJ18IARBD2oQsAMiAUUNAiAELQAPRQRAIAEhAwwDCyAAIAAoAswCQQxyNgLMAiABIQMMAgsgABD1ASEDDAELIAAQ+QEhAwsgACADNgI0CyAAKAI0IQEgAAJ/AkAgACgCOEUEQCABDQFB7AcMBAsgAQ0AQYCAIAwBCyACKAAYCzYCrAILQQALIQAgBEEQaiQAIAAL9hYCEH8CfiMAQRBrIgwkACAAIAAoAjAoABwiASAAKAKsAiICIAEgAksbIgJBBnQiAxCQCCIBNgI8An9BMCABRQ0AGkEAIQogAUEAIAMQmggaIAAgAjYCsAICQAJAAkACQAJ/IAAoAjgiCQRAIAAQlAMiCARAIAkoAiAgCCgCQEEIakYEQCAJKAIcBEBBACELA0AgDEEANgIEAkAgCSgCBCALai0AAEUNACAJKAIkIAtsIgFBB3EhBiABQQN2IgNBAWohBCAJKAIAIQUCQCAJKAIsIg1BA3YiB0UEQCAMQQRqIQIMAQtBCCAGayEKIAxBBGohAgNAIAMgBWotAAghASACIAYEfyAEIAVqLQAIIAp0IAEgBnZyBSABCzoAACAEQQFqIQQgA0EBaiEDIAJBAWohAiAHQX9qIgcNAAsLIA1BB3EiAQRAIAIgAyAFakEIaiIHLQAAIAZ2IgM6AAAgAUEIIAZrIgpLBEAgAiAEIAVqLQAIIAp0IActAAAgBnZyIgM6AAALIAIgA0F/IAF0QX9zcToAAAsgDCgCBCIBIAgoAkRPDQAgCSgCBCALajEAACERIAxCADcDCCAIKAI4IAFsIgFBB3EhBiABQQN2IgNBAWohBCAIKAIAIQUCQCAIKAJAIg1BA3YiB0UEQCAMQQhqIQIMAQtBCCAGayEKIAxBCGohAgNAIAMgBWotAAghASACIAYEfyAEIAVqLQAIIAp0IAEgBnZyBSABCzoAACAEQQFqIQQgA0EBaiEDIAJBAWohAiAHQX9qIgcNAAsLIA1BB3EiAQRAIAIgAyAFakEIaiIHLQAAIAZ2IgM6AAAgAUEIIAZrIgpLBEAgAiAEIAVqLQAIIAp0IActAAAgBnZyIgM6AAALIAIgA0F/IAF0QX9zcToAAAsgACgCPCAMKAIEQQZ0aiAMKQMIIBEgCDUCQIaENwMACyALQQFqIgsgCSgCHEkNAAsLIAgoAgQhAQJ/IAgoAkQEQCAAKAI8IQlBACENQQAhCwNAIAxBADYCCCAJQQhqIQMgCCgCECALaiICQQdxIQUgAkEDdiIEQQFqIQcgCCgCJCIOQQN2IgYEQEEIIAVrIQoDQCABIARqLQAIIQIgAyAFBH8gASAHai0ACCAKdCACIAV2cgUgAgs6AAAgB0EBaiEHIARBAWohBCADQQFqIQMgBkF/aiIGDQALCyAOQQdxIgIEQCADIAEgBGpBCGoiBi0AACAFdiIEOgAAIAJBCCAFayIKSwRAIAMgASAHai0ACCAKdCAGLQAAIAV2ciIEOgAACyADIARBfyACdEF/c3E6AAALIAlBGGohAyAIKAIUIAtqIgJBB3EhBSACQQN2IgRBAWohByAIKAIoIg5BA3YiBgRAQQggBWshCgNAIAEgBGotAAghAiADIAUEfyABIAdqLQAIIAp0IAIgBXZyBSACCzoAACAHQQFqIQcgBEEBaiEEIANBAWohAyAGQX9qIgYNAAsLIA5BB3EiAgRAIAMgASAEakEIaiIGLQAAIAV2IgQ6AAAgAkEIIAVrIgpLBEAgAyABIAdqLQAIIAp0IAYtAAAgBXZyIgQ6AAALIAMgBEF/IAJ0QX9zcToAAAsgCUEcaiEDIAgoAhggC2oiAkEHcSEFIAJBA3YiBEEBaiEHIAgoAiwiDkEDdiIGBEBBCCAFayEKA0AgASAEai0ACCECIAMgBQR/IAEgB2otAAggCnQgAiAFdnIFIAILOgAAIAdBAWohByAEQQFqIQQgA0EBaiEDIAZBf2oiBg0ACwsgDkEHcSICBEAgAyABIARqQQhqIgYtAAAgBXYiBDoAACACQQggBWsiCksEQCADIAEgB2otAAggCnQgBi0AACAFdnIiBDoAAAsgAyAEQX8gAnRBf3NxOgAACyAIKAJIBEAgCCgCHCALaiICQQdxIQUgAkEDdiIEQQFqIQcCQCAIKAIwIg5BA3YiBkUEQCAMQQhqIQMMAQtBCCAFayEKIAxBCGohAwNAIAEgBGotAAghAiADIAUEfyABIAdqLQAIIAp0IAIgBXZyBSACCzoAACAHQQFqIQcgBEEBaiEEIANBAWohAyAGQX9qIgYNAAsLIA5BB3EiAgRAIAMgASAEakEIaiIGLQAAIAV2IgQ6AAAgAkEIIAVrIgpLBEAgAyABIAdqLQAIIAp0IAYtAAAgBXZyIgQ6AAALIAMgBEF/IAJ0QX9zcToAAAsgCSAIKAIIIAwoAghBAnRqKAIANgIgCyAJQUBrIQkgCCgCDCALaiELIA1BAWoiDSAIKAJESQ0ACyAIKAIEIQELIAELBEAgARCRCAsgCCgCCCIBBEAgARCRCAsgCCgCACIBBEAgARCRCAsgCBCRCCAAKAI0RQ0HQQEhCiAAQTRqDAMLIAgoAgQiAQRAIAEQkQgLIAgoAggiAQRAIAEQkQgLIAgoAgAiAQRAIAEQkQgLIAgQkQgLIAAgACgCzAJBAXI2AswCCyAAKAI0RQ0BIABBNGoLIQggACgCMCILKAAcRQ0DIABBABCSAyIHRQ0CIAAoAjAhBSAAKALMAiIOIQECQCAOQQhxBH8gCCgCACIJIQICQCAFKAAYIgFBAUgNACAJIAFBBHRqIQYgBSEDIAkiAiEBA0ACQCABKAIMQf////8AcSIEIAMoABxPDQAgByAEQQR0aiIEKAIMQX9KDQAgBCgCCEEASA0AIAApAxAgBDUCAHwiESARQv////8PgyADLwAMGyAAKQMYWg0AIAEgAksEQCACIAEpAgA3AgAgAiABKQIINwIICyACQRBqIQILIAFBEGoiASAGTw0BIAAoAjAhAwwAAAsACyACQf8BIAIgCWtBBHUiARCgAyIDIAFrQQR0EJoIIAkgA0EEdGoiAUkEQANAIAJBfjYCDCACQRBqIgIgAUkNAAsLIAAgAyAFKAAYIgFJBH8gCSADQQR0IgEQkwghCSAAKAIwIgIgAzYAGCACIAGtNwBMIAUoABgFIAELNgKsAiAAIAk2AjQgACgCzAIFIAELQRhxRQRAQQAhDQwBCyAFKAAcQQJ0EJAIIg1FDQIgDUH/ASAFKAAcQQJ0EJoIGgsgBSgAGCICQQFOBEBBgIaMsHlBgIbMuHkgDkGAAnEbIRAgCCgCACIBIAJBBHRqIQQgACgCMCEDQQAhCQNAAkAgASgCDEH/////AHEiAiADKAAcTw0AIAcgAkEEdGoiBigCDCIFQX9KDQAgBigCCCIIQQBIDQAgBigCACIOrSISIAApAxB8IhEgEUL/////D4MgAy8ADBsgACkDGFoNAAJAIA1FBEAgCSEPIAIhCQwBCwJAIA0gAkECdGoiDygCACICQX9HBEAgCSEPIAIhCQwBCyAPIAk2AgAgCUEBaiEPCyABIAk2AgwLIAAoAjwgCUEGdGoiAiASNwMIIAggDnJFBEAgAiADNQAENwMICyACIAg2AhggBigCBCEGIAIgBSAQcTYCICACIAY2AhwgDyEJCyABQRBqIgEgBEkNAAsLIA0EQCAAKAKwAiAAKAKsAiIBSwRAIAAgACgCPCABQQZ0EJMINgI8IAAoAjAiAiAAKAKsAiIBNgAcIAIgAUEEdK03AEwgACABNgKwAgsgDRCRCAsgBxCRCCALKQAgUA0DIAsoABxBAXQiAUECahCQCCIDRQ0CIAwgCykAICAAKQMQfDcDCAJAIAAoAgAgDEEIaiADIAEQ3gFFBEAQxwEiBw0BCyALKAAcIgRFBEBBACEHDAELIAAoAjwhAUEAIQdBACECA0AgASABKQMIIAMgAkEBdGozAQBCIIaENwMIIAFBQGshASACQQFqIgIgBEcNAAsLIAMQkQggB0UNAwwCC0HsBwwDCyAHEJEICyAAIAAoAswCQQFyNgLMAkHsByAKRQ0BGgtBAAshASAMQRBqJAAgAQukAwEGfyAAKAI8IQIgACgCsAIiAUECdCIDEJAIIgQEQCACIAFBBnRqIQUgBEH/ASADEJoIIQQCQCABQQFIBEBBACEGDAELIAIhAUEAIQYDQAJAIAEoAiBBf0wEQCAEIAEgACgCPCIDa0EEdWogAiADa0EGdTYCACABIAJHBEAgAiABKQMANwMAIAIgASkDODcDOCACIAEpAzA3AzAgAiABKQMoNwMoIAIgASkDIDcDICACIAEpAxg3AxggAiABKQMQNwMQIAIgASkDCDcDCCAAKAI8IQMLIAJBQGsiAiADa0EGdSEGDAELIAEoAjgiAwRAIAMQkQgLIAFBADYCOAsgAUFAayIBIAVJDQALCwJAIAIgBU8NACACQQAgBSACaxCaCBogACgCNCIBRQ0AIAAoAjAoABgiAkEBSA0AIAEgAkEEdGohAyAAKAKwAiEFA0AgASgCDEH/////AHEiAiAFSQRAIAFBfiAEIAJBAnRqKAIAIgIgAkF/Rhs2AgwLIAFBEGoiASADSQ0ACwsgACgCMCAAKAK0AiAGajYAHCAEEJEIC0EAC+8EAhF/AX4jAEEQayIIJAAgACgCOCELQQAhDCAAAn8gAEGwAmogAC0AzAJBwABxRQ0AGiAAKAIwQRxqCygAACIBQQBBwABBABCFAyICNgI4AkAgAkUNACABQQFIDQAgACgCPCIJIAFBBnRqIQ4DQAJAIAkoAiBBf0oNACAJKQMAIRIgACgCOCEEIAggCSAAKAI8a0EGdTYCDCASIAQoAiBBeGqtiKchByAEKAIEIQIgEiAEKAIcIgWtgqciBiEBA0AgASACaiIDLQAARQRAIAMgBzoAACAEKAIkIAFsIgFBB3EhByABQQN2IQIgBCgCACENAn8gBCgCLCIKQQlPBEBB/wEgB3QhDyAKQXdqIgFBeHEhECAIQQxqIAFBA3ZqIRFBACEDIAhBDGohAUEAIQUDQCACIA1qQQhqIgYgAS0AACAHdCAFciIFIAYtAAAgAyAPciIDQX9zcUH/AHFyOgAAIAJBAWohAiADQQh1IQMgBUEIdSEFIAEgEUchBiABQQFqIgQhASAGDQALIAogEGtBeGohCiAFQf//A3EMAQsgCkUNA0EAIQMgCEEMaiEEQQALIQUgAiANaiIGQQhqIgIgAi0AACAKQQF0QeDMAWovAQAgB3QgA3IiAUF/c3EgBC0AACAHdCAFciICcjoAACABQYD+A3FFDQIgBkEJaiIDIAMtAAAgAUEIdkF/c3EgAkEIdnI6AAAMAgsgAUEBaiAFcCIBIAZHDQALQTMhDAwCCyAJQUBrIgkgDkkNAAsLIAsEQCALKAIEIgEEQCABEJEICyALKAIAIgEEQCABEJEICyALEJEICyAIQRBqJAAgDAvICgIPfwV+IwBB4AFrIgYkACAAKAIwIQNCACETIAZCADcD2AEgABCsAyEQQQAhCEEAIQRCACESQQAhCwJAAkACQAJAAkACQCAAKAI4IgIEQCACKAIsIQkgAigCKCELIAIoAiAhByACKAIYIQxBMCEBIAIoAhwiBSAFIAIoAiQiDWxBB2pBA3YiCmoiDkEsaiIPEJAIIgRFDQYgBCAKNgIoIAQgCTYCJCAEIAs2AiAgBCANNgIcIAQgBzYCGCAEIAU2AhQgBCAMNgIQIAQgDkEgaiIJNgIMIAQgCTYCCCAEQsiK0dIRNwIAIARBLGogAigCBCAFEJkIIAVqIAIoAgBBCGogChCZCBogACAGQdgBahCHAyILRQ0BIA+tIRILIAAoAjQiAQRAIAAoAjAoABhBBHQiAhCQCCIIRQRAQQAhCAwECyAIIAEgAhCZCBogAq0hEwtCACEUAn8CQAJAIAAoAjwiDEUEQEEAIQdCACERDAELIAAoAjAiDSgAHCIJQQR0EJAIIgdFDQVBACEFIAlFBEBCACERQQAMAwsgDCECQQAhCiAHIQEDQCABIAIpAwgiET4CACABIAIoAhg2AgggASACKAIcNgIEIAEgAigCIDYCDCABQRBqIQEgAkFAayECIAogEUIgiKdyIQogBUEBaiIFIAlHDQALIAmtQgSGIREgCg0BC0EAIQVBAAwBCwJ+QgAgDSgAHCIBQQF0EJAIIgVFDQAaIAEEQEEAIQIDQCAFIAJBAXRqIAwgAkEGdGo1Agw9AQAgAkEBaiICIAFHDQALCyABrUIBhgshFEEAQTAgBRsLIQECQCAERQ0AIAENACADIBA3ADwgAyASNwBcIAAgBCAQIBKnIANBsAFqQfDuvJ18IAZB1AFqEJoDIQEgECAGNQLUAXwhEAsCQCALRQ0AIAENACAGKQPYASESIAMgEDcANCADIBI3AGQgACALIBAgEqcgA0GgAWpBo+eO5H4gBkHUAWoQmgMhASAQIAY1AtQBfCEQCwJAIAhFDQAgAQ0AIAMgEzcARCADIBA+ABAgAyAQQiCIPQAoIAMgE0IEiD4AGCAIIBOnIgJB8O68nXwQowMgCCACIANBgAFqELkDIAYgACkDECAQfDcDAEEAIQEgACgCACAGIAggAhDfAUUEQBDHASEBCyAQIBN8IRALAkAgB0UNACABDQAgAyARNwBMIAMgED4AFCADIBBCIIg9ACogAyARQgSIPgAcIAcgEaciAkGj547kfhCjAyAHIAIgA0HwAGoQuQMgBiAAKQMQIBB8NwMAQQAhASAAKAIAIAYgByACEN8BRQRAEMcBIQELIBAgEXwhEAsCQCAFRQ0AIAENACAGIAApAxAgEHw3AwAgAyAQNwAgIAMgFDcAVEEAIQEgACgCACAGIAUgFKcQ3wFFBEAQxwEhAQsgECAUfCEQCyALQQBHIQkgCEEARyEKIAdBAEchDCAFQQBHIQIgAQ0BIAAoAgAgACkDECAQfBDhAUUEQBDHASIBDQILIAMgED4ACCADIBA3ACwgA0HAASADQcABahC5AyAGIAMgAygABBCZCCEBAkAgACgCACAAQRBqIAEgAygABBDfAUUEQBDHASIBDQELIAAgACgCzAJBfXE2AswCQQAhAQsgBEUNBAwDCyAEEJEIDAQLIAQNAQwCC0EAIQIgCEEARyEKIAtBAEchCUEwIQFBACEHQQAhDEEAIQUgBEUNAQsgBBCRCAsgCQRAIAsQkQgLIAoEQCAIEJEICyAMBEAgBxCRCAsgAkUNACAFEJEICyAGQeABaiQAIAELrgEBAX8jAEEQayIHJAAgB0EANgIEIAFBDGogA0F0aiAFEKMDIAQEQCABIAMgBBC5AwsgByAAKQMQIAJ8NwMIAkACQCAAKAIAIAdBCGogASADEN8BBEAgByADNgIEDAELEMcBIgQNAQsgACgCMCgAbCIERQRAQQAhBAwBCyAAKAIAIAcpAwggASADIAQgB0EEahC4AyEECyAGBEAgBiAHKAIENgIACyAHQRBqJAAgBAsqACABBEAgACACIAIQoAgiACABQX9qIAAgAUkbIgEQmQggAWpBADoAAAsLQwEBfwJAIAAQoAgiAyABTw0AIAEgA2siAUUNACAAIANqIAIgAhCgCCIAIAFBf2ogACABSRsiARCZCCABakEAOgAACwvbAgEEf0EAIQNBmJ4DLQAARQRAQYGAwAAhAANAIANBAnQiAkGgngNqIABB/QBsQQNqQavVqgFwIgBB/QBsQQNqQavVqgFwIgFB//8DcSAAQRB0cjYCACACQaCmA2ogAUH9AGxBA2pBq9WqAXAiAEH9AGxBA2pBq9WqAXAiAUH//wNxIABBEHRyNgIAIAJBoK4DaiABQf0AbEEDakGr1aoBcCIAQf0AbEEDakGr1aoBcCIBQf//A3EgAEEQdHI2AgAgAkGgtgNqIAFB/QBsQQNqQavVqgFwIgBB/QBsQQNqQavVqgFwIgFB//8DcSAAQRB0cjYCACACQaC+A2ogAUH9AGxBA2pBq9WqAXAiAkH9AGxBA2pBq9WqAXAiAEH//wNxIAJBEHRyNgIAIANBAWoiA0GAAkcNAAtBtAgQLxpBpA4QLxpBwJIDQfQlQcQBEJkIGkGYngNBAToAAAsLaAEDf0Ht/7X/ByEEIAAtAAAiAgRAQe7du/d+IQMDQCACQcDzAmotAAAiAiADIANBBXRqaiABIAJqQQJ0QaCeA2ooAgAgAyAEanMiBGpBA2ohAyAALQABIQIgAEEBaiEAIAINAAsLIAQLaAEDf0Ht/7X/ByEEIAAtAAAiAgRAQe7du/d+IQMDQCACQcDvAmotAAAiAiADIANBBXRqaiABIAJqQQJ0QaCeA2ooAgAgAyAEanMiBGpBA2ohAyAALQABIQIgAEEBaiEAIAINAAsLIAQLMgAgAEF/aiIAQQF2IAByIgBBAnYgAHIiAEEEdiAAciIAQQh2IAByIgBBEHYgAHJBAWoLnAECBH8CfiMAQaACayIBJAAgAUEBNgIMIAFBAjYCCCABQRBqIAAEfyABQZgCaiEDIAFBEGohAgNAIAAtAAAiBARAIAIgBEHA7wJqLQAAOgAAIABBAWohACACQQFqIgIgA0kNAQsLIAIgAUEQamsFQQALIAFBCGogAUEMahDGASABNQIMIQUgATUCCCEGIAFBoAJqJAAgBiAFQiCGhAsbAEGAhIAgQYCEgAggAEGAgAFLG0GAhAwgARsLggEBA38gAUECdiIFBEBB7t27934hA0EAIQEDQCAAIAFBAnRqIgQgBCgCACIEIAJB/wFxQQJ0QYAgckGgngNqKAIAIANqIgMgAmpzNgIAIAJBf3NBFXRBkaLEiAFqIAJBC3ZyIQIgAyAEaiADQQV0akEDaiEDIAFBAWoiASAFRw0ACwsLggEBA38gAUECdiIFBEBB7t27934hA0EAIQEDQCAAIAFBAnRqIgQgBCgCACACQf8BcUECdEGAIHJBoJ4DaigCACADaiIDIAJqcyIENgIAIAMgA0EFdGogBGpBA2ohAyACQX9zQRV0QZGixIgBaiACQQt2ciECIAFBAWoiASAFRw0ACwsL5AQBBn8CQAJAIAFBDEkNACACQXhqIQggACgCACIFQdKSmbIEc0GSosSIAWohBkEAIQMCQANAAkAgBiADQQJ0QaC+A2ooAgBrIgJB/wFxQQJ0QYAgckGgngNqKAIAIgRB7t27935qIgcgAmogBXNB0pKZsgRGBEAgACgCBCAEIAdBBXRqIAJBf3NBFXRBkaLEiAFqIAJBC3ZyIgRqIARB/wFxQQJ0QYAgckGgngNqKAIAakHD8NSpA2pzIAhGDQELIANBAWoiA0GAAkcNAQwCCwsgAg0CCyABQcEASQ0AIAVBzbTBBHNBkqLEiAFqIQZBACEDA0ACQCAGIANBAnRBoL4DaigCAGsiAkH/AXFBAnRBgCByQaCeA2ooAgAiBEHu3bv3fmoiByACaiAFc0HNtMEERgRAIAAoAgQgBCAHQQV0aiACQX9zQRV0QZGixIgBaiACQQt2ciIEaiAEQf8BcUECdEGAIHJBoJ4DaigCAGpBvpL9+35qc0EDRg0BCyADQQFqIgNBgAJHDQEMAgsLIAINAQsCQCABQQVJDQAgACgCACIFQbz+4OsGc0GSosSIAWohBkEAIQMDQAJAIAYgA0ECdEGgvgNqKAIAayICQf8BcUECdEGAIHJBoJ4DaigCACIEQe7du/d+aiIHIAJqIAVzQbz+4OsGRgRAIAAoAgQgBCAHQQV0aiACQX9zQRV0QZGixIgBaiACQQt2ciIEaiAEQf8BcUECdEGAIHJBoJ4DaigCAGpBrdyc4wVqc0HswNirBkYNAQsgA0EBaiIDQYACRw0BDAILCyACDQELQQAhAgsgAguyAQEDfyAAIQUDQAJAAkAgAC0AACIEQS9GDQAgBEHcAEYNACAEDQFB7f+1/wchBiAFLQAAIgQEQEHu3bv3fiEAA0AgBEHA8QJqLQAAIgQgACAAQQV0amogBEECdEGAGHJBoJ4DaigCACAAIAZqcyIGakEDaiEAIAUtAAEhBCAFQQFqIQUgBA0ACwsgBiABp2ogAnMgBiADQYCACHEbDwsgAEEBaiEFCyAAQQFqIQAMAAALAAsvAQJ/QQAhAQJAIABFDQAgACgCMCICRQ0AIABBACACKAAAQc2gxdIBRhshAQsgAQtMAQF/AkACQCAARQ0AIAAoAixBxZilsgRHDQAgACgCAA0BIAAoAgQiAUUNACABKAIwIgFFDQAgASgAAEHNoMXSAUYNAQtBACEACyAAC7cBAQh/IAAoAjAoABghAiABQQAgACgCQBEBACEDIAFBgAIgACgCQBEBACEFIAFBgAQgACgCQBEBACEGIAAoAjQhBCADIAJBf2pBACACGyIHcSIIIQEDQAJAAkAgBCABQQR0IgJqIgMoAgAgBUcNACACIARqIgkoAgQgBkcNACAJKAIMQf////8AcSAAKAKwAkkNAQtBACEDIAIgBGooAgxBf0YNACABQQFqIAdxIgEgCEcNAQsLIAMLowEBB38gACgCMCgAGCIDQX9qQQAgAxshBSACIAAoAjQiBGtBBHUhAyABIARrQQR1IQYgAigCBCEHIAIoAgAhCAJAA0AgBiADQQFqIAVxIgNHBEACQCAEIANBBHQiAmoiASgCACAIRw0AIAIgBGoiCSgCBCAHRw0AIAkoAgxB/////wBxIAAoArACSQ0DCyACIARqKAIMQX9HDQELC0EAIQELIAELhAIBCX9BACEEIAEoAjhBACAAKAJAEQEAIQMgASgCOEGAAiAAKAJAEQEAIQcgASgCOEGABCAAKAJAEQEAIQggACgCNCEJIAMgACgCMCgAGCIFQX9qQQAgBRsiCnEiCyEFAkACQANAAkAgCSAFQQR0IgZqIgMoAgAgB0cNACAGIAlqIgYoAgQgCEcNACAGLwEIIAJGDQMLIAQgAyAEIAMoAgwiBkF+RhsgBBshBCAGQX9GDQEgBUEBaiAKcSIFIAtHDQALQQAhAwsgBCADIAQbIgMNAEEADwsgA0EAOgAKIAMgAjsBCCADIAg2AgQgAyAHNgIAIAMgASAAKAI8a0EGdTYCDCADC9MBAgV/An4gACgCMCIFNQAEIQYgACgCsAIiA0EBTgRAIAAoAjwiASADQQZ0aiEDA0ACQCABKAIgQX9KDQAgASgCHCIERQ0AAkAgAC0AzAJBwABxDQAgASgCOCICRQ0AIAItAABBKEcNACACQZbNARDnBkUNASACQaHNARDnBkUNASACQa7NARDnBkUNAQsgASkDCCAErXwiByAGWA0AIAUoAGwiAkUEQCAHIQYMAQsgByAEQX9qIAJuQQR0QRBqrXwhBgsgAUFAayIBIANJDQALCyAGC0cBAX8CQAJAIABFDQAgAC0AAEEoRw0AQQEhASAAQZbNARDnBkUNASAAQaHNARDnBkUNASAAQa7NARDnBkUNAQtBACEBCyABC3MBAX8CQEHQARCQCCICRQ0AIAJBCGpBAEHIARCaCBogAiAANgIEIAJBADYCACACQcWYpbIENgIsIABFDQAgAUUNACACIAAgASkDCBCAAzcDECACIAEpAwg3AxggASgCGCEAIAIgATYCDCACIAA2AlQLIAILkwECAX8BfiAAEKwDIQMCQCAAKAIwIgIvAAwNACAAKAKwAkEEdK0gAigAGEEEdK0gAyABrXx8fEKAgICAEFQNAEEzEMgBQQAPC0HQARCQCCIBBEAgAUEIakEAQcgBEJoIGiABQQE6AM4BIAEgAzcDGCABIAA2AgQgAUEANgIAIAFBxZilsgQ2AiwgAQ8LQTAQyAFBAAuxAwIHfwF+IwBBIGsiBiQAIAYgATcDGCAGQgA3AxACQCADEJAIIghFBEBBACEIDAELQQAhCSAIIQoCQCACIANPIgsNACACEJAIIgkhCiAJDQAgCBCRCEEAIQgMAQsgAUL/////D1EEQCAAKAIAIAZBGGoQ4gEaCyACIQcCQCAAKAIwLwAMDQAgACgCACAGQRBqEOABGiACIQcgBikDGCIBIAKtfCAGKQMQIg1YDQAgCCANIAF9pyIHakEAIAMgB2sQmggaIAVFDQAgBUEBOgAACwJAAn8gACgCACAGQRhqIAogBxDeAQRAAkAgBEUNACACQQJ2IgxFDQBB7t27934hB0EAIQADQCAKIABBAnRqIgUgBSgCACAEQf8BcUECdEGAIHJBoJ4DaigCACAHaiIHIARqcyIFNgIAIAcgB0EFdGogBWpBA2ohByAEQX9zQRV0QZGixIgBaiAEQQt2ciEEIABBAWoiACAMRw0ACwsgCw0CIAYgAzYCDEEAIAggBkEMaiAJIAIQ9gINARoLEMcBC0UNACAIEJEIQQAhCAsgCUUNACAJEJEICyAGQSBqJAAgCAtgAQN/QQAhAQJAIAAoAgwiAygCGEUNACAAKAJUIgJFDQAgAy0AI0EBcUUEQCAAKAIEKAK4AiECCyAAIAI2AmAgAhCQCCEBIABBfzYCXCAAIAE2AlhBAEEwIAEbIQELIAELzwEBBX8gAEEQaiEFIAAoAgQhBkEcIQMCQAJAAkADQCAAQRwQkAgiAjYCNCACRQRAQTAPCyABRQ0CIAYoAgAgBSACIAMQ3gEhBCAAKAI0IQIgBEUEQCACEJEIIABBADYCNBDHAQ8LIAIoAgAiBCADTQ0BIAIQkQggAEEANgI0IAQiA0GACE0NAAtB7AcPCyAAIAIoAgg2AlQMAQsgAkIANwIAIAJBADYCGCACQgA3AhAgAkIANwIIQRwhAwsgAkGAgICAeDYCBCACIAM2AgBBAAuGBwIQfwJ+IwBBEGsiCiQAAkAgACgCDCIDKAIgIgJBgICACHEEQCAAQQE2AkxBACEGDAELIAAoAgQhCyAAIAAoAlRBf2ogACgCYG4iBEEBajYCTCACQYD+A3FFBEBBACEGDAELIAAgBEECdEEMQQggAkGAgIAgcRtqIgwQkAgiDTYCOEEwIQYgDUUNACADQSJqIQ4gDSECIAwhBwNAIAEEQCAKIAApAxAiEjcDCAJAAkAgACgCNCIDBEAgEiADNQIAfCITIBJUDQEgCiATNwMICyALKAIAIApBCGogAiAHEN4BRQRAIAAoAjgQkQggAEEANgI4EMcBIQYMBQsCQCAOLQAAQQFxRQ0AIAAoAjghCAJAIAAoAiQiAw0AAkACQCALKAK4AiICQQhPBEAgAiAHaiEPIAdB8d27935qIRAgCCgCACIJIAdzQZKixIgBaiERQQAhAwNAIAcgESADQQJ0QaC+A2ooAgBrIgJB/wFxQQJ0QYAgckGgngNqKAIAIgRB7t27935qIgUgAmogCXNGBEAgCCgCBCAEIBBqIAVBBXRqIAJBf3NBFXRBkaLEiAFqIAJBC3ZyIgRqIARB/wFxQQJ0QYAgckGgngNqKAIAanMgD00NAwsgA0EBaiIDQYACRw0ACwsgAEEANgIkDAELIAAgAkEBaiIDNgIkIAMgAk8NAQsgCBCRCCAAQQA2AjhBkc4AIQYMBgsgB0ECdiIJRQ0AIANBf2ohAkHu3bv3fiEEQQAhAwNAIAggA0ECdGoiBSAFKAIAIAJB/wFxQQJ0QYAgckGgngNqKAIAIARqIgQgAmpzIgU2AgAgBCAEQQV0aiAFakEDaiEEIAJBf3NBFXRBkaLEiAFqIAJBC3ZyIQIgA0EBaiIDIAlHDQALCyAAKAI4IQMgACgCTCEJQQAhBEEAIQICQAJAA0AgAiAJRwRAIAJBAnQhBSADIAJBAWoiAkECdGooAgAiCCADIAVqKAIAIgVNDQIgBCAIIAVrIAsoArgCSyIFciEEIAVFDQEMAgsLIARBAXFFDQELIAMQkQggAEEANgI4QewHIQYMBQsgAygCACIEIAdNBEBBACEGDAULIAQgB0GACGpNDQELQewHIQYMAwsgAxCRCCAAIARBfHEQkAgiAjYCOCAEIQcgAg0BDAILC0EAIQYgDUEAIAwQmggaIAIgDDYCAAsgCkEQaiQAIAYLxwEBBH9BACECAkAgACgCDC0AI0EBcQ0AAkAgACgCOCIDKAIAIgJFDQAgAiAAKAJMIgRBAnQiBUEIakcNACABRQRAIAAgBRCQCCICNgI8IAJFBEBBMA8LIAJBACAFEJoIGkEADwtBACECQQAgAyAEQQJ0aiIBKAIEIgMgASgCACIEayIBIAEgA0sbIgFBBEkNASABIAAoAmBLDQEgACAAKAIEIAAgBBCBAyABIAVBAEEAELADIgI2AjwgAg0AQTAPC0EAIQILIAILKAEBf0EAIQEgACgCBCgCACAAQRBqIAAoAjRBHBDfAQR/IAEFEMcBCwutAgIKfwF+IwBBEGsiAiQAIAAoAgQhCSAAKAIMIQEgAiAAKQMQIgs3AwggACgCOCIEKAIAIQMCQCABLQAiQQFxRQ0AIANBAnYiB0UNACAEIAAoAiRBf2oiAUH/AXFBAnRBgCByQaCeA2ooAgBB7t27935qIgUgAWogA3M2AgBBASEGIAdBAUYNACADIQgDQCAEIAZBAnRqIgogAUF/c0EVdEGRosSIAWogAUELdnIiAUH/AXFBAnRBgCByQaCeA2ooAgAgBSAIaiAFQQV0ampBA2oiBSABaiAKKAIAIghzNgIAIAZBAWoiBiAHRw0ACwsgACgCNCIBBEAgAiALIAE1AgB8NwMIC0EAIQEgCSgCACACQQhqIAQgAxDfAUUEQBDHASEBCyACQRBqJAAgAQuPAgIHfwF+IwBBEGsiASQAAkAgACgCBCIGKAIwKABsBEAgACgCOCAAKAJMQQJ0aiIAIAAoAgA2AgRBACEDDAELIAAoAgwhBSAAKAJMQQJ0IgIQkAgiBEUEQEEwIQMMAQsgASACNgIEQQAhAyAEIAFBBGogACgCPCACQQJBAEEAEO4CGiABIAApAxAgACgCOCAAKAJMQQJ0ajUCAHwiCDcDCCABKAIEIQIgACgCNCIHBEAgASAIIAc1AgB8NwMICyAGKAIAIAFBCGogBCACEN8BRQRAEMcBIQMLIAAoAjggACgCTEECdGoiACAAKAIAIAJqNgIEIAUgBSgCHCACajYCHCAEEJEICyABQRBqJAAgAwvQAQEFfyMAQfAAayIGJAAgBiABNwMIAkAgA0F/aiAEbkEEdEEQaiIKEJAIIghFBEBBMCEEDAELIAYgAwR+IAMhByAIIQkDQCAGQRBqECoaIAZBEGogAiAHIAQgByAESRsiBBArGiACIARqIQIgBkEQaiAJEC0aIAlBEGohCSAHIARrIgcNAAsgBikDCAUgAQsgA618NwMIQQAhBCAAIAZBCGogCCAKEN8BRQRAEMcBIQQLIAUEQCAFIAMgCmo2AgALIAgQkQgLIAZB8ABqJAAgBAsrAQF/IwBB4ABrIgMkACADECoaIAMgACABECsaIAMgAhAtGiADQeAAaiQAC9cBAQZ/IwBB8ABrIgQkACAEIAE3AwhBMCEFIAJBf2ogA25BBHRBEGoiCRCQCCIGBEAgAxCQCCIHBEACQAJAIAJFDQAgBiEIA0AgACAEQQhqIAcgAiADIAIgA0kbIgUQ3gEEQCAEQRBqECoaIARBEGogByAFECsaIARBEGogCBAtGiAEIAQpAwggBa18NwMIIAhBEGohCCACIAVrIgINAQwCCwsQxwEiBQ0BC0EAIQUgAEEAIAYgCRDfAQ0AEMcBIQULIAcQkQgLIAYQkQgLIARB8ABqJAAgBQvGAQECfyAAKAIAIgEEQAJ/An8CfwJ/An8CfyABKAIwBEAgAUEwahC7AyAAKAIAIQELIAEoAkAiAgsEQCACEJEIIAAoAgAhAQsgASgCNCICCwRAIAIQkQggACgCACEBCyABKAI4IgILBEAgAhCRCCAAKAIAIQELIAEoAjwiAgsEQCACEJEIIAAoAgAhAQsgASgCWCICCwRAIAIQkQggACgCACEBCyABKAIAIgILBH8gAhDNASAAKAIABSABCxCRCCAAQQA2AgALC5kCAQR/IAAoAgAiAQRAAn8gASgCIARAIAFBIGoQvAMgACgCACEBCyABKAIoIgILBH8gAhCRCCAAKAIABSABCygCABDNAUEAIQIgACgCAEEANgIAAn8CfyAAKAIAIgEoAjwiAwRAAkAgASgCsAJFBEAgAUE8aiEDDAELA0AgAyACQQZ0IgRqKAI4IgMEQCADEJEIIAAoAgAhAQsgASgCPCAEakEANgI4IAAoAgAiAUE8aiEDIAJBAWoiAiABKAKwAk8NASADKAIAIQMMAAALAAsgAygCABCRCCAAKAIAIQELIAEoAjQiAgsEQCACEJEIIAAoAgAhAQsgASgCOCICCwR/IAIQhgMgACgCAAUgAQsQkQggAEEANgIACwuCAgEJf0EAIQICQCAARQ0AIABBus0BQQQQ7QYNACAALQAEIgNBUGpB/wFxQQlLDQAgAC0ABSIEQVBqQf8BcUEJSw0AIAAtAAYiBUFQakH/AXFBCUsNACAALQAHIgZBUGpB/wFxQQlLDQAgAC0ACCIHQVBqQf8BcUEJSw0AIAAtAAkiCEFQakH/AXFBCUsNACAALQAKIglBUGpB/wFxQQlLDQAgAC0ACyIKQVBqQf8BcUEJSw0AIAAtAAxBLkcNAEEBIQIgAUUNACABIANBCmwgBGpBCmwgBWpBCmwgBmpBCmwgB2pBCmwgCGpBCmwgCWpBCmwgCmpBsPXXgX5qNgIACyACC2IBAX8jAEHwAGsiAyQAAn9BASACKAIMIAIoAgggAigCBCACKAIAcnJyRQ0AGiADQRBqECoaIANBEGogACABECsaIANBEGogAxAtGiADIAJBEBDkBkULIQIgA0HwAGokACACC60IAQZ/IwBBQGoiBiQAIAZBADYCDCADBEAgA0EANgIACwJAIAAQqANFBEBBCBDIAUEAIQAMAQsgAUUEQEEcEMgBQQAhAAwBCwJAIAAoAgwiBUUNACAFLQAiQRBxRQ0AIAAoAjQNACAAQQEQsgMiBUUEQCAAKAI0DQELIAUQyAFBACEADAELQQAhBSAAQQA2AkgCQCAAKAIAIgcEQCAGIAA1Aig3AxggAEEoaiEKAkAgByAGQRhqIAEgAiIEEN4BDQBBACEEEMcBIgVB6gdHDQAgACgCACAGQRBqEOIBGiAGKQMQIAYpAxh9pyEEQeoHIQULIAYgBDYCDAwBCwJAIAAoAjBFDQAgACgCDC0AIkEQcQ0AIAAoAighB0EAIQQgBkEANgIQIABBKGohCiAGAn8gACgCQEUEQCAGQRhqIAAQggQiBQ0DIAYgACgCDCIFKAIYIgk2AjQgBigCKCEIAn8gBS0AI0EBcQRAIAAgCEEAIAkgBkEQahDAAwwBCyAAIAhBACAJIAZBEGoQwQMLIgUEQCAGQRhqEIQEIAZBADYCECAGQQA2AgwMBAsgBkEYaiAAEIMEIQUgBkEYahCEBCAGQQA2AhBBACAFDQEaCyAAKAJEIgUgB0sEQCABIAAoAkAgB2ogBSAHayACIAIgB2ogBUsbIgQQmQgaIAYgBDYCEAtBAEHqByACIARGGyEFIAQLNgIMDAELAkACQAJAIAAoAgQiBygC0AJBAkYEQCAAKAIoIQkgBiAAKQMQQgx8NwMYIABBKGohCiAAKAIMIQQgACgCWCIFRQRAIAAQsQMiBQ0FIAAoAlgiBUUNBAsgACgCXEUNAiAELQAhRQRAQQAhCAwCCyAEKAIcEJAIIgghBSAIDQFBMCEFDAQLIABBKGohCiAAKAIoIQUgACgCDC0AI0EBcQRAIAAgASAFIAIgBkEMahDAAyEFDAQLIAAgASAFIAIgBkEMahDBAyEFDAMLIAcoAgAgBkEYaiAFIAQoAhwQ3gFFBEAgCBCRCBDHASEFDAMLAkAgBCgCICIHQYCABHEEfyAFIAQoAhwQ+AEgBCgCIAUgBwtBgP4DcQRAIAYgACgCVDYCECAAIAUtAAA2AkhBAEHsByAAKAJYIAZBEGogBSAEKAIcEPsCGyEEDAELQQAhBCAFIAAoAlgiB0YNACAHIAUgACgCVBCZCBoLIAgEQCAIEJEICyAAQQA2AlxB6wchBSAEDQILIAAoAlQiBSAJTQRAQQAhBSAGQQA2AgwMAgsgASAAKAJYIAlqIAUgCWsiACACIAAgAkkbIgAQmQgaIAYgADYCDAtBACEFCyAKIAYoAgwiASAKKAIAajYCACADBEAgAyABNgIAC0EAIQAgBUHqB0EAIAEgAkkbIAUbIgNFBEBBASEADAELIAMQyAELIAZBQGskACAAC40EAgZ/AX4jAEEQayIHJAAgByAAKQMQIgs3AwggACgCDCEFIAAoAgQhCgJAAkAgACgCWCIGRQRAIAAQsQMiBg0CIAAoAlgiBkUNAQsgACgCNCIJBEAgByALIAk1AgB8NwMICyAAKAJcBEACQCAFLQAhRQRAQQAhCQwBCyAFKAIcEJAIIgkhBiAJDQBBMCEGDAMLIAooAgAgB0EIaiAGIAUoAhwQ3gFFBEAgCRCRCBDHASEGDAMLAkACfyAFKAIgIghBgIAEcQRAIAYgBSgCHCAAKAIkEKQDIAUoAiAhCAsgCEGA/gNxCwRAIAcgACgCVDYCBCAFKAIcIgVBZGogBSAIQYCAwABxGyEFAkACfyAIQYAEcQRAIAAgBi0AADYCSCAAKAJYIQggCigCMC8ADARAIAggB0EEaiAGIAUQ9gIMAgsgCCAHQQRqIAYgBRD1AgwBCyAIQYACcUUNASAAKAJYIAdBBGogBiAFEOwCCyEGQQAhBSAGDQILQewHIQUMAQtBACEFIAAoAlgiCkUNACAGIApGDQAgCiAGIAAoAlQQmQgaCyAJBEAgCRCRCAsgAEEANgJcQesHIQYgBQ0CCyAAKAJUIgUgAk0EQEEAIQYgBEEANgIADAILIAEgACgCWCACaiAFIAJrIgAgAyAAIANJGyIAEJkIGiAEIAA2AgALQQAhBgsgB0EQaiQAIAYLwAMBB38jAEEQayIIJAACQCAAKAJUIgUgAk0EQEEAIQYgBEEANgIADAELIAAoAgQiCigCuAIhCQJAIAAoAlgiBkUEQCAAELEDIgYNAiAAKAJYIgZFDQELIAUgAmsiBSADIAUgA0kbIQNBACEHQQAgCWsiCyACcSEFIAlBf2ogAnEiCQRAIAggCigCuAIiAjYCCAJAIAUgACgCXEcEQCAAIAYgBSACIAhBCGoQwgMiBg0EIAAgBTYCXCAAKAJYIQYgCCgCCCECDAELIAIgBWogACgCVCIHTQ0AIAggByAFayICNgIICyADIAMgAiAJayIHIAcgA0sbIgdrIQMgAiAFaiEFIAEgBiAJaiAHEJkIIAdqIQELIAMgCigCuAJPBEAgACABIAUgAyALcSAIQQxqEMIDIgYNAiADIAgoAgwiAmshAyACIAVqIQUgAiAHaiEHIAEgAmohAQsgBCADBH8gCigCuAIhAiAFIAAoAlxHBEAgACAAKAJYIAUgAiAIQQxqEMIDIgYNAyAAIAU2AlwLIAEgACgCWCADIAIgAiADSxsiABCZCBogACAHagUgBws2AgALQQAhBgsgCEEQaiQAIAYLygUBDH8jAEEQayIIJAAgACgCVCIFIAJrIAMgAiADaiAFSxshCyACIAAoAgQiDCgCuAIiCm4hDSADIApuIQYCQAJAIAAoAgwiDi0AIUUEQEEAIQ8gASEFIAshBwwBCwJAIAAoAjgiAg0AIABBARCzAyICDQIgACgCOCICDQBBACECDAILAkAgACgCPA0AIA4tACNBBHFFDQAgAC0AzAENACAAQQEQtAMaIABBAToAzAEgACgCOCECCyACIAYgDWpBAnRqKAIAIAIgDUECdGooAgAiAmsiBxCQCCIFIQ8gBQ0AQTAhAgwBCyAIIAAgAhCBAzcDCAJ/IAwoAgAgCEEIaiAFIAcQ3gEEQEEAIQdBACAKIANLDQEaIAZBASAGQQFLGyEQQQAhCkEAIQcDQCAKIA1qIQYgCyAMKAK4AiICIAIgC0sbIgIhAyAOKAIgIglBgP4DcQRAIAAoAjggBkECdGoiAygCBCADKAIAayEDCyAJQYCABHEEQAJAIAAoAiQiCQ0AIAAgBSACIAAoAlQQpQMiCTYCJCAJDQBBkc4ADAQLIAUgAyAGIAlqEKQDCwJAIAAtAM0BRQ0AIAAoAjwiCUUNACAJIAZBAnRqKAIAIgZBAWpBAkkNAEEAIAUgAxCHAiAGRg0AQZLOAAwDCwJAIAMgAkkEQCAIIAI2AgQCfyAOKAIgIgZBgARxBEAgACAFLQAANgJIIAwoAjAvAAwEQCABIAhBBGogBSADEPYCDAILIAEgCEEEaiAFIAMQ9QIMAQtB7AcgBkGAAnFFDQUaIAEgCEEEaiAFIAMQ7AILDQFB7AcMBAsgASAFRg0AIAEgBSACEJkIGgsgAyAFaiEFIAEgAmohASACIAdqIQcgCyACayELIApBAWoiCiAQRw0AC0EADAELQQAhBxDHAQshAiAPBEAgDxCRCAsgBCAHNgIACyAIQRBqJAAgAguXAQICfwF+IwBBEGsiAiQAAn8gABCoAwRAIAJCADcDCAJAIAAoAjAEQANAIAAiAygCMCIADQALIAIgAygCDDUCGDcDCAwBCyAAKAIAIgMEQCADIAJBCGoQ4AEaDAELIAIgADUCVDcDCAsgAikDCCEEIAEEQCABIARCIIg+AgALIASnDAELQQgQyAFBfwshACACQRBqJAAgAAvEAwIDfwN+IwBBIGsiBCQAAkAgABCoA0UEQEEIEMgBQX8hBQwBCwJAIAAoAgAiBQRAIAUgBEEIahDgARoMAQsCQCAAEKgDBEAgBEIANwMYIAAoAjAEQCAAIQUDQCAFIgYoAjAiBQ0ACyAEIAYoAgw1AhgiBzcDGAwCCyAAKAIAIgUEQCAFIARBGGoQ4AEaIAQ1AhghBwwCCyAEIAA1AlQiBzcDGAwBC0EIEMgBQv////8PIQcLIAQgBzcDCAsCfiACBEAgAawgAjUCAEIghoQMAQsgAawLIQcCQCAEAn4CQCADQQJNBEACQAJAIANBAWsOAgABAwsgACgCACIFBEAgBSAEQRhqEOIBGiAEKQMYIQgMBQsgADUCKAwDCyAEKQMIDAILQRwQyAFBfyEFDAMLQgALIgg3AxgLIAQgByAIfCIJNwMQIAQpAwghCAJAIAdCf1cEQEF/IQUgCSAIWA0BDAILIAkgCFgNACAEIAg3AxAgCCEJCwJAIAAoAgAiBgRAQX8hBSAGIARBEGpBAEEAEN4BDQEMAgsgACAJPgIoCyAEKQMQIQcgAgRAIAIgB0IgiD4CAAsgB6chBQsgBEEgaiQAIAULTwECfyAARQRAQb/NAUHMzQFBGhApC0EAIQECQANAIAFB6ABsQcD4AmooAgAiAgRAIAIgABDqBkUNAgsgAUEBaiIBQSBHDQALQX8hAQsgAQvfAgEIfyAARQRAQcbOAUHRzgFBPBApCyACRQRAQcnPAUHRzgFBPRApCyADRQRAQdXPAUHRzgFBPhApC0EAIQpBACEEAn8gAQRAQQMhBkEAIQRBACELQQAhBwNAAkAgACALai0AACIFQfDPAWotAAAiCEH/AUYNAAJAIAVBPUYEQCAGQQFOBEAgBkF/aiEFQQAhCAwCC0EHDwtBAyEFIAZBA0YNAEEHDwsgB0EGdCAIciEIAn8gCCAKQQFqIgpBBEcNABogBCAFaiADKAIASwRAQQYPCyACIARqIAdBCnY6AAAgBEEBaiEJQQAhCiAFQQJIBEAgCSEEQQAMAQtBAiEGIAIgCWogB0ECdjoAACAEQQJqIQkgBUECRgRAQQAhByAJIQQMAgsgAiAJaiAIOgAAIARBA2ohBEEACyEHIAUhBgsgC0EBaiILIAFHDQALQQcgCg0BGgsgAyAENgIAQQALC2wBAX8gAEUEQEHw0QFB+9EBQR8QKQsgAkUEQEH70gFB+9EBQSAQKQtBECEDAkAgAUEDRw0AIAAtAABBAUcNACAALQABQQFHDQAgAC0AAiIAQf8BRiIBRUEAIAAbDQAgAiABNgIAQQAhAwsgAwsdACAARQRAQYfTAUGW0wFBGhApCyAAQQM2AgBBAAv/AgEGfyMAQRBrIgQkACACRQRAQZbUAUGi1AFBIRApCyAARQRAQaLVAUGi1AFBIhApC0EHIQUCQCABQQNJDQAgAC0AAEEfcUECRw0AAkAgAC0AASIDQYABcUUEQEECIQYgA0ECaiABSw0CIAIgAEECaiADQZCTAygCABEAACIFRQ0BDAILIANB/wBxIghBf2pBA0sNAUECIQMgCEECaiIGIAFLDQFBACEHA0AgACADai0AACAHQQh0ciEHIANBAWohAyAIQX9qIggNAAsgBiAHaiABSw0BIAIgACAGaiAHQZCTAygCABEAACIFDQELQQAhBSAAIAZqLAAAQX9KDQACQCAEQQxqQciSAygCABECAEUEQEH8kgMoAgAhAyAEKAIMIAJB9JIDKAIAEQIAIAMRAQBFBEBBACEFIAIgBCgCDCACQZyTAygCABEAAEUNAgsgBCgCDEHQkgMoAgARBgALQQ0hBQwBCyAEKAIMQdCSAygCABEGAAsgBEEQaiQAIAULkwEBA38gAkUEQEGt1QFBudUBQSAQKQsgAEUEQEG/1gFBudUBQSEQKQtBByEFAkAgAUECSQ0AIAAtAABBH3FBAkcNAEECIQMgAC0AASIEQQJqIAFLDQBBACEFQQAhASAEBEBBACEBA0AgACADai0AACABQQh0ciEBIANBAWohAyAEQX9qIgQNAAsLIAIgATYCAAsgBQtVAQJ/IAFFBEBBytYBQdnWAUEeECkLQQEhAiAABEBBACECIAAhAwNAIAJBAWohAiADQQh2IgMNAAsLIAEgAiAAIAJBA3RBf2p2QQFxakECajYCAEEAC8kCAQV/IABFBEBB39cBQerXAUEiECkLIAJFBEBB7dgBQerXAUEjECkLIANFBEBB+dgBQerXAUEkECkLQRAhBgJAIAFBBEkNAEEHIQYgAC0AAEEfcUEDRw0AIAAtAAEiBUH/AHEhB0ECIQQCQCAFQYABcUUEQCAHIQUMAQsgB0F/akEBSw0BQQAhBUECIQQgByEIA0AgACAEai0AACAFQQh0ciEFIARBAWohBCAIQX9qIggNAAsgB0ECaiEECyAFRQ0AIAQgBWogAUsNACAFQQN0IAAgBGotAABBB3FrQXhqIgYgAygCAEsEQCADIAY2AgBBBg8LIAYEQCAEQQFqIQVBACEEA0AgAiAEaiAAIAVqLQAAIARBB3EiCEEHc3ZBAXE6AAAgBSAIQQdGaiEFIARBAWoiBCAGRw0ACwsgAyAGNgIAQQAhBgsgBgteAQF/IAFFBEBBiNkBQZfZAUEcECkLQQMhAgJ/AkAgAEEDdiAAQQdxQQBHaiIAQf8ASQ0AQQQhAiAAQf8BSQ0AQQUhAkEQIABB/v8DSw0BGgsgASAAIAJqNgIAQQALC5sCAQV/IABFBEBBmtoBQaXaAUEiECkLIAJFBEBBqtsBQaXaAUEjECkLIANFBEBBttsBQaXaAUEkECkLQQchCAJAIAFBAkkNACAALQAAQR9xQQRHDQAgAC0AASIEQf8AcSEHQQIhBQJAIARBgAFxRQRAIAchBAwBCyAHIAFPDQEgB0F/akECSw0BQQIhBUEAIQQgByEGA0AgACAFai0AACAEQQh0ciEEIAVBAWohBSAGQX9qIgYNAAsgB0ECaiEFCyAEIAMoAgBLBEAgAyAENgIAQQYPCyAEIAVqIAFLDQAgBARAQQAhBgNAIAIgBmogACAFai0AADoAACAFQQFqIQUgBkEBaiIGIARHDQALCyADIAQ2AgBBACEICyAIC14BAX8gAUUEQEHF2wFB1NsBQRsQKQtBAiECAn8CQCAAQYABSQ0AQQMhAiAAQYACSQ0AQQQhAiAAQYCABEkNAEEFIQJBECAAQf///wdLDQEaCyABIAAgAmo2AgBBAAsLigMBBH8gAEUEQEHZ3AFB5NwBQSAQKQsgAkUEQEHu3QFB5NwBQSEQKQsgA0UEQEH83QFB5NwBQSIQKQsgAUEDSQRAQQcPCwJ/QQYgAygCAEECSQ0AGiAALQAAQR9xQQZHBEBBBw8LIAAsAAEiBEH/AXEhBkECIQUgBEF/TARAIARBgH9GBEBBBw8LIARB/wFxQYIBSwRAQQcPCyAGQf8AcSIHRQRAQQcPC0ECIQVBACEGIAchBANAIAAgBWotAAAgBkEIdHIhBiAFQQFqIQUgBEF/aiIEDQALIAdBAmohBQsgBkUEQEEHDwtBByAFIAZqIAFLDQAaQQAhAUEAIQQDQCAAIAVqLQAAIgdB/wBxIAFBB3RyIQECQCAHQYABcQ0AIAQgAygCAE8EQEEGDwsgBEUEQCACIAFBKG4iBDYCACACIAEgBEEobGs2AgRBACEBQQIhBAwBCyACIARBAnRqIAE2AgAgBEEBaiEEQQAhAQsgBUEBaiEFIAZBf2oiBg0ACyADIAQ2AgBBAAsLDQBBICAAZ2tBACAAGwuJAgEHfyAARQRAQYveAUGZ3gFBLBApCyACRQRAQaPfAUGZ3gFBLRApC0EQIQcCQCABQQJJDQAgACgCACIDQQNLDQAgA0EBTQRAIAAoAgRBJ0sNAQsgAUF/aiEIIAAoAgQgA0EobGohA0EAIQRBASEGA0AgBCADRWpBICADZ2tBACADGyIFQf8BcUEHbiIEaiEJIAUgBEEHbGtB/wFxQQBHIQQgBkEBaiEFIAYgCEkEQCAAIAVBAnRqKAIAIQMLIAQgCWohBCAFIQYgASAFRw0AC0ECIQMCQCAEQYABSQ0AQQMhAyAEQYACSQ0AQQQhAyAEQf//A0sNAQsgAiADIARqNgIAQQAhBwsgBws7AQF/QQAhAQNAIAAgAUEDdEHA3wFqKAIARgRAIAFBA3RBxN8BaigCAA8LIAFBAWoiAUHmAEcNAAtBfws7AQF/QQAhAQNAIAAgAUEDdEHE3wFqKAIARgRAIAFBA3RBwN8BaigCAA8LIAFBAWoiAUHmAEcNAAtBfwvZAQEDfyACRQRAQfDlAUH/5QFBoAEQKQsgAEUEQEGC5wFB/+UBQaEBECkLAn8CQAJAIAEEQEEAIQMDQCAAIANqLQAAIQVBACEEAkADQCAEQQN0QcDfAWooAgAgBUYNASAEQQFqIgRB5gBHDQALQRAPCyADQQFqIgMgAUcNAAsgAUH/AEsNAQsgAiABQQJqNgIADAELIAFB/wFNBEAgAiABQQNqNgIADAELIAFB//8DTQRAIAIgAUEEajYCAAwBC0EQIAFB////B0sNARogAiABQQVqNgIAC0EACwurAgEFfyAARQRAQZHnAUGc5wFBIxApCyACRQRAQZ/oAUGc5wFBJBApCyADRQRAQavoAUGc5wFBJRApC0EHIQgCQCABQQJJDQAgAC0AAEEfcUEWRw0AIAAtAAEiBEH/AHEhB0ECIQUCQCAEQYABcUUEQCAHIQQMAQsgByABTw0BIAdBf2pBAksNAUECIQVBACEEIAchBgNAIAAgBWotAAAgBEEIdHIhBCAFQQFqIQUgBkF/aiIGDQALIAdBAmohBQsgBCADKAIASwRAIAMgBDYCAEEGDwsgBCAFaiABSw0AIAQEQEEAIQYDQCAAIAVqLQAAENQDIgFBf0YEQEEQDwsgAiAGaiABOgAAIAVBAWohBSAGQQFqIgYgBEcNAAsLIAMgBDYCAEEAIQgLIAgLOwEBf0EAIQEDQCAAIAFBA3RBwOgBaigCAEYEQCABQQN0QcToAWooAgAPCyABQQFqIgFBygBHDQALQX8LOwEBf0EAIQEDQCAAIAFBA3RBxOgBaigCAEYEQCABQQN0QcDoAWooAgAPCyABQQFqIgFBygBHDQALQX8L2QEBA38gAkUEQEGQ7QFBn+0BQYQBECkLIABFBEBBqO4BQZ/tAUGFARApCwJ/AkACQCABBEBBACEDA0AgACADai0AACEFQQAhBAJAA0AgBEEDdEHA6AFqKAIAIAVGDQEgBEEBaiIEQcoARw0AC0EQDwsgA0EBaiIDIAFHDQALIAFB/wBLDQELIAIgAUECajYCAAwBCyABQf8BTQRAIAIgAUEDajYCAAwBCyABQf//A00EQCACIAFBBGo2AgAMAQtBECABQf///wdLDQEaIAIgAUEFajYCAAtBAAsLqwIBBX8gAEUEQEG37gFBwu4BQSMQKQsgAkUEQEHL7wFBwu4BQSQQKQsgA0UEQEHX7wFBwu4BQSUQKQtBByEIAkAgAUECSQ0AIAAtAABBH3FBE0cNACAALQABIgRB/wBxIQdBAiEFAkAgBEGAAXFFBEAgByEEDAELIAcgAU8NASAHQX9qQQJLDQFBAiEFQQAhBCAHIQYDQCAAIAVqLQAAIARBCHRyIQQgBUEBaiEFIAZBf2oiBg0ACyAHQQJqIQULIAQgAygCAEsEQCADIAQ2AgBBBg8LIAQgBWogAUsNACAEBEBBACEGA0AgACAFai0AABDYAyIBQX9GBEBBEA8LIAIgBmogAToAACAFQQFqIQUgBkEBaiIGIARHDQALCyADIAQ2AgBBACEICyAIC/UDAQd/IABFBEBB5u8BQfHvAUEjECkLIAJFBEBB9fABQfHvAUEkECkLIANFBEBBgfEBQfHvAUElECkLIAFBAkkEQEEHDwsgAC0AAEEfcUEMRwRAQQcPCyAALQABIgZB/wBxIQVBAiEEAkAgBkGAAXFFBEAgBSEHDAELIAUgAU8EQEEHDwsgBUF/akECSwRAQQcPC0ECIQZBACEHIAUhBANAIAAgBmotAAAgB0EIdHIhByAGQQFqIQYgBEF/aiIEDQALIAVBAmohBAsgBCAHaiABSwRAQQcPC0EAIQggBCABSQRAQQAhCANAQQAhByAAIARqLQAAIgYhCUEAIQUCQCAGQYABcUUNAANAIAdBAWohBSAGQQF0Qf4BcSEJIAZBwABxRQ0BIAdBBEkhCiAFIQcgCSEGIAoNAAsLIAVBBEsEQEEHDwsgBCAFaiABSwRAQQcPCyAEQQFqIQQgCSAFdiEGIAUgBUEBSyIJayIHBEAgBCAFakF/QQAgCRtqIQkDQCAAIARqLQAAIgVBwAFxQYABRwRAQQcPCyAFQT9xIAZBBnRyIQYgBEEBaiEEIAdBf2oiBw0ACyAJIQQLIAggAygCAEsEQCADIAg2AgBBBg8LIAIgCEECdGogBjYCACAIQQFqIQggBCABSQ0ACwsgAyAINgIAQQALJwACf0EBIABBgAFIDQAaQQIgAEGAEEgNABpBA0EEIABBgIAESBsLC+0BAQN/IABFBEBBkPEBQZvxAUEwECkLIAJFBEBBn/IBQZvxAUExECkLQQAhAwJAIAEEQEEAIQNBACEEA0AgACAEQQJ0aigCACIFQf//wwBLBEBBEA8LAn9BASAFQYABSA0AGkECIAVBgBBIDQAaQQNBBCAFQYCABEgbCyADaiEDIARBAWoiBCABRw0ACyADQf8ASw0BCyACIANBAmo2AgBBAA8LAn8CQCADQf8BTQRAIAIgA0EDajYCAAwBCyADQf//A00EQCACIANBBGo2AgAMAQtBECADQf///wdLDQEaIAIgA0EFajYCAAtBAAsL+QgBBH8jAEEgayIEJAAgAEUEQEGu8gFBufIBQTgQKQsgAUUEQEG58wFBufIBQTkQKQsgAkUEQEHH8wFBufIBQToQKQsCQAJAIAEoAgAiA0ECSQ0AIAAtAAEiBkEfSw0AQQIhBSAGQQJqIANLDQACfyAGBEBBACEDA0AgACAFai0AABDUAyIFQX9GDQMgAyAEaiAFOgAAIANBA2ohBSADQQFqIgMgAC0AAUkNAAsgBC0AACEDIAEgBTYCAEHoByADQVBqQf8BcSIDQQlLDQEaIANBCmwMAQsgAUECNgIAQegHCyEAIAIgACAELQABQVBqIgNB5AAgA0H/AXFBCkkbQf8BcWoiADYCACAAQeMASw0AIAIgBC0AAkFQakH/AXEiAEEKbEHoByAAQQpJGyAELQADQVBqIgBB5AAgAEH/AXFBCkkbQf8BcWoiADYCBCAAQQxLDQAgAiAELQAEQVBqQf8BcSIAQQpsQegHIABBCkkbIAQtAAVBUGoiAEHkACAAQf8BcUEKSRtB/wFxaiIANgIIIABBH0sNACACIAQtAAZBUGpB/wFxIgBBCmxB6AcgAEEKSRsgBC0AB0FQaiIAQeQAIABB/wFxQQpJG0H/AXFqIgA2AgwgAEEXSw0AIAIgBC0ACEFQakH/AXEiAEEKbEHoByAAQQpJGyAELQAJQVBqIgBB5AAgAEH/AXFBCkkbQf8BcWoiADYCECAAQTtLDQAgAkIANwIUIAJCADcCHEEAIQACQAJAIAQtAAoiBUFVaiIBQS9LDQBBACEDAkACQAJAAkACQAJAAkACQAJAAkAgAUEBaw4vCgAKCgsBAgMEBQYHCAkKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCgoKCg0ACyACIAVBK0c2AhggAiAELQALQVBqQf8BcSIAQQpsQegHIABBCkkbIAQtAAxBUGoiAEHkACAAQf8BcUEKSRtB/wFxaiIDNgIcQQchACADQRdLDQwgAiAELQANQVBqQf8BcSIAQQpsQegHIABBCkkbIAQtAA5BUGoiAEHkACAAQf8BcUEKSRtB/wFxaiIANgIgQQdBACAAQTtLGyEADAwLQQohAwwJC0EUIQMMCAtBHiEDDAcLQSghAwwGC0EyIQMMBQtBPCEDDAQLQcYAIQMMAwtB0AAhAwwCC0HaACEDDAELQegHIQMLIAIgAyAELQALQVBqIgFB5AAgAUH/AXFBCkkbQf8BcWoiAzYCFCADQTtLDQAgBC0ADCIDQVVqIgFBAksEQCADQdoARg0CDAELIAFBAWtFDQAgAiADQStHNgIYIAIgBC0ADUFQakH/AXEiAEEKbEHoByAAQQpJGyAELQAOQVBqIgBB5AAgAEH/AXFBCkkbQf8BcWoiAzYCHEEHIQAgA0EXSw0BIAIgBC0AD0FQakH/AXEiAEEKbEHoByAAQQpJGyAELQAQQVBqIgBB5AAgAEH/AXFBCkkbQf8BcWoiADYCIEEHQQAgAEE7SxshAAwBC0EHIQALIARBIGokACAAC/EBAQN/IABFBEBB0/MBQd/zAUEfECkLIAFFBEBB3/QBQd/zAUEgECkLIABBAEHwkgMoAgARAQAhAiAAQfSSAygCABECACIEQQdxIQMCfyACQX9HBEAgAwR/IABBAEHwkgMoAgARAQBFBUEBCyECIABBiJMDKAIAEQIAIAJqDAELIAQgA2tBCGohAiAAQfiSAygCABECAEEBaiAAQfSSAygCABECAEYEfyACIABB9JIDKAIAEQIAQQdxRWsFIAILQQN2CyIAQQFqIQIgAEGAAU8EQANAIAJBAWohAiAAQQh2IgANAAsLIAEgAkEBajYCAEEAC0cAIAFFBEBB7vQBQf30AUEcECkLIABFBEBB/fUBQf30AUEdECkLIAECfwJAIAAoAhwNACAAKAIgDQBBDwwBC0ETCzYCAEEAC+oDAQd/IwBBEGsiAyQAIABFBEBBjfYBQZr2AUEiECkLIAJFBEBBm/cBQZr2AUEjECkLQQAhCAJAIAICfwJAIAEEf0EAIQQDQEEQIQIgACAIQQV0aiIHKAIAIglBD0sNBCAHKAIEIQUgBygCCCEGQQIhB0EQIQICQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIAlBAWsODwABAgMEDAUGBwkIEgoKCg0LIANBDGoQyAMiAkUNCgwRCyAFIANBDGoQ3wMiAkUNCQwQCyAFKAIAIANBDGoQywMiAkUNCAwPCyAGIANBDGoQzQMiAkUNBwwOCyAGIANBDGoQzwMiAkUNBgwNCyAFIAYgA0EMahDSAyICRQ0FDAwLIAUgBiADQQxqENUDIgJFDQQMCwsgBSAGIANBDGoQ2QMiAkUNAwwKCyAFIANBDGoQ4AMiAkUNAgwJCyAFIAYgA0EMahDdAyICRQ0BDAgLIAUgBiADQQxqEOEDIgINBwsgAygCDCEHCyAEIAdqIQQgCEEBaiIIIAFHDQELCyAEQf8ASw0BIAQFIAgLQQJqDAELIARBA2ogBEH/AU0NABogBEEEaiAEQf//A00NABpBECECIARB////B0sNASAEQQVqCzYCAEEAIQILIANBEGokACACC+QHAQd/IwBBEGsiBCQAIABFBEBBqvcBQbX3AUEiECkLIAFFBEBBtPgBQbX3AUEjECkLIAJFBEBBwvgBQbX3AUEkECkLAkACQCABKAIAQQJJDQAgA0UNAEEAIQUDQEEAIQYgAiAFQQV0akEANgIMIAVBAWoiBSADRw0ACwNAIAQgAiAGQQV0aiIFKAIIIgk2AgxBECEHIAUoAgBBfmoiCkENSw0CIAVBCGohCCAFKAIEIQUCQAJAAkACQAJAAkACQAJAAkACQAJAAkAgCkEBaw4NAQIDBAUGBwgJDgoKCgALIAAgASgCACAFEMkDDQogBSAEQQhqEN8DDQogAiAGQQV0akEBNgIMIAEgBCgCCDYCAEEAIQcMDQsgACABKAIAIAUQygMNCSAEKAIMIARBCGoQywMNCSACIAZBBXRqQQE2AgwgASAEKAIINgIAQQAhBwwMCyAAIAEoAgAgBSAEQQxqEMwDDQggBCgCDCAEQQhqEM0DDQggAiAGQQV0akEBNgIMIAggBCgCDDYCACABIAQoAgg2AgBBACEHDAsLIAAgASgCACAFIARBDGoQzgMNByAEKAIMIARBCGoQzwMNByACIAZBBXRqQQE2AgwgCCAEKAIMNgIAIAEgBCgCCDYCAEEAIQcMCgsgASgCAEECRw0GIAAgBmoiBS0AAEEFRw0GIAUtAAENBiABQQI2AgAgAiAGQQV0akEBNgIMQQAhBwwJCyAAIAEoAgAgBSAEQQxqENADDQUgBSAEKAIMIARBCGoQ0gMNBSACIAZBBXRqQQE2AgwgCCAEKAIMNgIAIAEgBCgCCDYCAEEAIQcMCAsgACABKAIAIAUgBEEMahDWAw0EIAUgBCgCDCAEQQhqENUDDQQgAiAGQQV0akEBNgIMIAggBCgCDDYCACABIAQoAgg2AgBBACEHDAcLIAAgASgCACAFIARBDGoQ2gMNAyAFIAQoAgwgBEEIahDZAw0DIAIgBkEFdGpBATYCDCAIIAQoAgw2AgAgASAEKAIINgIAQQAhBwwGCyAAIAEoAgAgBSAEQQxqENsDDQIgBSAEKAIMIARBCGoQ3QMNAiACIAZBBXRqQQE2AgwgCCAEKAIMNgIAIAEgBCgCCDYCAEEAIQcMBQsgBCABKAIANgIIIAAgBEEIaiAFEN4DDQEgAiAGQQV0akEBNgIMIAEgBCgCCDYCAEEAIQcMBAsgACABKAIAIAUgCUEBEOMDDQAgBSAEKAIMIARBCGoQ4QMNACACIAZBBXRqQQE2AgwgASAEKAIINgIAQQAhBwwDCyAGQQFqIgYgA0cNAAsLQQchBwsgBEEQaiQAIAcLpAoBCH8jAEEQayIFJAAgAEUEQEHP+AFB2vgBQSYQKQsgAkUEQEHe+QFB2vgBQScQKQsCQAJAIAFBAkkNACAALQAAQf4BcUEwRw0AAn9BAiAALQABIgZBGHRBGHUiCUF/Sg0AGkEBIAZBgAFxRQ0AGiAJQf8AakH/AXFBAksNASAGQf8AcSIJQQJqIgogAUsNAUEAIQZBAiIHIAlFDQAaA0AgACAHai0AACAGQQh0ciEGIAdBAWohByAJQX9qIgkNAAsgCgsiByAGaiABSw0AQQAhASADRQ0BA0AgAiABQQV0akEANgIMIAFBAWoiASADRw0AC0EAIQwCQANAIAVBADYCCCACIAxBBXRqIgooAgAhCSAFIAooAggiATYCDCAKKAIEIQgCQCAERQRAIAooAgxBAUYNAQsgCUEPSwRAQRAhAQwFCyAKQQhqIQsCQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgCUEBaw4PAAECAwQFBgcICQoPDQsMFAsgBSAGNgIIIAAgB2ogBiAIEMcDIgENFSAFQQhqEMgDIgFFDRAMFQsgBSAGNgIIIAAgB2ogBiAIEMkDIgFFDQ4gBEUNEAwUCyAFIAY2AgggACAHaiAGIAgQygMiAQRAIARFDRAMFAsgCCgCACAFQQhqEMsDIgFFDQ4MEwsgBSAGNgIIIAAgB2ogBiAIIAVBDGoQzAMiAQRAIARFDQ8MEwsgCyAFKAIMIgE2AgAgASAFQQhqEM0DIgFFDQ0MEgsgBSAGNgIIIAAgB2ogBiAIIAVBDGoQzgMiAQRAIARFDQ4MEgsgCyAFKAIMIgE2AgAgASAFQQhqEM8DIgFFDQwMEQsCQAJAIAZBAkkNACAAIAdqIgEtAABBBUcNACABLQABRQ0BCyAERQ0NDBALIAVBAjYCCAwLCyAFIAY2AgggACAHaiAGIAggBUEMahDQAyIBBEAgBEUNDAwQCyALIAUoAgwiATYCACAIIAEgBUEIahDSAyIBRQ0KDA8LIAUgBjYCCCAAIAdqIAYgCCAFQQxqENYDIgEEQCAERQ0LDA8LIAsgBSgCDCIBNgIAIAggASAFQQhqENUDIgFFDQkMDgsgBSAGNgIIIAAgB2ogBiAIIAVBDGoQ2gMiAQRAIARFDQoMDgsgCyAFKAIMIgE2AgAgCCABIAVBCGoQ2QMiAUUNCAwNCyAFIAY2AgggACAHaiAGIAggBUEMahDbAyIBBEAgBEUNCQwNCyALIAUoAgwiATYCACAIIAEgBUEIahDdAyIBRQ0HDAwLIAUgBjYCCCAAIAdqIAVBCGogCBDeAyIBRQ0GIARFDQcMCwsgBSAGNgIIIAAgB2ogBiAIIAFBABDjAyIBBEAgBEUNBwwLCyAIIAUoAgwgBUEIahDhAyIBRQ0FDAoLIAAgB2otAABBP3FBMUYNAQwICyAAIAdqLQAAQT9xQTBHDQcLIAUgBjYCCCAAIAdqIAYgCCABQQEQ4wMiAQRAIARFDQQMCAsgCCAFKAIMIAVBCGoQ4QMiAUUNAgwHCyAFIAY2AgggACAHaiAFQQhqIAggARDiAyIBRQ0BIARFDQIMBgsgCCAFQQhqEN8DIgENBQsgBSgCCCEBIApBATYCDCAMQX8gBBshDCAGIAFrIQYgASAHaiEHCyAMQQFqIgwgA0kNAAtBACEJCwNAIAIgCUEFdGooAgxFDQFBACEBIAMgCUEBaiIJRw0ACwwBC0EHIQELIAVBEGokACABC9QCAQZ/IwBBEGsiBCQAIABFBEBB6/kBQfb5AUElECkLIAQgAkEEajYCDCACKAIAIQMgBCACQQxqIgU2AgwCQAJ/AkACQCADBEBBACEGA0AgA0F/akEOSw0CIAUoAgAhAyAEIAVBDGoiBTYCDCAGQQFqIQYgAw0ACyAGRQRAQQIhAwwFC0EgIAYQNiIHRQRAQQ0hAwwFCyAEIAJBBGo2AgwgAigCBCEIIAIoAgAhAyAEIAJBDGo2AgxBACEFIAMEQANAIANBf2pBDksNBCACKAIIIQIgByAFQQV0aiIGIAg2AgggBiADNgIAIAYgAjYCBCAEIAQoAgwiAkEEajYCDCACKAIEIQggAigCACEDIAQgAkEMajYCDCAFQQFqIQUgAw0ACwsgACABIAcgBUEBEOMDDAMLQQIhAwwDC0EQIQMMAgtBEAshAyAHEDcLIARBEGokACADC6kJARB/IwBBkARrIgMkACAARQRAQf36AUGI+wFBJBApCyACRQRAQf/7AUGI+wFBJRApC0HAkgMoAgBFBEBBi/wBQYj7AUEmECkLIANBADYCvAIgAyACQRRqIgo2ArgCIAMgAkEQaiILNgK0AiADIAJBGGoiDDYCsAIgAyACQRxqIg02AqwCIAMgAkEgaiIONgKoAiADIAJBDGoiBjYCpAIgAyACQQhqIg82AqACAkAgAkEEaiIIIANBoAJqEJABIgQNAAJAAkBBAUGAgAIQNiIFRQRAQQ0hBAwBCyADQgA3A6gDIANCgIACNwPoAiADIAU2AuQCIANCBjcDoAMgA0IQNwOIAyADQQc2AoADIANBBDYC4AIgA0ICNwPIAiADQQ02AsACIAMgA0HAA2o2AoQDIAMgA0GAA2o2AsQCIAAgASADQcACakECQQEQ4wNFBEBBACEHIAMoAugCIgkEQEEAIQdBACEEQQAhAEEAIQEDQCAEIAVqLQAAIABBAXRyIQAgAUEBaiIBQQhGBEAgBSAHaiAAOgAAIAdBAWohB0EAIQEgAygC6AIhCUEAIQALIARBAWoiBCAJSQ0ACwsgBigCACEEIAgoAgAhACADQUBrQQA2AgAgA0IANwM4IAMgADYCNCADQoKAgIAQNwIsIAMgBDYCKCADQoKAgIAQNwMgIAUgByADQSBqEOQDIQQgBRA3IAQNAQwCCyAFEDcgBigCACEEIANBADYClAIgA0IANwKMAiADIAQ2AogCIANCgoCAgBA3A4ACIAAgASADQYACahDkAyIEDQAgBigCAEEAQfCSAygCABEBAEUEQCADQYwEakHIkgMoAgARAgAiBA0BIAwoAgAhBCAOKAIAIQUgDSgCACEJIAooAgAhByALKAIAIRAgDygCACERIAgoAgAhEiADIAYoAgA2AmQgA0KCgICAEDcDaCADIBI2AnAgA0KCgICAEDcCdCADIBE2AnwgA0KCgICAEDcDgAEgAyAQNgKIASADQoKAgIAQNwKMASADIAc2ApQBIANCgoCAgBA3A5gBIAMgCTYCoAEgA0KCgICAEDcCpAEgAyAFNgKsASADQoKAgIAQNwOwASADIAQ2ArgBIANBADYCvAEgA0IANwPAASADQoKAgIAQNwNQIAMgAygCjAQ2AlggA0KCgICAEDcCXCAAIAEgA0HQAGoQ5AMhBCADKAKMBEHQkgMoAgARBgAgBA0BIAJBATYCAEEAIQQMAwsgBigCAEEBQfCSAygCABEBAEUEQEESIQQMAQsgBigCACEEIAgoAgAhBSADQQA2AvABIANCADcD6AEgAyAFNgLkASADQoKAgIAQNwLcASADIAQ2AtgBIANCgoCAgBA3A9ABIAAgASADQdABahDkAyIERQ0BCyAPKAIAIQIgCCgCACEAIAYoAgAhASAOKAIAIQUgDSgCACEJIAwoAgAhByALKAIAIQYgCigCACEIIANBADYCHCADIAg2AhggAyAGNgIUIAMgBzYCECADIAk2AgwgAyAFNgIIIAMgATYCBCADIAA2AgAgAiADEJEBDAELQQAhBCACQQA2AgALIANBkARqJAAgBAsgACAAQR9NBEBBAEELIABB6ABsQcD4AmooAgAbDwtBCwv5AgEJfyABRQRAQZ/8AUGs/AFBJxApCyADRQRAQab9AUGs/AFBKBApCwJAIAAQ5gMiBQ0AIABB6ABsQcj4AmooAgAhCUHgABA1IQYgCRA1IQcCQAJAAkACQCAGRQ0AIAdFDQAgBA0BDAILIAYEQCAGEDcLQQ0hBSAHRQ0DIAcQN0ENDwsgAEHoAGwiBUGc+QJqIQsgBUGY+QJqIQogCUF/aiEMIAVBlPkCaiENQQAhCANAIAcgCEEIdEGAgPwHcSAIQRh0ciAIQQh2QYD+A3EgCEEYdnJyNgAAIAYgDSgCABECACIFDQIgBiABIAIgCigCABEAACIFDQIgBiAHQQQgCigCABEAACIFDQIgBiAHIAsoAgARAQAiBQ0CIAkEQCAEIAkgBEF/aiAMSRshAEEAIQUDQCADIAUgB2otAAA6AAAgBEF/aiEEIANBAWohAyAFQQFqIgUgAEcNAAsLIAhBAWohCCAEDQALC0EAIQULIAcQNyAGEDcLIAUL+QQBCH8jAEHgAGsiDiQAIABFBEBBs/0BQcP9AUEsECkLIAdFBEBBw/4BQcP9AUEtECkLIAhFBEBBz/4BQcP9AUEuECkLAkAgBRDmAyIJDQAgBBCZASIJDQBBFiEJIAZBA3YgBkEHcUEAR2oiCiACSQ0AIAogAiAFQegAbEHI+AJqKAIAIhBqQQJqSQ0AIAoQNSELIAoQNSEPIAoQNSEMIAoQNSENAkACQCALRQ0AIA9FDQAgDEUNACANDQELIAsEQCALEDcLIA8EQCAPEDcLIAwEQCAMEDcLQQ0hCSANRQ0BIA0QNwwBCwJAIAIEQEEJIQkgDCACIAMgBEEobEGklANqKAIAEQAAIAJHDQELIA4gBUHoAGwiBEGU+QJqKAIAEQIAIgkNACALQQgQnAEgDiALQQggBEGY+QJqIgQoAgARAAAiCQ0AIA4gACABIAQoAgARAAAiCQ0AIA4gDCACIAQoAgARAAAiCQ0AIA4gDSAFQegAbEGc+QJqKAIAEQEAIgkNAEEAIQAgC0EAIAogAmsgEGsiCUF+aiIDEJoIIgQgA2pBAToAACAEIAlqQX9qIAwgAhCZCBogBSANIBAgDyAKIBBBf3NqIgIQ5wMiCQ0AIAIEQANAIAAgBGoiCSAJLQAAIAAgD2otAABzOgAAIABBAWoiACACRw0ACwsgCCgCACAKSQRAIAggCjYCAEEGIQkMAQsgByAEIAIQmQgiCSACaiANIBAQmQgaIAkgCmpBf2pBvAE6AAAgCSAJLQAAQf8BIApBA3QgBmtBAWp2cToAACAIIAo2AgBBACEJCyANEDcgDBA3IA8QNyALEDcLIA5B4ABqJAAgCQtbAQF/IAJFBEBB3v4BQe3+AUEfECkLIAFFBEBB7f8BQe3+AUEgECkLIAIoAgAhAyACQQM2AgBBBiECIANBA08EfyABQYECOwAAIAFBf0EAIAAbOgACQQAFIAILC+EFAQV/IwBBEGsiBSQAIABFBEBB+f8BQYWAAkEiECkLIAFFBEBBhYECQYWAAkEjECkLIAJFBEBBkYECQYWAAkEkECkLAkAgACAFQQxqEN8DIgMNACACKAIAIAUoAgwiA0kEQCACIAM2AgBBBiEDDAELQQAhBiAAQQBB8JIDKAIAEQEAIQMgAEH0kgMoAgARAgAiB0EHcSEEAn8gA0F/RwRAIAQEfyAAQQBB8JIDKAIAEQEARQVBAQshBiAAQYiTAygCABECACAGagwBCyAHIARrQQhqQQN2IgQgAEH4kgMoAgARAgBBAWogAEH0kgMoAgARAgBHDQAaQQAhBiAEIABB9JIDKAIAEQIAQQdxRWsLIQRBAiEDIAFBAjoAAAJ/IAFBAWogBEGAAUkNABogBEH/AU0EQCABQYEBOgABQQMhAyABQQJqDAELIARB//8DTQRAIAFBggE6AAEgASAEQQh2OgACQQQhAyABQQNqDAELQRAhAyAEQf///wdLDQEgAUGDAToAASABIARBCHY6AAMgASAEQRB2OgACQQUhAyABQQRqCyAEOgAAIAEgA2ohASAGBEAgAUEAOgAAIAFBAWohAQsCQCAAQQBB8JIDKAIAEQEAQQFGBEAgACABQYyTAygCABEBACIDRQ0BDAILIABBAEHwkgMoAgARAQBFDQACQCAFQQhqQciSAygCABECAEUEQCAAQfSSAygCABECAEF4cUEIaiEDIABB+JIDKAIAEQIAQQFqIABB9JIDKAIAEQIARgRAIAMgA0F4aiAAQfSSAygCABECAEEHcRshAwsgBSgCCCADQfySAygCABEBAEUEQCAFKAIIIgMgACADQZSTAygCABEAAEUNAgsgBSgCCEHQkgMoAgARBgALQQ0hAwwCCyAFKAIIIAFBjJMDKAIAEQEAIQMgBSgCCEHQkgMoAgARBgAgAw0BCyACIAUoAgw2AgBBACEDCyAFQRBqJAAgAwu3AgEEfyMAQRBrIgYkACABRQRAQaCBAkGsgQJBIRApCyACRQRAQbKCAkGsgQJBIhApCyAAIAZBDGoQywMiBEUEQEEGIQQCQCACKAIAIAYoAgwiA0kNAEEBIQMgAARAQQAhAyAAIQUDQCADQQFqIQMgBUEIdiIFDQALCwJAIAMgACADQQN0QX9qdkEBcWoiBEEESw0AQQQgBGsiBUUNAEEAIQMDQCAAQQh0IQAgA0EBaiIDIAVJDQALCyABIAQ6AAFBAiEDIAFBAjoAAAJAIARBBUsNAAJAIARBAWsOBQEBAQEAAgsgAUEAOgACQQMhA0EEIQQLIAMgBGohBQNAIAEgA2ogAEEYdjoAACAAQQh0IQAgA0EBaiIDIAVHDQALQQAhBCAFIQMLIAIgAzYCAAsgBkEQaiQAIAQLiQMBB38jAEEQayIIJAAgAEUEQEHBggJBzIICQSQQKQsgAkUEQEHPgwJBzIICQSUQKQsgA0UEQEHbgwJBzIICQSYQKQsgASAIQQxqEM0DIgRFBEBBBiEEAkAgCCgCDCIGIAMoAgBLDQAgAkEDOgAAQQEhByABQQN2IAFBB3EiCkEAR2oiBUEBaiEGQQIhBAJAIAVB/wBPBEACfyAFQf8BSQRAQQIhB0GBASEFQQEhCUEDDAELQQEhBCAFQf7/A0sNAiACQYIBOgABIAZBCHYhBUEDIQdBAiEJQQQLIQQgAiAJaiAFOgAACyACIAdqIAY6AAALQQAhBSACIARqQQAgAWtBB3E6AAAgBEEBaiEGIAEEQEEAIQQDQCAFIAAgBGotAABBAEcgBEEHcSIHQQdzdHIhBSAHQQdGBEAgAiAGaiAFOgAAIAZBAWohBkEAIQULIARBAWoiBCABRw0ACwtBACEEIApFDQAgAiAGaiAFOgAAIAZBAWohBgsgAyAGNgIACyAIQRBqJAAgBAvoAgEGfyMAQRBrIgckACAARQRAQeqDAkH1gwJBIxApCyACRQRAQfqEAkH1gwJBJBApCyADRQRAQYaFAkH1gwJBJRApCwJAIAEgB0EMahDPAyIEDQAgBygCDCIEIAMoAgBLBEAgAyAENgIAQQYhBAwBCyACQQQ6AAACQAJAIAFBgAFPBEACfyABQYACSQRAQQMhBEECIQVBASEIQYEBDAELAn8gAUGAgARJBEBBAyEFQQIhCEGCASEGQQEhCUEEDAELQRAhBCABQf///wdLDQUgAkGDAToAASABQRB2IQZBBCEFQQMhCEECIQlBBQshBCACIAlqIAY6AAAgAUEIdgshBiACIAhqIAY6AAAgAiAFaiABOgAADAELIAIgAToAAUECIQQgAUUNAQtBACEFA0AgAiAEaiAAIAVqLQAAOgAAIARBAWohBCAFQQFqIgUgAUcNAAsLIAMgBDYCAEEAIQQLIAdBEGokACAEC78FAQt/IwBBEGsiCCQAIABFBEBBlYUCQaOFAkEhECkLIAJFBEBBrYYCQaOFAkEiECkLIANFBEBBuYYCQaOFAkEjECkLAkAgACABIAhBDGoQ0gMiBA0AIAgoAgwiBCADKAIASwRAIAMgBDYCAEEGIQQMAQsCfwJAAkAgAUEBTQRAIAhBATYCDCACQQY6AABBACEFDAELIAFBf2ohCiAAKAIEIAAoAgBBKGxqIQdBACEFQQEhBgNAIAUgB0VqIAcQ0QMiBEEHbiIFaiELIAQgBUEHbGtBAEchBSAGQQFqIQQgBiAKSQRAIAAgBEECdGooAgAhBwsgBSALaiEFIAQhBiABIARHDQALIAhBATYCDCACQQY6AAAgBUH/AEsNAQsgCEECNgIMQQEhBEECDAELIAVB/wFNBEAgAkGBAToAASAIQQM2AgxBAiEEQQMMAQtBECEEIAVB//8DSw0BIAJBggE6AAEgAiAFQQh2OgACIAhBBDYCDEEDIQRBBAshCSACIARqIAU6AAAgAUECTwRAIAFBf2ohDiAAKAIEIAAoAgBBKGxqIQxBASENA0AgCSEHQQAhBAJ/IAwiBgRAA0AgAiAHIgVqIgsgBkH/AHEgBHIiCjoAACAEQYABciEEIAVBAWohByAGQQd2IgYNAAsgCCAHNgIMIAcgCSAFTw0BGiACIAlqIgQtAAAhBiAEIAo6AAAgCyAGOgAAIAcgCUEBaiIEIAVBf2oiBk8NARoDQCACIARqIgUtAAAhCyAFIAIgBmoiCi0AADoAACAKIAs6AAAgBEEBaiIEIAZBf2oiBkkNAAsgBwwBCyAIIAlBAWoiBDYCDCACIAlqQQA6AAAgBAshCSANQQFqIQQgDSAOSQRAIAAgBEECdGooAgAhDAsgBCENIAEgBEcNAAsLIAMgCTYCAEEAIQQLIAhBEGokACAEC+0CAQZ/IwBBEGsiByQAIABFBEBByIYCQdOGAkEiECkLIAJFBEBB1ocCQdOGAkEjECkLIANFBEBB4ocCQdOGAkEkECkLAkAgACABIAdBDGoQ1QMiBA0AIAcoAgwiBCADKAIASwRAIAMgBDYCAEEGIQQMAQsgAkEWOgAAAkACQCABQYABTwRAAn8gAUGAAkkEQEEDIQRBAiEFQQEhCEGBAQwBCwJ/IAFBgIAESQRAQQMhBUECIQhBggEhBkEBIQlBBAwBC0EQIQQgAUH///8HSw0FIAJBgwE6AAEgAUEQdiEGQQQhBUEDIQhBAiEJQQULIQQgAiAJaiAGOgAAIAFBCHYLIQYgAiAIaiAGOgAAIAIgBWogAToAAAwBCyACIAE6AAFBAiEEIAFFDQELQQAhBQNAIAIgBGogACAFai0AABDTAzoAACAEQQFqIQQgBUEBaiIFIAFHDQALCyADIAQ2AgBBACEECyAHQRBqJAAgBAvtAgEGfyMAQRBrIgckACAARQRAQfGHAkH8hwJBIhApCyACRQRAQYWJAkH8hwJBIxApCyADRQRAQZGJAkH8hwJBJBApCwJAIAAgASAHQQxqENkDIgQNACAHKAIMIgQgAygCAEsEQCADIAQ2AgBBBiEEDAELIAJBEzoAAAJAAkAgAUGAAU8EQAJ/IAFBgAJJBEBBAyEEQQIhBUEBIQhBgQEMAQsCfyABQYCABEkEQEEDIQVBAiEIQYIBIQZBASEJQQQMAQtBECEEIAFB////B0sNBSACQYMBOgABIAFBEHYhBkEEIQVBAyEIQQIhCUEFCyEEIAIgCWogBjoAACABQQh2CyEGIAIgCGogBjoAACACIAVqIAE6AAAMAQsgAiABOgABQQIhBCABRQ0BC0EAIQUDQCACIARqIAAgBWotAAAQ1wM6AAAgBEEBaiEEIAVBAWoiBSABRw0ACwsgAyAENgIAQQAhBAsgB0EQaiQAIAQLogUBBH8gAEUEQEGgiQJBq4kCQSIQKQsgAkUEQEGvigJBq4kCQSMQKQsgA0UEQEG7igJBq4kCQSQQKQtBACEFAkACfwJAAkACQAJAIAFFDQBBACEEA0BBECEHIAAgBEECdGooAgAiBkH//wdLDQYgBhDcAyAFaiEFIARBAWoiBCABRw0ACyAFQYABSQ0AIAVBgAJPBEBBBCEEIAVBgIAETwRAQQUhBCAFQf///wdLDQcLIAQgBWogAygCAEsNAiACQQw6AAAgBUH//wNLDQQgAkGCAToAASACIAVBCHY6AAJBBCEEQQMMBQtBAyEEIAVBA2ogAygCAEsNASACQYyCAjsAAEECDAQLQQIhBCAFQQJqIAMoAgBNDQELIAMgBTYCAEEGDwsgAkEMOgAAQQEMAQsgAkGDAToAASACIAVBCHY6AAMgAiAFQRB2OgACQQUhBEEECyACaiAFOgAAIAEEQEEAIQUDQCAAIAVBAnRqIgYoAgAQ3ANBf2oiB0EDTQRAAn8CQAJAAkACQCAHQQFrDgMBAgMACyAGKAIAIQZBASEHIAQMAwsgAiAEaiAGKAIAQQZ2QR9xQcABcjoAACAGLQAAQT9xQYB/ciEGQQIhByAEQQFqDAILIAIgBGoiByAGKAIAQQx2QQ9xQeABcjoAACAHIAYoAgBBBnZBP3FBgAFyOgABIAYtAABBP3FBgH9yIQZBAyEHIARBAmoMAQsgAiAEaiIHIAYoAgBBEnZBB3FB8AFyOgAAIAcgBigCAEEMdkE/cUGAAXI6AAEgByAGKAIAQQZ2QT9xQYABcjoAAiAGLQAAQT9xQYB/ciEGQQQhByAEQQNqCyACaiAGOgAAIAQgB2ohBAsgBUEBaiIFIAFHDQALCyADIAQ2AgBBACEHCyAHC+IEAQN/IwBBEGsiBSQAIABFBEBByooCQdqKAkEnECkLIAFFBEBB2osCQdqKAkEoECkLIAJFBEBB5osCQdqKAkEpECkLIAAgBUEMahDgAyIDRQRAQQYhAyAFKAIMIgQgAigCAE0EQCABQRc6AAAgASAAKAIAQQpuQQpwQfWLAmosAAAQ0wM6AAIgASAAKAIAQQpwQfWLAmosAAAQ0wM6AAMgASAAKAIEQQpuQQpwQfWLAmosAAAQ0wM6AAQgASAAKAIEQQpwQfWLAmosAAAQ0wM6AAUgASAAKAIIQQpuQQpwQfWLAmosAAAQ0wM6AAYgASAAKAIIQQpwQfWLAmosAAAQ0wM6AAcgASAAKAIMQQpuQQpwQfWLAmosAAAQ0wM6AAggASAAKAIMQQpwQfWLAmosAAAQ0wM6AAkgASAAKAIQQQpuQQpwQfWLAmosAAAQ0wM6AAogASAAKAIQQQpwQfWLAmosAAAQ0wM6AAsgASAAKAIUQQpuQQpwQfWLAmosAAAQ0wM6AAwgASAAKAIUQQpwQfWLAmosAAAQ0wM6AA0CfwJAIAAoAiANACAAKAIcDQBBDyEEQdoAIQNBDgwBCyABQS1BKyAAKAIYGxDTAzoADiABIAAoAhxBCm5BCnBB9YsCaiwAABDTAzoADyABIAAoAhxBCnBB9YsCaiwAABDTAzoAECABIAAoAiBBCm5BCnBB9YsCaiwAABDTAzoAESAAKAIgQQpwQfWLAmosAAAhA0ETIQRBEgsgAWogAxDTAzoAACABIARBfmo6AAFBACEDCyACIAQ2AgALIAVBEGokACADC4kBAQR/IAFBIBA2IgZFBEBBDQ8LIAEEQEEAIQcDQCAGIAdBBXQiBWoiBCAAIAVqIgUpAgg3AgggBCAFKQIANwIAIAQgBSkCGDcCGCAEIAUpAhA3AhAgBCAHNgIMIAdBAWoiByABRw0ACwsgBiABQSBBhwEQOCAGIAEgAiADQQ4Q9wMhBCAGEDcgBAthAQJ/QX8hAiAAKAIAQX9qIgNBDk0EQCADQQJ0QYCMAmooAgAhAgtBASEDIAIgASgCAEF/aiICQQ5NBH8gAkECdEG8jAJqKAIABSADC2oiAgR/IAIFIAAoAgwgASgCDGsLC8IDAQl/AkAgAUECSQ0AIAAoAgAhBkEBIQQDQCAGIAAgBEEFdGooAgBGBEAgASAEQQFqIgRHDQEMAgsLQRAPC0ENIQRBASADKAIAEDYiBQR/IAAgASAFIANBDxD3AyIEBEAgBRA3IAQPCyABQQgQNiIIRQRAIAUQN0ENDwtBACELIAVBAmoiBCAFLQABIgBB/wBxaiAEIABBGHRBGHVBAEgbIgcgBWshCSAHIAUgAygCAGpJBEADQCAIIAtBA3RqIgogBzYCACAHLAABIgRB/wFxIQACQCAEQQBOBEAgCiAANgIEQQIhBAwBCyAKQQA2AgRBAiEEIABB/wBxIgZFBEBBACEADAELIApBBGohDEEAIQADQCAMIAQgB2otAAAgAEEIdHIiADYCACAEQQFqIQQgBkF/aiIGDQALCyAKIAAgBGoiBDYCBCALQQFqIQsgBCAHaiIHIAUgAygCAGpJDQALCyAIIAFBCEGIARA4IAIgBSAJEJkIIQYgAQRAQQAhBANAIAYgCWogCCAEQQN0aiIAKAIAIAAoAgQQmQgaIAAoAgQgCWohCSAEQQFqIgQgAUcNAAsLIAgQNyAFEDdBAAUgBAsLkgEBBH8CQCAAKAIAIgMgASgCACIEIAAoAgQiAiABKAIEIgAgAiAASSIFGxDkBiIBDQBBACEBIAAgAkYNAAJAIAIgAE0EQCAFRQ0CDAELA0AgACADai0AAEUEQCACIABBAWoiAEcNAQwDCwtBAQ8LA0AgAiAEai0AAEUEQCAAIAJBAWoiAkcNAQwCCwtBfyEBCyABC7kNAQh/IwBBEGsiBSQAIABFBEBB+IwCQYWNAkEmECkLIAJFBEBBiY4CQYWNAkEnECkLIANFBEBBlY4CQYWNAkEoECkLAkACfwJAAkACQAJAIAEEQEEAIQxBACEIA0BBECEGIAAgDEEFdGoiCSgCACIHQQ9LDQcgCSgCBCELIAkoAgghCkECIQlBECEGAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCAHQQFrDg8AAQIDBAwFBgcICRUKCgoNCyAFQQxqEMgDIgZFDQoMFAsgCyAFQQxqEN8DIgZFDQkMEwsgCygCACAFQQxqEMsDIgZFDQgMEgsgCiAFQQxqEM0DIgZFDQcMEQsgCiAFQQxqEM8DIgZFDQYMEAsgCyAKIAVBDGoQ0gMiBkUNBQwPCyALIAogBUEMahDVAyIGRQ0EDA4LIAsgCiAFQQxqENkDIgZFDQMMDQsgCyAKIAVBDGoQ3QMiBkUNAgwMCyALIAVBDGoQ4AMiBkUNAQwLCyALIAogBUEMahDhAyIGDQoLIAUoAgwhCQsgCCAJaiEIIAxBAWoiDCABRw0BCwsgBSAINgIIIAhBgAFJDQEgCEGAAk8EQEEEIQkgCEGAgARPBEBBBSEJQRAhBiAIQf///wdLDQgLIAMoAgAgCCAJaiIGSQ0DIAVBATYCDCACQTBBMSAEQQ1GGzoAACAFQQI2AgwgCEH//wNLDQUgAkGCAToAASACIAhBCHY6AAJBBCEHIAVBBDYCDEEDDAYLQQMhByADKAIAIAhBA2oiBkkNAiAFQQE2AgwgAkGBAToAASACQTBBMSAEQQ1GGzoAACAFQQM2AgxBAgwFC0EAIQggBUEANgIIC0ECIQcgAygCACAIQQJqIgZPDQELIAMgBjYCAEEGIQYMAwsgAkEwQTEgBEENRhs6AAAgBUECNgIMQQEMAQsgAkGDAToAASACIAhBCHY6AAMgAiAIQRB2OgACQQUhByAFQQU2AgxBBAsgAmogCDoAACADIAMoAgAgB2siCDYCAAJAIAFFDQBBACEMA0BBECEGIAAgDEEFdGoiCSgCACILQQ9LDQIgCSgCBCEKIAkoAgghCSADAn8CQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIAtBAWsODwABAgMEBQYHCAkKEQ0LDBALIAUgCDYCCCAKKAIAIAIgB2ogBUEIahDpAyIGDRAgBSAFKAIIIgYgBSgCDGoiBzYCDCADKAIAIAZrDA0LIAUgCDYCCCAKIAIgB2ogBUEIahDqAyIGDQ8gBSAFKAIIIgYgBSgCDGoiBzYCDCADKAIAIAZrDAwLIAUgCDYCCCAKKAIAIAIgB2ogBUEIahDrAyIGDQ4gBSAFKAIIIgYgBSgCDGoiBzYCDCADKAIAIAZrDAsLIAUgCDYCCCAKIAkgAiAHaiAFQQhqEOwDIgYNDSAFIAUoAggiBiAFKAIMaiIHNgIMIAMoAgAgBmsMCgsgBSAINgIIIAogCSACIAdqIAVBCGoQ7QMiBg0MIAUgBSgCCCIGIAUoAgxqIgc2AgwgAygCACAGawwJCyACIAdqIgZBBToAACAFIAdBAmoiBzYCDCAGQQA6AAEgAygCAEF+agwICyAFIAg2AgggCiAJIAIgB2ogBUEIahDuAyIGDQogBSAFKAIIIgYgBSgCDGoiBzYCDCADKAIAIAZrDAcLIAUgCDYCCCAKIAkgAiAHaiAFQQhqEO8DIgYNCSAFIAUoAggiBiAFKAIMaiIHNgIMIAMoAgAgBmsMBgsgBSAINgIIIAogCSACIAdqIAVBCGoQ8AMiBg0IIAUgBSgCCCIGIAUoAgxqIgc2AgwgAygCACAGawwFCyAFIAg2AgggCiAJIAIgB2ogBUEIahDxAyIGDQcgBSAFKAIIIgYgBSgCDGoiBzYCDCADKAIAIAZrDAQLIAUgCDYCCCAKIAIgB2ogBUEIahDyAyIGDQYgBSAFKAIIIgYgBSgCDGoiBzYCDCADKAIAIAZrDAMLIAUgCDYCCCAKIAkgAiAHaiAFQQhqEPMDIgYNBSAFIAUoAggiBiAFKAIMaiIHNgIMIAMoAgAgBmsMAgsgBSAINgIIIAogCSACIAdqIAVBCGoQ9QMiBg0EIAUgBSgCCCIGIAUoAgxqIgc2AgwgAygCACAGawwBCyAFIAg2AgggCiAJIAIgB2ogBUEIakENEPcDIgYNAyAFIAUoAggiBiAFKAIMaiIHNgIMIAMoAgAgBmsLIgg2AgAgDEEBaiIMIAFHDQALCyADIAc2AgBBACEGCyAFQRBqJAAgBguXAgEGf0EYIQgCQCACQX9qQQFLDQAgAkECRgRAIAUQmQEiCA0BC0EWIQggAUELaiADQQN2IANBB3FBAEdqIgpLDQAgBygCACAKSQRAIAcgCjYCAEEGDwsgBkECaiELIAogAWsiDUF9aiEJAkAgAkECRgRAQQkhCCALIAkgBCAFQShsQaSUA2oiBSgCABEAACAJRw0CIAlFDQFBACEMA0AgCyAMaiEDA0AgAy0AAEUEQCADQQEgBCAFKAIAEQAAQQFGDQEMBQsLIAxBAWoiDCAJRw0ACwwBCyALQf8BIAkQmggaCyAGIAI6AAFBACEIIAZBADoAACAGIA1qIgJBf2pBADoAACACIAAgARCZCBogByAKNgIACyAIC4MEAQR/IwBBkAFrIgokACAARQRAQaSOAkGvjgJBLBApCyACRQRAQamPAkGvjgJBLRApCyADRQRAQbWPAkGvjgJBLhApCyAJRQRAQcSPAkGvjgJBLxApC0EYIQsCQCAEQX1xQQFHDQAgBEEDRgRAIAYQmQEiCw0BIAcQ5gMiCw0BCyAJKAIMQfSSAygCABECACEMIAkoAgxBiJMDKAIAEQIAIgsgAygCACINSwRAIAMgCzYCAEEGIQsMAQsCQCAEQQNGBEAgCiANNgKMASAAIAEgCCAFIAYgByAMIAIgCkGMAWoQ6AMiC0UNAQwCCyAHQegAbCIEQZD5AmooAgAiC0UEQEEQIQsMAgsgCkIANwNoIApBADYCLCAKIAE2AiggCiAANgIkIApCBjcDYCAKQQA2AkwgCiALNgJIIApBBzYCQCAKQQU2AiAgCkICNwMIQQ0hCyAKQQ02AgAgCiAEQdD4Amo2AkQgCiAKQUBrNgIEIAogCSgCDEGIkwMoAgARAgAiBDYCiAEgBBA1IgRFDQEgCkECIAQgCkGIAWpBDRD3AyILBEAgBBA3DAILIAogAygCADYCjAEgBCAKKAKIAUEBIAxBAEEAIAIgCkGMAWoQ+AMhCyAEEDcgCw0BCyACIAooAowBIAIgA0EBIAlBgJQDKAIAEQwAIQsLIApBkAFqJAAgCwt/AgR/An4jAEEgayIBJAAgAEUEQEHQjwJB4o8CQRoQKQsgACgCBCECIAAoAiAhAyAAKQIIIQUgACgCHCEEIAApAhAhBiABIAAoAhg2AhAgAUEANgIcIAEgBjcCFCABIAQ2AgwgASAFNwMAIAEgAzYCCCACIAEQkQEgAUEgaiQAC5MDAgR/An4jAEGQBGsiAiQAIAFBCGpBAEG4AhCaCCEFIAJCADcDiAQgASAAKQMQNwMAAkAgACgCACACQYgEaiACQYAEEN4BRQ0AIAItAABByABHDQAgAi0AAUHNAEcNACACLQACQTNHDQAgAi0AA0HXAEcNACABQgA3AwALIAEgACgCMCkALCAAKQMQfDcDGCAAKAIAIAFBIGoiBBDgARoCQAJAIABB15ACQQAQiwMiA0UNACABIAMpAwggACkDEHwiBjcDCCABIAYgAzUCHCIHfDcDECAHQsgAUg0AQQAhAyAAKAIAIAUgAUEoakHIABDeAUUNASABQcgANgK4AkEBIQMgASABKAK8AkEBcjYCvAIMAQtBASEDIAQpAwAgAUEYaiIEKQMAfUKEAlQNAEEAIQMgACgCACAEIAFBKGoiAEGEAhDeAUUNACAALQAAQc4ARw0AIAEtAClBxwBHDQAgAS0AKkHJAEcNACABLQArQdMARw0AIAEgASgCvAJBAnI2ArwCQQEhAwsgAkGQBGokACADC5gBAQN/IwBB0ABrIgEkAEEAIQMgAUEANgJMAkAgACgCxAIiAkUNACAAQdeQAkIAQcgAQQAgAkGAgICAeHIgAUHMAGoQhgQiAw0AIAFBAEHIABCaCCICKAJMIAJByABBABCHBCEDIAIoAkwQiAQaIAAgACgCzAJB/79+cTYCzAIgACAAKAK0AkF/ajYCtAILIAFB0ABqJAAgAwvjAgEEfyMAQZAHayIBJAAgAUHAADYCREHjkAIQxQMhAyABQcgAakEAQcACEJoIGkHsByECAkAgACABQcgAahD7A0UNACABKAKEA0EBRw0AIAAgAUHIAGogAUEwahD+A0UEQEEBIQIMAQsgAUGABDYCjANBgZECQaoDIAFBkANqIAFBjANqEMYDBEBBASECDAELQQEhAiABQZADaiABKAKMAyABQQhqEOUDDQAgAUGQA2pBAEHIABCaCBogAUEwakEQIAFBkANqQQhyIgIgAUHEAGpBAUEAQQAgA0EAIAFBCGoQ+QMaIAFB1wNqIQMDQCACIAItAAAgAy0AAHMiBDoAACADIAMtAAAgBHMiBDoAACACIAItAAAgBHM6AAAgAkEBaiICIANBf2oiA0kNAAsgAUEIahD6A0EAIQIgACgCACABQdAAaiABQZADakHIABDfAQ0AEMcBIQILIAFBkAdqJAAgAgu7AgIGfwV+IwBB8ABrIgMkAAJAQYCABBCQCCIERQRAQQAhCAwBCyADQRBqECoaIAMgASkDACIJNwMIAkAgASkDGCAJfSIJQoCABCAJQoCABFQbIgqnIgYEQEEAIQgDQCAAKAIAIANBCGogBCAGEN4BRQ0CIAEpAxAiCyADKQMIIglaIAsgCSAKfCINVHEhB0EAIAEpAwgiDCAJWiAMIA1UcSIFRSAHG0UEQCAEIAwgCX2nakEAIAUbIgUgBCAFGyIFQQAgBCALIAl9p2pBACAHGyIHIAQgBmogBxsgBWsQmggaCyADQRBqIAQgBhArGiADIAMpAwggCnwiCTcDCCABKQMYIAl9IglCgIAEIAlCgIAEVBsiCqciBg0ACwsgA0EQaiACEC0aQQEhCAsgBBCRCAsgA0HwAGokACAIC+MYAQd/IwBB4AJrIgckACAHQgA3AxggB0IANwMQQQAhBSAHQQA2AgwCQAJAAkACQAJAAkACQAJAAn8CQAJAAkACQAJAAkACQAJAAkAgAUE4TQRAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJ/AkACQAJAAkACQAJAAkACfwJ/AkACQAJAAkACQAJAAkACQCABQQFrDjgBAgMEBQYHCgsMDQ4PEBITFBUWFxgZGhscPR0eHyAhIiMkJSYnKCkqKywtLi8wMTIzNDU2Nzg5OgALIAAQpwMiBkUNPSAGKAIAENwBIgAQoAhBAWohCQxICyAAEKcDIgVFDTwgBSgCACACIAMgBBDdASEFDEsLIAAQpwMiBkUNOyAGKAIsRQ1DQQghCSAGQQhqIQAMRgsgABCnAyIGRQ06IAYoAixFDUIgByAGKQMINwMQQRAhCUEEDAULIAAQpwMiBkUNOSAGKAIsIgVFDUEgByAGKQMIQhB8NwMQIAUoAghBcGoMAwsgABCnAyIGRQ04IAZBEGohAAxBCyAAEKcDIgZFDTdBBCEJIAYoAjBBBGohAAxCCyAAEKcDIgZFDTYgByAGKQMQNwMQIAYoAjAoAAQLIQlBBAshCEEAIQpBACEADEALIAAQpwMiBkUNMyAGKAIwQTxqIQAMPAsgABCnAyIGRQ0yIAYoAjBB3ABqIQAMOwsgABCnAyIGRQ0xQSwgBiAGKAIwIgUpADwgBSgAXEHIitHSAUHw7rydfBCEAyIADQQaDDkLIAAQpwMiBkUNMCAGEJMDIgBFDTgMNgsgABCnAyIGRQ0vIAYoAjBBNGohAAw4CyAAEKcDIgZFDS4gBigCMEHkAGohAAw3CyAAEKcDIgZFDS0gBiAGKAIwIgUpADQgBSgAZEHCitHSAUGj547kfhCEAyIARQ01QdgAIAAoAlRBAnRB2ABqIANB2ABGGwshCUEDIQhBACEKDDgLIAAQpwMiBkUNKyAGEJQDIgBFDTMMMQsgABCnAyIGRQ0qIAcgBigCMCIFMwAoQiCGIAU1ABCENwMYQQIhCEEIIQlBACEKIAdBGGohAAw2CyAAEKcDIgZFDSkgBigCMEHEAGohAAwyCyAAEKcDIgZFDSggBigCMEEYaiEAQQIMLwsgABCnAyIGRQ0nIAYoAjQiAEUNJyAGKAIwKAAYQQR0IQkMMgsgABCnAyIGRQ0mIAcgBigCMCIFMwAqQiCGIAU1ABSENwMYQQIhCEEIIQlBACEKIAdBGGohAAwyCyAAEKcDIgZFDSUgBigCMEHMAGohAAwuCyAAEKcDIgZFDSQgBigCMEEcaiEAQQIMKwsgABCnAyIGRQ0jQSwhBSAGKAIwIgAzACpCIIYgADUAFIQgBikDGFoNMUEDIQhBACEKIAAoABxBBHQiCSADTQ0hQQAhAAwvCyAAEKcDIgZFDSIgBigCMEEgaiEADCsLIAAQpwMiBkUNISAGKAIwQdQAaiEADCoLIAAQpwMiBkUNICAGIAdBIGoQ+wNFDSAgB0HcAmohAEECDCcLIAAQpwMiBkUNH0EsIQUgBiAHQSBqEPsDRQ0tQQIhCCAHLQDcAkECcUUNLSAHQThqIQAMKQsgABCnAyIGRQ0eQSwhBSAGIAdBIGoQ+wNFDSxBAiEIIActANwCQQJxRQ0sIAdBhAI2AgxBBCEJQQAhCiAHQQxqIQAMKgsgABCnAyIGRQ0dQSwhBSAGIAdBIGoQ+wNFDStBAiEIIActANwCQQJxRQ0rIAdByABqIQBBhAIhCUEAIQoMKQsgABCnAyIGRQ0cIAYoAjBBLGohAEECDCMLIAAQpwMiBkUNGyAGKAIwQQhqIQBBAgwiCyAAEKcDIgZFDRogBkGsAmohAEECDCELIAAQpwMiBkUNGSAGQbACaiEAQQIMIAsgABCnAyIGRQ0YIAZBuAJqIQBBAgwfCyAAEKcDIgZFDRdBACEAIAYhCQNAIAkoArACIghBAU4EQCAJKAI8IgUgCEEGdGohCANAIAAgBSgCIEGAgMCAeHFBgICAgHhGaiEAIAVBQGsiBSAISQ0ACwsgCSgCICIJDQALIAcgADYCDEECIQhBBCEJQQAhCiAHQQxqIQAMIwsgABCnAyIGRQ0WIAYoAjAiBSgAbEUNHiAFQewAaiEAQQIMHQsgABCnAyIGRQ0VIAYoAgAgB0EMahDjARpBAiEIQQQhCUEAIQogB0EMaiEADCELIAAQpwMiBkUNFCAHIAYoAswCNgIMQQIhCEEEIQlBACEKIAdBDGohAAwgCyAAEKgDIghFDRMgCCgCAA0UQQEhACAIIQUDQCAFKAIEKAIAENwBEKAIIABqQQFqIQAgBSgCMCIFDQALIAQEQCAEIAA2AgALQQEhBSACRQ0iIANFDSIgACADSw0VA0AgAiAIKAIEKAIAENwBIgUgBRCgCEEBaiIAEJkIIABqIQIgCCgCMCIIDQALIAJBADoAAAwgCyAAEKgDIgVFDRIgBSgCDCIKRQ0SQQYhCEEAIQYgCigCOCIFRQRAQcAAIQkgCiEADB8LIAUQoAhBwQBqIQkgCiEADB4LIAAQqAMiBUUNESAFKAIIIgBFDRFBAiEIQRAhCQwWCyAAEKgDIgVFDRAgBSgCCEUNECAFQSBqIQAMFAsgABCoAyIFRQ0PIAUoAggiBUUNDyAHIAUoAgA2AgxBAiEIQQQhCUEAIQYgB0EMaiEAQQAhCgwbCyAAEKgDIgVFDQ4gBSgCCCIFRQ0OIAcgBSgCBDYCDEECIQhBBCEJQQAhBiAHQQxqIQBBACEKDBoLIAAQqAMiBUUNDSAFKAIMIgBFDQ0MEAsgABCoAyIFRQ0MIAUoAggiBUUNDCAHIAUvAQg2AgxBAiEIQQQhCUEAIQYgB0EMaiEAQQAhCgwYCyAAEKgDIgVFDQsgBSgCBCIARQ0LIAUoAgwiBUUNCyAHIAUgACgCPGtBBnU2AgxBAiEIQQQhCUEAIQYgB0EMaiEAQQAhCgwXCyAAEKgDIgVFDQogBSgCDCIFRQ0KQQghCSAFQQhqIQBBAiEIDA8LIAAQqAMiBUUNCSAFKAIMIgVFDQkgBUEQaiEADAwLIAAQqAMiBUUNCCAFKAIMIgVFDQggBUEYaiEADAwLIAAQqAMiBUUNByAFKAIMIgVFDQcgBUEcaiEADAsLIAAQqAMiBUUNBiAFKAIMIgVFDQYgBUEgaiEADAoLIAAQqAMiBUUNBSAFQSRqIQAMCQsgABCoAyIFRQ0EIAUoAgwiCkUNBCAHIAUoAiQiCzYCDEECIQhBBCEJQQAhBiAHQQxqIQAgCi0AIkECcUUEQEEAIQoMEQsgByAKKAIYIAtzIAUoAhhrNgIMDAkLIAAQqAMiBUUNAyAFKAIMIgVFDQMgByAFKAIkNgIMQQIhCEEEIQlBACEGIAdBDGohAEEAIQoMDwtBHBDIAQwRC0EAIQogBkEBEJIDIQAMDQtBLCEFIAAQpwMNDgtBCCEFDA0LQRwQyAFBACEFDA0LQSoQyAFBACEFDAwLQQIhCEEIIQkMAQtBAiEIQQQhCQtBACEGQQAhCgwGC0EFCyEIQQQhCUEAIQoMBAtBLCEFDAULQQIhCAtBCCEJQQAhCgwBC0ECIQhBACEKCyAEBEAgBCAJNgIACwJAAkACf0EAIAJFDQAaQQAgA0UNABpBKiAJIANLDQAaQQAgCEF+aiIEQQRLDQAaAkACQAJAAkACQCAEQQJrDgMAAQIEC0EAIQUgBigCACAHQRBqIAIgCRDeAQ0CEMcBIQUMAgsgAiAANgIAQQAhAEEAIQUMAQsgAiAKKQMANwMAIAIgCkE4aiIEKQMANwM4IAIgCikDMDcDMCACIAopAyg3AyggAiAKKQMgNwMgIAIgCikDGDcDGCACIAopAxA3AxAgAiAKKQMINwMIQQAhBSAEKAIARQ0AIAIgAkFAayIENgI4IAQgCigCOBDsBhoLIABBAEchAgwCCyACIAAgCRCZCBpBAAshBSAAQQBHIQIgAEUNACAIQQNHDQAgABCRCAwBCyAIQQVHDQAgAkUNAAJAAkAgAUF1aiIIQQRLDQACQCAIQQFrDgQBAQEAAgsgABCIAwwCC0EcEMgBDAELIAAQhgMLIAUNAQtBASEFDAELIAUQyAFBACEFCyAHQeACaiQAIAULvQMBCH8jAEEwayICJABBCCEFAkACQCAAEKgDRQ0AIAAoAgAiA0UEQCAAKAIMIgZFDQECQCAGKAI4IgNFBEAgAkIANwMoQQAhAyACQQA2AiQgAEEAQQBBARDEAyEEIAAgAkEoakEIIAJBJGpBABC/AxogACAEQQBBABDEAxpB6wchBQJAIAIoAiRBCEcNACACKAIsIQggAigCKCEJQeCUAiEHA0ACQCADQRRsIgRB1JQCaigCACAJcSAEQdCUAmooAgBHDQAgBEHYlAJqKAIAIARB3JQCaigCACAIcUcNAEEAIQUgAkEANgIgIAJCADcDGCACQgA3AxAgACgCBCgCPCEDIAIgBygCADYCBCACIAYgA2tBBnU2AgAgAkEQakGcmAIgAhDFBhogACgCBCAGIAJBEGoQjQMgAUUNAiABIAJBEGoQ7AYaDAILIANBAWoiA0EUbEHglAJqIQcgA0EWRw0ACwsgAQRAIAYoAjgiAw0CCyAFDQNBASEADAQLIAFFDQILIAEgAxDsBhpBASEADAILQQEhACABRQ0BIAFBgAggAxDcARCbAwwBCyAFEMgBQQAhAAsgAkEwaiQAIAAL8wEBBX8jAEEgayEEQQAhAwJAIAFB5ABJDQAgAkUNACAAKAJAQcKmkYIDRw0AIARCADcDGCAEQgA3AxAgBEIANwMIIARCADcDACAEQSBqIQZByAAhAyAEIQEDQCADQQFqIQcCQCAAIANqLQAAIgVBgAFxBEAgBUH/AHEgA2pBAmohBSAHIQMDQCABIAZGDQIgA0HkAEYNAiABIAAgA2otAAA6AAAgAUEBaiEBIAVB/wFxIANBAWoiA0H/AXFHDQALDAELIAEgBWpBAWohASAHIQMLIANB4wBMQQAgASAGSRsNAAsgAiAEKQMYPgIAQQEhAwsgAwurAQEDfyABKAIwRQRAQRwPCyAAQgA3AgBBACECIABBADYCICAAQgA3AhggAEIANwIQIABBCGoiA0IANwIAIAAgASgCDCIEKQIoNwIAIAMgBCkCMDcCAANAIAEoAgwoAhgiAyACIAMgAksbIQIgASgCMCIBDQALIAAgAhCQCCIDNgIQIAAgAhCQCCIENgIUQTAhAQJAIANFDQAgBEUNACAAIAI2AhhBACEBCyABC+cJARd/IwBBoAFrIgMkACADQRBqQQBBxAAQmggaIANBADYCDCABKAIwIgIgA0HYAGpBxAAgA0EMakEAEL8DGgJ/QewHIAMoAgxBxABHDQAaAkAgAkUEQCAAKAIgIQQMAQsgA0EoaiEWIABBCGohFwNAIAJBMGohDAJAIAIoAjAiBEUNACAEIANBEGpBxAAgA0EMakEAEL8DGkHsByADKAIMQcQARw0DGiAWIABBEBDkBg0AIANB2ABqIANBEGpBxAAQmQgaIAwoAgAhAgwBC0HsByELAkAgAygCWEHQqI3CBEcNACADKAJoQc2I1fkFRw0AIAMoApABQdiMyeoERw0AIAMoAlwQkAgiBEUNACAEIANB2ABqQcQAEJkIIQYCQAJAIAMoApgBIgRBwqaRggNHBEAgBEHDnsHKBUcNAiAGKAIEIQQgA0EANgKcASACIAZBxABqIARBvH9qIgQgA0GcAWpBABC/AxogAygCnAEgBEYNAQwCCyADQQA2ApwBIAZBxABqIQQgBigCPEF0aiIFIAYoAgQiCUG8f2oiB0kEQCAFEJAIIghFDQIgAiAIIAUgA0GcAWpBABC/AxogBSADKAKcAUYEQCAEQQAgBxCaCBoCQCAHQQFIDQAgBUEFSA0AIAUgCGohCiAGIAlqIQkgCEEEaiECA0AgAkEBaiEHAkAgAi0AACICQYABcQRAIAJB/wBxIQ1BACEFIAchAgNAIAQgCUYNAiACIApGDQIgBCACLQAAOgAAIARBAWohBCACQQFqIQIgBUH/AXEhByAFQQFqIQUgByANSQ0ACwwBCyACIARqQQFqIQQgByECCyACIApPDQEgBCAJSQ0ACwsgCBCRCAwCCyAIEJEIDAILIAIgBCAHIANBnAFqQQAQvwMaIAMoApwBIAdHDQELIABBEEEUIAAtACBBAXEiAhtqKAIAIQogAEEUQRAgAhtqKAIAIQ1B7AchCwJAIAYoAkAiAkHCppGCA0cEQCACQcOewcoFRw0CIAogDSAAKAIcEJkIGiAGKAIMIQUMAQsCQCAGKAJcIg5FBEBBACEFDAELIAAoAhwhFCAGQeQAaiIIIAYoAkxqIhAgBigCVGohEUEAIQdBACEFA0AgCCgCACIPIAVqIhUgDksNAyAIKAIIIRIgCCgCBCETIAUgCmogECAPEJkIGiAPIBQgB2sgByAPaiIYIBRJGyIJIAVqIgIgDksNAyACIAlJDQNBACECIAkEQANAIAogAiAFamoiBCANIAIgB2pqLQAAIAQtAABqOgAAIAJBAWoiAiAJSQ0ACwsgEyAVaiIFIA5LDQMgDyAQaiEQIAogFWogESATEJkIGkGAgICAeCASayASIBJBAEgbIBhqIQcgCEEMaiEIIBEgE2ohESAFIA5JDQALCyAFIAYoAgxHDQEgACAFNgIcCyAFRQRAQQAhCwwBCyAKIAUgBkEoahC+AyECIBcgBikCMDcCACAAIAYpAig3AgBBAEHsByACGyELCyAGEJEICyADQdgAaiADQRBqQcQAEJkIGiAAIAAoAiBBAWoiBDYCIEEAIAwoAgAiAiALGw0AC0EAIAsNARoLIAEgAEEUaiAAQRBqIARBAXEiAhsoAgA2AkAgAEEUQRAgAhtqQQA2AgAgASAAKAIcNgJEQQALIQwgA0GgAWokACAMC0oBAX8gAARAIAAoAhAiAQRAIAEQkQgLIAAoAhQiAQRAIAEQkQgLIABCADcCACAAQQA2AiAgAEIANwIYIABCADcCECAAQgA3AggLC/MZAgx/AX4jAEGAEmsiBSQAQQAhDSAFQQA2AgwgABCnAyEDAkACQCABRQRAQRwhBAwBCyADRUEDdEEcIAEtAAAiBhshBCADRQ0AIAZFDQBBPyEEIAAtAMwCQQFxRQ0AAkACQAJAAkACQCABQQBBgIKAASAFQQxqEJkEBEAgBSgCDCEGIAIEQCACEKAIIgRBCWoQkAgiAUUEQCAGQQA2AigMBwsCf0EAIARFDQAaIAQgAUEEaiACIAQQmQggBGoiA0F/ai0AAEHcAEYNABogA0HcADoAACAEQQFqCyIDIAFqQQA6AAQgASADNgIAIAYgATYCKAwFCyAGQfiYAkEAEIsDBEBBsJkCIQFB75oCIQNBoZoCKQAAIRBBqZoCLQAAIQICQANAQaqaAiEEA0AgBUHwCWogAyABKAIIEJkIGiABKAIEIAVB8AlqaiAELQAAOgAAIAUgASgCBGpB8QlqIAQtAAE6AAAgBSABKAIEakHyCWogBC0AAjoAACAFIAEoAgRqQfMJaiAELQADOgAAIAEoAgggBUHwCWpqIgMgEDcAACADIAI6AAggACAFQfAJakEAEIsDDQIgBC0ABARAIARBBGohBCABKAIAIQMMAQsLIAEoAgwhAyABQQxqIQEgAw0AC0EAIQQLIARBnJoCIAQbIgEtAAMhBCABLQACIQMgAS0AASECIAEtAAAhB0EOEJAIIgFFBEAgBkEANgIoDAcLIAFB3AA7AQggASAEOgAHIAEgAzoABiABIAI6AAUgASAHOgAEIAFBBTYCACAGIAE2AigMBQsgAEGOmQJBABCLAyIORQ0BQQAhDCAAKAIAENwBIgQQoAgiAiAEaiIDIQEgAyADQYB/aiAEIAJBgAFKGyIJTQ0CIAMhAQNAIAEtAABBLkYEQEEBIQwMBAsgAUF/aiIBIAlLDQALDAMLEMcBIQQMBQtBCRCQCCIBBEAgAUEANgIAIAFBADoABAsgBiABNgIoDAILIAEgCU0NAEEAIQpBACELA0ACQAJAIAEtAAAiBEFdaiICQQxLBEAgBEHcAEcNAgwBCyACQQFrDgsBAQEBAQEBAQEBAQALIAxFDQIgCkEBaiEKIAEhCwsCQCALRQ0AIAogDEgNAAJAIAsgAWsiD0EKRw0AIAFBkZwCQQoQ7QYNAEEAIQIgASEHAkAgASADTwRAQQAhAgwBCwNAAkAgBEH/AXFBXWoiCEEMSw0AAkAgCEEBaw4LAQEBAQEBAQEBAQEAC0HcACEECyAFQeABaiACaiAEOgAAIAJBAWohAiADIAdBAWoiB0cEQCAHLQAAIQQMAQsLIAJBgAFLDQELIAVB8AlqIAVB4AFqIAIQmQgaIAVB8AlqIAJqIgRBq5wCKQAANwAAIARBu5wCLwAAOwAQIARBs5wCKQAANwAIIAYgBUHwCWpBABCLA0UNAAJ/IAJFBEAgBUHgAWoQoAghAgsgAkEJagsQkAgiBARAIAQCf0EAIAJFDQAaIAIgBEEEaiAFQeABaiACEJkIIAJqIgFBf2otAABB3ABGDQAaIAFB3AA6AAAgAkEBagsiAWpBADoABCAEIAE2AgAgBiAENgIoDAULIAZBADYCKAsCQCAPQQlHDQAgAUGcnAJBCRDtBg0AQQAhBCABIQICQCABIANPBEBBACEEDAELA0ACQCACLQAAIgdBXWoiCEEMSw0AAkAgCEEBaw4LAQEBAQEBAQEBAQEAC0HcACEHCyAFQeABaiAEaiAHOgAAIARBAWohBCACQQFqIgIgA0cNAAsgBEGAAUsNAQsgBUEQaiAFQeABaiAEEJkIGiAFQRBqIARqIgJBq5wCKQAANwAAIAJBu5wCLwAAOwAQIAJBs5wCKQAANwAIIAYgBUEQakEAEIsDRQ0AAn8gBEUEQCAFQeABahCgCCEECyAEQQlqCxCQCCICBEAgAgJ/QQAgBEUNABogBCACQQRqIAVB4AFqIAQQmQggBGoiAUF/ai0AAEHcAEYNABogAUHcADoAACAEQQFqCyIBakEAOgAEIAIgATYCACAGIAI2AigMBQsgBkEANgIoCyAPQQRHDQAgAUGmnAJBBBDtBg0AQQAhBCABIQICQCABIANPBEBBACEEDAELA0ACQCACLQAAIgdBXWoiCEEMSw0AAkAgCEEBaw4LAQEBAQEBAQEBAQEAC0HcACEHCyAFQeABaiAEaiAHOgAAIARBAWohBCACQQFqIgIgA0cNAAsgBEGAAUsNAQsgBUHwCWogBUHgAWogBBCZCBogBUHwCWogBGoiAkGrnAIpAAA3AAAgAkG7nAIvAAA7ABAgAkGznAIpAAA3AAggBiAFQfAJakEAEIsDRQ0AAn8gBEUEQCAFQeABahCgCCEECyAEQQlqCxCQCCICBEAgAgJ/QQAgBEUNABogBCACQQRqIAVB4AFqIAQQmQggBGoiAUF/ai0AAEHcAEYNABogAUHcADoAACAEQQFqCyIBakEAOgAEIAIgATYCACAGIAI2AigMBAsgBkEANgIoCyABQX9qIgEgCUsNAAsLAkAgBUHgAWogACgCABDcARDsBiIBEKAIIgRBBmpBgAhLDQBBACECIAVB4AFqIARqIgRBvZwCKAAANgAAIARBwJwCKAAANgADIAVCADcD+BEgAUGAAhDJASIHRQ0AIAcgBUH4EWoQ4AEaQQAhAQJAIAUpA/gRIhBCdHxC8wdWDQBBACECQQAhASAHQQAgBUHwCWogEKcQ3gFFDQBBACECIAUoAvgRIAVB8AlqakEAOgAAQQAhASAFQfAJakHEnAJBCxDtBg0AIAVB8AlqQQtyIQQDQAJAIAQtAAAiAUE9Rg0AIAFBIEYNACAEIQMDQCABQf8BcSIBQQ1NQQBBASABdEGByABxG0UEQCADLQABIQEgA0EBaiEDDAELC0EAIQIgAyAETQRAQQAhAQwDC0EAIQEgAyAEayIDQYABSw0CIAVBEGogBCADEJkIGiAFQRBqIANqQQA6AABBASEBIAMhAgwCCyAEQQFqIQQMAAALAAsgBxDNASABRQ0AIAVB8AlqIAVBEGogAhCZCBogBUHwCWogAmoiAUGrnAIpAAA3AAAgAUG7nAIvAAA7ABAgAUGznAIpAAA3AAggBiAFQfAJakEAEIsDRQ0AAn8gAkUEQCAFQRBqEKAIIQILIAJBCWoLEJAIIgEEQAJ/QQAgAkUNABogAiABQQRqIAVBEGogAhCZCCACaiIEQX9qLQAAQdwARg0AGiAEQdwAOgAAIAJBAWoLIgQgAWpBADoABCABIAQ2AgAgBiABNgIoDAILIAZBADYCKAsgACgCICIBRQRAIAYoArACIQEgBigCPCEDQYAIEJAIIglFDQIgAUEBTgRAIAMgAUEGdGohCCAOQShqIQsgBUGICmohCgNAAkAgAygCOCIHRQ0AIAMtACJBEHENACAHIgEhAiADKAIYQX9qQT5LDQADQAJAAkAgAS0AACIEQS9GDQAgBEHcAEYNACAEDQEgAkHQnAIQ5wYNAyAJIAcQ7AYiByEBIAchAgJ/AkACQAJAAkADQAJAAkACQCABLQAAIgRBL0YNACAEQdwARg0AIAQNASACIA4oAjgQ7AYhASAFQfAJakEAQcQAEJoIGiAFQQA2AuABIAVBADYCECAFQQA2AvgRIAYgB0F9IAVB4AFqEP0CRQ0MIAUoAuABQTUgBUH4EWpBBCAFQRBqEP8DGiAFKALgASEEIAUtAPoRQRBxRQ0GIAQgBUHwCWpBxAAgBUEQakEAEL8DGiAFKAIQQcQARw0FIAUoAvAJQdCojcIERw0EIAogC0EQEOQGIQQgBSgC4AEQ/wIaIAQNDAJ/IAEgB2siAUUEQCAHEKAIIQELIAFBCWoLEJAIIgQNAiAGQQA2AiggBxCRCAwRCyABQQFqIQILIAFBAWohAQwBCwtBACABRQ0EGiAEQQRqIAcgARCZCCABaiIDQX9qLQAAQdwARw0DIAEMBAsgBSgC4AEQ/wIaDAcLIAUoAuABEP8CGgwGCyAEEP8CGgwFCyADQdwAOgAAIAFBAWoLIgMgBGpBADoABCAEIAM2AgAgBiAENgIoIAcQkQgMBwsgAUEBaiECCyABQQFqIQEMAAALAAsgA0FAayIDIAhJDQALCyAJEJEIDAILIAEoAigiAUEEaiECAn8gASgCACIBRQRAIAIQoAghAQsgAUEJagsQkAgiBEUEQCAGQQA2AigMAgsgBAJ/QQAgAUUNABogASAEQQRqIAIgARCZCCABaiIDQX9qLQAAQdwARg0AGiADQdwAOgAAIAFBAWoLIgNqQQA6AAQgBCADNgIAIAYgBDYCKAsDQCAAIgFFDQEgASgCICIADQALIAYgATYCJCABIAY2AiBBASENDAILIAUoAgwQmwQaQZjOACEECyAEEMgBCyAFQYASaiQAIA0LmQQCBX8CfiMAQRBrIggkACAIQX82AgggACgCMC8ADCEKIAggACADEK8DIgc2AgxBACEJIAcEQCAFQf///19xIgkgBSAFQYCAgAhxGyIFIAkgBUGA/gNxGyIFIAVB//93cSAFQYCABHEbIQsCQAJAAkACQAJAAn8gACABQQAgBCAKQQFLGyIKIAhBCGoQjAMiBARAQRQgC0EATg0BGiAEIQUMAgsgACABIAogCEEIahCOAyIFDQEgCCgCDCEHQTMLIQkgByAENgIMDAELIAAQkQMgCCgCDCIHIAU2AgwCQCAAKAI0IglFDQAgCCgCCCIEIAAoAjAoABhPDQAgByAJIARBBHRqIgk2AgggCSAKOwEICyALQYCABHFFDQIgASAHKQMYIAMgCxCmAyEFIAgoAgwiByAFNgIkIAUNAUGRzgAhCQsgB0UNAiAIQQxqELsDDAILIAcoAgwhBQsgACkDECEMIAcgAzYCVCAHIAwgBykDGCINfDcDECAFQgA3AzAgBSADNgIYQQAhCSAFQQA2AhwgBSALQYCAgIB4cjYCICAFQgA3AyggBSANNwMIIAdB5ABqECoaQQBBAEEAEIYCIQMgBSACNwMQIAUgAzYCJCAAIAAoAswCQQJyNgLMAiAAKALUAiIFBEAgACgC2AJBACAHKAJUQQAgBREJAAsgB0EANgLIAQsgBiAIKAIMNgIACyAIQRBqJAAgCQu9CQELfyMAQRBrIgckAEEAIQQCQCABRQ0AIAJFDQAgACgCBCEIIAAoAgwhCwJAIAAoAlhFBEAgByAAKQMQNwMIIAAgABCxAyIENgLIASAEDQICQCAAKAI0DQAgASACIABB0ABqEIEERQ0AIAAoAgwiBCAEKAIgQYCAwAByNgIgIAAgAEEAELIDIgQ2AsgBIAQNAwsgACgCOEUEQCAAIABBABCzAyIENgLIASAEDQMLAkAgACgCPA0AIAstACNBBHFFDQAgACAAQQAQtAMiBDYCyAEgBA0DCwJAIAAoAjQiBUUEQEEAIQQMAQtBACEEIAgoAgAgB0EIaiAFIAUoAgAQ3wFFBEAQxwEhBAsgCyAAKAI0KAIAIgUgCygCHGo2AhwgByAHKQMIIAWtfDcDCAsgACgCOCIFBEAgCCgCACAHQQhqIAUgBSgCABDfAUUEQBDHASEECyALIAsoAhwgACgCOCIFKAIAajYCHCAHIAcpAwggBTUCAHw3AwgLIAQNAQsgACgCKCIGRQRAIAAgAzYCSAtBMyEEIAIgBmogACgCDCIJKAIYSw0AIABB5ABqIQ4gBiAGIAAoAmAiBW4iDCAFbGshBCAAKAJYIgYhDUEAIQoDQCAEIAZqIAEgBSAEayIFIAIgAiAFSxsiBRCZCBogACAAKAIoIAVqIgY2AigCQAJ/AkACQAJ/AkAgBCAFaiIEIAAoAmBJBEAgBiAJKAIYSQ0BCyAHIAApAxAgCTUCHHw3AwggDiAAKAJYIAQQKxogACAAKALEASAAKAJYIAQQhgI2AsQBIAkoAiAiBkGA/gNxBH8gByAENgIEIApFBEAgACgCYEGAAmoQkAgiCkUNBCAJKAIgIQYgCiENCyAGQYACcQR/IAogB0EEaiAAKAJYIAQQ6AIaIAkoAiAFIAYLQYAEcQRAIAogB0EEaiAAKAJYIAQCfyAMRQRAIAAoAkghAwsgAwtBAEEEQX8gA0HBAXEbEO4CGgsgBygCBCEEIAAoAjgiBgRAIAYgDEECdGoiBiAGKAIAIARqNgIECyAAKAI8BEBBACAKIAcoAgQQhwIhBiAAKAI8IAxBAnRqIAY2AgALIAkoAiAFIAYLQYCABHEEQCANIAQgACgCJCAMahCjAwsgCCgCACAHQQhqIA0gBBDfAUUEQBDHAQwCCyAIKALUAiIGBEAgCCgC2AIgACgCKCAAKAJUQQAgBhEJAAsgCSAJKAIcIARqNgIcIAxBAWohDEEAIQQLIAIgBWsiAg0EQQALIQQgCgRAIAoQkQgLIAQNBUEAIQQgACgCKCALKAIYSQ0FIAAoAgwiBCAAKALEATYCJCAOIARBKGoQLRogACgCPA0BQQAMAgtBMCEEDAQLIAAQtwMLIQQgACgCNCIFBEAgBSAAKAIMIgQpAig3AgwgBSAEKQIwNwIUIAAoAjQgACgCDCIEKAIYNgIIIAQgACgCUDYCGCAAELUDIQQLIAAoAjgEQCAAELYDIQQLIAgoAjAoAGwiBUUNAiAIKAIAIAAoAgwiBCkDCCAIKQMQfCAEKAIcIAUQugMhBAwCCyABIAVqIQEgACgCWCEGIAAoAmAhBQwAAAsACyAAIAQ2AsgBCyAHQRBqJAAgBAvAAQEGfyMAQRBrIgQkACAEIAA2AgwgACgCDCEDIAAoAgQhAQJAAkACQCAAKALIASICDQAgACgCKCEFAkAgACgCNCIGRQRAQesHIQIgBSADKAIYRg0BDAMLQesHIQIgBSAGKAIIRw0BCyABKAI4BEAgARCYAyICDQELQQAhAiABKALUAiIDRQ0CIAEoAtgCIAAoAlQiACAAQQEgAxEJAAwCCyADRQ0BCyABIAAQjwMaCyAEQQxqELsDIARBEGokACACC9kBAQN/A0AgASwAACIEQf8BcSECAkACQAJAAkACQANAIAJBKkcEQCACRQ0EIAJBP0cNAiAALQAARQRAQQAPCyABQQFqIQEMBgsgAS0AASIDQSpGDQALQQEhAiADRQ0DIANBGHRBGHVBwPECai0AACAALAAAIgNBwPECai0AAEcNASAAIAFBAWoQiQRFDQEMAwsgBEHA8QJqLQAAIAAsAAAiA0HA8QJqLQAARwRAQQAPCyABQQFqIQELIAMNAkEADwsgAC0AAEUhAgsgAg8LIABBAWohAAwAAAsAC70CAQJ/IAAQpwNFQQN0QRwgAhtBHCABGyEEAkACQAJAAkAgA0UNACAEDQAgAy0AAEUNASAAIAMQkQQhBAsgBA0BCyABEKAIQRlqEJAIIgVFBEBBMCEEDAELIAVCADcCACAFQRBqIgRCADcCACAFQgA3AgggBUEUaiABEOwGGiAFIAA2AgAgBEGAgICAeDYCAAJAIAAoAiAEQEEAIQQDQAJ/IAAoAjgiAwRAIANBGGoMAQsgACgCMEEcagsoAAAgBGohBCAAKAIgIgANAAsgBSAEQQFyIgA2AgggAEECdCIEEJAIIQAgBUGAgMCAeDYCECAFIAA2AgQgAEUEQEEwIQQMAgsgAEEAIAQQmggaCyAFIAIQiwQiBEUNAiAFKAIEIQALIAAEQCAAEJEICyAFEJEICyAEEMgBQQAhBQsgBQu5AgEFfwJAAkAgACgCACIDRQ0AA0ACQCADKAI0IgIEQCAAKAIMIgQgAygCMCgAGCIFTg0BIAIgBUEEdGohBSACIARBBHRqIQIDQCAAIARBAWo2AgwCQCADIAIQgwNFDQAgACABIAMgAiADKAI8IAIoAgxBBnRqEIwERQ0AQQAPCyACQRBqIgIgBU8NAiAAKAIMIQQMAAALAAsgACgCDCICIAMoArACIgVODQAgAygCPCEGIAAgAkEBajYCDEEAIQQgACABIANBACAGIAJBBnRqIgIQjAQNAyAGIAVBBnRqIQUDQCACQUBrIgIgBU8NASAAIAAoAgxBAWo2AgxBACEEIAAgASADQQAgAhCMBEUNAAsMAwsgAygCICIDRQ0BIABBADYCDCAAIAM2AgAMAAALAAtB6QchBAsgBAvfBQIJfwF+IwBBoAhrIggkAEEAIQkgCEEANgIMQQAhCyACKAIoIgUEQCAFKAIAIQsLAkAgACgCECAEKAIgcUGAgICAeEcNAAJAIAQoAjgiBkUNACAAKAIERQ0AAn8gBQRAIAYgBUEEaiAFKAIAIgUQ7QYNAyAFIAZqIQYLIAYLQYACIAIoAkARAQAgACgCCCINcCEKIAAoAgQhDAJAIAIoAiRFDQAgCiEFA0AgDCAFQQJ0aigCACIHRQRAIAUhCgwCCyAHKAI4IgcEQCAHIAYQ5wZFDQQLIAVBAWogDXAiBSAKRw0ACwsgDCAKQQJ0aiAENgIAIAQoAjghBgsCQCAGRQRAQQAhBiAEIQcMAQsgBi0AAEUEQCAEIQcMAQsgBCEHIAIoAiAiBUUNACAEIQcDQCAIQQA6ABACQCAFKAIoIgZFDQAgBigCAEUNACAIQRBqQYEIIAZBBGoQmwMLIAhBEGpBgQggBCgCOBCcAyAFIAhBEGpBAEEAEIwDIgYgByAGGyEHIAUoAiAiBQ0ACyAEKAI4IQYLIAQgAigCPGtBBnUhBSAGRQRAIAggBTYCACAIQRBqQeGcAiAIEMUGGkEAIQkgACgCACAIQRBqQX0gCEEMahD9AkUNASAIKAIMIAhBEGoQgAQaIAgoAgwQ/wIaIAhBEGohBgtBACEJIAYgC2oiBCAAQRRqEIkERQ0AIAEgBTYCiAggAUF/NgKECCABIAcoAhg2AowIIAEgBygCIDYCkAggBygCHCEFIAFBADYCoAggASAFNgKUCCABIAcpAxAiDj4CmAggASAOQiCIPgKcCCADBEAgASADIAIoAjRrQQR1NgKECCABIAMvAQg2AqAICyABQYAIIAQQmwMgASIFIQQDQAJAAkAgBS0AACIHQS9GDQAgB0HcAEYNACAHDQEgASAENgKACEEBIQkMAwsgBUEBaiEECyAFQQFqIQUMAAALAAsgCEGgCGokACAJC0EBAX8CQCAABEAgACgCABCnAw0BC0EAIQALAkAgAEVBA3RBHCABGyICDQAgACABEIsEIgINAEEBDwsgAhDIAUEACzQBAX8CQCAABEAgACgCABCnAw0BC0EIEMgBQQAPCyAAKAIEIgEEQCABEJEICyAAEJEIQQELrgUBCX8jAEEQayIJJABBACEBIAlBADYCDAJAIAAoArwCRQ0AIAAoAjwhASAAKAKwAiICQQJ0EJAIIgUEQAJAAkACQCACQQFIDQAgASACQQZ0aiECQQAhBgNAAkAgASgCIEF/Sg0AIAEoAjgiA0UNACADQQAQvQMNACABKAI4EK0DDQAgBSAGQQJ0aiABKAI4NgIAIAZBAWohBgsgAUFAayIBIAJJDQALIAZFDQAgBSAGQQRBiQEQ3AYgBSgCACICEKAIQQJqIQdBASEBAkAgBkEBRg0AQQAhBCACIQMDQCAFIAFBAnRqKAIAIgggAxDnBgRAIAgQoAggB2pBAmohByABIQQLIAFBAWoiASAGRg0BIAUgBEECdGooAgAhAwwAAAsACyAHQQFqEJAIIgRFBEAgBRCRCAwDCyAEIQEgAi0AACIDBEAgBCEBA0AgASADOgAAIAFBAWohASACLQABIQMgAkEBaiECIAMNAAsLIAFBjRQ7AAAgBkECSQ0BIAFBAmohAUEAIQNBASEIA0AgBSAIQQJ0aigCACICIAUgA0ECdGooAgAQ5wYEQCACLQAAIgMEQANAIAEgAzoAACABQQFqIQEgAi0AASEDIAJBAWohAiADDQALCyABQY0UOwAAIAghAyABQQJqIQELIAhBAWoiCCAGRw0ACwwBC0EAIQdBARCQCCEECyAFEJEIIARFDQAgACgCvAIiAUF/RgRAIAAgByAAKAIwLwAMEKIDIgE2ArwCCyAAQe6cAkIAIAdBACABQYCAgIB4ciAJQQxqEIYEIgFFBEAgCSgCDCAEIAdBAhCHBCEBIAkoAgwQiAQaCyAAIAAoAswCQf9zcTYCzAIgACAAKAK0AkF/ajYCtAIgBBCRCAwCC0EwIQEgBw0BC0EAIQELIAlBEGokACABCw8AIAAoAgAgASgCABDnBgvmAQEGfyAARQRAQQAPCyAAIQIDQAJAIAEEQCACQQAgAUGAgIAgEJIEIQQMAQsCQCACKAI0BEBBlJ4DKAIAIQUgAigCzAIhAyACQe6cAhCpAyIGRQ0BQYCAEEGAgIAgIANBBHEbIQcgBiEDA0ACQCADLwEIEJgEGiACIABBACAHEJIEIQQgAiAGIAMQqgMhAyAEDQAgAw0BCwsgBRCYBBoMAgsgAiAAQQBBgICAIBCSBCEEDAELQQAhBCAFEJgEGgsgAkHunAIQkwQgAkH5nAIQkwQgAkGFnQIQkwQgAigCICICDQALIAQLbQEBfyMAQRBrIgQkACABIAJBACADIAAoAswCEJQEIgIEQCAEQQA2AgwgAiAEQQxqEJUEIgEEQANAIAQoAgwEQCAAIAEQkwQLIAIgBEEMahCVBCIBDQALCyACEJEICyAEQRBqJABBAEHsByACGwtkAQJ/AkAgACgCOARAIAAgAUEAEIsDIgJFDQEgACACIAEQjQMPCyAAKAI0RQ0AIAAgARCpAyIDRQ0AIAMhAgNAIAAgACgCPCACKAIMQQZ0aiABEI0DIAAgAyACEKoDIgINAAsLC68EAgN/AX4jAEEgayIFJAAgBUEANgIQAkACQCAARQ0AIAENAEEAIQEgAEHunAJBACAFQRBqEP0CRQ0BQQAhASAFKAIQQQAQwwMhACAFQQA2AhgCQCAAQX9qIANPDQBBACEBQQAhAwJ/IAIEQCACEKAIQQFqIQMLIAAgA0EUaiIGakEBagsQkAgiB0UNACAHQQAgBhCaCCIBIAQ2AhAgAwRAIAEgAUEUaiIENgIAIAQgAiADEJkIGgsgASABIANqQRRqIgM2AgQgBSgCECADIAAgBUEYakEAEL8DGiAFKAIYIgAEQCABIAEoAgQiAzYCCCABIAAgA2o2AgwMAQsgARCRCEEAIQELIAUoAhAQ/wIaDAELAkACQCAADQAgAUUNACAFQgA3AwggBSABQYACEMkBIgA2AhAgAEUNASAAIAVBCGoQ4AEaQQAhAQJAIAUpAwgiCEJ/fEL+//8fVg0AIAinIgZBf2ogA08NAEEAIQFBACEAAn8gAgRAIAIQoAhBAWohAAsgBiAAQRRqIgNqQQFqCxCQCCIHRQ0AIAdBACADEJoIIgEgBDYCECAABEAgASABQRRqIgM2AgAgAyACIAAQmQgaCyABIAAgAWpBFGoiADYCBCAFQgA3AxggBSgCECAFQRhqIAAgBhDeAQRAIAEgASgCBCIANgIIIAEgACAGajYCDAwBCyABEJEIQQAhAQsgBSgCEBDNAQwCC0EcEMgBC0EAIQELIAVBIGokACABC78BAQV/AkACQCAAKAIIIgIgACgCDCIGSQRAA0AgAi0AAEF2aiIDQQNLBEAgAiEEDAMLIAIhBAJAIANBAWsOAgMDAAsgACACQQFqIgI2AgggAiAGSQ0ACwtBACECDAELA0ACQCAEIgMgBk8EQCAAIANBAWo2AggMAQsgAy0AACEFIAAgA0EBaiIENgIIIAVBdmoiBUEDSw0BIAVBAWsOAgEBAAsLIANBADoAACABRQ0AIAEgAyACazYCACACDwsgAgvCBgEOfyMAQRBrIgckACAHQQA2AgxB7AchAgJAIAAtAMwCQQRxDQAgAEGSnQJBfiAHQQxqEP0CRQ0AQewHIQICQCAHKAIMQQAQwwMiAUF/Rg0AIAFBAWoQkAgiCEUNACABIAhqIglBADoAACAHKAIMIAggASAHQQhqQQAQvwMaAkAgASAHKAIIRwRAQewHIQIMAQsCfyABQQdMBEAgACgCyAIiBEEBcSEFQQAhAyAIDAELQegHIQIgCCgCAEHkAEcNASAIKAIEIgRBD0sNAQJAIAAoAjAoABwiA0EEdCILIARBHXRBH3VxIANBA3QiDCAEQR50QR91cWogA0ECdCIGQQhqQQggBEEBcSIFG2oiCiAEQRx0QR91Ig0gA0EGakEDdnEiDmogAUYNACABIAZBBGpBCCAFGyAMQXhqQQAgBEECcRtqIAtBcGpBACAEQQRxG2ogDmpGBEAgA0F/aiEDDAELIAEgCkYNACAKIAYgDXFqIAFHDQILIANFDQEgACAENgLIAiAIQQhqCyEBIAUEQCABIANBAnRqIgYgCUsEQEHsByECDAILIAMEQCAAKAI8IQVBACECA0AgBSACQQZ0aiABIAJBAnRqKAIANgIkIAJBAWoiAiADRw0ACwsgBiEBCyAEQQJxBEAgASADQQN0aiIGIAlLBEBB7AchAgwCCyADBEAgACgCPCEFQQAhAgNAIAUgAkEGdGogASACQQN0aikDADcDECACQQFqIgIgA0cNAAsLIAYhAQsCQCAEQQRxRQRAIAEhBgwBC0HsByECIAEgA0EEdGoiBiAJSw0BIANFDQBBACECA0AgACgCPCACQQZ0aiIFIAEpAAA3ACggBSABKQAINwAwIAFBEGohASACQQFqIgIgA0cNAAsgACgCyAIhBAtBACECIARBCHFFDQAgA0UNACAGIANBB2pBA3ZqIAlHDQAgACgCPCEEQQAhAkGAASEAQQAhAUEAIQUDQCAEIAVBBnRqIgkgCSgCICAAIAEgBmotAABxQQBHQRR0cjYCICAAQQFxIAFqIQEgAEEHdCAAQQF2ciEAIAVBAWoiBSADRw0ACwsgCBCRCAsgBygCDBD/AhoLIAdBEGokACACC6oFAQp/IwBBEGsiCCQAQQAhASAIQQA2AgwCQCAAKALAAkUNACAAKAI8IgIgACgCMCgAHCIEQQZ0aiEGAkAgBEEATA0AIAIhAQNAIAEtACJBEHFFBEAgAUFAayIBIAZJDQEMAgsLIAAgACgCyAJBCHI2AsgCCyAEQQR0IAAoAsgCIgVBHXRBH3VxIARBA3QgBUEedEEfdXFqIARBAnRBCGpBCCAFQQFxIgMbaiAEQQZqQQN2IAVBHHRBH3VxaiIJQQFqIgEQkAgiBwRAIAVBAnEhCiAHQQAgARCaCCIHIAVBD3E2AgQgB0HkADYCACAHQQhqIQECQCADRQ0AIARBAUgNACACIQMDQCABIAMoAiQ2AgAgAUEEaiEBIANBQGsiAyAGSQ0ACyAAKALIAiIFQQJxIQoLAkAgCkUNACAEQQFIDQAgAiEDA0AgASADKQMQNwMAIAFBCGohASADQUBrIgMgBkkNAAsLAkAgBEEBSA0AIAVBBHFFDQADQCABIAIpACg3AAAgASACKQAwNwAIIAFBEGohASACQUBrIgIgBkkNAAsgACgCyAIhBQsCQCAFQQhxRQ0AIAAoAjwiAyAGTw0AQQAhBEGAASECA0AgAy0AIkEQcQRAIAEgBGoiBSAFLQAAIAJyOgAACyAEIAJBAXFqIQQgAkEHdCACQf4BcUEBdnIhAiADQUBrIgMgBkkNAAsLIAAoAsACIgFBf0YEQCAAIAkgACgCMC8ADBCiAyIBNgLAAgsgAEGSnQJCACAJQQAgAUGAgICAeHIgCEEMahCGBCIBRQRAIAgoAgwgByAJQQIQhwQhASAIKAIMEIgEGgsgACAAKALMAkH/T3E2AswCIAAgACgCtAJBf2o2ArQCIAcQkQgMAQtBMEEAIAkbIQELIAhBEGokACABCw0AQZSeAyAANgIAIAALmwwCDX8DfiMAQSBrIgQkAEEAIQogBEEANgIcIARCADcDEAJAAkACQCAARQ0AIANFDQAgAC0AAA0BC0EcEMgBDAELEJ0DIAAgAkH//wNxIAJBgIAgcSIHQQl2QYAIc3IQyQEiAEUEQEEAIQoMAQsgACAEQRBqEOABGkEAIQpB6AchCQJAAkAgBCkDECIRQiBaBEAgBEH4AhCQCCIFNgIcAkAgBUUNAEGAIBCQCCIIRQ0AIARCADcDCEEAIQEgBEEANgIEIAVBAEH4AhCaCCIFIAA2AgAgBUHcADYCQCAAIARBBGoQ4wEaIAQoAhwiACAAKALMAiAEKAIEQQh2QQFxIAJBDnZBgAFxIAJBD3ZBIHFycnI2AswCAkAgBCkDCCISIBFCgICAwAAgEUKAgIDAAFQbIhNUBEBBACEBAn8gACgCACAEQQhqIAggBCkDECASfSIRQoAgIBFCgCBUG6ciCxDeAQRAIAJBgIAQcSEOA0AgBCkDCCIRUARAAkAgCCgCACIAQdKSmbIERw0AIAgoAghBwaylggJHDQAgCCgCDEHMks2iBUcNAEGQzgAhBQwGCyAIKAIERSAAQciazbkFRnEhAQsCQCALRQ0AIAQoAhwiBkHUAGohDyAHIAEiDHJFIRBBACEAIAQpAxAhEgNAIA8gACAIakHQARCZCCINKAIAIQUCQAJAIBBFDQAgBUHNoMXaAUcNACAGKAIsDQAgBigCYCAGKAJYIgVLDQEgBSAGKAJcIgVLDQEgESAFrXxCIHwgEloNASAGIBE3AwggBiAGQcQAajYCLCAGIA0pAgA3AkQgBiANKQIIIhI3AkwgBCARIBJC/////w+DfDcDCAwDCwJAIAVBzaDF0gFHDQAgBigCWEEgSQ0AIAYgESASIAIgDBCCAwwGCyAMDQAgBUHNoK3SAUcNACAGIBIgAhD3AQwFCyAOBEBBigEhBQwHCyAEIBFCgAR8IhE3AwggAEGABGoiACALSQ0ACwtBACAEKQMIIhEgE1oNAhogBCgCHCgCACAEQQhqIAggBCkDECARfSIRQoAgIBFCgCBUG6ciCxDeAQ0ACwsQxwELIgUNAQsgBCkDCCERIAQoAhwiACgCLEUEQCAAIBE3AwgLIAAgETcDECAAIABB1ABqIgY2AjAgACAEKQMQIhI3AxggESASVARAQQAhBSAGLwAODQELQegHIQULQQAhACAFBEAgBSEJDAMLIAQoAhwiBigCMCEFIAcEQCAFQSA2AAQgBUEAOwAMIAZBADYCLCAGIAYoAswCQQFyNgLMAgsgASEHIAUgBSgAHEH/////AHE2ABwgBSAFKAAYQf////8AcTYAGCACQYCADHEEQCAGIAYoAswCQQFyNgLMAgsgBwRAIAYgBigCzAJBgAJyNgLMAgsgBkGABCAFLwAOdDYCuAIgBCkDECERIAUpADwiElBFBEAgBikDECASfCARVg0DCyAFKQA0IhJQRQRAIAYpAxAgEnwgEVYNAwtBACAFMwAoIhJQIAUoABAiBxtFBEAgBiAHrSASQiCGhBCAAyARVg0DC0EAIAUzACoiElAgBSgAFCIHG0UEQCAGIAetIBJCIIaEEIADIBFWDQMLIAUpACAiElBFBEAgBikDECASfCARVg0DCyAEKAIcEJUDIgkNAiAEKAIcEJYDIgchCQJAIAcgAkGAgARxcg0AQQAhCSAEKAIcQZ+dAkEAEIsDIgVFDQBBACEJIAQoAhxBABCRBBogBCgCHCAFKAIgNgK8AgsCQAJAIAJBgIAIcSAHcg0AIAQoAhwiAi0AzAJBEHENACACQaqdAkEAEIsDIgJFDQAgBCgCHBCWBBogBCgCHCACKAIgNgLAAiAHRQ0BQQAhAAwECyAHDQMLAkAgBCgCHEG3nQJBABCLAyIKRQRAIAQoAhwhAAwBCyAEKAIcIgAgCigCIDYCxAILQQEhCiAAIAAoAswCIgJBAnZBAXEgAnI2AswCDAMLQTAhCQtBACEICyAAEM0BIARBHGoQvAMgCRDIASAEQQA2AhxBACEACyADIAgEfyAIEJEIIAQoAhwFIAALNgIACyAEQSBqJAAgCguEAgEDfwJAAkAgABCnAyIARQRAQQgQyAEMAQtBASEDIAAoAswCIgFBAnFFDQEgACABQcAAcjYCzAIgABCXAxpBACEBAkACfwJ/IAAoAswCIgJBgIABcQRAIAAQ/AMhASAAKALMAiECCyACQYAIcQsEQCAAEI8EIgIgASACGyEBIAAoAswCIQILIAJBgCBxCwR/IAAQlwQiAiABIAIbIQEgACgCzAIFIAILQQJxRQ0AIAAoAjgEQCAAEJgDGgsgABCZAyICIAEgAhshASAAKALEAkUNACAAEP0DIgIgASACGyEBCyAAIAAoAswCQb9/cTYCzAIgAUUNASABEMgBC0EAIQMLIAMLTQECfyMAQRBrIgEkACABIAAQpwMiAjYCDAJAIAJFBEBBCBDIAUEAIQAMAQsgAkIANwLUAiAAEJoEIQAgAUEMahC8AwsgAUEQaiQAIAALCgAgACgCABCbBAsKACAAKAIAEP8CCwoAIAAoAgAQjgQLLAEBf0EEEPUGIgQQoAQaIAQgACgCACABEKEEIAIgAxChBBCKBCIBNgIAIAELCwAgAEEANgIAIAALBwAgABCiBAsKACAAEMEFEP0BCwoAIAAgARCkBBoLLwEBfyMAQRBrIgIkACAAIAJBCGogAhClBBogACABIAEQpgQQ/AYgAkEQaiQAIAALHAAgARD9ARogABD9ARogAhD9ARogABDHBRogAAsHACAAEKAICw4AIAAgASgCgAgQpAQaC7YBAQJ/IwBBEGsiAiQAIAAQqQQgAEHDnQIgAiABEKoEIgMQqwQgAxCsBBogAEHMnQIgAiABKAKACBCkBCIDEK0EIAMQ/QYaIABB1p0CIAFBhAhqEK4EIABB4J0CIAFBiAhqEK4EIABB650CIAFBjAhqEK4EIABB9J0CIAFBlAhqEK4EIABB/Z0CIAFBmAhqEK4EIABBiJ4CIAFBnAhqEK4EIABBk54CIAFBoAhqEK4EIAJBEGokAAsKACAAEAIQrwQaCw0AIAAgARAENgIAIAALNQEBfyMAQRBrIgMkACAAKAIAIANBCGogARCqBCIBKAIAIAIoAgAQAyABEKwEGiADQRBqJAALCwAgACgCABAFIAALQgEBfyMAQRBrIgMkACAAKAIAIANBCGogARCqBCIBKAIAIAMgAhCwBCICKAIAEAMgAhCsBBogARCsBBogA0EQaiQAC0IBAX8jAEEQayIDJAAgACgCACADQQhqIAEQqgQiASgCACADIAIQsQQiAigCABADIAIQrAQaIAEQrAQaIANBEGokAAsLACAAIAE2AgAgAAs0AQF/IwBBEGsiAiQAIAJBCGogARD9ARC7BSEBIAAQ9wQgARC3BRAKNgIAIAJBEGokACAACzQBAX8jAEEQayICJAAgAkEIaiABEP0BEOMFIQEgABD7BCABELcFEAo2AgAgAkEQaiQAIAALDAAgACgCACABEI0ECw8AIAAoAgAgASgCBBCABAsPACAAKAIAIAEoAgAQwwMLDwAgACgCACABEKEEEP4CCxAAIAAQoQQgASACIAMQmQQLFgAgACgCACABEKEEIAIQoQQgAxCFBAsTACAAKAIAIAEQoQQgAiADEP0CCxsAIAAoAgAgASgCBCACIAMoAgAgBCgCABC/AwsTACAAKAIAIAEgAigCACADEMQDCwoAQaDGAxC8BBoLqAoBA38jAEFAaiIBJAAQvQQQvgQhAhC+BCEDEL8EEMAEEMEEEL4EEMIEQYoBEMQEIAIQxAQgA0GangIQxQRBiwEQBkGMARDIBCABQQA2AjwgAUGNATYCOCABIAEpAzg3AzBBnp4CIAFBMGoQyQQgAUEANgI8IAFBjgE2AjggASABKQM4NwMoQaaeAiABQShqEMsEEL0EEL4EIQIQvgQhAxDMBBDNBBDOBBC+BBDCBEGPARDEBCACEMQEIANBq54CEMUEQZABEAZBkQEQ0gQgAUEANgI8IAFBkgE2AjggASABKQM4NwMgQa+eAiABQSBqENMEIAFBADYCPCABQZMBNgI4IAEgASkDODcDGEG3ngIgAUEYahDVBBC9BBC+BCECEL4EIQMQ1gQQ1wQQ2AQQvgQQwgRBlAEQxAQgAhDEBCADQb6eAhDFBEGVARAGQZYBENoEIAFBADYCPCABQZcBNgI4IAEgASkDODcDEEGengIgAUEQahDbBCABQQA2AjwgAUGYATYCOCABIAEpAzg3AwhBpp4CIAFBCGoQ3QQQvQQQ3gQhAhDfBCEDEOAEEOEEEOIEEOMEEMIEQZkBEMIEIAIQwgQgA0HCngIQxQRBmgEQBkGbARDmBBC9BBDnBCECEOgEIQMQ6QQQ6gQQ6wQQ4wQQwgRBnAEQwgQgAhDCBCADQcqeAhDFBEGdARAGQZ4BEO4EIAFBADYCPCABQZ8BNgI4IAEgASkDODcDAEGmngIgARDwBBC9BBC+BCECEL4EIQMQ8QQQ8gQQ8wQQvgQQwgRBoAEQxAQgAhDEBCADQdSeAhDFBEGhARAGQaIBEPYEEPEEQcOdAhD3BBD4BEGjAUGkARD6BEEAQQBBAEEAEAcQ8QRBzJ0CEPcEEPgEQaMBQaUBEPoEQQBBAEEAQQAQByABQYQINgI4EPEEQdadAhD7BBD4BEGmASABQThqEP0EEPsEEP4EQacBIAFBOGoQ/QQQByABQYgINgI4EPEEQeCdAhD7BBD4BEGmASABQThqEP0EEPsEEP4EQacBIAFBOGoQ/QQQByABQYwINgI4EPEEQeudAhD7BBD4BEGmASABQThqEP0EEPsEEP4EQacBIAFBOGoQ/QQQByABQZQINgI4EPEEQfSdAhD7BBD4BEGmASABQThqEP0EEPsEEP4EQacBIAFBOGoQ/QQQByABQZgINgI4EPEEQf2dAhD7BBD4BEGmASABQThqEP0EEPsEEP4EQacBIAFBOGoQ/QQQByABQZwINgI4EPEEQYieAhD7BBD4BEGmASABQThqEP0EEPsEEP4EQacBIAFBOGoQ/QQQByABQaAINgI4EPEEQZOeAhD7BBD4BEGmASABQThqEP0EEPsEEP4EQacBIAFBOGoQ/QQQB0GmngJBqAEQgAVB4p4CQakBEIEFQe+eAkGqARCCBUGBnwJBqwEQggVBkJ8CQawBEIIFQZ+fAkGtARCDBUGynwJBrgEQhAVBxJ8CQa8BEIUFQdWfAkGwARCGBUHmnwJBsQEQhwVB858CQbIBEIgFQYSgAkGzARCJBUGaoAJBtAEQigVBqqACQbUBEIsFQbigAkG2ARCMBSABQSw2AjhBzKACIAFBOGoQjQUgAUHpBzYCOEHhoAIgAUE4ahCNBSABQQA2AjhB9aACIAFBOGoQjQUgAUGACDYCOEGAoQIgAUE4ahCNBSABQX82AjhBiaECIAFBOGoQjgUgAUGAAjYCOEGcoQIgAUE4ahCNBSABQUBrJAAgAAsDAAELBABBAAsFABDnBQsFABDoBQsFABDpBQsGAEHsowILBwAgABDlBQsGAEHvowILBgBB8aMCCw4AIAAEQCAAEOYFEDcLCxIAQQgQ9QYgABD9ASgCABDqBQsxAQF/IwBBEGsiASQAEL8EIAFBCGoQlQUgAUEIahDrBRD4BEG3ASAAEA0gAUEQaiQACz8BAX8jAEEQayICJAAgAiABKQIANwMIEL8EIAAgAhCVBSACEO4FEPgEQbgBIAJBCGoQ8AVBABAOIAJBEGokAAsxAQF/IwBBEGsiAiQAIAJBCGogASgCACABKAIEEI8FIAAgAkEIahCQBRogAkEQaiQACz8BAX8jAEEQayICJAAgAiABKQIANwMIEL8EIAAgAhCVBSACEPIFEPgEQbkBIAJBCGoQ8AVBABAOIAJBEGokAAsFABD3BQsFABD4BQsFABD5BQsHACAAEPYFCwsAIAAEQCAAEDcLCwoAQQQQ9QYQoAQLMQEBfyMAQRBrIgEkABDMBCABQQhqEJIFIAFBCGoQ+gUQwgRBugEgABANIAFBEGokAAs/AQF/IwBBEGsiAiQAIAIgASkCADcDCBDMBCAAIAIQlQUgAhD9BRD4BEG7ASACQQhqEPAFQQAQDiACQRBqJAALCAAgACgCAEULPwEBfyMAQRBrIgIkACACIAEpAgA3AwgQzAQgACACEJUFIAIQ/wUQ+ARBvAEgAkEIahDwBUEAEA4gAkEQaiQACwUAEIMGCwUAEIQGCwUAEIUGCwcAIAAQggYLMQEBfyMAQRBrIgEkABDWBCABQQhqEJUFIAFBCGoQhgYQ+ARBvQEgABANIAFBEGokAAs/AQF/IwBBEGsiAiQAIAIgASkCADcDCBDWBCAAIAIQlQUgAhCIBhD4BEG+ASACQQhqEPAFQQAQDiACQRBqJAALLAEBfyMAQRBrIgIkACAAIAIgASgCBBCkBCIBEJEFGiABEP0GGiACQRBqJAALPwEBfyMAQRBrIgIkACACIAEpAgA3AwgQ1gQgACACEJUFIAIQigYQ+ARBvwEgAkEIahDwBUEAEA4gAkEQaiQACwUAQcABCwUAQcEBCwUAEI0GCwUAEI4GCwUAEI8GCwUAEMwECwcAIAAQjAYLCgBBBBD1BhCQBgsxAQF/IwBBEGsiASQAEOAEIAFBCGoQkgUgAUEIahCRBhDCBEHCASAAEA0gAUEQaiQACwUAQcMBCwUAQcQBCwUAEJQGCwUAEJUGCwUAEJYGCwcAIAAQkwYLCgBBBBD1BhCXBgsxAQF/IwBBEGsiASQAEOkEIAFBCGoQkgUgAUEIahCYBhDCBEHFASAAEA0gAUEQaiQACwoAIAAoAgAoAgALPwEBfyMAQRBrIgIkACACIAEpAgA3AwgQ6QQgACACEJUFIAIQmgYQ+ARBxgEgAkEIahDwBUEAEA4gAkEQaiQACwUAEJ0GCwUAEJ4GCwUAEJ8GCwcAIAAQnAYLEABBpAgQ9QZBAEGkCBCaCAsxAQF/IwBBEGsiASQAEPEEIAFBCGoQkgUgAUEIahCgBhDCBEHHASAAEA0gAUEQaiQACwUAEL4FCwYAQfyjAgsvAQF/IwBBEGsiAiQAIAIgASAAKAIAEQUAIAIQvAUhASACEP0GGiACQRBqJAAgAQsnAQF/IwBBEGsiASQAIAEgADYCDCABQQxqEP0EIQAgAUEQaiQAIAALBQAQ5AULDQAgASAAKAIAahClAgsVAQF/QQQQ9QYiASAAKAIANgIAIAELBgBBjKgCCxYAIAIQ/QEhAiABIAAoAgBqIAI2AgALQgEBfyMAQRBrIgIkACACIAE2AgwQ8QQgACACQQhqEJUFIAJBCGoQogYQ+ARByAEgAkEMahD9BEEAEA4gAkEQaiQACzABAX8jAEEQayICJAAgACACQQhqEJIFIAJBCGoQkwUQwgRByQEgARAIIAJBEGokAAswAQF/IwBBEGsiAiQAIAAgAkEIahCVBSACQQhqEJYFEPgEQcoBIAEQCCACQRBqJAALMAEBfyMAQRBrIgIkACAAIAJBCGoQmAUgAkEIahCZBRCaBUHLASABEAggAkEQaiQACzABAX8jAEEQayICJAAgACACQQhqEJwFIAJBCGoQnQUQngVBzAEgARAIIAJBEGokAAswAQF/IwBBEGsiAiQAIAAgAkEIahCcBSACQQhqEKAFEJ4FQc0BIAEQCCACQRBqJAALMAEBfyMAQRBrIgIkACAAIAJBCGoQnAUgAkEIahChBRCeBUHOASABEAggAkEQaiQACzABAX8jAEEQayICJAAgACACQQhqEJwFIAJBCGoQowUQngVBzwEgARAIIAJBEGokAAswAQF/IwBBEGsiAiQAIAAgAkEIahCYBSACQQhqEKUFEJoFQdABIAEQCCACQRBqJAALMAEBfyMAQRBrIgIkACAAIAJBCGoQmAUgAkEIahCnBRCaBUHRASABEAggAkEQaiQACzABAX8jAEEQayICJAAgACACQQhqEJgFIAJBCGoQqQUQmgVB0gEgARAIIAJBEGokAAswAQF/IwBBEGsiAiQAIAAgAkEIahCrBSACQQhqEKwFEK0FQdMBIAEQCCACQRBqJAALMAEBfyMAQRBrIgIkACAAIAJBCGoQmAUgAkEIahCvBRCaBUHUASABEAggAkEQaiQACxEAIAAQsQUgARClAhCyBRAJCxEAIAAQ+wQgARClAhCzBRAJCwwAIAAgASACELQFGgs0AQF/IwBBEGsiAiQAIAJBCGogARD9ARC1BSEBIAAQtgUgARC3BRAKNgIAIAJBEGokACAACzQBAX8jAEEQayICJAAgAkEIaiABEP0BELsFIQEgABD3BCABELcFEAo2AgAgAkEQaiQAIAALBABBAQsFABClBgsqAQF/IwBBEGsiASQAIAEgABEDADYCDCABQQxqEKUCIQAgAUEQaiQAIAALBABBAgsFABCmBgsPACABEP0BIAARAgAQ/QELBABBBQsFABCpBgsGAEHEqAILbAEBfyMAQTBrIgUkACABEP0BIQEgBUEYaiACEKcGIAMQ/QEhAyAFQQhqIAQQpwYgBSABIAVBGGogAyAFQQhqIAARBAA2AiggBUEoahCoBiEAIAVBCGoQ/QYaIAVBGGoQ/QYaIAVBMGokACAACwQAQQMLBQAQqwYLBgBB2KgCCxQAIAEQ/QEgAhD9ASAAEQEAEP0BCwUAEKwGCwUAEK0GCzQBAX8jAEEQayIDJAAgAyABEP0BIAIQ/QEgABEBADYCDCADQQxqEKUCIQEgA0EQaiQAIAELBQAQrgYLOAEBfyMAQRBrIgMkACABEP0BIQEgAyACEKcGIAEgAyAAEQEAEP0BIQAgAxD9BhogA0EQaiQAIAALBQAQrwYLPgEBfyMAQRBrIgUkACAFIAEQpwYgBSACEP0BIAMQ/QEgBBD9ASAAEQQAEP0BIQIgBRD9BhogBUEQaiQAIAILBQAQsAYLVQEBfyMAQSBrIgUkACABEP0BIQEgBUEQaiACEKcGIAUgAxCnBiABIAVBEGogBSAEEP0BIAARBAAQ/QEhBCAFEP0GGiAFQRBqEP0GGiAFQSBqJAAgBAsFABCxBgtCAQF/IwBBEGsiBSQAIAEQ/QEhASAFIAIQpwYgASAFIAMQ/QEgBBD9ASAAEQQAEP0BIQMgBRD9BhogBUEQaiQAIAMLBABBBgsFABCyBgsGAEGIqgILIwAgARD9ASACEP0BIAMQ/QEgBBD9ASAFEP0BIAARBwAQ/QELBQAQswYLPgEBfyMAQRBrIgUkACAFIAEQ/QEgAhD9ASADEP0BIAQQ/QEgABEEADYCDCAFQQxqEKUCIQEgBUEQaiQAIAELBQAQtAYLBQAgALcLBQAgALgLEgAgACACNgIEIAAgATYCACAAC0UBAX8jAEEQayICJAAgAiAAEP0BNgIEIAJBCGogARD9ARD9ARC4BSACQQRqIAJBCGoQuQUgAkEEahDxASACQRBqJAAgAAsFABC6BQsHACAAEP0BCwwAIAAgASkCADcCAAspACAAKAIAIAEoAgA2AgAgACgCACABKAIENgIEIAAgACgCAEEIajYCAAsGAEHUoQILOwEBfyMAQRBrIgIkACACIAAQ/QE2AgwgAkEMaiABEP0BEP0BELwFEL0FIAJBDGoQ8QEgAkEQaiQAIAALLgEBfyAAEL8FQQRqEJAIIgEgABC/BTYCACABQQRqIAAQogQgABC/BRCZCBogAQsZACAAKAIAIAE2AgAgACAAKAIAQQhqNgIACwYAQcyiAgsHACAAEMAFCxUAIAAQwgUEQCAAEMMFDwsgABDEBQsVACAAEMIFBEAgABDFBQ8LIAAQxgULDQAgABC3BSwAC0EASAsKACAAELcFKAIECwoAIAAQtwUtAAsLCgAgABC3BSgCAAsKACAAELcFELcFCwoAIAAQ/QEaIAALDQAgABDJBRDKBUFwagsHACAAELcFCwcAIAAQ1wULDAAgABC3BSABOgALCwoAIAAQtwUQtwULKgEBf0EKIQEgAEELTwR/IABBAWoQzgUiACAAQX9qIgAgAEELRhsFIAELCwoAIABBD2pBcHELCwAgACABQQAQ0AULHAAgABDYBSABSQRAQeSiAhDZBQALIAFBARDaBQsHACAAELcFCwwAIAAQtwUgATYCAAsTACAAELcFIAFBgICAgHhyNgIICwwAIAAQtwUgATYCBAsTACACBEAgACABIAIQmQgaCyAACwwAIAAgAS0AADoAAAsHACAAENgFCwQAQX8LHAEBf0EIEAsiASAAENsFGiABQYixAkHVARAMAAsHACAAEPUGCxUAIAAgARD6BhogAEHosAI2AgAgAAsLACAAIAEgAhDdBQsLACABIAJBARDgBQsKACAAELcFKAIACxEAIAAQtwUoAghB/////wdxCwsAIAAgASACEOEFCwkAIAAgARDiBQsHACAAEMMBCzsBAX8jAEEQayICJAAgAiAAEP0BNgIMIAJBDGogARD9ARD9ARClAhC9BSACQQxqEPEBIAJBEGokACAACwYAQZy1AgsGAEGwowILFAEBfyAAKAIEIgEEQCABEDcLIAALBgBBsKMCCwYAQcCjAgsGAEHcowILFQAgACABNgIAIAAgARD2BjYCBCAACwUAEO0FCy8BAX8jAEEQayICJAAgAiABELcFNgIMIAJBDGogABECABD9ASEAIAJBEGokACAACwYAQfSjAgsFABDxBQtZAQJ/IwBBEGsiAiQAIAEQ/QEgACgCBCIDQQF1aiEBIAAoAgAhACACIAEgA0EBcQR/IAEoAgAgAGooAgAFIAALEQIANgIMIAJBDGoQpQIhACACQRBqJAAgAAsVAQF/QQgQ9QYiASAAKQIANwMAIAELBgBBgKQCCwUAEPUFC2IBAn8jAEEQayICJAAgARD9ASAAKAIEIgNBAXVqIQEgACgCACEAIAJBCGogASADQQFxBH8gASgCACAAaigCAAUgAAsRBQAgAkEIahD0BSEAIAJBCGoQrAQaIAJBEGokACAACw4AIAAoAgAQDyAAKAIACwYAQYikAgsGAEG0pAILBgBBtKQCCwYAQcSkAgsGAEHgpAILBQAQ/AULCgAgABEDABD9AQsGAEHwpAILBQAQ/gULBgBB9KQCCwUAEIEGCzsBAX8gARD9ASAAKAIEIgJBAXVqIQEgACgCACEAIAEgAkEBcQR/IAEoAgAgAGooAgAFIAALEQIAEP0BCwYAQfykAgsGAEGMpQILBgBBjKUCCwYAQZylAgsGAEG4pQILBQAQhwYLBgBByKUCCwUAEIkGCwYAQdClAgsFABCLBgsGAEHYpQILBgBB7KUCCwYAQeylAgsGAEGEpgILBgBBpKYCCwoAIAAQoAQaIAALBQAQkgYLBgBBtKYCCwYAQcimAgsGAEHIpgILBgBB5KYCCwYAQYSnAgstAQF/IwBBEGsiASQAIAAQoAQaIAFBADYCDCAAIAFBDGo2AgAgAUEQaiQAIAALBQAQmQYLBgBBlKcCCwUAEJsGCwYAQZinAgsGAEG0pwILBgBBtKcCCwYAQdCnAgsGAEH4pwILBQAQoQYLBgBBiKgCCwUAEKQGCz8BAX8jAEEQayICJAAgACgCACEAIAJBCGogARD9ASAAEQUAIAJBCGoQ9AUhASACQQhqEKwEGiACQRBqJAAgAQsGAEGUqAILBgBBnKgCCwYAQaCoAgsSACAAIAFBBGogASgCABCqBhoLGAEBf0EEEPUGIgEgABD9ASgCADYCACABCwYAQbCoAgssAQF/IwBBEGsiAyQAIAAgA0EIaiADEKUEGiAAIAEgAhD8BiADQRBqJAAgAAsGAEHMqAILBgBB4KgCCwYAQeyoAgsGAEH4qAILBgBBkKkCCwYAQbCpAgsGAEHQqQILBgBB8KkCCwYAQZCqAgsGAEGQtQILBQAQuwQLCwAgAEGff2pBGkkLEAAgAEHfAHEgACAAELYGGwsGAEGkxgMLSgEBfyMAQRBrIgMkACADIAFBwICAAnEEfyADIAJBBGo2AgwgAigCAAVBAAs2AgAgACABQYCAAnIgAxAQELoGIQEgA0EQaiQAIAELGwAgAEGBYE8EfxC4BkEAIABrNgIAQX8FIAALC1QAIAVC/5+AgICAfINQRQRAELgGQRw2AgBBfw8LIAFB/////wdPBEAQuAZBMDYCAEF/DwsgA0EQcQRAEL0ECyAAIAEgAiADIAQgBUIMiKcQERC6BgsOABC9BCAAIAEQEhC6BguiAQEDf0EAIQIDQCAAIAJqIgQgAkGkqgJqLQAAOgAAIAJBDkchAyACQQFqIQIgAw0ACyABBEBBDiECIAEhAwNAIAJBAWohAiADQQlLIQQgA0EKbiEDIAQNAAsgACACakEAOgAAA0AgACACQX9qIgJqIAEgAUEKbiIDQQpsa0EwcjoAACABQQlLIQQgAyEBIAQNAAsPCyAEQTA6AAAgAEEAOgAPC0oBAn8jAEEgayICJAACfwJAIAAgARATIgNBeEYEQCAAEPQGDQELIAMQugYMAQsgAiAAEL0GIAIgARAUELoGCyEAIAJBIGokACAACzYBAX8jAEEQayIDJAAgACgCPCABIAJB/wFxIANBCGoQvAgQ8wYaIAMpAwghASADQRBqJAAgAQvJAgEGfyMAQSBrIgMkACADIAAoAhwiBDYCECAAKAIUIQUgAyACNgIcIAMgATYCGCADIAUgBGsiATYCFCABIAJqIQVBAiEGIANBEGohAQJ/AkACQCAAKAI8IANBEGpBAiADQQxqEBUQ8wZFBEADQCAFIAMoAgwiBEYNAiAEQX9MDQMgAUEIaiABIAQgASgCBCIHSyIIGyIBIAQgB0EAIAgbayIHIAEoAgBqNgIAIAEgASgCBCAHazYCBCAFIARrIQUgACgCPCABIAYgCGsiBiADQQxqEBUQ8wZFDQALCyADQX82AgwgBUF/Rw0BCyAAIAAoAiwiATYCHCAAIAE2AhQgACABIAAoAjBqNgIQIAIMAQsgAEEANgIcIABCADcDECAAIAAoAgBBIHI2AgBBACAGQQJGDQAaIAIgASgCBGsLIQQgA0EgaiQAIAQLDAAgACgCPBD9ARAWCygBAX8jAEEQayIDJAAgAyACNgIMIAAgASACENcGIQIgA0EQaiQAIAILKAEBfyMAQRBrIgMkACADIAI2AgwgACABIAIQ2AYhAiADQRBqJAAgAgufAQECfwJAIAEoAkxBAE4EQCABEJIFDQELAkAgAEH/AXEiAyABLABLRg0AIAEoAhQiAiABKAIQTw0AIAEgAkEBajYCFCACIAA6AAAgAw8LIAEgABCdCA8LAkACQCAAQf8BcSIDIAEsAEtGDQAgASgCFCICIAEoAhBPDQAgASACQQFqNgIUIAIgADoAAAwBCyABIAAQnQghAwsgARDxASADCygBAX8jAEEQayIDJAAgAyACNgIMIAAgASACENsGIQIgA0EQaiQAIAILCgAgAEFQakEKSQsGAEHQ9gILlgIAQQEhAgJAIAAEfyABQf8ATQ0BAkAQyQYoArABKAIARQRAIAFBgH9xQYC/A0YNAxC4BkEZNgIADAELIAFB/w9NBEAgACABQT9xQYABcjoAASAAIAFBBnZBwAFyOgAAQQIPCyABQYCwA09BACABQYBAcUGAwANHG0UEQCAAIAFBP3FBgAFyOgACIAAgAUEMdkHgAXI6AAAgACABQQZ2QT9xQYABcjoAAUEDDwsgAUGAgHxqQf//P00EQCAAIAFBP3FBgAFyOgADIAAgAUESdkHwAXI6AAAgACABQQZ2QT9xQYABcjoAAiAAIAFBDHZBP3FBgAFyOgABQQQPCxC4BkEZNgIAC0F/BSACCw8LIAAgAToAAEEBCwUAEMcGCxQAIABFBEBBAA8LIAAgAUEAEMgGC38CAX8BfiAAvSIDQjSIp0H/D3EiAkH/D0cEfCACRQRAIAEgAEQAAAAAAAAAAGEEf0EABSAARAAAAAAAAPBDoiABEMsGIQAgASgCAEFAags2AgAgAA8LIAEgAkGCeGo2AgAgA0L/////////h4B/g0KAgICAgICA8D+EvwUgAAsLhAMBA38jAEHQAWsiBSQAIAUgAjYCzAFBACECIAVBoAFqQQBBKBCaCBogBSAFKALMATYCyAECQEEAIAEgBUHIAWogBUHQAGogBUGgAWogAyAEEM0GQQBIBEBBfyEBDAELIAAoAkxBAE4EQCAAEJIFIQILIAAoAgAhBiAALABKQQBMBEAgACAGQV9xNgIACyAGQSBxIQYCfyAAKAIwBEAgACABIAVByAFqIAVB0ABqIAVBoAFqIAMgBBDNBgwBCyAAQdAANgIwIAAgBUHQAGo2AhAgACAFNgIcIAAgBTYCFCAAKAIsIQcgACAFNgIsIAAgASAFQcgBaiAFQdAAaiAFQaABaiADIAQQzQYiASAHRQ0AGiAAQQBBACAAKAIkEQAAGiAAQQA2AjAgACAHNgIsIABBADYCHCAAQQA2AhAgACgCFCEDIABBADYCFCABQX8gAxsLIQEgACAAKAIAIgMgBnI2AgBBfyABIANBIHEbIQEgAkUNACAAEPEBCyAFQdABaiQAIAELihICD38BfiMAQdAAayIHJAAgByABNgJMIAdBN2ohFSAHQThqIRJBACETQQAhD0EAIQECQAJAA0ACQCAPQQBIDQAgAUH/////ByAPa0oEQBC4BkE9NgIAQX8hDwwBCyABIA9qIQ8LIAcoAkwiDCEBAkACQAJAAn8CQAJAAkACQAJAAkACQAJAAkAgDC0AACIIBEADQAJAAkACQCAIQf8BcSIIRQRAIAEhCAwBCyAIQSVHDQEgASEIA0AgAS0AAUElRw0BIAcgAUECaiIJNgJMIAhBAWohCCABLQACIQogCSEBIApBJUYNAAsLIAggDGshASAABEAgACAMIAEQzgYLIAENEUF/IRBBASEIIAcoAkwsAAEQxgYhCSAHKAJMIQECQCAJRQ0AIAEtAAJBJEcNACABLAABQVBqIRBBASETQQMhCAsgByABIAhqIgE2AkxBACEIAkAgASwAACIRQWBqIgpBH0sEQCABIQkMAQsgASEJQQEgCnQiCkGJ0QRxRQ0AA0AgByABQQFqIgk2AkwgCCAKciEIIAEsAAEiEUFgaiIKQR9LDQEgCSEBQQEgCnQiCkGJ0QRxDQALCwJAIBFBKkYEQCAHAn8CQCAJLAABEMYGRQ0AIAcoAkwiCS0AAkEkRw0AIAksAAFBAnQgBGpBwH5qQQo2AgAgCSwAAUEDdCADakGAfWooAgAhDkEBIRMgCUEDagwBCyATDRVBACETQQAhDiAABEAgAiACKAIAIgFBBGo2AgAgASgCACEOCyAHKAJMQQFqCyIBNgJMIA5Bf0oNAUEAIA5rIQ4gCEGAwAByIQgMAQsgB0HMAGoQzwYiDkEASA0TIAcoAkwhAQtBfyELAkAgAS0AAEEuRw0AIAEtAAFBKkYEQAJAIAEsAAIQxgZFDQAgBygCTCIBLQADQSRHDQAgASwAAkECdCAEakHAfmpBCjYCACABLAACQQN0IANqQYB9aigCACELIAcgAUEEaiIBNgJMDAILIBMNFCAABH8gAiACKAIAIgFBBGo2AgAgASgCAAVBAAshCyAHIAcoAkxBAmoiATYCTAwBCyAHIAFBAWo2AkwgB0HMAGoQzwYhCyAHKAJMIQELQQAhCQNAIAkhCkF/IQ0gASwAAEG/f2pBOUsNFCAHIAFBAWoiETYCTCABLAAAIQkgESEBIAkgCkE6bGpBj6oCai0AACIJQX9qQQhJDQALIAlFDRMCQAJAAkAgCUETRgRAQX8hDSAQQX9MDQEMFwsgEEEASA0BIAQgEEECdGogCTYCACAHIAMgEEEDdGopAwA3A0ALQQAhASAARQ0TDAELIABFDREgB0FAayAJIAIgBhDQBiAHKAJMIRELIAhB//97cSIUIAggCEGAwABxGyEIQQAhDUG4qgIhECASIQkgEUF/aiwAACIBQV9xIAEgAUEPcUEDRhsgASAKGyIBQah/aiIRQSBNDQECQAJ/AkACQCABQb9/aiIKQQZLBEAgAUHTAEcNFCALRQ0BIAcoAkAMAwsgCkEBaw4DEwETCAtBACEBIABBICAOQQAgCBDRBgwCCyAHQQA2AgwgByAHKQNAPgIIIAcgB0EIajYCQEF/IQsgB0EIagshCUEAIQECQANAIAkoAgAiCkUNAQJAIAdBBGogChDKBiIKQQBIIgwNACAKIAsgAWtLDQAgCUEEaiEJIAsgASAKaiIBSw0BDAILC0F/IQ0gDA0VCyAAQSAgDiABIAgQ0QYgAUUEQEEAIQEMAQtBACEKIAcoAkAhCQNAIAkoAgAiDEUNASAHQQRqIAwQygYiDCAKaiIKIAFKDQEgACAHQQRqIAwQzgYgCUEEaiEJIAogAUkNAAsLIABBICAOIAEgCEGAwABzENEGIA4gASAOIAFKGyEBDBELIAcgAUEBaiIJNgJMIAEtAAEhCCAJIQEMAQsLIBFBAWsOHwwMDAwMDAwMAQwDBAEBAQwEDAwMDAgFBgwMAgwJDAwHCyAPIQ0gAA0PIBNFDQxBASEBA0AgBCABQQJ0aigCACIIBEAgAyABQQN0aiAIIAIgBhDQBkEBIQ0gAUEBaiIBQQpHDQEMEQsLQQEhDSABQQlLDQ8DQCABIghBAWoiAUEKRwRAIAQgAUECdGooAgBFDQELC0F/QQEgCEEJSRshDQwPCyAAIAcrA0AgDiALIAggASAFERYAIQEMDAtBACENIAcoAkAiAUHCqgIgARsiDEEAIAsQ4wYiASALIAxqIAEbIQkgFCEIIAEgDGsgCyABGyELDAkLIAcgBykDQDwAN0EBIQsgFSEMIBIhCSAUIQgMCAsgBykDQCIWQn9XBEAgB0IAIBZ9IhY3A0BBASENQbiqAgwGCyAIQYAQcQRAQQEhDUG5qgIMBgtBuqoCQbiqAiAIQQFxIg0bDAULQQAhDUG4qgIhECAHKQNAIBIQ0gYhDCAIQQhxRQ0FIAsgEiAMayIBQQFqIAsgAUobIQsMBQsgC0EIIAtBCEsbIQsgCEEIciEIQfgAIQELQQAhDUG4qgIhECAHKQNAIBIgAUEgcRDTBiEMIAhBCHFFDQMgBykDQFANAyABQQR2QbiqAmohEEECIQ0MAwtBACEBIApB/wFxIghBB0sNBQJAAkACQAJAAkACQAJAIAhBAWsOBwECAwQMBQYACyAHKAJAIA82AgAMCwsgBygCQCAPNgIADAoLIAcoAkAgD6w3AwAMCQsgBygCQCAPOwEADAgLIAcoAkAgDzoAAAwHCyAHKAJAIA82AgAMBgsgBygCQCAPrDcDAAwFC0EAIQ0gBykDQCEWQbiqAgshECAWIBIQ1AYhDAsgCEH//3txIAggC0F/ShshCCAHKQNAIRYCfwJAIAsNACAWUEUNACASIQxBAAwBCyALIBZQIBIgDGtqIgEgCyABShsLIQsgEiEJCyAAQSAgDSAJIAxrIgogCyALIApIGyIRaiIJIA4gDiAJSBsiASAJIAgQ0QYgACAQIA0QzgYgAEEwIAEgCSAIQYCABHMQ0QYgAEEwIBEgCkEAENEGIAAgDCAKEM4GIABBICABIAkgCEGAwABzENEGDAELC0EAIQ0MAQtBfyENCyAHQdAAaiQAIA0LGAAgAC0AAEEgcUUEQCABIAIgABCeCBoLC0gBA39BACEBIAAoAgAsAAAQxgYEQANAIAAoAgAiAiwAACEDIAAgAkEBajYCACADIAFBCmxqQVBqIQEgAiwAARDGBg0ACwsgAQvGAgACQCABQRRLDQAgAUF3aiIBQQlLDQACQAJAAkACQAJAAkACQAJAAkACQCABQQFrDgkBAgMEBQYHCAkACyACIAIoAgAiAUEEajYCACAAIAEoAgA2AgAPCyACIAIoAgAiAUEEajYCACAAIAE0AgA3AwAPCyACIAIoAgAiAUEEajYCACAAIAE1AgA3AwAPCyACIAIoAgBBB2pBeHEiAUEIajYCACAAIAEpAwA3AwAPCyACIAIoAgAiAUEEajYCACAAIAEyAQA3AwAPCyACIAIoAgAiAUEEajYCACAAIAEzAQA3AwAPCyACIAIoAgAiAUEEajYCACAAIAEwAAA3AwAPCyACIAIoAgAiAUEEajYCACAAIAExAAA3AwAPCyACIAIoAgBBB2pBeHEiAUEIajYCACAAIAEpAwA3AwAPCyAAIAIgAxEFAAsLbgEBfyMAQYACayIFJAACQCACIANMDQAgBEGAwARxDQAgBSABIAIgA2siAkGAAiACQYACSSIDGxCaCBogA0UEQANAIAAgBUGAAhDOBiACQYB+aiICQf8BSw0ACwsgACAFIAIQzgYLIAVBgAJqJAALLQAgAFBFBEADQCABQX9qIgEgAKdBB3FBMHI6AAAgAEIDiCIAQgBSDQALCyABCzUAIABQRQRAA0AgAUF/aiIBIACnQQ9xQaCuAmotAAAgAnI6AAAgAEIEiCIAQgBSDQALCyABC4MBAgN/AX4CQCAAQoCAgIAQVARAIAAhBQwBCwNAIAFBf2oiASAAIABCCoAiBUIKfn2nQTByOgAAIABC/////58BViECIAUhACACDQALCyAFpyICBEADQCABQX9qIgEgAiACQQpuIgNBCmxrQTByOgAAIAJBCUshBCADIQIgBA0ACwsgAQutFwMQfwJ+AXwjAEGwBGsiCiQAIApBADYCLAJ/IAEQ1gYiFkJ/VwRAQQEhESABmiIBENYGIRZBsK4CDAELIARBgBBxBEBBASERQbOuAgwBC0G2rgJBsa4CIARBAXEiERsLIRUCQCAWQoCAgICAgID4/wCDQoCAgICAgID4/wBRBEAgAEEgIAIgEUEDaiIMIARB//97cRDRBiAAIBUgERDOBiAAQcuuAkHPrgIgBUEFdkEBcSIGG0HDrgJBx64CIAYbIAEgAWIbQQMQzgYgAEEgIAIgDCAEQYDAAHMQ0QYMAQsgCkEQaiEQAkACfwJAIAEgCkEsahDLBiIBIAGgIgFEAAAAAAAAAABiBEAgCiAKKAIsIgZBf2o2AiwgBUEgciITQeEARw0BDAMLIAVBIHIiE0HhAEYNAiAKKAIsIQhBBiADIANBAEgbDAELIAogBkFjaiIINgIsIAFEAAAAAAAAsEGiIQFBBiADIANBAEgbCyELIApBMGogCkHQAmogCEEASBsiDiEJA0AgCQJ/IAFEAAAAAAAA8EFjIAFEAAAAAAAAAABmcQRAIAGrDAELQQALIgY2AgAgCUEEaiEJIAEgBrihRAAAAABlzc1BoiIBRAAAAAAAAAAAYg0ACwJAIAhBAUgEQCAJIQYgDiEHDAELIA4hBwNAIAhBHSAIQR1IGyEIAkAgCUF8aiIGIAdJDQAgCK0hF0IAIRYDQCAGIBZC/////w+DIAY1AgAgF4Z8IhYgFkKAlOvcA4AiFkKAlOvcA359PgIAIAZBfGoiBiAHTw0ACyAWpyIGRQ0AIAdBfGoiByAGNgIACwNAIAkiBiAHSwRAIAZBfGoiCSgCAEUNAQsLIAogCigCLCAIayIINgIsIAYhCSAIQQBKDQALCyAIQX9MBEAgC0EZakEJbUEBaiESIBNB5gBGIRQDQEEJQQAgCGsgCEF3SBshDAJAIAcgBk8EQCAHIAdBBGogBygCABshBwwBC0GAlOvcAyAMdiENQX8gDHRBf3MhD0EAIQggByEJA0AgCSAJKAIAIgMgDHYgCGo2AgAgAyAPcSANbCEIIAlBBGoiCSAGSQ0ACyAHIAdBBGogBygCABshByAIRQ0AIAYgCDYCACAGQQRqIQYLIAogCigCLCAMaiIINgIsIA4gByAUGyIJIBJBAnRqIAYgBiAJa0ECdSASShshBiAIQQBIDQALC0EAIQkCQCAHIAZPDQAgDiAHa0ECdUEJbCEJQQohCCAHKAIAIgNBCkkNAANAIAlBAWohCSADIAhBCmwiCE8NAAsLIAtBACAJIBNB5gBGG2sgE0HnAEYgC0EAR3FrIgggBiAOa0ECdUEJbEF3akgEQCAIQYDIAGoiA0EJbSINQQJ0IA5qQYRgaiEMQQohCCADIA1BCWxrIgNBB0wEQANAIAhBCmwhCCADQQFqIgNBCEcNAAsLAkBBACAGIAxBBGoiEkYgDCgCACINIA0gCG4iDyAIbGsiAxsNAEQAAAAAAADgP0QAAAAAAADwP0QAAAAAAAD4PyADIAhBAXYiFEYbRAAAAAAAAPg/IAYgEkYbIAMgFEkbIRhEAQAAAAAAQENEAAAAAAAAQEMgD0EBcRshAQJAIBFFDQAgFS0AAEEtRw0AIBiaIRggAZohAQsgDCANIANrIgM2AgAgASAYoCABYQ0AIAwgAyAIaiIJNgIAIAlBgJTr3ANPBEADQCAMQQA2AgAgDEF8aiIMIAdJBEAgB0F8aiIHQQA2AgALIAwgDCgCAEEBaiIJNgIAIAlB/5Pr3ANLDQALCyAOIAdrQQJ1QQlsIQlBCiEIIAcoAgAiA0EKSQ0AA0AgCUEBaiEJIAMgCEEKbCIITw0ACwsgDEEEaiIIIAYgBiAISxshBgsCfwNAQQAgBiIIIAdNDQEaIAhBfGoiBigCAEUNAAtBAQshFAJAIBNB5wBHBEAgBEEIcSEPDAELIAlBf3NBfyALQQEgCxsiBiAJSiAJQXtKcSIDGyAGaiELQX9BfiADGyAFaiEFIARBCHEiDw0AQQkhBgJAIBRFDQBBCSEGIAhBfGooAgAiDEUNAEEKIQNBACEGIAxBCnANAANAIAZBAWohBiAMIANBCmwiA3BFDQALCyAIIA5rQQJ1QQlsQXdqIQMgBUFfcUHGAEYEQEEAIQ8gCyADIAZrIgZBACAGQQBKGyIGIAsgBkgbIQsMAQtBACEPIAsgAyAJaiAGayIGQQAgBkEAShsiBiALIAZIGyELCyALIA9yIhNBAEchAyAAQSAgAgJ/IAlBACAJQQBKGyAFQV9xIg1BxgBGDQAaIBAgCSAJQR91IgZqIAZzrSAQENQGIgZrQQFMBEADQCAGQX9qIgZBMDoAACAQIAZrQQJIDQALCyAGQX5qIhIgBToAACAGQX9qQS1BKyAJQQBIGzoAACAQIBJrCyALIBFqIANqakEBaiIMIAQQ0QYgACAVIBEQzgYgAEEwIAIgDCAEQYCABHMQ0QYCQAJAAkAgDUHGAEYEQCAKQRBqQQhyIQ0gCkEQakEJciEJIA4gByAHIA5LGyIDIQcDQCAHNQIAIAkQ1AYhBgJAIAMgB0cEQCAGIApBEGpNDQEDQCAGQX9qIgZBMDoAACAGIApBEGpLDQALDAELIAYgCUcNACAKQTA6ABggDSEGCyAAIAYgCSAGaxDOBiAHQQRqIgcgDk0NAAsgEwRAIABB064CQQEQzgYLIAcgCE8NASALQQFIDQEDQCAHNQIAIAkQ1AYiBiAKQRBqSwRAA0AgBkF/aiIGQTA6AAAgBiAKQRBqSw0ACwsgACAGIAtBCSALQQlIGxDOBiALQXdqIQYgB0EEaiIHIAhPDQMgC0EJSiEDIAYhCyADDQALDAILAkAgC0EASA0AIAggB0EEaiAUGyENIApBEGpBCHIhDiAKQRBqQQlyIQggByEJA0AgCCAJNQIAIAgQ1AYiBkYEQCAKQTA6ABggDiEGCwJAIAcgCUcEQCAGIApBEGpNDQEDQCAGQX9qIgZBMDoAACAGIApBEGpLDQALDAELIAAgBkEBEM4GIAZBAWohBiAPRUEAIAtBAUgbDQAgAEHTrgJBARDOBgsgACAGIAggBmsiAyALIAsgA0obEM4GIAsgA2shCyAJQQRqIgkgDU8NASALQX9KDQALCyAAQTAgC0ESakESQQAQ0QYgACASIBAgEmsQzgYMAgsgCyEGCyAAQTAgBkEJakEJQQAQ0QYLIABBICACIAwgBEGAwABzENEGDAELIBVBCWogFSAFQSBxIgkbIQsCQCADQQtLDQBBDCADayIGRQ0ARAAAAAAAACBAIRgDQCAYRAAAAAAAADBAoiEYIAZBf2oiBg0ACyALLQAAQS1GBEAgGCABmiAYoaCaIQEMAQsgASAYoCAYoSEBCyAQIAooAiwiBiAGQR91IgZqIAZzrSAQENQGIgZGBEAgCkEwOgAPIApBD2ohBgsgEUECciEPIAooAiwhByAGQX5qIg0gBUEPajoAACAGQX9qQS1BKyAHQQBIGzoAACAEQQhxIQggCkEQaiEHA0AgByIGAn8gAZlEAAAAAAAA4EFjBEAgAaoMAQtBgICAgHgLIgdBoK4Cai0AACAJcjoAACABIAe3oUQAAAAAAAAwQKIhAQJAIAZBAWoiByAKQRBqa0EBRw0AAkAgCA0AIANBAEoNACABRAAAAAAAAAAAYQ0BCyAGQS46AAEgBkECaiEHCyABRAAAAAAAAAAAYg0ACyAAQSAgAiAPAn8CQCADRQ0AIAcgCmtBbmogA04NACADIBBqIA1rQQJqDAELIBAgCkEQamsgDWsgB2oLIgZqIgwgBBDRBiAAIAsgDxDOBiAAQTAgAiAMIARBgIAEcxDRBiAAIApBEGogByAKQRBqayIHEM4GIABBMCAGIAcgECANayIJamtBAEEAENEGIAAgDSAJEM4GIABBICACIAwgBEGAwABzENEGCyAKQbAEaiQAIAIgDCAMIAJIGwsFACAAvQsPACAAIAEgAkEAQQAQzAYLEAAgACABIAJB2QFBABDMBgs0AQF/IAAoAhQiAyABIAIgACgCECADayIDIAMgAksbIgMQmQgaIAAgACgCFCADajYCFCACC7oBAQJ/IwBBoAFrIgQkACAEQQhqQdiuAkGQARCZCBoCQAJAIAFBf2pB/////wdPBEAgAQ0BQQEhASAEQZ8BaiEACyAEIAA2AjQgBCAANgIcIARBfiAAayIFIAEgASAFSxsiATYCOCAEIAAgAWoiADYCJCAEIAA2AhggBEEIaiACIAMQ1wYhACABRQ0BIAQoAhwiASABIAQoAhhGa0EAOgAADAELELgGQT02AgBBfyEACyAEQaABaiQAIAALEQAgAEH/////ByABIAIQ2gYLywQBBX8jAEHQAWsiBCQAIARCATcDCAJAIAEgAmwiB0UNACAEIAI2AhAgBCACNgIUQQAgAmshCCACIgEhBkECIQUDQCAEQRBqIAVBAnRqIAIgBmogASIGaiIBNgIAIAVBAWohBSABIAdJDQALAkAgACAHaiAIaiIGIABNBEBBASEFQQEhAQwBC0EBIQVBASEBA0ACfyAFQQNxQQNGBEAgACACIAMgASAEQRBqEN0GIARBCGpBAhDeBiABQQJqDAELAkAgBEEQaiABQX9qIgVBAnRqKAIAIAYgAGtPBEAgACACIAMgBEEIaiABQQAgBEEQahDfBgwBCyAAIAIgAyABIARBEGoQ3QYLIAFBAUYEQCAEQQhqQQEQ4AZBAAwBCyAEQQhqIAUQ4AZBAQshASAEIAQoAghBAXIiBTYCCCAAIAJqIgAgBkkNAAsLIAAgAiADIARBCGogAUEAIARBEGoQ3wYDQAJAAkACQAJAIAFBAUcNACAFQQFHDQAgBCgCDA0BDAULIAFBAUoNAQsgBEEIaiAEQQhqEOEGIgUQ3gYgASAFaiEBIAQoAgghBQwBCyAEQQhqQQIQ4AYgBCAEKAIIQQdzNgIIIARBCGpBARDeBiAAIAhqIgcgBEEQaiABQX5qIgZBAnRqKAIAayACIAMgBEEIaiABQX9qQQEgBEEQahDfBiAEQQhqQQEQ4AYgBCAEKAIIQQFyIgU2AgggByACIAMgBEEIaiAGQQEgBEEQahDfBiAGIQELIAAgCGohAAwAAAsACyAEQdABaiQAC88BAQZ/IwBB8AFrIgUkACAFIAA2AgBBASEGAkAgA0ECSA0AQQAgAWshCkEBIQYgACEHA0AgACAHIApqIgggBCADQX5qIglBAnRqKAIAayIHIAIRAQBBAE4EQCAAIAggAhEBAEF/Sg0CCyAFIAZBAnRqIQACQCAHIAggAhEBAEEATgRAIAAgBzYCACADQX9qIQkMAQsgACAINgIAIAghBwsgBkEBaiEGIAlBAkgNASAFKAIAIQAgCSEDDAAACwALIAEgBSAGEOIGIAVB8AFqJAALWAECfyAAAn8gAUEfTQRAIAAoAgAhAiAAKAIEDAELIAAoAgQhAiAAQQA2AgQgACACNgIAIAFBYGohAUEACyIDIAF2NgIEIAAgA0EgIAFrdCACIAF2cjYCAAvqAgEFfyMAQfABayIHJAAgByADKAIAIgg2AugBIAMoAgQhAyAHIAA2AgAgByADNgLsAUEBIQkCQAJAAkACQEEAIAhBAUYgAxsNAEEBIQkgACAGIARBAnRqKAIAayIIIAAgAhEBAEEBSA0AQQAgAWshCyAFRSEKQQEhCQNAAkAgCCEDAkAgCkEBcUUNACAEQQJIDQAgBEECdCAGakF4aigCACEIIAAgC2oiCiADIAIRAQBBf0oNASAKIAhrIAMgAhEBAEF/Sg0BCyAHIAlBAnRqIAM2AgAgB0HoAWogB0HoAWoQ4QYiABDeBiAJQQFqIQkgACAEaiEEIAcoAugBQQFGBEAgBygC7AFFDQULQQAhBUEBIQogAyEAIAMgBiAEQQJ0aigCAGsiCCAHKAIAIAIRAQBBAEoNAQwDCwsgACEDDAILIAAhAwsgBQ0BCyABIAcgCRDiBiADIAEgAiAEIAYQ3QYLIAdB8AFqJAALVgECfyAAAn8gAUEfTQRAIAAoAgQhAiAAKAIADAELIAAgACgCACICNgIEIABBADYCACABQWBqIQFBAAsiAyABdDYCACAAIAIgAXQgA0EgIAFrdnI2AgQLJgEBfyAAKAIAQX9qaCIBRQRAIAAoAgRoIgBBIGpBACAAGw8LIAELpwEBBX8jAEGAAmsiBCQAAkAgAkECSA0AIAEgAkECdGoiByAENgIAIABFDQAgBCEDA0AgAyABKAIAIABBgAIgAEGAAkkbIgUQmQgaQQAhAwNAIAEgA0ECdGoiBigCACABIANBAWoiA0ECdGooAgAgBRCZCBogBiAGKAIAIAVqNgIAIAIgA0cNAAsgACAFayIARQ0BIAcoAgAhAwwAAAsACyAEQYACaiQAC+gBAQJ/IAJBAEchAwJAAkACQAJAIAJFDQAgAEEDcUUNACABQf8BcSEEA0AgAC0AACAERg0CIABBAWohACACQX9qIgJBAEchAyACRQ0BIABBA3ENAAsLIANFDQELIAAtAAAgAUH/AXFGDQECQCACQQRPBEAgAUH/AXFBgYKECGwhBANAIAAoAgAgBHMiA0F/cyADQf/9+3dqcUGAgYKEeHENAiAAQQRqIQAgAkF8aiICQQNLDQALCyACRQ0BCyABQf8BcSEDA0AgAC0AACADRg0CIABBAWohACACQX9qIgINAAsLQQAPCyAAC0cBA39BACEDAkAgAkUNAANAIAAtAAAiBCABLQAAIgVGBEAgAUEBaiEBIABBAWohACACQX9qIgINAQwCCwsgBCAFayEDCyADCwsAIABBv39qQRpJCw8AIABBIHIgACAAEOUGGwt3AQN/QQAhAwJAIAAtAAAiAkUNAANAIAEtAAAiBEUEQCACIQMMAgsCQCACIARGDQAgAhDmBiABLQAAEOYGRg0AIAAtAAAhAwwCCyABQQFqIQEgAC0AASECIABBAWohACACDQALCyADQf8BcRDmBiABLQAAEOYGawsaACAAIAEQ6QYiAEEAIAAtAAAgAUH/AXFGGwvbAQECfwJAIAFB/wFxIgMEQCAAQQNxBEADQCAALQAAIgJFDQMgAiABQf8BcUYNAyAAQQFqIgBBA3ENAAsLAkAgACgCACICQX9zIAJB//37d2pxQYCBgoR4cQ0AIANBgYKECGwhAwNAIAIgA3MiAkF/cyACQf/9+3dqcUGAgYKEeHENASAAKAIEIQIgAEEEaiEAIAJB//37d2ogAkF/c3FBgIGChHhxRQ0ACwsDQCAAIgItAAAiAwRAIAJBAWohACADIAFB/wFxRw0BCwsgAg8LIAAQoAggAGoPCyAAC00BAn8gAS0AACECAkAgAC0AACIDRQ0AIAIgA0cNAANAIAEtAAEhAiAALQABIgNFDQEgAUEBaiEBIABBAWohACACIANGDQALCyADIAJrC8oBAQF/AkACQCAAIAFzQQNxDQAgAUEDcQRAA0AgACABLQAAIgI6AAAgAkUNAyAAQQFqIQAgAUEBaiIBQQNxDQALCyABKAIAIgJBf3MgAkH//ft3anFBgIGChHhxDQADQCAAIAI2AgAgASgCBCECIABBBGohACABQQRqIQEgAkH//ft3aiACQX9zcUGAgYKEeHFFDQALCyAAIAEtAAAiAjoAACACRQ0AA0AgACABLQABIgI6AAEgAEEBaiEAIAFBAWohASACDQALCyAACwwAIAAgARDrBhogAAuMAQEDfyACRQRAQQAPC0EAIQQCQCAALQAAIgNFDQADQAJAIAJBf2oiAkUNACABLQAAIgVFDQACQCADIAVGDQAgAxDmBiABLQAAEOYGRg0AIAAtAAAhBAwDCyABQQFqIQEgAC0AASEDIABBAWohACADDQEMAgsLIAMhBAsgBEH/AXEQ5gYgAS0AABDmBmsLFgBBACAAEP0BEBYiACAAQRtGGxDzBgsUACAAQQAgAacgAUIgiKcQFxC6Bgs5AQF/IwBBEGsiAyQAIAAgASACQf8BcSADQQhqELwIEPMGIQAgAykDCCEBIANBEGokAEJ/IAEgABsLDQAgACABIAIQGBC6BgtKAQF/IwBBEGsiAyQAIAMgAjYCDCADIAE2AggCfyAAIANBCGpBASADQQRqEBUiAARAIAAQ8wYMAQsgAygCBAshACADQRBqJAAgAAsVACAARQRAQQAPCxC4BiAANgIAQX8LNgEBfyMAQSBrIgEkAAJ/QQEgACABQQhqEBkiAEUNABoQuAYgADYCAEEACyEAIAFBIGokACAACzABAX8gAEEBIAAbIQECQANAIAEQkAgiAA0BEIIHIgAEQCAAEQ4ADAELCxAaAAsgAAsHACAAEPUGCw0AIABBjLACNgIAIAALPAECfyABEKAIIgJBDWoQ9QYiA0EANgIIIAMgAjYCBCADIAI2AgAgACADEPkGIAEgAkEBahCZCDYCACAACwcAIABBDGoLHgAgABD3BhogAEG4sAI2AgAgAEEEaiABEPgGGiAACwoAQeivAhDZBQALjQEBA38jAEEQayIEJAAgABDIBSACTwRAAkAgAkEKTQRAIAAgAhDLBSAAEMwFIQMMAQsgAhDNBSEDIAAgABDRBSADQQFqIgUQzwUiAxDSBSAAIAUQ0wUgACACENQFCyADEP0BIAEgAhDVBRogBEEAOgAPIAIgA2ogBEEPahDWBSAEQRBqJAAPCyAAEPsGAAseACAAEMIFBEAgABDRBSAAEN4FIAAQ3wUQ3AULIAALBQAQgAcLBQAQgQcLCABBgICAgHgLCABB/////wcLCQBB8MYDEKUCCwYAQfWvAgscACAAQbiwAjYCACAAQQRqEIUHGiAAEP0BGiAACyoBAX8CQCAAEJIFRQ0AIAAoAgAQhgciAUEIahCHB0F/Sg0AIAEQNwsgAAsHACAAQXRqCxMAIAAgACgCAEF/aiIANgIAIAALCQAgABCEBxA3CwoAIABBBGoQpQILDAAgABCEBxogABA3CwwAIAAQxwUaIAAQNwsLACAAIAFBABCNBwspACACRQRAIAAgARCOBw8LIAAgAUYEQEEBDwsgABCPByABEI8HEOoGRQsNACAAKAIEIAEoAgRGCwcAIAAoAgQLqgEBAX8jAEFAaiIDJAACf0EBIAAgAUEAEI0HDQAaQQAgAUUNABpBACABQdCxAkGAsgJBABCRByIBRQ0AGiADQX82AhQgAyAANgIQIANBADYCDCADIAE2AgggA0EYakEAQScQmggaIANBATYCOCABIANBCGogAigCAEEBIAEoAgAoAhwRCQBBACADKAIgQQFHDQAaIAIgAygCGDYCAEEBCyEAIANBQGskACAAC6cCAQN/IwBBQGoiBCQAIAAoAgAiBkF8aigCACEFIAZBeGooAgAhBiAEIAM2AhQgBCABNgIQIAQgADYCDCAEIAI2AghBACEBIARBGGpBAEEnEJoIGiAAIAZqIQACQCAFIAJBABCNBwRAIARBATYCOCAFIARBCGogACAAQQFBACAFKAIAKAIUEQoAIABBACAEKAIgQQFGGyEBDAELIAUgBEEIaiAAQQFBACAFKAIAKAIYEQsAIAQoAiwiAEEBSw0AIABBAWsEQCAEKAIcQQAgBCgCKEEBRhtBACAEKAIkQQFGG0EAIAQoAjBBAUYbIQEMAQsgBCgCIEEBRwRAIAQoAjANASAEKAIkQQFHDQEgBCgCKEEBRw0BCyAEKAIYIQELIARBQGskACABC1sAIAEoAhAiAEUEQCABQQE2AiQgASADNgIYIAEgAjYCEA8LAkAgACACRgRAIAEoAhhBAkcNASABIAM2AhgPCyABQQE6ADYgAUECNgIYIAEgASgCJEEBajYCJAsLHAAgACABKAIIQQAQjQcEQCABIAEgAiADEJIHCws1ACAAIAEoAghBABCNBwRAIAEgASACIAMQkgcPCyAAKAIIIgAgASACIAMgACgCACgCHBEJAAtSAQF/IAAoAgQhBCAAKAIAIgAgAQJ/QQAgAkUNABogBEEIdSIBIARBAXFFDQAaIAIoAgAgAWooAgALIAJqIANBAiAEQQJxGyAAKAIAKAIcEQkAC3IBAn8gACABKAIIQQAQjQcEQCAAIAEgAiADEJIHDwsgACgCDCEEIABBEGoiBSABIAIgAxCVBwJAIARBAkgNACAFIARBA3RqIQQgAEEYaiEAA0AgACABIAIgAxCVByABLQA2DQEgAEEIaiIAIARJDQALCwtKAEEBIQICQCAAIAEgAC0ACEEYcQR/IAIFQQAhAiABRQ0BIAFB0LECQbCyAkEAEJEHIgBFDQEgAC0ACEEYcUEARwsQjQchAgsgAgujBAEEfyMAQUBqIgUkAAJAAkACQCABQby0AkEAEI0HBEAgAkEANgIADAELIAAgASABEJcHBEBBASEDIAIoAgAiAUUNAyACIAEoAgA2AgAMAwsgAUUNAUEAIQMgAUHQsQJB4LICQQAQkQciAUUNAiACKAIAIgQEQCACIAQoAgA2AgALIAEoAggiBCAAKAIIIgZBf3NxQQdxDQIgBEF/cyAGcUHgAHENAkEBIQMgACgCDCABKAIMQQAQjQcNAiAAKAIMQbC0AkEAEI0HBEAgASgCDCIBRQ0DIAFB0LECQZSzAkEAEJEHRSEDDAMLIAAoAgwiBEUNAUEAIQMgBEHQsQJB4LICQQAQkQciBARAIAAtAAhBAXFFDQMgBCABKAIMEJkHIQMMAwsgACgCDCIERQ0CQQAhAyAEQdCxAkHQswJBABCRByIEBEAgAC0ACEEBcUUNAyAEIAEoAgwQmgchAwwDCyAAKAIMIgBFDQJBACEDIABB0LECQYCyAkEAEJEHIgBFDQIgASgCDCIBRQ0CQQAhAyABQdCxAkGAsgJBABCRByIBRQ0CIAVBfzYCFCAFIAA2AhBBACEDIAVBADYCDCAFIAE2AgggBUEYakEAQScQmggaIAVBATYCOCABIAVBCGogAigCAEEBIAEoAgAoAhwRCQAgBSgCIEEBRw0CIAIoAgBFDQAgAiAFKAIYNgIAC0EBIQMMAQtBACEDCyAFQUBrJAAgAwu2AQECfwJAA0AgAUUEQEEADwtBACECIAFB0LECQeCyAkEAEJEHIgFFDQEgASgCCCAAKAIIQX9zcQ0BIAAoAgwgASgCDEEAEI0HBEBBAQ8LIAAtAAhBAXFFDQEgACgCDCIDRQ0BIANB0LECQeCyAkEAEJEHIgMEQCABKAIMIQEgAyEADAELCyAAKAIMIgBFDQBBACECIABB0LECQdCzAkEAEJEHIgBFDQAgACABKAIMEJoHIQILIAILXQEBf0EAIQICQCABRQ0AIAFB0LECQdCzAkEAEJEHIgFFDQAgASgCCCAAKAIIQX9zcQ0AQQAhAiAAKAIMIAEoAgxBABCNB0UNACAAKAIQIAEoAhBBABCNByECCyACC6MBACABQQE6ADUCQCABKAIEIANHDQAgAUEBOgA0IAEoAhAiA0UEQCABQQE2AiQgASAENgIYIAEgAjYCECAEQQFHDQEgASgCMEEBRw0BIAFBAToANg8LIAIgA0YEQCABKAIYIgNBAkYEQCABIAQ2AhggBCEDCyABKAIwQQFHDQEgA0EBRw0BIAFBAToANg8LIAFBAToANiABIAEoAiRBAWo2AiQLCyAAAkAgASgCBCACRw0AIAEoAhxBAUYNACABIAM2AhwLC7YEAQR/IAAgASgCCCAEEI0HBEAgASABIAIgAxCcBw8LAkAgACABKAIAIAQQjQcEQAJAIAIgASgCEEcEQCABKAIUIAJHDQELIANBAUcNAiABQQE2AiAPCyABIAM2AiAgASgCLEEERwRAIABBEGoiBSAAKAIMQQN0aiEDQQAhB0EAIQggAQJ/AkADQAJAIAUgA08NACABQQA7ATQgBSABIAIgAkEBIAQQngcgAS0ANg0AAkAgAS0ANUUNACABLQA0BEBBASEGIAEoAhhBAUYNBEEBIQdBASEIQQEhBiAALQAIQQJxDQEMBAtBASEHIAghBiAALQAIQQFxRQ0DCyAFQQhqIQUMAQsLIAghBkEEIAdFDQEaC0EDCzYCLCAGQQFxDQILIAEgAjYCFCABIAEoAihBAWo2AiggASgCJEEBRw0BIAEoAhhBAkcNASABQQE6ADYPCyAAKAIMIQUgAEEQaiIGIAEgAiADIAQQnwcgBUECSA0AIAYgBUEDdGohBiAAQRhqIQUCQCAAKAIIIgBBAnFFBEAgASgCJEEBRw0BCwNAIAEtADYNAiAFIAEgAiADIAQQnwcgBUEIaiIFIAZJDQALDAELIABBAXFFBEADQCABLQA2DQIgASgCJEEBRg0CIAUgASACIAMgBBCfByAFQQhqIgUgBkkNAAwCAAsACwNAIAEtADYNASABKAIkQQFGBEAgASgCGEEBRg0CCyAFIAEgAiADIAQQnwcgBUEIaiIFIAZJDQALCwtLAQJ/IAAoAgQiBkEIdSEHIAAoAgAiACABIAIgBkEBcQR/IAMoAgAgB2ooAgAFIAcLIANqIARBAiAGQQJxGyAFIAAoAgAoAhQRCgALSQECfyAAKAIEIgVBCHUhBiAAKAIAIgAgASAFQQFxBH8gAigCACAGaigCAAUgBgsgAmogA0ECIAVBAnEbIAQgACgCACgCGBELAAv3AQAgACABKAIIIAQQjQcEQCABIAEgAiADEJwHDwsCQCAAIAEoAgAgBBCNBwRAAkAgAiABKAIQRwRAIAEoAhQgAkcNAQsgA0EBRw0CIAFBATYCIA8LIAEgAzYCIAJAIAEoAixBBEYNACABQQA7ATQgACgCCCIAIAEgAiACQQEgBCAAKAIAKAIUEQoAIAEtADUEQCABQQM2AiwgAS0ANEUNAQwDCyABQQQ2AiwLIAEgAjYCFCABIAEoAihBAWo2AiggASgCJEEBRw0BIAEoAhhBAkcNASABQQE6ADYPCyAAKAIIIgAgASACIAMgBCAAKAIAKAIYEQsACwuWAQAgACABKAIIIAQQjQcEQCABIAEgAiADEJwHDwsCQCAAIAEoAgAgBBCNB0UNAAJAIAIgASgCEEcEQCABKAIUIAJHDQELIANBAUcNASABQQE2AiAPCyABIAI2AhQgASADNgIgIAEgASgCKEEBajYCKAJAIAEoAiRBAUcNACABKAIYQQJHDQAgAUEBOgA2CyABQQQ2AiwLC5kCAQZ/IAAgASgCCCAFEI0HBEAgASABIAIgAyAEEJsHDwsgAS0ANSEHIAAoAgwhBiABQQA6ADUgAS0ANCEIIAFBADoANCAAQRBqIgkgASACIAMgBCAFEJ4HIAcgAS0ANSIKciEHIAggAS0ANCILciEIAkAgBkECSA0AIAkgBkEDdGohCSAAQRhqIQYDQCABLQA2DQECQCALBEAgASgCGEEBRg0DIAAtAAhBAnENAQwDCyAKRQ0AIAAtAAhBAXFFDQILIAFBADsBNCAGIAEgAiADIAQgBRCeByABLQA1IgogB3IhByABLQA0IgsgCHIhCCAGQQhqIgYgCUkNAAsLIAEgB0H/AXFBAEc6ADUgASAIQf8BcUEARzoANAs7ACAAIAEoAgggBRCNBwRAIAEgASACIAMgBBCbBw8LIAAoAggiACABIAIgAyAEIAUgACgCACgCFBEKAAseACAAIAEoAgggBRCNBwRAIAEgASACIAMgBBCbBwsLIwECfyAAEKAIQQFqIgEQkAgiAkUEQEEADwsgAiAAIAEQmQgLKgEBfyMAQRBrIgEkACABIAA2AgwgASgCDBCPBxClByEAIAFBEGokACAAC54CAQF/EKgHQdC3AhAbEKkHQdW3AkEBQQFBABAcQdq3AhCqB0HftwIQqwdB67cCEKwHQfm3AhCtB0H/twIQrgdBjrgCEK8HQZK4AhCwB0GfuAIQsQdBpLgCELIHQbK4AhCzB0G4uAIQtAcQ9wRBv7gCEB0QtQdBy7gCEB0QtgdBBCIAQey4AhAeELcHQQJB+bgCEB4QuAcgAEGIuQIQHhC5B0GXuQIQH0GnuQIQugdBxbkCELsHQeq5AhC8B0GRugIQvQdBsLoCEL4HQdi6AhC/B0H1ugIQwAdBm7sCEMEHQbm7AhDCB0HguwIQuwdBgLwCELwHQaG8AhC9B0HCvAIQvgdB5LwCEL8HQYW9AhDAB0GnvQIQwwdBxr0CEMQHCwUAEMUHCwUAEMYHCz0BAX8jAEEQayIBJAAgASAANgIMEMcHIAEoAgxBARDIB0EYIgB0IAB1EMkHQRgiAHQgAHUQICABQRBqJAALPQEBfyMAQRBrIgEkACABIAA2AgwQygcgASgCDEEBEMgHQRgiAHQgAHUQyQdBGCIAdCAAdRAgIAFBEGokAAs1AQF/IwBBEGsiASQAIAEgADYCDBDLByABKAIMQQEQzAdB/wFxEM0HQf8BcRAgIAFBEGokAAs9AQF/IwBBEGsiASQAIAEgADYCDBDOByABKAIMQQIQzwdBECIAdCAAdRDQB0EQIgB0IAB1ECAgAUEQaiQACzcBAX8jAEEQayIBJAAgASAANgIMENEHIAEoAgxBAhDSB0H//wNxENMHQf//A3EQICABQRBqJAALLQEBfyMAQRBrIgEkACABIAA2AgwQ1AcgASgCDEEEEP4GEP8GECAgAUEQaiQACy0BAX8jAEEQayIBJAAgASAANgIMEPsEIAEoAgxBBBDVBxDWBxAgIAFBEGokAAstAQF/IwBBEGsiASQAIAEgADYCDBDXByABKAIMQQQQ2AcQ2QcQICABQRBqJAALLQEBfyMAQRBrIgEkACABIAA2AgwQ2gcgASgCDEEEENUHENYHECAgAUEQaiQACycBAX8jAEEQayIBJAAgASAANgIMENsHIAEoAgxBBBAhIAFBEGokAAsnAQF/IwBBEGsiASQAIAEgADYCDBDcByABKAIMQQgQISABQRBqJAALBQAQ3QcLBQAQ3gcLBQAQ3wcLBQAQ4AcLBQAQ4QcLKAEBfyMAQRBrIgEkACABIAA2AgwQ4gcQvgQgASgCDBAiIAFBEGokAAsoAQF/IwBBEGsiASQAIAEgADYCDBDjBxC+BCABKAIMECIgAUEQaiQACygBAX8jAEEQayIBJAAgASAANgIMELYFEOQHIAEoAgwQIiABQRBqJAALKAEBfyMAQRBrIgEkACABIAA2AgwQ5QcQ5gcgASgCDBAiIAFBEGokAAsoAQF/IwBBEGsiASQAIAEgADYCDBDnBxDoByABKAIMECIgAUEQaiQACygBAX8jAEEQayIBJAAgASAANgIMEOkHEOoHIAEoAgwQIiABQRBqJAALKAEBfyMAQRBrIgEkACABIAA2AgwQ6wcQ7AcgASgCDBAiIAFBEGokAAsoAQF/IwBBEGsiASQAIAEgADYCDBDtBxDqByABKAIMECIgAUEQaiQACygBAX8jAEEQayIBJAAgASAANgIMEO4HEOwHIAEoAgwQIiABQRBqJAALKAEBfyMAQRBrIgEkACABIAA2AgwQ7wcQ8AcgASgCDBAiIAFBEGokAAsoAQF/IwBBEGsiASQAIAEgADYCDBDxBxDyByABKAIMECIgAUEQaiQACwYAQbC0AgsGAEHItAILBQAQ9QcLDwEBfxD2B0EYIgB0IAB1Cw8BAX8Q9wdBGCIAdCAAdQsFABD4BwsFABD5BwsJABC+BEH/AXELCQAQ+gdB/wFxCwUAEPsHCw8BAX8Q/AdBECIAdCAAdQsPAQF/EP0HQRAiAHQgAHULBQAQ/gcLCgAQvgRB//8DcQsKABD/B0H//wNxCwUAELQGCwUAEL4ECwUAEIAICwUAEIEICwUAEIAHCwUAEIEHCwUAEIIICwUAEIMICwUAEIQICwYAQai+AgsGAEGAvwILBgBB3L8CCwYAQbjAAgsGAEGkpAILBQAQhQgLBQAQhggLBABBAQsFABCHCAsEAEECCwUAEIgICwQAQQMLBQAQiQgLBABBBAsFABCKCAsEAEEFCwUAEIsICwUAEIwICwUAEI0ICwQAQQYLBQAQjggLBABBBwsNAEH0xgNB9QERAgAaCycBAX8jAEEQayIBJAAgASAANgIMIAEoAgwhABCnByABQRBqJAAgAAsGAEHUtAILDwEBf0GAAUEYIgB0IAB1Cw8BAX9B/wBBGCIAdCAAdQsGAEHstAILBgBB4LQCCwUAQf8BCwYAQfi0AgsQAQF/QYCAAkEQIgB0IAB1CxABAX9B//8BQRAiAHQgAHULBgBBhLUCCwYAQf//AwsEAEF/CwYAQai1AgsGAEG0tQILBgBBwLUCCwYAQcy1AgsGAEHwwAILBgBBmMECCwYAQcDBAgsGAEHowQILBgBBkMICCwYAQbjCAgsGAEHgwgILBgBBiMMCCwYAQbDDAgsGAEHYwwILBQAQ8wcL/i4BC38jAEEQayILJAACQAJAAkACQAJAAkACQAJAAkACQAJAIABB9AFNBEBB+MYDKAIAIgZBECAAQQtqQXhxIABBC0kbIgRBA3YiAXYiAEEDcQRAIABBf3NBAXEgAWoiBEEDdCICQajHA2ooAgAiAUEIaiEAAkAgASgCCCIDIAJBoMcDaiICRgRAQfjGAyAGQX4gBHdxNgIADAELQYjHAygCABogAyACNgIMIAIgAzYCCAsgASAEQQN0IgNBA3I2AgQgASADaiIBIAEoAgRBAXI2AgQMDAsgBEGAxwMoAgAiCE0NASAABEACQCAAIAF0QQIgAXQiAEEAIABrcnEiAEEAIABrcUF/aiIAIABBDHZBEHEiAHYiAUEFdkEIcSIDIAByIAEgA3YiAEECdkEEcSIBciAAIAF2IgBBAXZBAnEiAXIgACABdiIAQQF2QQFxIgFyIAAgAXZqIgNBA3QiAkGoxwNqKAIAIgEoAggiACACQaDHA2oiAkYEQEH4xgMgBkF+IAN3cSIGNgIADAELQYjHAygCABogACACNgIMIAIgADYCCAsgAUEIaiEAIAEgBEEDcjYCBCABIARqIgIgA0EDdCIFIARrIgNBAXI2AgQgASAFaiADNgIAIAgEQCAIQQN2IgVBA3RBoMcDaiEEQYzHAygCACEBAn8gBkEBIAV0IgVxRQRAQfjGAyAFIAZyNgIAIAQMAQsgBCgCCAshBSAEIAE2AgggBSABNgIMIAEgBDYCDCABIAU2AggLQYzHAyACNgIAQYDHAyADNgIADAwLQfzGAygCACIJRQ0BIAlBACAJa3FBf2oiACAAQQx2QRBxIgB2IgFBBXZBCHEiAyAAciABIAN2IgBBAnZBBHEiAXIgACABdiIAQQF2QQJxIgFyIAAgAXYiAEEBdkEBcSIBciAAIAF2akECdEGoyQNqKAIAIgIoAgRBeHEgBGshASACIQMDQAJAIAMoAhAiAEUEQCADKAIUIgBFDQELIAAoAgRBeHEgBGsiAyABIAMgAUkiAxshASAAIAIgAxshAiAAIQMMAQsLIAIoAhghCiACIAIoAgwiBUcEQEGIxwMoAgAgAigCCCIATQRAIAAoAgwaCyAAIAU2AgwgBSAANgIIDAsLIAJBFGoiAygCACIARQRAIAIoAhAiAEUNAyACQRBqIQMLA0AgAyEHIAAiBUEUaiIDKAIAIgANACAFQRBqIQMgBSgCECIADQALIAdBADYCAAwKC0F/IQQgAEG/f0sNACAAQQtqIgBBeHEhBEH8xgMoAgAiCEUNAAJ/QQAgAEEIdiIARQ0AGkEfIARB////B0sNABogACAAQYD+P2pBEHZBCHEiAXQiACAAQYDgH2pBEHZBBHEiAHQiAyADQYCAD2pBEHZBAnEiA3RBD3YgACABciADcmsiAEEBdCAEIABBFWp2QQFxckEcagshB0EAIARrIQMCQAJAAkAgB0ECdEGoyQNqKAIAIgFFBEBBACEAQQAhBQwBCyAEQQBBGSAHQQF2ayAHQR9GG3QhAkEAIQBBACEFA0ACQCABKAIEQXhxIARrIgYgA08NACABIQUgBiIDDQBBACEDIAEhBSABIQAMAwsgACABKAIUIgYgBiABIAJBHXZBBHFqKAIQIgFGGyAAIAYbIQAgAiABQQBHdCECIAENAAsLIAAgBXJFBEBBAiAHdCIAQQAgAGtyIAhxIgBFDQMgAEEAIABrcUF/aiIAIABBDHZBEHEiAHYiAUEFdkEIcSICIAByIAEgAnYiAEECdkEEcSIBciAAIAF2IgBBAXZBAnEiAXIgACABdiIAQQF2QQFxIgFyIAAgAXZqQQJ0QajJA2ooAgAhAAsgAEUNAQsDQCAAKAIEQXhxIARrIgYgA0khAiAGIAMgAhshAyAAIAUgAhshBSAAKAIQIgEEfyABBSAAKAIUCyIADQALCyAFRQ0AIANBgMcDKAIAIARrTw0AIAUoAhghByAFIAUoAgwiAkcEQEGIxwMoAgAgBSgCCCIATQRAIAAoAgwaCyAAIAI2AgwgAiAANgIIDAkLIAVBFGoiASgCACIARQRAIAUoAhAiAEUNAyAFQRBqIQELA0AgASEGIAAiAkEUaiIBKAIAIgANACACQRBqIQEgAigCECIADQALIAZBADYCAAwIC0GAxwMoAgAiACAETwRAQYzHAygCACEBAkAgACAEayIDQRBPBEBBgMcDIAM2AgBBjMcDIAEgBGoiAjYCACACIANBAXI2AgQgACABaiADNgIAIAEgBEEDcjYCBAwBC0GMxwNBADYCAEGAxwNBADYCACABIABBA3I2AgQgACABaiIAIAAoAgRBAXI2AgQLIAFBCGohAAwKC0GExwMoAgAiAiAESwRAQYTHAyACIARrIgE2AgBBkMcDQZDHAygCACIAIARqIgM2AgAgAyABQQFyNgIEIAAgBEEDcjYCBCAAQQhqIQAMCgtBACEAIARBL2oiCAJ/QdDKAygCAARAQdjKAygCAAwBC0HcygNCfzcCAEHUygNCgKCAgICABDcCAEHQygMgC0EMakFwcUHYqtWqBXM2AgBB5MoDQQA2AgBBtMoDQQA2AgBBgCALIgFqIgZBACABayIHcSIFIARNDQlBACEAQbDKAygCACIBBEBBqMoDKAIAIgMgBWoiCSADTQ0KIAkgAUsNCgtBtMoDLQAAQQRxDQQCQAJAQZDHAygCACIBBEBBuMoDIQADQCAAKAIAIgMgAU0EQCADIAAoAgRqIAFLDQMLIAAoAggiAA0ACwtBABCYCCICQX9GDQUgBSEGQdTKAygCACIAQX9qIgEgAnEEQCAFIAJrIAEgAmpBACAAa3FqIQYLIAYgBE0NBSAGQf7///8HSw0FQbDKAygCACIABEBBqMoDKAIAIgEgBmoiAyABTQ0GIAMgAEsNBgsgBhCYCCIAIAJHDQEMBwsgBiACayAHcSIGQf7///8HSw0EIAYQmAgiAiAAKAIAIAAoAgRqRg0DIAIhAAsCQCAEQTBqIAZNDQAgAEF/Rg0AQdjKAygCACIBIAggBmtqQQAgAWtxIgFB/v///wdLBEAgACECDAcLIAEQmAhBf0cEQCABIAZqIQYgACECDAcLQQAgBmsQmAgaDAQLIAAhAiAAQX9HDQUMAwtBACEFDAcLQQAhAgwFCyACQX9HDQILQbTKA0G0ygMoAgBBBHI2AgALIAVB/v///wdLDQEgBRCYCCICQQAQmAgiAE8NASACQX9GDQEgAEF/Rg0BIAAgAmsiBiAEQShqTQ0BC0GoygNBqMoDKAIAIAZqIgA2AgAgAEGsygMoAgBLBEBBrMoDIAA2AgALAkACQAJAQZDHAygCACIBBEBBuMoDIQADQCACIAAoAgAiAyAAKAIEIgVqRg0CIAAoAggiAA0ACwwCC0GIxwMoAgAiAEEAIAIgAE8bRQRAQYjHAyACNgIAC0EAIQBBvMoDIAY2AgBBuMoDIAI2AgBBmMcDQX82AgBBnMcDQdDKAygCADYCAEHEygNBADYCAANAIABBA3QiAUGoxwNqIAFBoMcDaiIDNgIAIAFBrMcDaiADNgIAIABBAWoiAEEgRw0AC0GExwMgBkFYaiIAQXggAmtBB3FBACACQQhqQQdxGyIBayIDNgIAQZDHAyABIAJqIgE2AgAgASADQQFyNgIEIAAgAmpBKDYCBEGUxwNB4MoDKAIANgIADAILIAAtAAxBCHENACACIAFNDQAgAyABSw0AIAAgBSAGajYCBEGQxwMgAUF4IAFrQQdxQQAgAUEIakEHcRsiAGoiAzYCAEGExwNBhMcDKAIAIAZqIgIgAGsiADYCACADIABBAXI2AgQgASACakEoNgIEQZTHA0HgygMoAgA2AgAMAQsgAkGIxwMoAgAiBUkEQEGIxwMgAjYCACACIQULIAIgBmohA0G4ygMhAAJAAkACQAJAAkACQANAIAMgACgCAEcEQCAAKAIIIgANAQwCCwsgAC0ADEEIcUUNAQtBuMoDIQADQCAAKAIAIgMgAU0EQCADIAAoAgRqIgMgAUsNAwsgACgCCCEADAAACwALIAAgAjYCACAAIAAoAgQgBmo2AgQgAkF4IAJrQQdxQQAgAkEIakEHcRtqIgcgBEEDcjYCBCADQXggA2tBB3FBACADQQhqQQdxG2oiAiAHayAEayEAIAQgB2ohAyABIAJGBEBBkMcDIAM2AgBBhMcDQYTHAygCACAAaiIANgIAIAMgAEEBcjYCBAwDCyACQYzHAygCAEYEQEGMxwMgAzYCAEGAxwNBgMcDKAIAIABqIgA2AgAgAyAAQQFyNgIEIAAgA2ogADYCAAwDCyACKAIEIgFBA3FBAUYEQCABQXhxIQgCQCABQf8BTQRAIAIoAggiBiABQQN2IglBA3RBoMcDakcaIAIoAgwiBCAGRgRAQfjGA0H4xgMoAgBBfiAJd3E2AgAMAgsgBiAENgIMIAQgBjYCCAwBCyACKAIYIQkCQCACIAIoAgwiBkcEQCAFIAIoAggiAU0EQCABKAIMGgsgASAGNgIMIAYgATYCCAwBCwJAIAJBFGoiASgCACIEDQAgAkEQaiIBKAIAIgQNAEEAIQYMAQsDQCABIQUgBCIGQRRqIgEoAgAiBA0AIAZBEGohASAGKAIQIgQNAAsgBUEANgIACyAJRQ0AAkAgAiACKAIcIgRBAnRBqMkDaiIBKAIARgRAIAEgBjYCACAGDQFB/MYDQfzGAygCAEF+IAR3cTYCAAwCCyAJQRBBFCAJKAIQIAJGG2ogBjYCACAGRQ0BCyAGIAk2AhggAigCECIBBEAgBiABNgIQIAEgBjYCGAsgAigCFCIBRQ0AIAYgATYCFCABIAY2AhgLIAIgCGohAiAAIAhqIQALIAIgAigCBEF+cTYCBCADIABBAXI2AgQgACADaiAANgIAIABB/wFNBEAgAEEDdiIBQQN0QaDHA2ohAAJ/QfjGAygCACIEQQEgAXQiAXFFBEBB+MYDIAEgBHI2AgAgAAwBCyAAKAIICyEBIAAgAzYCCCABIAM2AgwgAyAANgIMIAMgATYCCAwDCyADAn9BACAAQQh2IgRFDQAaQR8gAEH///8HSw0AGiAEIARBgP4/akEQdkEIcSIBdCIEIARBgOAfakEQdkEEcSIEdCICIAJBgIAPakEQdkECcSICdEEPdiABIARyIAJyayIBQQF0IAAgAUEVanZBAXFyQRxqCyIBNgIcIANCADcCECABQQJ0QajJA2ohBAJAQfzGAygCACICQQEgAXQiBXFFBEBB/MYDIAIgBXI2AgAgBCADNgIAIAMgBDYCGAwBCyAAQQBBGSABQQF2ayABQR9GG3QhASAEKAIAIQIDQCACIgQoAgRBeHEgAEYNAyABQR12IQIgAUEBdCEBIAQgAkEEcWpBEGoiBSgCACICDQALIAUgAzYCACADIAQ2AhgLIAMgAzYCDCADIAM2AggMAgtBhMcDIAZBWGoiAEF4IAJrQQdxQQAgAkEIakEHcRsiBWsiBzYCAEGQxwMgAiAFaiIFNgIAIAUgB0EBcjYCBCAAIAJqQSg2AgRBlMcDQeDKAygCADYCACABIANBJyADa0EHcUEAIANBWWpBB3EbakFRaiIAIAAgAUEQakkbIgVBGzYCBCAFQcDKAykCADcCECAFQbjKAykCADcCCEHAygMgBUEIajYCAEG8ygMgBjYCAEG4ygMgAjYCAEHEygNBADYCACAFQRhqIQADQCAAQQc2AgQgAEEIaiECIABBBGohACADIAJLDQALIAEgBUYNAyAFIAUoAgRBfnE2AgQgASAFIAFrIgZBAXI2AgQgBSAGNgIAIAZB/wFNBEAgBkEDdiIDQQN0QaDHA2ohAAJ/QfjGAygCACICQQEgA3QiA3FFBEBB+MYDIAIgA3I2AgAgAAwBCyAAKAIICyEDIAAgATYCCCADIAE2AgwgASAANgIMIAEgAzYCCAwECyABQgA3AhAgAQJ/QQAgBkEIdiIDRQ0AGkEfIAZB////B0sNABogAyADQYD+P2pBEHZBCHEiAHQiAyADQYDgH2pBEHZBBHEiA3QiAiACQYCAD2pBEHZBAnEiAnRBD3YgACADciACcmsiAEEBdCAGIABBFWp2QQFxckEcagsiADYCHCAAQQJ0QajJA2ohAwJAQfzGAygCACICQQEgAHQiBXFFBEBB/MYDIAIgBXI2AgAgAyABNgIAIAEgAzYCGAwBCyAGQQBBGSAAQQF2ayAAQR9GG3QhACADKAIAIQIDQCACIgMoAgRBeHEgBkYNBCAAQR12IQIgAEEBdCEAIAMgAkEEcWpBEGoiBSgCACICDQALIAUgATYCACABIAM2AhgLIAEgATYCDCABIAE2AggMAwsgBCgCCCIAIAM2AgwgBCADNgIIIANBADYCGCADIAQ2AgwgAyAANgIICyAHQQhqIQAMBQsgAygCCCIAIAE2AgwgAyABNgIIIAFBADYCGCABIAM2AgwgASAANgIIC0GExwMoAgAiACAETQ0AQYTHAyAAIARrIgE2AgBBkMcDQZDHAygCACIAIARqIgM2AgAgAyABQQFyNgIEIAAgBEEDcjYCBCAAQQhqIQAMAwsQuAZBMDYCAEEAIQAMAgsCQCAHRQ0AAkAgBSgCHCIBQQJ0QajJA2oiACgCACAFRgRAIAAgAjYCACACDQFB/MYDIAhBfiABd3EiCDYCAAwCCyAHQRBBFCAHKAIQIAVGG2ogAjYCACACRQ0BCyACIAc2AhggBSgCECIABEAgAiAANgIQIAAgAjYCGAsgBSgCFCIARQ0AIAIgADYCFCAAIAI2AhgLAkAgA0EPTQRAIAUgAyAEaiIAQQNyNgIEIAAgBWoiACAAKAIEQQFyNgIEDAELIAUgBEEDcjYCBCAEIAVqIgIgA0EBcjYCBCACIANqIAM2AgAgA0H/AU0EQCADQQN2IgFBA3RBoMcDaiEAAn9B+MYDKAIAIgNBASABdCIBcUUEQEH4xgMgASADcjYCACAADAELIAAoAggLIQEgACACNgIIIAEgAjYCDCACIAA2AgwgAiABNgIIDAELIAICf0EAIANBCHYiAUUNABpBHyADQf///wdLDQAaIAEgAUGA/j9qQRB2QQhxIgB0IgEgAUGA4B9qQRB2QQRxIgF0IgQgBEGAgA9qQRB2QQJxIgR0QQ92IAAgAXIgBHJrIgBBAXQgAyAAQRVqdkEBcXJBHGoLIgA2AhwgAkIANwIQIABBAnRBqMkDaiEBAkACQCAIQQEgAHQiBHFFBEBB/MYDIAQgCHI2AgAgASACNgIAIAIgATYCGAwBCyADQQBBGSAAQQF2ayAAQR9GG3QhACABKAIAIQQDQCAEIgEoAgRBeHEgA0YNAiAAQR12IQQgAEEBdCEAIAEgBEEEcWpBEGoiBigCACIEDQALIAYgAjYCACACIAE2AhgLIAIgAjYCDCACIAI2AggMAQsgASgCCCIAIAI2AgwgASACNgIIIAJBADYCGCACIAE2AgwgAiAANgIICyAFQQhqIQAMAQsCQCAKRQ0AAkAgAigCHCIDQQJ0QajJA2oiACgCACACRgRAIAAgBTYCACAFDQFB/MYDIAlBfiADd3E2AgAMAgsgCkEQQRQgCigCECACRhtqIAU2AgAgBUUNAQsgBSAKNgIYIAIoAhAiAARAIAUgADYCECAAIAU2AhgLIAIoAhQiAEUNACAFIAA2AhQgACAFNgIYCwJAIAFBD00EQCACIAEgBGoiAEEDcjYCBCAAIAJqIgAgACgCBEEBcjYCBAwBCyACIARBA3I2AgQgAiAEaiIDIAFBAXI2AgQgASADaiABNgIAIAgEQCAIQQN2IgVBA3RBoMcDaiEEQYzHAygCACEAAn9BASAFdCIFIAZxRQRAQfjGAyAFIAZyNgIAIAQMAQsgBCgCCAshBSAEIAA2AgggBSAANgIMIAAgBDYCDCAAIAU2AggLQYzHAyADNgIAQYDHAyABNgIACyACQQhqIQALIAtBEGokACAAC6oNAQd/AkAgAEUNACAAQXhqIgIgAEF8aigCACIBQXhxIgBqIQUCQCABQQFxDQAgAUEDcUUNASACIAIoAgAiAWsiAkGIxwMoAgAiBEkNASAAIAFqIQAgAkGMxwMoAgBHBEAgAUH/AU0EQCACKAIIIgcgAUEDdiIGQQN0QaDHA2pHGiAHIAIoAgwiA0YEQEH4xgNB+MYDKAIAQX4gBndxNgIADAMLIAcgAzYCDCADIAc2AggMAgsgAigCGCEGAkAgAiACKAIMIgNHBEAgBCACKAIIIgFNBEAgASgCDBoLIAEgAzYCDCADIAE2AggMAQsCQCACQRRqIgEoAgAiBA0AIAJBEGoiASgCACIEDQBBACEDDAELA0AgASEHIAQiA0EUaiIBKAIAIgQNACADQRBqIQEgAygCECIEDQALIAdBADYCAAsgBkUNAQJAIAIgAigCHCIEQQJ0QajJA2oiASgCAEYEQCABIAM2AgAgAw0BQfzGA0H8xgMoAgBBfiAEd3E2AgAMAwsgBkEQQRQgBigCECACRhtqIAM2AgAgA0UNAgsgAyAGNgIYIAIoAhAiAQRAIAMgATYCECABIAM2AhgLIAIoAhQiAUUNASADIAE2AhQgASADNgIYDAELIAUoAgQiAUEDcUEDRw0AQYDHAyAANgIAIAUgAUF+cTYCBCACIABBAXI2AgQgACACaiAANgIADwsgBSACTQ0AIAUoAgQiAUEBcUUNAAJAIAFBAnFFBEAgBUGQxwMoAgBGBEBBkMcDIAI2AgBBhMcDQYTHAygCACAAaiIANgIAIAIgAEEBcjYCBCACQYzHAygCAEcNA0GAxwNBADYCAEGMxwNBADYCAA8LIAVBjMcDKAIARgRAQYzHAyACNgIAQYDHA0GAxwMoAgAgAGoiADYCACACIABBAXI2AgQgACACaiAANgIADwsgAUF4cSAAaiEAAkAgAUH/AU0EQCAFKAIMIQQgBSgCCCIDIAFBA3YiBUEDdEGgxwNqIgFHBEBBiMcDKAIAGgsgAyAERgRAQfjGA0H4xgMoAgBBfiAFd3E2AgAMAgsgASAERwRAQYjHAygCABoLIAMgBDYCDCAEIAM2AggMAQsgBSgCGCEGAkAgBSAFKAIMIgNHBEBBiMcDKAIAIAUoAggiAU0EQCABKAIMGgsgASADNgIMIAMgATYCCAwBCwJAIAVBFGoiASgCACIEDQAgBUEQaiIBKAIAIgQNAEEAIQMMAQsDQCABIQcgBCIDQRRqIgEoAgAiBA0AIANBEGohASADKAIQIgQNAAsgB0EANgIACyAGRQ0AAkAgBSAFKAIcIgRBAnRBqMkDaiIBKAIARgRAIAEgAzYCACADDQFB/MYDQfzGAygCAEF+IAR3cTYCAAwCCyAGQRBBFCAGKAIQIAVGG2ogAzYCACADRQ0BCyADIAY2AhggBSgCECIBBEAgAyABNgIQIAEgAzYCGAsgBSgCFCIBRQ0AIAMgATYCFCABIAM2AhgLIAIgAEEBcjYCBCAAIAJqIAA2AgAgAkGMxwMoAgBHDQFBgMcDIAA2AgAPCyAFIAFBfnE2AgQgAiAAQQFyNgIEIAAgAmogADYCAAsgAEH/AU0EQCAAQQN2IgFBA3RBoMcDaiEAAn9B+MYDKAIAIgRBASABdCIBcUUEQEH4xgMgASAEcjYCACAADAELIAAoAggLIQEgACACNgIIIAEgAjYCDCACIAA2AgwgAiABNgIIDwsgAkIANwIQIAICf0EAIABBCHYiBEUNABpBHyAAQf///wdLDQAaIAQgBEGA/j9qQRB2QQhxIgF0IgQgBEGA4B9qQRB2QQRxIgR0IgMgA0GAgA9qQRB2QQJxIgN0QQ92IAEgBHIgA3JrIgFBAXQgACABQRVqdkEBcXJBHGoLIgE2AhwgAUECdEGoyQNqIQQCQAJAAkBB/MYDKAIAIgNBASABdCIFcUUEQEH8xgMgAyAFcjYCACAEIAI2AgAgAiAENgIYDAELIABBAEEZIAFBAXZrIAFBH0YbdCEBIAQoAgAhAwNAIAMiBCgCBEF4cSAARg0CIAFBHXYhAyABQQF0IQEgBCADQQRxakEQaiIFKAIAIgMNAAsgBSACNgIAIAIgBDYCGAsgAiACNgIMIAIgAjYCCAwBCyAEKAIIIgAgAjYCDCAEIAI2AgggAkEANgIYIAIgBDYCDCACIAA2AggLQZjHA0GYxwMoAgBBf2oiAjYCACACDQBBwMoDIQIDQCACKAIAIgBBCGohAiAADQALQZjHA0F/NgIACwtcAgF/AX4CQAJ/QQAgAEUNABogAK0gAa1+IgOnIgIgACABckGAgARJDQAaQX8gAiADQiCIpxsLIgIQkAgiAEUNACAAQXxqLQAAQQNxRQ0AIABBACACEJoIGgsgAAuFAQECfyAARQRAIAEQkAgPCyABQUBPBEAQuAZBMDYCAEEADwsgAEF4akEQIAFBC2pBeHEgAUELSRsQlAgiAgRAIAJBCGoPCyABEJAIIgJFBEBBAA8LIAIgAEF8QXggAEF8aigCACIDQQNxGyADQXhxaiIDIAEgAyABSRsQmQgaIAAQkQggAgvHBwEJfyAAKAIEIgZBA3EhAiAAIAZBeHEiBWohAwJAQYjHAygCACIJIABLDQAgAkEBRg0ACwJAIAJFBEBBACECIAFBgAJJDQEgBSABQQRqTwRAIAAhAiAFIAFrQdjKAygCAEEBdE0NAgtBAA8LAkAgBSABTwRAIAUgAWsiAkEQSQ0BIAAgBkEBcSABckECcjYCBCAAIAFqIgEgAkEDcjYCBCADIAMoAgRBAXI2AgQgASACEJcIDAELQQAhAiADQZDHAygCAEYEQEGExwMoAgAgBWoiAyABTQ0CIAAgBkEBcSABckECcjYCBCAAIAFqIgIgAyABayIBQQFyNgIEQYTHAyABNgIAQZDHAyACNgIADAELIANBjMcDKAIARgRAQQAhAkGAxwMoAgAgBWoiAyABSQ0CAkAgAyABayICQRBPBEAgACAGQQFxIAFyQQJyNgIEIAAgAWoiASACQQFyNgIEIAAgA2oiAyACNgIAIAMgAygCBEF+cTYCBAwBCyAAIAZBAXEgA3JBAnI2AgQgACADaiIBIAEoAgRBAXI2AgRBACECQQAhAQtBjMcDIAE2AgBBgMcDIAI2AgAMAQtBACECIAMoAgQiBEECcQ0BIARBeHEgBWoiByABSQ0BIAcgAWshCgJAIARB/wFNBEAgAygCDCECIAMoAggiAyAEQQN2IgRBA3RBoMcDakcaIAIgA0YEQEH4xgNB+MYDKAIAQX4gBHdxNgIADAILIAMgAjYCDCACIAM2AggMAQsgAygCGCEIAkAgAyADKAIMIgRHBEAgCSADKAIIIgJNBEAgAigCDBoLIAIgBDYCDCAEIAI2AggMAQsCQCADQRRqIgIoAgAiBQ0AIANBEGoiAigCACIFDQBBACEEDAELA0AgAiEJIAUiBEEUaiICKAIAIgUNACAEQRBqIQIgBCgCECIFDQALIAlBADYCAAsgCEUNAAJAIAMgAygCHCIFQQJ0QajJA2oiAigCAEYEQCACIAQ2AgAgBA0BQfzGA0H8xgMoAgBBfiAFd3E2AgAMAgsgCEEQQRQgCCgCECADRhtqIAQ2AgAgBEUNAQsgBCAINgIYIAMoAhAiAgRAIAQgAjYCECACIAQ2AhgLIAMoAhQiA0UNACAEIAM2AhQgAyAENgIYCyAKQQ9NBEAgACAGQQFxIAdyQQJyNgIEIAAgB2oiASABKAIEQQFyNgIEDAELIAAgBkEBcSABckECcjYCBCAAIAFqIgEgCkEDcjYCBCAAIAdqIgMgAygCBEEBcjYCBCABIAoQlwgLIAAhAgsgAgsXACAAQQhNBEAgARCQCA8LIAAgARCWCAuaAwEFf0EQIQICQCAAQRAgAEEQSxsiAyADQX9qcUUEQCADIQAMAQsDQCACIgBBAXQhAiAAIANJDQALC0FAIABrIAFNBEAQuAZBMDYCAEEADwtBECABQQtqQXhxIAFBC0kbIgEgAGpBDGoQkAgiAkUEQEEADwsgAkF4aiEDAkAgAEF/aiACcUUEQCADIQAMAQsgAkF8aiIFKAIAIgZBeHEgACACakF/akEAIABrcUF4aiICIAAgAmogAiADa0EPSxsiACADayICayEEIAZBA3FFBEAgAygCACEDIAAgBDYCBCAAIAIgA2o2AgAMAQsgACAEIAAoAgRBAXFyQQJyNgIEIAAgBGoiBCAEKAIEQQFyNgIEIAUgAiAFKAIAQQFxckECcjYCACAAIAAoAgRBAXI2AgQgAyACEJcICwJAIAAoAgQiAkEDcUUNACACQXhxIgMgAUEQak0NACAAIAEgAkEBcXJBAnI2AgQgACABaiICIAMgAWsiAUEDcjYCBCAAIANqIgMgAygCBEEBcjYCBCACIAEQlwgLIABBCGoLrAwBBn8gACABaiEFAkACQCAAKAIEIgJBAXENACACQQNxRQ0BIAAoAgAiAiABaiEBIAAgAmsiAEGMxwMoAgBHBEBBiMcDKAIAIQcgAkH/AU0EQCAAKAIIIgMgAkEDdiIGQQN0QaDHA2pHGiADIAAoAgwiBEYEQEH4xgNB+MYDKAIAQX4gBndxNgIADAMLIAMgBDYCDCAEIAM2AggMAgsgACgCGCEGAkAgACAAKAIMIgNHBEAgByAAKAIIIgJNBEAgAigCDBoLIAIgAzYCDCADIAI2AggMAQsCQCAAQRRqIgIoAgAiBA0AIABBEGoiAigCACIEDQBBACEDDAELA0AgAiEHIAQiA0EUaiICKAIAIgQNACADQRBqIQIgAygCECIEDQALIAdBADYCAAsgBkUNAQJAIAAgACgCHCIEQQJ0QajJA2oiAigCAEYEQCACIAM2AgAgAw0BQfzGA0H8xgMoAgBBfiAEd3E2AgAMAwsgBkEQQRQgBigCECAARhtqIAM2AgAgA0UNAgsgAyAGNgIYIAAoAhAiAgRAIAMgAjYCECACIAM2AhgLIAAoAhQiAkUNASADIAI2AhQgAiADNgIYDAELIAUoAgQiAkEDcUEDRw0AQYDHAyABNgIAIAUgAkF+cTYCBCAAIAFBAXI2AgQgBSABNgIADwsCQCAFKAIEIgJBAnFFBEAgBUGQxwMoAgBGBEBBkMcDIAA2AgBBhMcDQYTHAygCACABaiIBNgIAIAAgAUEBcjYCBCAAQYzHAygCAEcNA0GAxwNBADYCAEGMxwNBADYCAA8LIAVBjMcDKAIARgRAQYzHAyAANgIAQYDHA0GAxwMoAgAgAWoiATYCACAAIAFBAXI2AgQgACABaiABNgIADwtBiMcDKAIAIQcgAkF4cSABaiEBAkAgAkH/AU0EQCAFKAIMIQQgBSgCCCIDIAJBA3YiBUEDdEGgxwNqRxogAyAERgRAQfjGA0H4xgMoAgBBfiAFd3E2AgAMAgsgAyAENgIMIAQgAzYCCAwBCyAFKAIYIQYCQCAFIAUoAgwiA0cEQCAHIAUoAggiAk0EQCACKAIMGgsgAiADNgIMIAMgAjYCCAwBCwJAIAVBFGoiAigCACIEDQAgBUEQaiICKAIAIgQNAEEAIQMMAQsDQCACIQcgBCIDQRRqIgIoAgAiBA0AIANBEGohAiADKAIQIgQNAAsgB0EANgIACyAGRQ0AAkAgBSAFKAIcIgRBAnRBqMkDaiICKAIARgRAIAIgAzYCACADDQFB/MYDQfzGAygCAEF+IAR3cTYCAAwCCyAGQRBBFCAGKAIQIAVGG2ogAzYCACADRQ0BCyADIAY2AhggBSgCECICBEAgAyACNgIQIAIgAzYCGAsgBSgCFCICRQ0AIAMgAjYCFCACIAM2AhgLIAAgAUEBcjYCBCAAIAFqIAE2AgAgAEGMxwMoAgBHDQFBgMcDIAE2AgAPCyAFIAJBfnE2AgQgACABQQFyNgIEIAAgAWogATYCAAsgAUH/AU0EQCABQQN2IgJBA3RBoMcDaiEBAn9B+MYDKAIAIgRBASACdCICcUUEQEH4xgMgAiAEcjYCACABDAELIAEoAggLIQIgASAANgIIIAIgADYCDCAAIAE2AgwgACACNgIIDwsgAEIANwIQIAACf0EAIAFBCHYiBEUNABpBHyABQf///wdLDQAaIAQgBEGA/j9qQRB2QQhxIgJ0IgQgBEGA4B9qQRB2QQRxIgR0IgMgA0GAgA9qQRB2QQJxIgN0QQ92IAIgBHIgA3JrIgJBAXQgASACQRVqdkEBcXJBHGoLIgI2AhwgAkECdEGoyQNqIQQCQAJAQfzGAygCACIDQQEgAnQiBXFFBEBB/MYDIAMgBXI2AgAgBCAANgIAIAAgBDYCGAwBCyABQQBBGSACQQF2ayACQR9GG3QhAiAEKAIAIQMDQCADIgQoAgRBeHEgAUYNAiACQR12IQMgAkEBdCECIAQgA0EEcWpBEGoiBSgCACIDDQALIAUgADYCACAAIAQ2AhgLIAAgADYCDCAAIAA2AggPCyAEKAIIIgEgADYCDCAEIAA2AgggAEEANgIYIAAgBDYCDCAAIAE2AggLC1IBA38QJyICKAIAIgEgAEEDakF8cSIDaiEAAkAgA0EBTkEAIAAgAU0bDQAgAD8AQRB0SwRAIAAQI0UNAQsgAiAANgIAIAEPCxC4BkEwNgIAQX8LggQBA38gAkGABE8EQCAAIAEgAhAkGiAADwsgACACaiEDAkAgACABc0EDcUUEQAJAIAJBAUgEQCAAIQIMAQsgAEEDcUUEQCAAIQIMAQsgACECA0AgAiABLQAAOgAAIAFBAWohASACQQFqIgIgA08NASACQQNxDQALCwJAIANBfHEiBEHAAEkNACACIARBQGoiBUsNAANAIAIgASgCADYCACACIAEoAgQ2AgQgAiABKAIINgIIIAIgASgCDDYCDCACIAEoAhA2AhAgAiABKAIUNgIUIAIgASgCGDYCGCACIAEoAhw2AhwgAiABKAIgNgIgIAIgASgCJDYCJCACIAEoAig2AiggAiABKAIsNgIsIAIgASgCMDYCMCACIAEoAjQ2AjQgAiABKAI4NgI4IAIgASgCPDYCPCABQUBrIQEgAkFAayICIAVNDQALCyACIARPDQEDQCACIAEoAgA2AgAgAUEEaiEBIAJBBGoiAiAESQ0ACwwBCyADQQRJBEAgACECDAELIANBfGoiBCAASQRAIAAhAgwBCyAAIQIDQCACIAEtAAA6AAAgAiABLQABOgABIAIgAS0AAjoAAiACIAEtAAM6AAMgAUEEaiEBIAJBBGoiAiAETQ0ACwsgAiADSQRAA0AgAiABLQAAOgAAIAFBAWohASACQQFqIgIgA0cNAAsLIAAL8wICAn8BfgJAIAJFDQAgACACaiIDQX9qIAE6AAAgACABOgAAIAJBA0kNACADQX5qIAE6AAAgACABOgABIANBfWogAToAACAAIAE6AAIgAkEHSQ0AIANBfGogAToAACAAIAE6AAMgAkEJSQ0AIABBACAAa0EDcSIEaiIDIAFB/wFxQYGChAhsIgE2AgAgAyACIARrQXxxIgRqIgJBfGogATYCACAEQQlJDQAgAyABNgIIIAMgATYCBCACQXhqIAE2AgAgAkF0aiABNgIAIARBGUkNACADIAE2AhggAyABNgIUIAMgATYCECADIAE2AgwgAkFwaiABNgIAIAJBbGogATYCACACQWhqIAE2AgAgAkFkaiABNgIAIAQgA0EEcUEYciIEayICQSBJDQAgAa0iBUIghiAFhCEFIAMgBGohAQNAIAEgBTcDGCABIAU3AxAgASAFNwMIIAEgBTcDACABQSBqIQEgAkFgaiICQR9LDQALCyAAC+0CAQJ/AkAgACABRg0AAkAgASACaiAASwRAIAAgAmoiBCABSw0BCyAAIAEgAhCZCA8LIAAgAXNBA3EhAwJAAkAgACABSQRAIAMEQCAAIQMMAwsgAEEDcUUEQCAAIQMMAgsgACEDA0AgAkUNBCADIAEtAAA6AAAgAUEBaiEBIAJBf2ohAiADQQFqIgNBA3ENAAsMAQsCQCADDQAgBEEDcQRAA0AgAkUNBSAAIAJBf2oiAmoiAyABIAJqLQAAOgAAIANBA3ENAAsLIAJBA00NAANAIAAgAkF8aiICaiABIAJqKAIANgIAIAJBA0sNAAsLIAJFDQIDQCAAIAJBf2oiAmogASACai0AADoAACACDQALDAILIAJBA00NAANAIAMgASgCADYCACABQQRqIQEgA0EEaiEDIAJBfGoiAkEDSw0ACwsgAkUNAANAIAMgAS0AADoAACADQQFqIQMgAUEBaiEBIAJBf2oiAg0ACwsgAAtZAQF/IAAgAC0ASiIBQX9qIAFyOgBKIAAoAgAiAUEIcQRAIAAgAUEgcjYCAEF/DwsgAEIANwIEIAAgACgCLCIBNgIcIAAgATYCFCAAIAEgACgCMGo2AhBBAAuQAQEDfyMAQRBrIgMkACADIAE6AA8CQCAAKAIQIgJFBEBBfyECIAAQnAgNASAAKAIQIQILAkAgACgCFCIEIAJPDQAgAUH/AXEiAiAALABLRg0AIAAgBEEBajYCFCAEIAE6AAAMAQtBfyECIAAgA0EPakEBIAAoAiQRAABBAUcNACADLQAPIQILIANBEGokACACC8ABAQR/AkAgAigCECIDBH8gAwVBACEEIAIQnAgNASACKAIQCyACKAIUIgVrIAFJBEAgAiAAIAEgAigCJBEAAA8LQQAhBgJAIAIsAEtBAEgNACABIQQDQCAEIgNFDQEgACADQX9qIgRqLQAAQQpHDQALIAIgACADIAIoAiQRAAAiBCADSQ0BIAEgA2shASAAIANqIQAgAigCFCEFIAMhBgsgBSAAIAEQmQgaIAIgAigCFCABajYCFCABIAZqIQQLIAQLVwECfyABIAJsIQQCQCADKAJMQX9MBEAgACAEIAMQngghAAwBCyADEJIFIQUgACAEIAMQngghACAFRQ0AIAMQ8QELIAAgBEYEQCACQQAgARsPCyAAIAFuC5QBAQN/IAAhAQJAAkAgAEEDcUUNACAALQAARQRAQQAPCyAAIQEDQCABQQFqIgFBA3FFDQEgAS0AAA0ACwwBCwNAIAEiAkEEaiEBIAIoAgAiA0F/cyADQf/9+3dqcUGAgYKEeHFFDQALIANB/wFxRQRAIAIgAGsPCwNAIAItAAEhAyACQQFqIgEhAiADDQALCyABIABrCx8AQejKAygCAEUEQEHsygMgATYCAEHoygMgADYCAAsLBAAjAAsQACMAIABrQXBxIgAkACAACwYAIAAkAAsGACAAQAALCQAgASAAEQIACw0AIAEgAiADIAARAAALCwAgASACIAARAQALBwAgABEDAAsJACABIAARBgALDwAgASACIAMgBCAAEQQACxEAIAEgAiADIAQgBSAAEQcACxMAIAEgAiADIAQgBSAGIAARDAALCwAgASACIAARDQALEwAgASACIAMgBCAFIAYgABEPAAsLACABIAIgABEFAAsNACABIAIgAyAAEQgACxMAIAEgAiADIAQgBSAGIAARCgALDQAgASACIAMgABEVAAsNACABIAIgAyAAERcACxMAIAEgAiADIAQgBSAGIAARFgALEQAgASACIAMgBCAFIAARCwALDwAgASACIAMgBCAAEQkACxMAIAAgASACrSADrUIghoQQrggLIwAgACABIAKtIAOtQiCGhCAErSAFrUIghoQgBiAHIAgQrwgLHQAgACABIAKtIAOtQiCGhCAErSAFrUIghoQQswgLIgEBfiAAIAEgAq0gA61CIIaEIAQQtAgi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Yy9saWJ0b21jcnlwdC9zcmMvcGsvZWNjL2x0Y19lY2NfcHJvamVjdGl2ZV9kYmxfcG9pbnQuYwBSICE9IE5VTEwAbW9kdWx1cyAhPSBOVUxMAG1wICE9IE5VTEwAUCAhPSBOVUxMAC9Vc2Vycy9taWNoYWVsL0RvY3VtZW50cy9Xb3JrYmVuY2gvV293c2VyL3JlcG9zL3N0b3JtanMvYnVpbGQvcmVsZWFzZS9TdG9ybUxpYi9zcmMvbGlidG9tY3J5cHQvc3JjL3BrL2VjYy9sdGNfZWNjX3Byb2plY3RpdmVfYWRkX3BvaW50LmMAUSAhPSBOVUxMAFIgIT0gTlVMTABtb2R1bHVzICE9IE5VTEwAbXAgIT0gTlVMTABBICE9IE5VTEwAL1VzZXJzL21pY2hhZWwvRG9jdW1lbnRzL1dvcmtiZW5jaC9Xb3dzZXIvcmVwb3Mvc3Rvcm1qcy9idWlsZC9yZWxlYXNlL1N0b3JtTGliL3NyYy9saWJ0b21jcnlwdC9zcmMvcGsvZWNjL2x0Y19lY2NfbXVsMmFkZC5jAEIgIT0gTlVMTABDICE9IE5VTEwAa0EgIT0gTlVMTABrQiAhPSBOVUxMAG1vZHVsdXMgIT0gTlVMTABOICE9IE5VTEwAL1VzZXJzL21pY2hhZWwvRG9jdW1lbnRzL1dvcmtiZW5jaC9Xb3dzZXIvcmVwb3Mvc3Rvcm1qcy9idWlsZC9yZWxlYXNlL1N0b3JtTGliL3NyYy9saWJ0b21jcnlwdC9zcmMvbWF0aC9yYW5kX3ByaW1lLmMAbHRjX21wLm5hbWUgIT0gTlVMTAAvVXNlcnMvbWljaGFlbC9Eb2N1bWVudHMvV29ya2JlbmNoL1dvd3Nlci9yZXBvcy9zdG9ybWpzL2J1aWxkL3JlbGVhc2UvU3Rvcm1MaWIvc3JjL2xpYnRvbWNyeXB0L3NyYy9way9yc2EvcnNhX21ha2Vfa2V5LmMAa2V5ICE9IE5VTEwAb3V0ICE9ICgodm9pZCopMCkAL1VzZXJzL21pY2hhZWwvRG9jdW1lbnRzL1dvcmtiZW5jaC9Xb3dzZXIvcmVwb3Mvc3Rvcm1qcy9idWlsZC9yZWxlYXNlL1N0b3JtTGliL3NyYy9saWJ0b21jcnlwdC9zcmMvbWlzYy96ZXJvbWVtLmMAaW4gIT0gTlVMTAAvVXNlcnMvbWljaGFlbC9Eb2N1bWVudHMvV29ya2JlbmNoL1dvd3Nlci9yZXBvcy9zdG9ybWpzL2J1aWxkL3JlbGVhc2UvU3Rvcm1MaWIvc3JjL2xpYnRvbWNyeXB0L3NyYy9way9yc2EvcnNhX2V4cHRtb2QuYwBvdXQgIT0gTlVMTABvdXRsZW4gIT0gTlVMTABrZXkgIT0gTlVMTABMaWJUb21NYXRoAAAAAOYSAAAcAAAADwAAABAAAAARAAAAEgAAABMAAAAUAAAAFQAAABYAAAAXAAAAGAAAABkAAAAaAAAAGwAAABwAAAAdAAAAHgAAAB8AAAAgAAAAIQAAACIAAAAjAAAAJAAAACUAAAAmAAAAJwAAACgAAAApAAAAKgAAACsAAAAsAAAALQAAAC4AAAAvAAAAMAAAADEAAAAyAAAAMwAAADQAAAA1AAAANgAAADcAAAA4AAAAOQAAADoAAAA7AAAAPAAAAD0AAABhICE9IE5VTEwAL1VzZXJzL21pY2hhZWwvRG9jdW1lbnRzL1dvcmtiZW5jaC9Xb3dzZXIvcmVwb3Mvc3Rvcm1qcy9idWlsZC9yZWxlYXNlL1N0b3JtTGliL3NyYy9saWJ0b21jcnlwdC9zcmMvbWF0aC9sdG1fZGVzYy5jAEHIKAt6/v///w0AAAD9////EAAAAGEgIT0gKCh2b2lkKikwKQBiICE9IE5VTEwAYyAhPSBOVUxMAGQgIT0gTlVMTABmbGF0LQBwYXJ0LQBtcHFlLQBibGs0LQBmaWxlOgBtYXA6AGh0dHA6AABYAAAAWQAAAFoAAABbAAAAJXUAQdApC7EIQBUAAGEVAACCFQAAoxUAAMQVAADlFQAABhYAACcWAABIFgAAaRYAAIoWAACrFgAAzBYAAO0WAAAOFwAALxcAAFAXAABxFwAAkhcAALMXAADUFwAA9RcAABYYAAA3GAAAWBgAAHkYAACaGAAAAAAAAFM0OEI2Q0RUTjVYRVFBS1FESk5ETEpCSjczRkRGTTNVAFVDTVhGNkVKWTM1MkVGSDRYRlJYQ0ZIMlhDOU1RUlpLAE1NS1ZIWTQ4UlA3V1hQNEdIWUJRN1NMOUo5VU5QSEJQADhNWExXSFE3VkdHTFRaOU1RWlFTRkRDTEpZRVQzQ1BQAEVKMlI1VE02WEZFMkdVTkc1UURHSEtROVVBS1BXWlNaAFBCR0ZCRTQyWjZMTks2NVVHSlEzV1pWTUNMUDRIUVFUAFg3U0VKSlM5VFNHQ1c1UDI4RUJTQzQ3QUpQRVk4VlUyADVLVkJRQThWWUU2WFJZM0RMR0M1WkRFNFhTNFA3WUEyADQ3OEpEMks1NkVWTlZWWTRYWDhURFdZVDVCOEtCMjU0ADhUUzRWTkZRUlpUTjZZV0hFOUNIVkRIOU5WV0Q0NzRBAExKNTJaMzJERjRMWjRaSkpYVktLM0FaUUE2R0FCTEpCAEs2QkRIWTJFQ1VFMjU0NVlLTkxCSlBWWVdIRTdYWUFHAE5EVlc4R1dMQVlDUlBHUk5ZOFJUN1paVVFVNjNWTFBSADZWV0NRVE44VjNaWk1SVUNaWFY4QThDR1VYMlRBQThIAFk0NU1EM0NBSzRLWFNTWEhZRDlWWTY0WjhFS0o0WEZYAEc4TU44VURHNk5BMkFOR1k2QTNETlk4MkhSR0YyOVpIAFc5UlJITEIyRkRVOVdXNUIzRUNFQkxSU0ZXWlNGN0hXADNESDVSRTVOVk01R1RGRDg1TFhHV1Q2Rks4NTlFVFI1ADhXTEtVQVhFOTRQRlFVNFkyNDlQQVoyNE40UjRYS1RRAEEzNERYWDNWSEdHWFNRQlJGRTVVRkZEWE1GOUc0RzU0AFpHN0o5SzkzOEhKRUZXUFFVQTc2OE1BMlBGRVI2RUFKAE5FN0NVTk5OVFZBUFhWN0UzRzJCU1ZCV0dWTVc4QkwyADNWOUUyRlRNQk05UVFXSzdVNk1BTVdBWldRREI4MzhGADJOU0ZCOE1FTFVMSjgzVTZZSEEzVVA2SzRNUUQ0OEw2AFFBMlRaOUVXWjRDVVU4Qk1CNVdYQ1RZNjVGOUNTVzRFAFZIQjM3OFc2NEJBVDlTSDdENjhWVjlOTFFESzlZRUdUAFUzTkZRSlY0TTZHQzdLQk45WFFKM0JSRE4zUExEOU5FAGV4cGFuZCAzMi1ieXRlIGswMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAJXMuJXUAQZAyC8YFYCAp4QHOqv6jq44wrwLRfUEkBr2uvkPDurcIE1HP+PclQqVK2g9SHJA7Y0k29t0b6ljUQHBhVQnNC6JLaCyK8Tw6ZbuhqCOX/RUAlIgzWen7aSHvhVtXbPq1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CEIAAAnkABAHBwAACFoAAAgaAAAJlAAUB0MAAAh6AAAIOgAACdQAEgcTAAAIagAACCoAAAm0AAAICgAACIoAAAhKAAAJ9AAQBwUAAAhWAAAIFgBACAAAEwczAAAIdgAACDYAAAnMABEHDwAACGYAAAgmAAAJrAAACAYAAAiGAAAIRgAACewAEAcJAAAIXgAACB4AAAmcABQHYwAACH4AAAg+AAAJ3AASBxsAAAhuAAAILgAACbwAAAgOAAAIjgAACE4AAAn8AGAHAAAACFEAAAgRABUIgwASBx8AAAhxAAAIMQAACcIAEAcKAAAIYQAACCEAAAmiAAAIAQAACIEAAAhBAAAJ4gAQBwYAAAhZAAAIGQAACZIAEwc7AAAIeQAACDkAAAnSABEHEQAACGkAAAgpAAAJsgAACAkAAAiJAAAISQAACfIAEAcEAAAIVQAACBUAEAgCARMHKwAACHUAAAg1AAAJygARBw0AAAhlAAAIJQAACaoAAAgFAAAIhQAACEUAAAnqABAHCAAACF0AAAgdAAAJmgAUB1MAAAh9AAAIPQAACdoAEgcXAAAIbQAACC0AAAm6AAAIDQAACI0AAAhNAAAJ+gAQBwMAAAhTAAAIEwAVCMMAEwcjAAAIcwAACDMAAAnGABEHCwAACGMAAAgjAAAJpgAACAMAAAiDAAAIQwAACeYAEAcHAAAIWwAACBsAAAmWABQHQwAACHsAAAg7AAAJ1gASBxMAAAhrAAAIKwAACbYAAAgLAAAIiwAACEsAAAn2ABAHBQAACFcAAAgXAEAIAAATBzMAAAh3AAAINwAACc4AEQcPAAAIZwAACCcAAAmuAAAIBwAACIcAAAhHAAAJ7gAQBwkAAAhfAAAIHwAACZ4AFAdjAAAIfwAACD8AAAneABIHGwAACG8AAAgvAAAJvgAACA8AAAiPAAAITwAACf4AYAcAAAAIUAAACBAAFAhzABIHHwAACHAAAAgwAAAJwQAQBwoAAAhgAAAIIAAACaEAAAgAAAAIgAAACEAAAAnhABAHBgAACFgAAAgYAAAJkQATBzsAAAh4AAAIOAAACdEAEQcRAAAIaAAACCgAAAmxAAAICAAACIgAAAhIAAAJ8QAQBwQAAAhUAAAIFAAVCOMAEwcrAAAIdAAACDQAAAnJABEHDQAACGQAAAgkAAAJqQAACAQAAAiEAAAIRAAACekAEAcIAAAIXAAACBwAAAmZABQHUwAACHwAAAg8AAAJ2QASBxcAAAhsAAAILAAACbkAAAgMAAAIjAAACEwAAAn5ABAHAwAACFIAAAgSABUIowATByMAAAhyAAAIMgAACcUAEQcLAAAIYgAACCIAAAmlAAAIAgAACIIAAAhCAAAJ5QAQBwcAAAhaAAAIGgAACZUAFAdDAAAIegAACDoAAAnVABIHEwAACGoAAAgqAAAJtQAACAoAAAiKAAAISgAACfUAEAcFAAAIVgAACBYAQAgAABMHMwAACHYAAAg2AAAJzQARBw8AAAhmAAAIJgAACa0AAAgGAAAIhgAACEYAAAntABAHCQAACF4AAAgeAAAJnQAUB2MAAAh+AAAIPgAACd0AEgcbAAAIbgAACC4AAAm9AAAIDgAACI4AAAhOAAAJ/QBgBwAAAAhRAAAIEQAVCIMAEgcfAAAIcQAACDEAAAnDABAHCgAACGEAAAghAAAJowAACAEAAAiBAAAIQQAACeMAEAcGAAAIWQAACBkAAAmTABMHOwAACHkAAAg5AAAJ0wARBxEAAAhpAAAIKQAACbMAAAgJAAAIiQAACEkAAAnzABAHBAAACFUAAAgVABAIAgETBysAAAh1AAAINQAACcsAEQcNAAAIZQAACCUAAAmrAAAIBQAACIUAAAhFAAAJ6wAQBwgAAAhdAAAIHQAACZsAFAdTAAAIfQAACD0AAAnbABIHFwAACG0AAAgtAAAJuwAACA0AAAiNAAAITQAACfsAEAcDAAAIUwAACBMAFQjDABMHIwAACHMAAAgzAAAJxwARBwsAAAhjAAAIIwAACacAAAgDAAAIgwAACEMAAAnnABAHBwAACFsAAAgbAAAJlwAUB0MAAAh7AAAIOwAACdcAEgcTAAAIawAACCsAAAm3AAAICwAACIsAAAhLAAAJ9wAQBwUAAAhXAAAIFwBACAAAEwczAAAIdwAACDcAAAnPABEHDwAACGcAAAgnAAAJrwAACAcAAAiHAAAIRwAACe8AEAcJAAAIXwAACB8AAAmfABQHYwAACH8AAAg/AAAJ3wASBxsAAAhvAAAILwAACb8AAAgPAAAIjwAACE8AAAn/ABAFAQAXBQEBEwURABsFARARBQUAGQUBBBUFQQAdBQFAEAUDABgFAQIUBSEAHAUBIBIFCQAaBQEIFgWBAEAFAAAQ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IHN5bXMgaW4gdXNlCgAgICAgICBpbml0aWFsIGdyb3VwICVkLCBbJWQgLi4gJWRdLCBoYXMgJWQgc3ltcyAoJTQuMWYlJSkKACAgICAgIHBhc3MgJWQ6IHNpemUgaXMgJWQsIGdycCB1c2VzIGFyZSAAJWQgACAgICAgIGJ5dGVzOiBtYXBwaW5nICVkLCAAc2VsZWN0b3JzICVkLCAAY29kZSBsZW5ndGhzICVkLCAAY29kZXMgJWQKAAogICAgWyVkOiBodWZmK210ZiAAcnQrcmxkAAoKYnppcDIvbGliYnppcDI6IGludGVybmFsIGVycm9yIG51bWJlciAlZC4KVGhpcyBpcyBhIGJ1ZyBpbiBiemlwMi9saWJiemlwMiwgJXMuClBsZWFzZSByZXBvcnQgaXQgdG8gbWUgYXQ6IGpzZXdhcmRAYnppcC5vcmcuICBJZiB0aGlzIGhhcHBlbmVkCndoZW4geW91IHdlcmUgdXNpbmcgc29tZSBwcm9ncmFtIHdoaWNoIHVzZXMgbGliYnppcDIgYXMgYQpjb21wb25lbnQsIHlvdSBzaG91bGQgYWxzbyByZXBvcnQgdGhpcyBidWcgdG8gdGhlIGF1dGhvcihzKQpvZiB0aGF0IHByb2dyYW0uICBQbGVhc2UgbWFrZSBhbiBlZmZvcnQgdG8gcmVwb3J0IHRoaXMgYnVnOwp0aW1lbHkgYW5kIGFjY3VyYXRlIGJ1ZyByZXBvcnRzIGV2ZW50dWFsbHkgbGVhZCB0byBoaWdoZXIKcXVhbGl0eSBzb2Z0d2FyZS4gIFRoYW5rcy4gIEp1bGlhbiBTZXdhcmQsIDEwIERlY2VtYmVyIDIwMDcuCgoACioqKiBBIHNwZWNpYWwgbm90ZSBhYm91dCBpbnRlcm5hbCBlcnJvciBudW1iZXIgMTAwNyAqKioKCkV4cGVyaWVuY2Ugc3VnZ2VzdHMgdGhhdCBhIGNvbW1vbiBjYXVzZSBvZiBpLmUuIDEwMDcKaXMgdW5yZWxpYWJsZSBtZW1vcnkgb3Igb3RoZXIgaGFyZHdhcmUuICBUaGUgMTAwNyBhc3NlcnRpb24KanVzdCBoYXBwZW5zIHRvIGNyb3NzLWNoZWNrIHRoZSByZXN1bHRzIG9mIGh1Z2UgbnVtYmVycyBvZgptZW1vcnkgcmVhZHMvd3JpdGVzLCBhbmQgc28gYWN0cyAodW5pbnRlbmRlZGx5KSBhcyBhIHN0cmVzcwp0ZXN0IG9mIHlvdXIgbWVtb3J5IHN5c3RlbS4KCkkgc3VnZ2VzdCB0aGUgZm9sbG93aW5nOiB0cnkgY29tcHJlc3NpbmcgdGhlIGZpbGUgYWdhaW4sCnBvc3NpYmx5IG1vbml0b3JpbmcgcHJvZ3Jlc3MgaW4gZGV0YWlsIHdpdGggdGhlIC12diBmbGFnLgoKKiBJZiB0aGUgZXJyb3IgY2Fubm90IGJlIHJlcHJvZHVjZWQsIGFuZC9vciBoYXBwZW5zIGF0IGRpZmZlcmVudAogIHBvaW50cyBpbiBjb21wcmVzc2lvbiwgeW91IG1heSBoYXZlIGEgZmxha3kgbWVtb3J5IHN5c3RlbS4KICBUcnkgYSBtZW1vcnktdGVzdCBwcm9ncmFtLiAgSSBoYXZlIHVzZWQgTWVtdGVzdDg2CiAgKHd3dy5tZW10ZXN0ODYuY29tKS4gIEF0IHRoZSB0aW1lIG9mIHdyaXRpbmcgaXQgaXMgZnJlZSAoR1BMZCkuCiAgTWVtdGVzdDg2IHRlc3RzIG1lbW9yeSBtdWNoIG1vcmUgdGhvcm91Z2x5IHRoYW4geW91ciBCSU9TcwogIHBvd2VyLW9uIHRlc3QsIGFuZCBtYXkgZmluZCBmYWlsdXJlcyB0aGF0IHRoZSBCSU9TIGRvZXNuJ3QuCgoqIElmIHRoZSBlcnJvciBjYW4gYmUgcmVwZWF0YWJseSByZXByb2R1Y2VkLCB0aGlzIGlzIGEgYnVnIGluCiAgYnppcDIsIGFuZCBJIHdvdWxkIHZlcnkgbXVjaCBsaWtlIHRvIGhlYXIgYWJvdXQgaXQuICBQbGVhc2UKICBsZXQgbWUga25vdywgYW5kLCBpZGVhbGx5LCBzYXZlIGEgY29weSBvZiB0aGUgZmlsZSBjYXVzaW5nIHRoZQogIHByb2JsZW0gLS0gd2l0aG91dCB3aGljaCBJIHdpbGwgYmUgdW5hYmxlIHRvIGludmVzdGlnYXRlIGl0LgoKACB7MHglMDh4LCAweCUwOHh9AAogICAgY29tYmluZWQgQ1JDczogc3RvcmVkID0gMHglMDh4LCBjb21wdXRlZCA9IDB4JTA4eAAxLjAuNSwgMTAtRGVjLTIwMDcAAAAAAAAABwAAAAgAAAAJAAAACgAAAAsAAAAMAAAADQAAAA4AAAAQAAAAEQAAABMAAAAVAAAAFwAAABkAAAAcAAAAHwAAACIAAAAlAAAAKQAAAC0AAAAyAAAANwAAADwAAABCAAAASQAAAFAAAABYAAAAYQAAAGsAAAB2AAAAggAAAI8AAACdAAAArQAAAL4AAADRAAAA5gAAAP0AAAAXAQAAMwEAAFEBAABzAQAAmAEAAMEBAADuAQAAIAIAAFYCAACSAgAA1AIAABwDAABsAwAAwwMAACQEAACOBAAAAgUAAIMFAAAQBgAAqwYAAFYHAAASCAAA4AgAAMMJAAC9CgAA0AsAAP8MAABMDgAAug8AAEwRAAAHEwAA7hQAAAYXAABUGQAA3BsAAKUeAAC2IQAAFSUAAMooAADfLAAAWzEAAEs2AAC5OwAAskEAAERIAAB+TwAAcVcAAC9gAADOaQAAYnQAAP9/AEGAywELhQH/////AAAAAP////8EAAAA/////wIAAAD/////BgAAAP////8BAAAA/////wUAAAD/////AwAAAP////8HAAAA/////wEAAAD/////BQAAAP////8DAAAA/////wcAAAD/////AgAAAP////8EAAAA/////wYAAAD/////CAAAADEuMi41AEGQzAELRhAAAACDAAAACAAAAIYAAAACAAAAggAAAAEAAACAAAAAgAAAAH8AAABAAAAAhQAAACAAAACBAAAAXQAAAAFPbGRXb3JsZFwAQeLMAQuBAwEAAwAHAA8AHwA/AH8A/wAobGlzdGZpbGUpAChhdHRyaWJ1dGVzKQAoc2lnbmF0dXJlKQAobGlzdGZpbGUpAChhdHRyaWJ1dGVzKQAoc2lnbmF0dXJlKQBGaWxlAG5hbWUgIT0gTlVMTAAvVXNlcnMvbWljaGFlbC9Eb2N1bWVudHMvV29ya2JlbmNoL1dvd3Nlci9yZXBvcy9zdG9ybWpzL2J1aWxkL3JlbGVhc2UvU3Rvcm1MaWIvc3JjL2xpYnRvbWNyeXB0L3NyYy9taXNjL2NyeXB0X2ZpbmRfaGFzaC5jAGluICE9IE5VTEwAL1VzZXJzL21pY2hhZWwvRG9jdW1lbnRzL1dvcmtiZW5jaC9Xb3dzZXIvcmVwb3Mvc3Rvcm1qcy9idWlsZC9yZWxlYXNlL1N0b3JtTGliL3NyYy9saWJ0b21jcnlwdC9zcmMvbWlzYy9iYXNlNjRfZGVjb2RlLmMAb3V0ICE9IE5VTEwAb3V0bGVuICE9IE5VTEwAQfDPAQvBD/////////////////////////////////////////////////////////8+////PzQ1Njc4OTo7PD3////+////AAECAwQFBgcICQoLDA0ODxAREhMUFRYXGBn///////8aGxwdHh8gISIjJCUmJygpKissLS4vMDEyM/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////9pbiAhPSBOVUxMAC9Vc2Vycy9taWNoYWVsL0RvY3VtZW50cy9Xb3JrYmVuY2gvV293c2VyL3JlcG9zL3N0b3JtanMvYnVpbGQvcmVsZWFzZS9TdG9ybUxpYi9zcmMvbGlidG9tY3J5cHQvc3JjL3BrL2FzbjEvZGVyX2RlY29kZV9ib29sZWFuLmMAb3V0ICE9IE5VTEwAb3V0bGVuICE9IE5VTEwAL1VzZXJzL21pY2hhZWwvRG9jdW1lbnRzL1dvcmtiZW5jaC9Xb3dzZXIvcmVwb3Mvc3Rvcm1qcy9idWlsZC9yZWxlYXNlL1N0b3JtTGliL3NyYy9saWJ0b21jcnlwdC9zcmMvcGsvYXNuMS9kZXJfbGVuZ3RoX2Jvb2xlYW4uYwBudW0gIT0gTlVMTAAvVXNlcnMvbWljaGFlbC9Eb2N1bWVudHMvV29ya2JlbmNoL1dvd3Nlci9yZXBvcy9zdG9ybWpzL2J1aWxkL3JlbGVhc2UvU3Rvcm1MaWIvc3JjL2xpYnRvbWNyeXB0L3NyYy9way9hc24xL2Rlcl9kZWNvZGVfaW50ZWdlci5jAGluICE9IE5VTEwAbnVtICE9IE5VTEwAL1VzZXJzL21pY2hhZWwvRG9jdW1lbnRzL1dvcmtiZW5jaC9Xb3dzZXIvcmVwb3Mvc3Rvcm1qcy9idWlsZC9yZWxlYXNlL1N0b3JtTGliL3NyYy9saWJ0b21jcnlwdC9zcmMvcGsvYXNuMS9kZXJfZGVjb2RlX3Nob3J0X2ludGVnZXIuYwBpbiAhPSBOVUxMAG91dGxlbiAhPSBOVUxMAC9Vc2Vycy9taWNoYWVsL0RvY3VtZW50cy9Xb3JrYmVuY2gvV293c2VyL3JlcG9zL3N0b3JtanMvYnVpbGQvcmVsZWFzZS9TdG9ybUxpYi9zcmMvbGlidG9tY3J5cHQvc3JjL3BrL2FzbjEvZGVyX2xlbmd0aF9zaG9ydF9pbnRlZ2VyLmMAaW4gIT0gTlVMTAAvVXNlcnMvbWljaGFlbC9Eb2N1bWVudHMvV29ya2JlbmNoL1dvd3Nlci9yZXBvcy9zdG9ybWpzL2J1aWxkL3JlbGVhc2UvU3Rvcm1MaWIvc3JjL2xpYnRvbWNyeXB0L3NyYy9way9hc24xL2Rlcl9kZWNvZGVfYml0X3N0cmluZy5jAG91dCAhPSBOVUxMAG91dGxlbiAhPSBOVUxMAG91dGxlbiAhPSBOVUxMAC9Vc2Vycy9taWNoYWVsL0RvY3VtZW50cy9Xb3JrYmVuY2gvV293c2VyL3JlcG9zL3N0b3JtanMvYnVpbGQvcmVsZWFzZS9TdG9ybUxpYi9zcmMvbGlidG9tY3J5cHQvc3JjL3BrL2FzbjEvZGVyX2xlbmd0aF9iaXRfc3RyaW5nLmMAaW4gIT0gTlVMTAAvVXNlcnMvbWljaGFlbC9Eb2N1bWVudHMvV29ya2JlbmNoL1dvd3Nlci9yZXBvcy9zdG9ybWpzL2J1aWxkL3JlbGVhc2UvU3Rvcm1MaWIvc3JjL2xpYnRvbWNyeXB0L3NyYy9way9hc24xL2Rlcl9kZWNvZGVfb2N0ZXRfc3RyaW5nLmMAb3V0ICE9IE5VTEwAb3V0bGVuICE9IE5VTEwAb3V0bGVuICE9IE5VTEwAL1VzZXJzL21pY2hhZWwvRG9jdW1lbnRzL1dvcmtiZW5jaC9Xb3dzZXIvcmVwb3Mvc3Rvcm1qcy9idWlsZC9yZWxlYXNlL1N0b3JtTGliL3NyYy9saWJ0b21jcnlwdC9zcmMvcGsvYXNuMS9kZXJfbGVuZ3RoX29jdGV0X3N0cmluZy5jAGluICE9IE5VTEwAL1VzZXJzL21pY2hhZWwvRG9jdW1lbnRzL1dvcmtiZW5jaC9Xb3dzZXIvcmVwb3Mvc3Rvcm1qcy9idWlsZC9y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AABaAAAAYQAAAGEAAABiAAAAYgAAAGMAAABjAAAAZAAAAGQAAABlAAAAZQAAAGYAAABmAAAAZwAAAGcAAABoAAAAaAAAAGkAAABpAAAAagAAAGoAAABrAAAAawAAAGwAAABsAAAAbQAAAG0AAABuAAAAbgAAAG8AAABvAAAAcAAAAHAAAABxAAAAcQAAAHIAAAByAAAAcwAAAHMAAAB0AAAAdAAAAHUAAAB1AAAAdgAAAHYAAAB3AAAAdwAAAHgAAAB4AAAAeQAAAHkAAAB6AAAAegAAAG91dGxlbiAhPSBOVUxMAC9Vc2Vycy9taWNoYWVsL0RvY3VtZW50cy9Xb3JrYmVuY2gvV293c2VyL3JlcG9zL3N0b3JtanMvYnVpbGQvcmVsZWFzZS9TdG9ybUxpYi9zcmMvbGlidG9tY3J5cHQvc3JjL3BrL2FzbjEvZGVyX2xlbmd0aF9wcmludGFibGVfc3RyaW5nLmMAb2N0ZXRzICE9IE5VTEwAaW4gIT0gTlVMTAAvVXNlcnMvbWljaGFlbC9Eb2N1bWVudHMvV29ya2JlbmNoL1dvd3Nlci9yZXBvcy9zdG9ybWpzL2J1aWxkL3JlbGVhc2UvU3Rvcm1MaWIvc3JjL2xpYnRvbWNyeXB0L3NyYy9way9hc24xL2Rlcl9kZWNvZGVfcHJpbnRhYmxlX3N0cmluZy5jAG91dCAhPSBOVUxMAG91dGxlbiAhPSBOVUxMAGluICE9IE5VTEwAL1VzZXJzL21pY2hhZWwvRG9jdW1lbnRzL1dvcmtiZW5jaC9Xb3dzZXIvcmVwb3Mvc3Rvcm1qcy9idWlsZC9yZWxlYXNlL1N0b3JtTGliL3NyYy9saWJ0b21jcnlwdC9zcmMvcGsvYXNuMS9kZXJfZGVjb2RlX3V0Zjhfc3RyaW5nLmMAb3V0ICE9IE5VTEwAb3V0bGVuICE9IE5VTEwAaW4gIT0gTlVMTAAvVXNlcnMvbWljaGFlbC9Eb2N1bWVudHMvV29ya2JlbmNoL1dvd3Nlci9yZXBvcy9zdG9ybWpzL2J1aWxkL3JlbGVhc2UvU3Rvcm1MaWIvc3JjL2xpYnRvbWNyeXB0L3NyYy9way9hc24xL2Rlcl9sZW5ndGhfdXRmOF9zdHJpbmcuYwBvdXRsZW4gIT0gTlVMTABpbiAhPSBOVUxMAC9Vc2Vycy9taWNoYWVsL0RvY3VtZW50cy9Xb3JrYmVuY2gvV293c2VyL3JlcG9zL3N0b3JtanMvYnVpbGQvcmVsZWFzZS9TdG9ybUxpYi9zcmMvbGlidG9tY3J5cHQvc3JjL3BrL2FzbjEvZGVyX2RlY29kZV91dGN0aW1lLmMAaW5sZW4gIT0gTlVMTABvdXQgIT0gTlVMTABudW0gIT0gTlVMTAAvVXNlcnMvbWljaGFlbC9Eb2N1bWVudHMvV29ya2JlbmNoL1dvd3Nlci9yZXBvcy9zdG9ybWpzL2J1aWxkL3JlbGVhc2UvU3Rvcm1MaWIvc3JjL2xpYnRvbWNyeXB0L3NyYy9way9hc24xL2Rlcl9sZW5ndGhfaW50ZWdlci5jAG91dGxlbiAhPSBOVUxMAG91dGxlbiAhPSBOVUxMAC9Vc2Vycy9taWNoYWVsL0RvY3VtZW50cy9Xb3JrYmVuY2gvV293c2VyL3JlcG9zL3N0b3JtanMvYnVpbGQvcmVsZWFzZS9TdG9ybUxpYi9zcmMvbGlidG9tY3J5cHQvc3JjL3BrL2FzbjEvZGVyX2xlbmd0aF91dGN0aW1lLmMAdXRjdGltZSAhPSBOVUxMAGxpc3QgIT0gTlVMTAAvVXNlcnMvbWljaGFlbC9Eb2N1bWVudHMvV29ya2JlbmNoL1dvd3Nlci9yZXBvcy9zdG9ybWpzL2J1aWxkL3JlbGVhc2UvU3Rvcm1MaWIvc3JjL2xpYnRvbWNyeXB0L3NyYy9way9hc24xL2Rlcl9sZW5ndGhfc2VxdWVuY2UuYwBvdXRsZW4gIT0gTlVMTABpbiAhPSBOVUxMAC9Vc2Vycy9taWNoYWVsL0RvY3VtZW50cy9Xb3JrYmVuY2gvV293c2VyL3JlcG9zL3N0b3JtanMvYnVpbGQvcmVsZWFzZS9TdG9ybUxpYi9zcmMvbGlidG9tY3J5cHQvc3JjL3BrL2FzbjEvZGVyX2RlY29kZV9jaG9pY2UuYwBpbmxlbiAhPSBOVUxMAGxpc3QgIT0gTlVMTABpbiAhPSBOVUxMAC9Vc2Vycy9taWNoYWVsL0RvY3VtZW50cy9Xb3JrYmVuY2gvV293c2VyL3JlcG9zL3N0b3JtanMvYnVpbGQvcmVsZWFzZS9TdG9ybUxpYi9zcmMvbGlidG9tY3J5cHQvc3JjL3BrL2FzbjEvZGVyX2RlY29kZV9zZXF1ZW5jZV9leC5jAGxpc3QgIT0gTlVMTABpbiAhPSBOVUxMAC9Vc2Vycy9taWNoYWVsL0RvY3VtZW50cy9Xb3JrYmVuY2gvV293c2VyL3JlcG9zL3N0b3JtanMvYnVpbGQvcmVsZWFzZS9TdG9ybUxpYi9zcmMvbGlidG9tY3J5cHQvc3JjL3BrL2FzbjEvZGVyX2RlY29kZV9zZXF1ZW5jZV9tdWx0aS5jAGluICE9IE5VTEwAL1VzZXJzL21pY2hhZWwvRG9jdW1lbnRzL1dvcmtiZW5jaC9Xb3dzZXIvcmVwb3Mvc3Rvcm1qcy9idWlsZC9yZWxlYXNlL1N0b3JtTGliL3NyYy9saWJ0b21jcnlwdC9zcmMvcGsvcnNhL3JzYV9pbXBvcnQuYwBrZXkgIT0gTlVMTABsdGNfbXAubmFtZSAhPSBOVUxMAHNlZWQgIT0gTlVMTAAvVXNlcnMvbWljaGFlbC9Eb2N1bWVudHMvV29ya2JlbmNoL1dvd3Nlci9yZXBvcy9zdG9ybWpzL2J1aWxkL3JlbGVhc2UvU3Rvcm1MaWIvc3JjL2xpYnRvbWNyeXB0L3NyYy9way9wa2NzMS9wa2NzXzFfbWdmMS5jAG1hc2sgIT0gTlVMTABtc2doYXNoICE9IE5VTEwAL1VzZXJzL21pY2hhZWwvRG9jdW1lbnRzL1dvcmtiZW5jaC9Xb3dzZXIvcmVwb3Mvc3Rvcm1qcy9idWlsZC9yZWxlYXNlL1N0b3JtTGliL3NyYy9saWJ0b21jcnlwdC9zcmMvcGsvcGtjczEvcGtjc18xX3Bzc19lbmNvZGUuYwBvdXQgIT0gTlVMTABvdXRsZW4gIT0gTlVMTABvdXRsZW4gIT0gTlVMTAAvVXNlcnMvbWljaGFlbC9Eb2N1bWVudHMvV29ya2JlbmNoL1dvd3Nlci9yZXBvcy9zdG9ybWpzL2J1aWxkL3JlbGVhc2UvU3Rvcm1MaWIvc3JjL2xpYnRvbWNyeXB0L3NyYy9way9hc24xL2Rlcl9lbmNvZGVfYm9vbGVhbi5jAG91dCAhPSBOVUxMAG51bSAhPSBOVUxMAC9Vc2Vycy9taWNoYWVsL0RvY3VtZW50cy9Xb3JrYmVuY2gvV293c2VyL3JlcG9zL3N0b3JtanMvYnVpbGQvcmVsZWFzZS9TdG9ybUxpYi9zcmMvbGlidG9tY3J5cHQvc3JjL3BrL2FzbjEvZGVyX2VuY29kZV9pbnRlZ2VyLmMAb3V0ICE9IE5VTEwAb3V0bGVuICE9IE5VTEwAb3V0ICE9IE5VTEwAL1VzZXJzL21pY2hhZWwvRG9jdW1lbnRzL1dvcmtiZW5jaC9Xb3dzZXIvcmVwb3Mvc3Rvcm1qcy9idWlsZC9yZWxlYXNlL1N0b3JtTGliL3NyYy9saWJ0b21jcnlwdC9zcmMvcGsvYXNuMS9kZXJfZW5jb2RlX3Nob3J0X2ludGVnZXIuYwBvdXRsZW4gIT0gTlVMTABpbiAhPSBOVUxMAC9Vc2Vycy9taWNoYWVsL0RvY3VtZW50cy9Xb3JrYmVuY2gvV293c2VyL3JlcG9zL3N0b3JtanMvYnVpbGQvcmVsZWFzZS9TdG9ybUxpYi9zcmMvbGlidG9tY3J5cHQvc3JjL3BrL2FzbjEvZGVyX2VuY29kZV9iaXRfc3RyaW5nLmMAb3V0ICE9IE5VTEwAb3V0bGVuICE9IE5VTEwAaW4gIT0gTlVMTAAvVXNlcnMvbWljaGFlbC9Eb2N1bWVudHMvV29ya2JlbmNoL1dvd3Nlci9yZXBvcy9zdG9ybWpzL2J1aWxkL3JlbGVhc2UvU3Rvcm1MaWIvc3JjL2xpYnRvbWNyeXB0L3NyYy9way9hc24xL2Rlcl9lbmNvZGVfb2N0ZXRfc3RyaW5nLmMAb3V0ICE9IE5VTEwAb3V0bGVuICE9IE5VTEwAd29yZHMgIT0gTlVMTAAvVXNlcnMvbWljaGFlbC9Eb2N1bWVudHMvV29ya2JlbmNoL1dvd3Nlci9yZXBvcy9zdG9ybWpzL2J1aWxkL3JlbGVhc2UvU3Rvcm1MaWIvc3JjL2xpYnRvbWNyeXB0L3NyYy9way9hc24xL2Rlcl9lbmNvZGVfb2JqZWN0X2lkZW50aWZpZXIuYwBvdXQgIT0gTlVMTABvdXRsZW4gIT0gTlVMTABpbiAhPSBOVUxMAC9Vc2Vycy9taWNoYWVsL0RvY3VtZW50cy9Xb3JrYmVuY2gvV293c2VyL3JlcG9zL3N0b3JtanMvYnVpbGQvcmVsZWFzZS9TdG9ybUxpYi9zcmMvbGlidG9tY3J5cHQvc3JjL3BrL2FzbjEvZGVyX2VuY29kZV9pYTVfc3RyaW5nLmMAb3V0ICE9IE5VTEwAb3V0bGVuICE9IE5VTEwAaW4gIT0gTlVMTAAvVXNlcnMvbWljaGFlbC9Eb2N1bWVudHMvV29ya2JlbmNoL1dvd3Nlci9yZXBvcy9zdG9ybWpzL2J1aWxkL3JlbGVhc2UvU3Rvcm1MaWIvc3JjL2xpYnRvbWNyeXB0L3NyYy9way9hc24xL2Rlcl9lbmNvZGVfcHJpbnRhYmxlX3N0cmluZy5jAG91dCAhPSBOVUxMAG91dGxlbiAhPSBOVUxMAGluICE9IE5VTEwAL1VzZXJzL21pY2hhZWwvRG9jdW1lbnRzL1dvcmtiZW5jaC9Xb3dzZXIvcmVwb3Mvc3Rvcm1qcy9idWlsZC9yZWxlYXNlL1N0b3JtTGliL3NyYy9saWJ0b21jcnlwdC9zcmMvcGsvYXNuMS9kZXJfZW5jb2RlX3V0Zjhfc3RyaW5nLmMAb3V0ICE9IE5VTEwAb3V0bGVuICE9IE5VTEwAdXRjdGltZSAhPSBOVUxMAC9Vc2Vycy9taWNoYWVsL0RvY3VtZW50cy9Xb3JrYmVuY2gvV293c2VyL3JlcG9zL3N0b3JtanMvYnVpbGQvcmVsZWFzZS9TdG9ybUxpYi9zcmMvbGlidG9tY3J5cHQvc3JjL3BrL2FzbjEvZGVyX2VuY29kZV91dGN0aW1lLmMAb3V0ICE9IE5VTEwAb3V0bGVuICE9IE5VTEwAMDEyMzQ1Njc4OQABAAAAAgAAAAIAAAADAAAABAAAAAUAAAAGAAAAFgAAABMAAAAMAAAAFwAAAP////8wAAAAMQAAADEAAAD//////v////7////9/////P////v////6////6v///+3////0////6f///wEAAADQ////z////8////9saXN0ICE9IE5VTEwAL1VzZXJzL21pY2hhZWwvRG9jdW1lbnRzL1dvcmtiZW5jaC9Xb3dzZXIvcmVwb3Mvc3Rvcm1qcy9idWlsZC9yZWxlYXNlL1N0b3JtTGliL3NyYy9saWJ0b21jcnlwdC9zcmMvcGsvYXNuMS9kZXJfZW5jb2RlX3NlcXVlbmNlX2V4LmMAb3V0ICE9IE5VTEwAb3V0bGVuICE9IE5VTEwAaW4gIT0gTlVMTAAvVXNlcnMvbWljaGFlbC9Eb2N1bWVudHMvV29ya2JlbmNoL1dvd3Nlci9yZXBvcy9zdG9ybWpzL2J1aWxkL3JlbGVhc2UvU3Rvcm1MaWIvc3JjL2xpYnRvbWNyeXB0L3NyYy9way9yc2EvcnNhX3NpZ25faGFzaC5jAG91dCAhPSBOVUxMAG91dGxlbiAhPSBOVUxMAGtleSAhPSBOVUxMAGtleSAhPSAoKHZvaWQqKTApAC9Vc2Vycy9taWNoYWVsL0RvY3VtZW50cy9Xb3JrYmVuY2gvV293c2VyL3JlcG9zL3N0b3JtanMvYnVpbGQvcmVsZWFzZS9TdG9ybUxpYi9zcmMvbGlidG9tY3J5cHQvc3JjL3BrL3JzYS9yc2FfZnJlZS5jAChzaWduYXR1cmUpAG1kNQAtLS0tLUJFR0lOIFBSSVZBVEUgS0VZLS0tLS1NSUlCT1FJQkFBSkJBSkppZHdTL3VJTE1CU081RExHc0JGa25JWFdXalFKZTJrZmRmRWszRy9qNjZ3NEtraFoxVjYxUnQ0ekxhTVZDWXBEdW43Rkx3UmprTURTZXBPMXEyRGNDQXdFQUFRSkFOdGl6dFZETUpoMmhFMWhqUERLeVVtRUo5VS9hTjNnb211S09qYlFiUS9iV1djTS9XZmhTVkhtUHF0cWgvYlFJMlVYRnIwcm5YbmdldGVaSExyL2I4UUloQU11V3JpU0tHTUFDdzE4L3JWVmZVclRoczkxNW9kS0JIMUFscjN2TVZWelpBaUVBdUJIUFNRa2d3Y2I2TDRNV2FpS3VPenEwOG1TeU5xUGVOOG9TeTE4cTg0OENJSGVNbiszcytlT211N3N1MVVZUWw2eUg3T3JkQmQxcTNVeGZGTkVKaUFiaEFpQXF4ZEN5T3hIR2xiTTdhUzNET2czY3E1YXlvTjJjdnRWN2gxUjR0OE9tVndJZ0YrNXovNnZrekJVc1poZDhOd3lpcytNZVFZSDBycEZwTUtkVGxxbVBGMlE9LS0tLS1FTkQgUFJJVkFURSBLRVktLS0tLQBB0JQCCwZNWgAA//8AQeCUAguSAyiMAAAGAAAA/////wEAAAD/////LIwAAE1QURr/////AAAAAAAAAAAwjAAAUklGRv////8AAAAAAAAAADSMAABTTUsy/////wAAAAAAAAAAOIwAAEJJS2n/////AAAAAAAAAAA8jAAACgUBCP////8AAAAAAAAAAECMAABGT05U/////wAAAAAAAAAARIwAADxodG3/////AAAAAAAAAABIjAAAPEhUTf////8AAAAAAAAAAEiMAABXb28h/////wAAAAAAAAAATYwAAEJMUDH/////AAAAAAAAAABRjAAAQkxQMv////8AAAAAAAAAAFGMAABNRExY/////wAAAAAAAAAAVYwAAFRZUEX/////AAAAAAAAAABZjAAAR0lGOP////8AAAAAAAAAAF2MAABNRDIw/////wAAAAAAAAAAYYwAAFdEQkP/////AAAAAAAAAABkjAAAU1BYR/////8AAAAAAAAAAGiMAAD/2P/g/////wAAAAAAAAAAbIwAAElEO1D/////V1hMO/////9wjABBhJgCCwJ0jABBnJgCC4YBRmlsZSUwOHUuJXMAZXhlAGRjNgBtcHEAd2F2AHNtawBiaWsAcGN4AGZudABodG1sAHRibABibHAAbWR4AHB1ZABnaWYAbTIAZGJjAGJscwBqcGcAc2xrAHh4eABiYXNlXChwYXRjaF9tZXRhZGF0YSkAU3RyZWFtaW5nQnVja2V0cy50eHQAQbCZAgtdb40AABIAAAAWAAAAho0AABIAAAAWAAAAnY0AABIAAAAWAAAAtI0AABIAAAAWAAAAy40AABIAAAAWAAAA4o0AABIAAAAWAAAA+Y0AAAcAAAALAAAABY4AAAcAAAALAEGcmgILig5CYXNlAC1tZDUubHN0AGJhc2V0ZWVuZW5VU2VuR0JlbkNOZW5UV2RlREVlc0VTZXNNWGZyRlJpdElUa29LUnB0QlJwdFBUcnVSVXpoQ056aFRXAGV4cGFuc2lvbjEtbG9jYWxlLSMjIyMAZXhwYW5zaW9uMS1zcGVlY2gtIyMjIwBleHBhbnNpb24yLWxvY2FsZS0jIyMjAGV4cGFuc2lvbjItc3BlZWNoLSMjIyMAZXhwYW5zaW9uMy1sb2NhbGUtIyMjIwBleHBhbnNpb24zLXNwZWVjaC0jIyMjAGxvY2FsZS0jIyMjAHNwZWVjaC0jIyMjAEJhdHRsZS5uZXQAQ2FtcGFpZ25zAE1vZHMAXChwYXRjaF9tZXRhZGF0YSkALVBBVENIAFBhdGNoUHJlZml4AChwYXRjaF9tZXRhZGF0YSkARmlsZSUwOHUueHh4AChsaXN0ZmlsZSkAKHNpZ25hdHVyZSkAKGF0dHJpYnV0ZXMpAChhdHRyaWJ1dGVzKQAobGlzdGZpbGUpAChhdHRyaWJ1dGVzKQAoc2lnbmF0dXJlKQBmaWxlTmFtZQBwbGFpbk5hbWUAaGFzaEluZGV4AGJsb2NrSW5kZXgAZmlsZVNpemUAY29tcFNpemUAZmlsZVRpbWVMbwBmaWxlVGltZUhpAGxvY2FsZQBCdWYAZ2V0U2l6ZQB0b0pTAFB0cgBnZXRBZGRyAGlzTnVsbABTdHIAVm9pZFB0cgBVaW50MzJQdHIAU0ZpbGVGaW5kRGF0YQBHZXRMYXN0RXJyb3IAU0ZpbGVDbG9zZUFyY2hpdmUAU0ZpbGVDbG9zZUZpbGUAU0ZpbGVGaW5kQ2xvc2UAU0ZpbGVGaW5kRmlyc3RGaWxlAFNGaWxlRmluZE5leHRGaWxlAFNGaWxlR2V0RmlsZU5hbWUAU0ZpbGVHZXRGaWxlU2l6ZQBTRmlsZUhhc0ZpbGUAU0ZpbGVPcGVuQXJjaGl2ZQBTRmlsZU9wZW5QYXRjaEFyY2hpdmUAU0ZpbGVPcGVuRmlsZUV4AFNGaWxlUmVhZEZpbGUAU0ZpbGVTZXRGaWxlUG9pbnRlcgBFUlJPUl9GSUxFX05PVF9GT1VORABFUlJPUl9OT19NT1JFX0ZJTEVTAEZJTEVfQkVHSU4ATUFYX1BBVEgAU0ZJTEVfSU5WQUxJRF9TSVpFAFNUUkVBTV9GTEFHX1JFQURfT05MWQBOMTBlbXNjcmlwdGVuMTFtZW1vcnlfdmlld0loRUUAAAAA3JoAALKQAABOU3QzX18yMTJiYXNpY19zdHJpbmdJY05TXzExY2hhcl90cmFpdHNJY0VFTlNfOWFsbG9jYXRvckljRUVFRQBOU3QzX18yMjFfX2Jhc2ljX3N0cmluZ19jb21tb25JTGIxRUVFAAAAANyaAAAbkQAAYJsAANyQAAAAAAAAAQAAAESRAAAAAAAAYWxsb2NhdG9yPFQ+OjphbGxvY2F0ZShzaXplX3QgbikgJ24nIGV4Y2VlZHMgbWF4aW11bSBzdXBwb3J0ZWQgc2l6ZQA1RW1CdWYAANyaAACokQAAUDVFbUJ1ZgC8mwAAuJEAAAAAAACwkQAAUEs1RW1CdWYAAAAAvJsAANCRAAABAAAAsJEAAGlpAHYAdmkAwJEAAJyaAABpaWkAnJoAANyRAAAk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AADkmQAAOJoAAGIAAADkmQAARJoAAGMAAADkmQAAUJoAAGgAAADkmQAAXJoAAGEAAADkmQAAaJoAAHMAAADkmQAAdJoAAHQAAADkmQAAgJoAAGkAAADkmQAAjJoAAGoAAADkmQAAmJoAAGwAAADkmQAApJoAAG0AAADkmQAAsJoAAGYAAADkmQAAvJoAAGQAAADkmQAAyJoAAAAAAAAAmQAA4QAAAOYAAADjAAAA5AAAAOcAAADoAAAA6QAAAOoAAAAAAAAATJsAAOEAAADrAAAA4wAAAOQAAADnAAAA7AAAAO0AAADuAAAATjEwX19jeHhhYml2MTIwX19zaV9jbGFzc190eXBlX2luZm9FAAAAAASbAAAkmwAAAJkAAAAAAAComwAA4QAAAO8AAADjAAAA5AAAAOcAAADwAAAA8QAAAPIAAABOMTBfX2N4eGFiaXYxMjFfX3ZtaV9jbGFzc190eXBlX2luZm9FAAAABJsAAICbAAAAmQAAAAAAAGCZAADhAAAA8wAAAOMAAADkAAAA9AAAAHZvaWQAYm9vbABjaGFyAHNpZ25lZCBjaGFyAHVuc2lnbmVkIGNoYXIAc2hvcnQAdW5zaWduZWQgc2hvcnQAaW50AHVuc2lnbmVkIGludABsb25nAHVuc2lnbmVkIGxvbmcAZmxvYXQAZG91YmxlAHN0ZDo6c3RyaW5nAHN0ZDo6YmFzaWNfc3RyaW5nPHVuc2lnbmVkIGNoYXI+AHN0ZDo6d3N0cmluZwBzdGQ6OnUxNnN0cmluZwBzdGQ6OnUzMnN0cmluZwBlbXNjcmlwdGVuOjp2YWwAZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8Y2hhcj4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8c2lnbmVkIGNoYXI+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHVuc2lnbmVkIGNoYXI+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHNob3J0PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzx1bnNpZ25lZCBzaG9ydD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8aW50PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzx1bnNpZ25lZCBpbnQ+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PGxvbmc+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHVuc2lnbmVkIGxvbmc+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PGludDhfdD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8dWludDhfdD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8aW50MTZfdD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8dWludDE2X3Q+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PGludDMyX3Q+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHVpbnQzMl90PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxmbG9hdD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8ZG91YmxlPgBOU3QzX18yMTJiYXNpY19zdHJpbmdJaE5TXzExY2hhcl90cmFpdHNJaEVFTlNfOWFsbG9jYXRvckloRUVFRQAAAABgmwAA5p4AAAAAAAABAAAARJEAAAAAAABOU3QzX18yMTJiYXNpY19zdHJpbmdJd05TXzExY2hhcl90cmFpdHNJd0VFTlNfOWFsbG9jYXRvckl3RUVFRQAAYJsAAECfAAAAAAAAAQAAAESRAAAAAAAATlN0M19fMjEyYmFzaWNfc3RyaW5nSURzTlNfMTFjaGFyX3RyYWl0c0lEc0VFTlNfOWFsbG9jYXRvcklEc0VFRUUAAABgmwAAmJ8AAAAAAAABAAAARJEAAAAAAABOU3QzX18yMTJiYXNpY19zdHJpbmdJRGlOU18xMWNoYXJfdHJhaXRzSURpRUVOU185YWxsb2NhdG9ySURpRUVFRQAAAGCbAAD0nwAAAAAAAAEAAABEkQAAAAAAAE4xMGVtc2NyaXB0ZW4xMW1lbW9yeV92aWV3SWNFRQAA3JoAAFCgAABOMTBlbXNjcmlwdGVuMTFtZW1vcnlfdmlld0lhRUUAANyaAAB4oAAATjEwZW1zY3JpcHRlbjExbWVtb3J5X3ZpZXdJc0VFAADcmgAAoKAAAE4xMGVtc2NyaXB0ZW4xMW1lbW9yeV92aWV3SXRFRQAA3JoAAMigAABOMTBlbXNjcmlwdGVuMTFtZW1vcnlfdmlld0lpRUUAANyaAADwoAAATjEwZW1zY3JpcHRlbjExbWVtb3J5X3ZpZXdJakVFAADcmgAAGKEAAE4x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';
if (!isDataURI(wasmBinaryFile)) {
  wasmBinaryFile = locateFile(wasmBinaryFile);
}

function getBinary() {
  try {
    if (wasmBinary) {
      return new Uint8Array(wasmBinary);
    }

    var binary = tryParseAsDataURI(wasmBinaryFile);
    if (binary) {
      return binary;
    }
    if (readBinary) {
      return readBinary(wasmBinaryFile);
    } else {
      throw "both async and sync fetching of the wasm failed";
    }
  }
  catch (err) {
    abort(err);
  }
}

function getBinaryPromise() {
  // If we don't have the binary yet, and have the Fetch api, use that;
  // in some environments, like Electron's render process, Fetch api may be present, but have a different context than expected, let's only use it on the Web
  if (!wasmBinary && (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) && typeof fetch === 'function'
      // Let's not use fetch to get objects over file:// as it's most likely Cordova which doesn't support fetch for file://
      && !isFileURI(wasmBinaryFile)
      ) {
    return fetch(wasmBinaryFile, { credentials: 'same-origin' }).then(function(response) {
      if (!response['ok']) {
        throw "failed to load wasm binary file at '" + wasmBinaryFile + "'";
      }
      return response['arrayBuffer']();
    }).catch(function () {
      return getBinary();
    });
  }
  // Otherwise, getBinary should be able to get it synchronously
  return new Promise(function(resolve, reject) {
    resolve(getBinary());
  });
}



// Create the wasm instance.
// Receives the wasm imports, returns the exports.
function createWasm() {
  // prepare imports
  var info = {
    'env': asmLibraryArg,
    'wasi_snapshot_preview1': asmLibraryArg
  };
  // Load the wasm module and create an instance of using native support in the JS engine.
  // handle a generated wasm instance, receiving its exports and
  // performing other necessary setup
  /** @param {WebAssembly.Module=} module*/
  function receiveInstance(instance, module) {
    var exports = instance.exports;
    Module['asm'] = exports;
    removeRunDependency('wasm-instantiate');
  }
  // we can't run yet (except in a pthread, where we have a custom sync instantiator)
  addRunDependency('wasm-instantiate');


  function receiveInstantiatedSource(output) {
    // 'output' is a WebAssemblyInstantiatedSource object which has both the module and instance.
    // receiveInstance() will swap in the exports (to Module.asm) so they can be called
    // TODO: Due to Closure regression https://github.com/google/closure-compiler/issues/3193, the above line no longer optimizes out down to the following line.
    // When the regression is fixed, can restore the above USE_PTHREADS-enabled path.
    receiveInstance(output['instance']);
  }


  function instantiateArrayBuffer(receiver) {
    return getBinaryPromise().then(function(binary) {
      return WebAssembly.instantiate(binary, info);
    }).then(receiver, function(reason) {
      err('failed to asynchronously prepare wasm: ' + reason);
      abort(reason);
    });
  }

  // Prefer streaming instantiation if available.
  function instantiateAsync() {
    if (!wasmBinary &&
        typeof WebAssembly.instantiateStreaming === 'function' &&
        !isDataURI(wasmBinaryFile) &&
        // Don't use streaming for file:// delivered objects in a webview, fetch them synchronously.
        !isFileURI(wasmBinaryFile) &&
        typeof fetch === 'function') {
      fetch(wasmBinaryFile, { credentials: 'same-origin' }).then(function (response) {
        var result = WebAssembly.instantiateStreaming(response, info);
        return result.then(receiveInstantiatedSource, function(reason) {
            // We expect the most common failure cause to be a bad MIME type for the binary,
            // in which case falling back to ArrayBuffer instantiation should work.
            err('wasm streaming compile failed: ' + reason);
            err('falling back to ArrayBuffer instantiation');
            instantiateArrayBuffer(receiveInstantiatedSource);
          });
      });
    } else {
      return instantiateArrayBuffer(receiveInstantiatedSource);
    }
  }
  // User shell pages can write their own Module.instantiateWasm = function(imports, successCallback) callback
  // to manually instantiate the Wasm module themselves. This allows pages to run the instantiation parallel
  // to any other async startup actions they are performing.
  if (Module['instantiateWasm']) {
    try {
      var exports = Module['instantiateWasm'](info, receiveInstance);
      return exports;
    } catch(e) {
      err('Module.instantiateWasm callback failed with error: ' + e);
      return false;
    }
  }

  instantiateAsync();
  return {}; // no exports yet; we'll fill them in later
}


// Globals used by JS i64 conversions
var tempDouble;
var tempI64;

// === Body ===

var ASM_CONSTS = {
  
};




// STATICTOP = STATIC_BASE + 57872;
/* global initializers */  __ATINIT__.push({ func: function() { ___wasm_call_ctors() } });




/* no memory initializer */
// {{PRE_LIBRARY}}


  function demangle(func) {
      return func;
    }

  function demangleAll(text) {
      var regex =
        /\b_Z[\w\d_]+/g;
      return text.replace(regex,
        function(x) {
          var y = demangle(x);
          return x === y ? x : (y + ' [' + x + ']');
        });
    }

  function jsStackTrace() {
      var err = new Error();
      if (!err.stack) {
        // IE10+ special cases: It does have callstack info, but it is only populated if an Error object is thrown,
        // so try that as a special-case.
        try {
          throw new Error();
        } catch(e) {
          err = e;
        }
        if (!err.stack) {
          return '(no stack trace available)';
        }
      }
      return err.stack.toString();
    }

  function stackTrace() {
      var js = jsStackTrace();
      if (Module['extraStackTrace']) js += '\n' + Module['extraStackTrace']();
      return demangleAll(js);
    }

  function ___cxa_allocate_exception(size) {
      return _malloc(size);
    }

  
  var ___exception_infos={};
  
  var ___exception_last=0;
  
  function __ZSt18uncaught_exceptionv() { // std::uncaught_exception()
      return __ZSt18uncaught_exceptionv.uncaught_exceptions > 0;
    }function ___cxa_throw(ptr, type, destructor) {
      ___exception_infos[ptr] = {
        ptr: ptr,
        adjusted: [ptr],
        type: type,
        destructor: destructor,
        refcount: 0,
        caught: false,
        rethrown: false
      };
      ___exception_last = ptr;
      if (!("uncaught_exception" in __ZSt18uncaught_exceptionv)) {
        __ZSt18uncaught_exceptionv.uncaught_exceptions = 1;
      } else {
        __ZSt18uncaught_exceptionv.uncaught_exceptions++;
      }
      throw ptr;
    }

  
  
  var PATH={splitPath:function(filename) {
        var splitPathRe = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
        return splitPathRe.exec(filename).slice(1);
      },normalizeArray:function(parts, allowAboveRoot) {
        // if the path tries to go above the root, `up` ends up > 0
        var up = 0;
        for (var i = parts.length - 1; i >= 0; i--) {
          var last = parts[i];
          if (last === '.') {
            parts.splice(i, 1);
          } else if (last === '..') {
            parts.splice(i, 1);
            up++;
          } else if (up) {
            parts.splice(i, 1);
            up--;
          }
        }
        // if the path is allowed to go above the root, restore leading ..s
        if (allowAboveRoot) {
          for (; up; up--) {
            parts.unshift('..');
          }
        }
        return parts;
      },normalize:function(path) {
        var isAbsolute = path.charAt(0) === '/',
            trailingSlash = path.substr(-1) === '/';
        // Normalize the path
        path = PATH.normalizeArray(path.split('/').filter(function(p) {
          return !!p;
        }), !isAbsolute).join('/');
        if (!path && !isAbsolute) {
          path = '.';
        }
        if (path && trailingSlash) {
          path += '/';
        }
        return (isAbsolute ? '/' : '') + path;
      },dirname:function(path) {
        var result = PATH.splitPath(path),
            root = result[0],
            dir = result[1];
        if (!root && !dir) {
          // No dirname whatsoever
          return '.';
        }
        if (dir) {
          // It has a dirname, strip trailing slash
          dir = dir.substr(0, dir.length - 1);
        }
        return root + dir;
      },basename:function(path) {
        // EMSCRIPTEN return '/'' for '/', not an empty string
        if (path === '/') return '/';
        var lastSlash = path.lastIndexOf('/');
        if (lastSlash === -1) return path;
        return path.substr(lastSlash+1);
      },extname:function(path) {
        return PATH.splitPath(path)[3];
      },join:function() {
        var paths = Array.prototype.slice.call(arguments, 0);
        return PATH.normalize(paths.join('/'));
      },join2:function(l, r) {
        return PATH.normalize(l + '/' + r);
      }};
  
  
  function setErrNo(value) {
      HEAP32[((___errno_location())>>2)]=value;
      return value;
    }
  
  var PATH_FS={resolve:function() {
        var resolvedPath = '',
          resolvedAbsolute = false;
        for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
          var path = (i >= 0) ? arguments[i] : FS.cwd();
          // Skip empty and invalid entries
          if (typeof path !== 'string') {
            throw new TypeError('Arguments to path.resolve must be strings');
          } else if (!path) {
            return ''; // an invalid portion invalidates the whole thing
          }
          resolvedPath = path + '/' + resolvedPath;
          resolvedAbsolute = path.charAt(0) === '/';
        }
        // At this point the path should be resolved to a full absolute path, but
        // handle relative paths to be safe (might happen when process.cwd() fails)
        resolvedPath = PATH.normalizeArray(resolvedPath.split('/').filter(function(p) {
          return !!p;
        }), !resolvedAbsolute).join('/');
        return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
      },relative:function(from, to) {
        from = PATH_FS.resolve(from).substr(1);
        to = PATH_FS.resolve(to).substr(1);
        function trim(arr) {
          var start = 0;
          for (; start < arr.length; start++) {
            if (arr[start] !== '') break;
          }
          var end = arr.length - 1;
          for (; end >= 0; end--) {
            if (arr[end] !== '') break;
          }
          if (start > end) return [];
          return arr.slice(start, end - start + 1);
        }
        var fromParts = trim(from.split('/'));
        var toParts = trim(to.split('/'));
        var length = Math.min(fromParts.length, toParts.length);
        var samePartsLength = length;
        for (var i = 0; i < length; i++) {
          if (fromParts[i] !== toParts[i]) {
            samePartsLength = i;
            break;
          }
        }
        var outputParts = [];
        for (var i = samePartsLength; i < fromParts.length; i++) {
          outputParts.push('..');
        }
        outputParts = outputParts.concat(toParts.slice(samePartsLength));
        return outputParts.join('/');
      }};
  
  var TTY={ttys:[],init:function () {
        // https://github.com/emscripten-core/emscripten/pull/1555
        // if (ENVIRONMENT_IS_NODE) {
        //   // currently, FS.init does not distinguish if process.stdin is a file or TTY
        //   // device, it always assumes it's a TTY device. because of this, we're forcing
        //   // process.stdin to UTF8 encoding to at least make stdin reading compatible
        //   // with text files until FS.init can be refactored.
        //   process['stdin']['setEncoding']('utf8');
        // }
      },shutdown:function() {
        // https://github.com/emscripten-core/emscripten/pull/1555
        // if (ENVIRONMENT_IS_NODE) {
        //   // inolen: any idea as to why node -e 'process.stdin.read()' wouldn't exit immediately (with process.stdin being a tty)?
        //   // isaacs: because now it's reading from the stream, you've expressed interest in it, so that read() kicks off a _read() which creates a ReadReq operation
        //   // inolen: I thought read() in that case was a synchronous operation that just grabbed some amount of buffered data if it exists?
        //   // isaacs: it is. but it also triggers a _read() call, which calls readStart() on the handle
        //   // isaacs: do process.stdin.pause() and i'd think it'd probably close the pending call
        //   process['stdin']['pause']();
        // }
      },register:function(dev, ops) {
        TTY.ttys[dev] = { input: [], output: [], ops: ops };
        FS.registerDevice(dev, TTY.stream_ops);
      },stream_ops:{open:function(stream) {
          var tty = TTY.ttys[stream.node.rdev];
          if (!tty) {
            throw new FS.ErrnoError(43);
          }
          stream.tty = tty;
          stream.seekable = false;
        },close:function(stream) {
          // flush any pending line data
          stream.tty.ops.flush(stream.tty);
        },flush:function(stream) {
          stream.tty.ops.flush(stream.tty);
        },read:function(stream, buffer, offset, length, pos /* ignored */) {
          if (!stream.tty || !stream.tty.ops.get_char) {
            throw new FS.ErrnoError(60);
          }
          var bytesRead = 0;
          for (var i = 0; i < length; i++) {
            var result;
            try {
              result = stream.tty.ops.get_char(stream.tty);
            } catch (e) {
              throw new FS.ErrnoError(29);
            }
            if (result === undefined && bytesRead === 0) {
              throw new FS.ErrnoError(6);
            }
            if (result === null || result === undefined) break;
            bytesRead++;
            buffer[offset+i] = result;
          }
          if (bytesRead) {
            stream.node.timestamp = Date.now();
          }
          return bytesRead;
        },write:function(stream, buffer, offset, length, pos) {
          if (!stream.tty || !stream.tty.ops.put_char) {
            throw new FS.ErrnoError(60);
          }
          try {
            for (var i = 0; i < length; i++) {
              stream.tty.ops.put_char(stream.tty, buffer[offset+i]);
            }
          } catch (e) {
            throw new FS.ErrnoError(29);
          }
          if (length) {
            stream.node.timestamp = Date.now();
          }
          return i;
        }},default_tty_ops:{get_char:function(tty) {
          if (!tty.input.length) {
            var result = null;
            if (ENVIRONMENT_IS_NODE) {
              // we will read data by chunks of BUFSIZE
              var BUFSIZE = 256;
              var buf = Buffer.alloc ? Buffer.alloc(BUFSIZE) : new Buffer(BUFSIZE);
              var bytesRead = 0;
  
              try {
                bytesRead = nodeFS.readSync(process.stdin.fd, buf, 0, BUFSIZE, null);
              } catch(e) {
                // Cross-platform differences: on Windows, reading EOF throws an exception, but on other OSes,
                // reading EOF returns 0. Uniformize behavior by treating the EOF exception to return 0.
                if (e.toString().indexOf('EOF') != -1) bytesRead = 0;
                else throw e;
              }
  
              if (bytesRead > 0) {
                result = buf.slice(0, bytesRead).toString('utf-8');
              } else {
                result = null;
              }
            } else
            if (typeof window != 'undefined' &&
              typeof window.prompt == 'function') {
              // Browser.
              result = window.prompt('Input: ');  // returns null on cancel
              if (result !== null) {
                result += '\n';
              }
            } else if (typeof readline == 'function') {
              // Command line.
              result = readline();
              if (result !== null) {
                result += '\n';
              }
            }
            if (!result) {
              return null;
            }
            tty.input = intArrayFromString(result, true);
          }
          return tty.input.shift();
        },put_char:function(tty, val) {
          if (val === null || val === 10) {
            out(UTF8ArrayToString(tty.output, 0));
            tty.output = [];
          } else {
            if (val != 0) tty.output.push(val); // val == 0 would cut text output off in the middle.
          }
        },flush:function(tty) {
          if (tty.output && tty.output.length > 0) {
            out(UTF8ArrayToString(tty.output, 0));
            tty.output = [];
          }
        }},default_tty1_ops:{put_char:function(tty, val) {
          if (val === null || val === 10) {
            err(UTF8ArrayToString(tty.output, 0));
            tty.output = [];
          } else {
            if (val != 0) tty.output.push(val);
          }
        },flush:function(tty) {
          if (tty.output && tty.output.length > 0) {
            err(UTF8ArrayToString(tty.output, 0));
            tty.output = [];
          }
        }}};
  
  var MEMFS={ops_table:null,mount:function(mount) {
        return MEMFS.createNode(null, '/', 16384 | 511 /* 0777 */, 0);
      },createNode:function(parent, name, mode, dev) {
        if (FS.isBlkdev(mode) || FS.isFIFO(mode)) {
          // no supported
          throw new FS.ErrnoError(63);
        }
        if (!MEMFS.ops_table) {
          MEMFS.ops_table = {
            dir: {
              node: {
                getattr: MEMFS.node_ops.getattr,
                setattr: MEMFS.node_ops.setattr,
                lookup: MEMFS.node_ops.lookup,
                mknod: MEMFS.node_ops.mknod,
                rename: MEMFS.node_ops.rename,
                unlink: MEMFS.node_ops.unlink,
                rmdir: MEMFS.node_ops.rmdir,
                readdir: MEMFS.node_ops.readdir,
                symlink: MEMFS.node_ops.symlink
              },
              stream: {
                llseek: MEMFS.stream_ops.llseek
              }
            },
            file: {
              node: {
                getattr: MEMFS.node_ops.getattr,
                setattr: MEMFS.node_ops.setattr
              },
              stream: {
                llseek: MEMFS.stream_ops.llseek,
                read: MEMFS.stream_ops.read,
                write: MEMFS.stream_ops.write,
                allocate: MEMFS.stream_ops.allocate,
                mmap: MEMFS.stream_ops.mmap,
                msync: MEMFS.stream_ops.msync
              }
            },
            link: {
              node: {
                getattr: MEMFS.node_ops.getattr,
                setattr: MEMFS.node_ops.setattr,
                readlink: MEMFS.node_ops.readlink
              },
              stream: {}
            },
            chrdev: {
              node: {
                getattr: MEMFS.node_ops.getattr,
                setattr: MEMFS.node_ops.setattr
              },
              stream: FS.chrdev_stream_ops
            }
          };
        }
        var node = FS.createNode(parent, name, mode, dev);
        if (FS.isDir(node.mode)) {
          node.node_ops = MEMFS.ops_table.dir.node;
          node.stream_ops = MEMFS.ops_table.dir.stream;
          node.contents = {};
        } else if (FS.isFile(node.mode)) {
          node.node_ops = MEMFS.ops_table.file.node;
          node.stream_ops = MEMFS.ops_table.file.stream;
          node.usedBytes = 0; // The actual number of bytes used in the typed array, as opposed to contents.length which gives the whole capacity.
          // When the byte data of the file is populated, this will point to either a typed array, or a normal JS array. Typed arrays are preferred
          // for performance, and used by default. However, typed arrays are not resizable like normal JS arrays are, so there is a small disk size
          // penalty involved for appending file writes that continuously grow a file similar to std::vector capacity vs used -scheme.
          node.contents = null; 
        } else if (FS.isLink(node.mode)) {
          node.node_ops = MEMFS.ops_table.link.node;
          node.stream_ops = MEMFS.ops_table.link.stream;
        } else if (FS.isChrdev(node.mode)) {
          node.node_ops = MEMFS.ops_table.chrdev.node;
          node.stream_ops = MEMFS.ops_table.chrdev.stream;
        }
        node.timestamp = Date.now();
        // add the new node to the parent
        if (parent) {
          parent.contents[name] = node;
        }
        return node;
      },getFileDataAsRegularArray:function(node) {
        if (node.contents && node.contents.subarray) {
          var arr = [];
          for (var i = 0; i < node.usedBytes; ++i) arr.push(node.contents[i]);
          return arr; // Returns a copy of the original data.
        }
        return node.contents; // No-op, the file contents are already in a JS array. Return as-is.
      },getFileDataAsTypedArray:function(node) {
        if (!node.contents) return new Uint8Array(0);
        if (node.contents.subarray) return node.contents.subarray(0, node.usedBytes); // Make sure to not return excess unused bytes.
        return new Uint8Array(node.contents);
      },expandFileStorage:function(node, newCapacity) {
        var prevCapacity = node.contents ? node.contents.length : 0;
        if (prevCapacity >= newCapacity) return; // No need to expand, the storage was already large enough.
        // Don't expand strictly to the given requested limit if it's only a very small increase, but instead geometrically grow capacity.
        // For small filesizes (<1MB), perform size*2 geometric increase, but for large sizes, do a much more conservative size*1.125 increase to
        // avoid overshooting the allocation cap by a very large margin.
        var CAPACITY_DOUBLING_MAX = 1024 * 1024;
        newCapacity = Math.max(newCapacity, (prevCapacity * (prevCapacity < CAPACITY_DOUBLING_MAX ? 2.0 : 1.125)) >>> 0);
        if (prevCapacity != 0) newCapacity = Math.max(newCapacity, 256); // At minimum allocate 256b for each file when expanding.
        var oldContents = node.contents;
        node.contents = new Uint8Array(newCapacity); // Allocate new storage.
        if (node.usedBytes > 0) node.contents.set(oldContents.subarray(0, node.usedBytes), 0); // Copy old data over to the new storage.
        return;
      },resizeFileStorage:function(node, newSize) {
        if (node.usedBytes == newSize) return;
        if (newSize == 0) {
          node.contents = null; // Fully decommit when requesting a resize to zero.
          node.usedBytes = 0;
          return;
        }
        if (!node.contents || node.contents.subarray) { // Resize a typed array if that is being used as the backing store.
          var oldContents = node.contents;
          node.contents = new Uint8Array(newSize); // Allocate new storage.
          if (oldContents) {
            node.contents.set(oldContents.subarray(0, Math.min(newSize, node.usedBytes))); // Copy old data over to the new storage.
          }
          node.usedBytes = newSize;
          return;
        }
        // Backing with a JS array.
        if (!node.contents) node.contents = [];
        if (node.contents.length > newSize) node.contents.length = newSize;
        else while (node.contents.length < newSize) node.contents.push(0);
        node.usedBytes = newSize;
      },node_ops:{getattr:function(node) {
          var attr = {};
          // device numbers reuse inode numbers.
          attr.dev = FS.isChrdev(node.mode) ? node.id : 1;
          attr.ino = node.id;
          attr.mode = node.mode;
          attr.nlink = 1;
          attr.uid = 0;
          attr.gid = 0;
          attr.rdev = node.rdev;
          if (FS.isDir(node.mode)) {
            attr.size = 4096;
          } else if (FS.isFile(node.mode)) {
            attr.size = node.usedBytes;
          } else if (FS.isLink(node.mode)) {
            attr.size = node.link.length;
          } else {
            attr.size = 0;
          }
          attr.atime = new Date(node.timestamp);
          attr.mtime = new Date(node.timestamp);
          attr.ctime = new Date(node.timestamp);
          // NOTE: In our implementation, st_blocks = Math.ceil(st_size/st_blksize),
          //       but this is not required by the standard.
          attr.blksize = 4096;
          attr.blocks = Math.ceil(attr.size / attr.blksize);
          return attr;
        },setattr:function(node, attr) {
          if (attr.mode !== undefined) {
            node.mode = attr.mode;
          }
          if (attr.timestamp !== undefined) {
            node.timestamp = attr.timestamp;
          }
          if (attr.size !== undefined) {
            MEMFS.resizeFileStorage(node, attr.size);
          }
        },lookup:function(parent, name) {
          throw FS.genericErrors[44];
        },mknod:function(parent, name, mode, dev) {
          return MEMFS.createNode(parent, name, mode, dev);
        },rename:function(old_node, new_dir, new_name) {
          // if we're overwriting a directory at new_name, make sure it's empty.
          if (FS.isDir(old_node.mode)) {
            var new_node;
            try {
              new_node = FS.lookupNode(new_dir, new_name);
            } catch (e) {
            }
            if (new_node) {
              for (var i in new_node.contents) {
                throw new FS.ErrnoError(55);
              }
            }
          }
          // do the internal rewiring
          delete old_node.parent.contents[old_node.name];
          old_node.name = new_name;
          new_dir.contents[new_name] = old_node;
          old_node.parent = new_dir;
        },unlink:function(parent, name) {
          delete parent.contents[name];
        },rmdir:function(parent, name) {
          var node = FS.lookupNode(parent, name);
          for (var i in node.contents) {
            throw new FS.ErrnoError(55);
          }
          delete parent.contents[name];
        },readdir:function(node) {
          var entries = ['.', '..'];
          for (var key in node.contents) {
            if (!node.contents.hasOwnProperty(key)) {
              continue;
            }
            entries.push(key);
          }
          return entries;
        },symlink:function(parent, newname, oldpath) {
          var node = MEMFS.createNode(parent, newname, 511 /* 0777 */ | 40960, 0);
          node.link = oldpath;
          return node;
        },readlink:function(node) {
          if (!FS.isLink(node.mode)) {
            throw new FS.ErrnoError(28);
          }
          return node.link;
        }},stream_ops:{read:function(stream, buffer, offset, length, position) {
          var contents = stream.node.contents;
          if (position >= stream.node.usedBytes) return 0;
          var size = Math.min(stream.node.usedBytes - position, length);
          if (size > 8 && contents.subarray) { // non-trivial, and typed array
            buffer.set(contents.subarray(position, position + size), offset);
          } else {
            for (var i = 0; i < size; i++) buffer[offset + i] = contents[position + i];
          }
          return size;
        },write:function(stream, buffer, offset, length, position, canOwn) {
          // If the buffer is located in main memory (HEAP), and if
          // memory can grow, we can't hold on to references of the
          // memory buffer, as they may get invalidated. That means we
          // need to do copy its contents.
          if (buffer.buffer === HEAP8.buffer) {
            canOwn = false;
          }
  
          if (!length) return 0;
          var node = stream.node;
          node.timestamp = Date.now();
  
          if (buffer.subarray && (!node.contents || node.contents.subarray)) { // This write is from a typed array to a typed array?
            if (canOwn) {
              node.contents = buffer.subarray(offset, offset + length);
              node.usedBytes = length;
              return length;
            } else if (node.usedBytes === 0 && position === 0) { // If this is a simple first write to an empty file, do a fast set since we don't need to care about old data.
              node.contents = buffer.slice(offset, offset + length);
              node.usedBytes = length;
              return length;
            } else if (position + length <= node.usedBytes) { // Writing to an already allocated and used subrange of the file?
              node.contents.set(buffer.subarray(offset, offset + length), position);
              return length;
            }
          }
  
          // Appending to an existing file and we need to reallocate, or source data did not come as a typed array.
          MEMFS.expandFileStorage(node, position+length);
          if (node.contents.subarray && buffer.subarray) node.contents.set(buffer.subarray(offset, offset + length), position); // Use typed array write if available.
          else {
            for (var i = 0; i < length; i++) {
             node.contents[position + i] = buffer[offset + i]; // Or fall back to manual write if not.
            }
          }
          node.usedBytes = Math.max(node.usedBytes, position + length);
          return length;
        },llseek:function(stream, offset, whence) {
          var position = offset;
          if (whence === 1) {
            position += stream.position;
          } else if (whence === 2) {
            if (FS.isFile(stream.node.mode)) {
              position += stream.node.usedBytes;
            }
          }
          if (position < 0) {
            throw new FS.ErrnoError(28);
          }
          return position;
        },allocate:function(stream, offset, length) {
          MEMFS.expandFileStorage(stream.node, offset + length);
          stream.node.usedBytes = Math.max(stream.node.usedBytes, offset + length);
        },mmap:function(stream, buffer, offset, length, position, prot, flags) {
          if (!FS.isFile(stream.node.mode)) {
            throw new FS.ErrnoError(43);
          }
          var ptr;
          var allocated;
          var contents = stream.node.contents;
          // Only make a new copy when MAP_PRIVATE is specified.
          if ( !(flags & 2) &&
                contents.buffer === buffer.buffer ) {
            // We can't emulate MAP_SHARED when the file is not backed by the buffer
            // we're mapping to (e.g. the HEAP buffer).
            allocated = false;
            ptr = contents.byteOffset;
          } else {
            // Try to avoid unnecessary slices.
            if (position > 0 || position + length < contents.length) {
              if (contents.subarray) {
                contents = contents.subarray(position, position + length);
              } else {
                contents = Array.prototype.slice.call(contents, position, position + length);
              }
            }
            allocated = true;
            // malloc() can lead to growing the heap. If targeting the heap, we need to
            // re-acquire the heap buffer object in case growth had occurred.
            var fromHeap = (buffer.buffer == HEAP8.buffer);
            ptr = _malloc(length);
            if (!ptr) {
              throw new FS.ErrnoError(48);
            }
            (fromHeap ? HEAP8 : buffer).set(contents, ptr);
          }
          return { ptr: ptr, allocated: allocated };
        },msync:function(stream, buffer, offset, length, mmapFlags) {
          if (!FS.isFile(stream.node.mode)) {
            throw new FS.ErrnoError(43);
          }
          if (mmapFlags & 2) {
            // MAP_PRIVATE calls need not to be synced back to underlying fs
            return 0;
          }
  
          var bytesWritten = MEMFS.stream_ops.write(stream, buffer, 0, length, offset, false);
          // should we check if bytesWritten and length are the same?
          return 0;
        }}};
  
  
  var ERRNO_CODES={EPERM:63,ENOENT:44,ESRCH:71,EINTR:27,EIO:29,ENXIO:60,E2BIG:1,ENOEXEC:45,EBADF:8,ECHILD:12,EAGAIN:6,EWOULDBLOCK:6,ENOMEM:48,EACCES:2,EFAULT:21,ENOTBLK:105,EBUSY:10,EEXIST:20,EXDEV:75,ENODEV:43,ENOTDIR:54,EISDIR:31,EINVAL:28,ENFILE:41,EMFILE:33,ENOTTY:59,ETXTBSY:74,EFBIG:22,ENOSPC:51,ESPIPE:70,EROFS:69,EMLINK:34,EPIPE:64,EDOM:18,ERANGE:68,ENOMSG:49,EIDRM:24,ECHRNG:106,EL2NSYNC:156,EL3HLT:107,EL3RST:108,ELNRNG:109,EUNATCH:110,ENOCSI:111,EL2HLT:112,EDEADLK:16,ENOLCK:46,EBADE:113,EBADR:114,EXFULL:115,ENOANO:104,EBADRQC:103,EBADSLT:102,EDEADLOCK:16,EBFONT:101,ENOSTR:100,ENODATA:116,ETIME:117,ENOSR:118,ENONET:119,ENOPKG:120,EREMOTE:121,ENOLINK:47,EADV:122,ESRMNT:123,ECOMM:124,EPROTO:65,EMULTIHOP:36,EDOTDOT:125,EBADMSG:9,ENOTUNIQ:126,EBADFD:127,EREMCHG:128,ELIBACC:129,ELIBBAD:130,ELIBSCN:131,ELIBMAX:132,ELIBEXEC:133,ENOSYS:52,ENOTEMPTY:55,ENAMETOOLONG:37,ELOOP:32,EOPNOTSUPP:138,EPFNOSUPPORT:139,ECONNRESET:15,ENOBUFS:42,EAFNOSUPPORT:5,EPROTOTYPE:67,ENOTSOCK:57,ENOPROTOOPT:50,ESHUTDOWN:140,ECONNREFUSED:14,EADDRINUSE:3,ECONNABORTED:13,ENETUNREACH:40,ENETDOWN:38,ETIMEDOUT:73,EHOSTDOWN:142,EHOSTUNREACH:23,EINPROGRESS:26,EALREADY:7,EDESTADDRREQ:17,EMSGSIZE:35,EPROTONOSUPPORT:66,ESOCKTNOSUPPORT:137,EADDRNOTAVAIL:4,ENETRESET:39,EISCONN:30,ENOTCONN:53,ETOOMANYREFS:141,EUSERS:136,EDQUOT:19,ESTALE:72,ENOTSUP:138,ENOMEDIUM:148,EILSEQ:25,EOVERFLOW:61,ECANCELED:11,ENOTRECOVERABLE:56,EOWNERDEAD:62,ESTRPIPE:135};var NODEFS={isWindows:false,staticInit:function() {
        NODEFS.isWindows = !!process.platform.match(/^win/);
        var flags = process["binding"]("constants");
        // Node.js 4 compatibility: it has no namespaces for constants
        if (flags["fs"]) {
          flags = flags["fs"];
        }
        NODEFS.flagsForNodeMap = {
          "1024": flags["O_APPEND"],
          "64": flags["O_CREAT"],
          "128": flags["O_EXCL"],
          "0": flags["O_RDONLY"],
          "2": flags["O_RDWR"],
          "4096": flags["O_SYNC"],
          "512": flags["O_TRUNC"],
          "1": flags["O_WRONLY"]
        };
      },bufferFrom:function (arrayBuffer) {
        // Node.js < 4.5 compatibility: Buffer.from does not support ArrayBuffer
        // Buffer.from before 4.5 was just a method inherited from Uint8Array
        // Buffer.alloc has been added with Buffer.from together, so check it instead
        return Buffer["alloc"] ? Buffer.from(arrayBuffer) : new Buffer(arrayBuffer);
      },convertNodeCode:function(e) {
        var code = e.code;
        return ERRNO_CODES[code];
      },mount:function (mount) {
        return NODEFS.createNode(null, '/', NODEFS.getMode(mount.opts.root), 0);
      },createNode:function (parent, name, mode, dev) {
        if (!FS.isDir(mode) && !FS.isFile(mode) && !FS.isLink(mode)) {
          throw new FS.ErrnoError(28);
        }
        var node = FS.createNode(parent, name, mode);
        node.node_ops = NODEFS.node_ops;
        node.stream_ops = NODEFS.stream_ops;
        return node;
      },getMode:function (path) {
        var stat;
        try {
          stat = fs.lstatSync(path);
          if (NODEFS.isWindows) {
            // Node.js on Windows never represents permission bit 'x', so
            // propagate read bits to execute bits
            stat.mode = stat.mode | ((stat.mode & 292) >> 2);
          }
        } catch (e) {
          if (!e.code) throw e;
          throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
        }
        return stat.mode;
      },realPath:function (node) {
        var parts = [];
        while (node.parent !== node) {
          parts.push(node.name);
          node = node.parent;
        }
        parts.push(node.mount.opts.root);
        parts.reverse();
        return PATH.join.apply(null, parts);
      },flagsForNode:function(flags) {
        flags &= ~0x200000 /*O_PATH*/; // Ignore this flag from musl, otherwise node.js fails to open the file.
        flags &= ~0x800 /*O_NONBLOCK*/; // Ignore this flag from musl, otherwise node.js fails to open the file.
        flags &= ~0x8000 /*O_LARGEFILE*/; // Ignore this flag from musl, otherwise node.js fails to open the file.
        flags &= ~0x80000 /*O_CLOEXEC*/; // Some applications may pass it; it makes no sense for a single process.
        var newFlags = 0;
        for (var k in NODEFS.flagsForNodeMap) {
          if (flags & k) {
            newFlags |= NODEFS.flagsForNodeMap[k];
            flags ^= k;
          }
        }
  
        if (!flags) {
          return newFlags;
        } else {
          throw new FS.ErrnoError(28);
        }
      },node_ops:{getattr:function(node) {
          var path = NODEFS.realPath(node);
          var stat;
          try {
            stat = fs.lstatSync(path);
          } catch (e) {
            if (!e.code) throw e;
            throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
          }
          // node.js v0.10.20 doesn't report blksize and blocks on Windows. Fake them with default blksize of 4096.
          // See http://support.microsoft.com/kb/140365
          if (NODEFS.isWindows && !stat.blksize) {
            stat.blksize = 4096;
          }
          if (NODEFS.isWindows && !stat.blocks) {
            stat.blocks = (stat.size+stat.blksize-1)/stat.blksize|0;
          }
          return {
            dev: stat.dev,
            ino: stat.ino,
            mode: stat.mode,
            nlink: stat.nlink,
            uid: stat.uid,
            gid: stat.gid,
            rdev: stat.rdev,
            size: stat.size,
            atime: stat.atime,
            mtime: stat.mtime,
            ctime: stat.ctime,
            blksize: stat.blksize,
            blocks: stat.blocks
          };
        },setattr:function(node, attr) {
          var path = NODEFS.realPath(node);
          try {
            if (attr.mode !== undefined) {
              fs.chmodSync(path, attr.mode);
              // update the common node structure mode as well
              node.mode = attr.mode;
            }
            if (attr.timestamp !== undefined) {
              var date = new Date(attr.timestamp);
              fs.utimesSync(path, date, date);
            }
            if (attr.size !== undefined) {
              fs.truncateSync(path, attr.size);
            }
          } catch (e) {
            if (!e.code) throw e;
            throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
          }
        },lookup:function (parent, name) {
          var path = PATH.join2(NODEFS.realPath(parent), name);
          var mode = NODEFS.getMode(path);
          return NODEFS.createNode(parent, name, mode);
        },mknod:function (parent, name, mode, dev) {
          var node = NODEFS.createNode(parent, name, mode, dev);
          // create the backing node for this in the fs root as well
          var path = NODEFS.realPath(node);
          try {
            if (FS.isDir(node.mode)) {
              fs.mkdirSync(path, node.mode);
            } else {
              fs.writeFileSync(path, '', { mode: node.mode });
            }
          } catch (e) {
            if (!e.code) throw e;
            throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
          }
          return node;
        },rename:function (oldNode, newDir, newName) {
          var oldPath = NODEFS.realPath(oldNode);
          var newPath = PATH.join2(NODEFS.realPath(newDir), newName);
          try {
            fs.renameSync(oldPath, newPath);
          } catch (e) {
            if (!e.code) throw e;
            throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
          }
          oldNode.name = newName;
        },unlink:function(parent, name) {
          var path = PATH.join2(NODEFS.realPath(parent), name);
          try {
            fs.unlinkSync(path);
          } catch (e) {
            if (!e.code) throw e;
            throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
          }
        },rmdir:function(parent, name) {
          var path = PATH.join2(NODEFS.realPath(parent), name);
          try {
            fs.rmdirSync(path);
          } catch (e) {
            if (!e.code) throw e;
            throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
          }
        },readdir:function(node) {
          var path = NODEFS.realPath(node);
          try {
            return fs.readdirSync(path);
          } catch (e) {
            if (!e.code) throw e;
            throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
          }
        },symlink:function(parent, newName, oldPath) {
          var newPath = PATH.join2(NODEFS.realPath(parent), newName);
          try {
            fs.symlinkSync(oldPath, newPath);
          } catch (e) {
            if (!e.code) throw e;
            throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
          }
        },readlink:function(node) {
          var path = NODEFS.realPath(node);
          try {
            path = fs.readlinkSync(path);
            path = NODEJS_PATH.relative(NODEJS_PATH.resolve(node.mount.opts.root), path);
            return path;
          } catch (e) {
            if (!e.code) throw e;
            throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
          }
        }},stream_ops:{open:function (stream) {
          var path = NODEFS.realPath(stream.node);
          try {
            if (FS.isFile(stream.node.mode)) {
              stream.nfd = fs.openSync(path, NODEFS.flagsForNode(stream.flags));
            }
          } catch (e) {
            if (!e.code) throw e;
            throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
          }
        },close:function (stream) {
          try {
            if (FS.isFile(stream.node.mode) && stream.nfd) {
              fs.closeSync(stream.nfd);
            }
          } catch (e) {
            if (!e.code) throw e;
            throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
          }
        },read:function (stream, buffer, offset, length, position) {
          // Node.js < 6 compatibility: node errors on 0 length reads
          if (length === 0) return 0;
          try {
            return fs.readSync(stream.nfd, NODEFS.bufferFrom(buffer.buffer), offset, length, position);
          } catch (e) {
            throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
          }
        },write:function (stream, buffer, offset, length, position) {
          try {
            return fs.writeSync(stream.nfd, NODEFS.bufferFrom(buffer.buffer), offset, length, position);
          } catch (e) {
            throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
          }
        },llseek:function (stream, offset, whence) {
          var position = offset;
          if (whence === 1) {
            position += stream.position;
          } else if (whence === 2) {
            if (FS.isFile(stream.node.mode)) {
              try {
                var stat = fs.fstatSync(stream.nfd);
                position += stat.size;
              } catch (e) {
                throw new FS.ErrnoError(NODEFS.convertNodeCode(e));
              }
            }
          }
  
          if (position < 0) {
            throw new FS.ErrnoError(28);
          }
  
          return position;
        },mmap:function(stream, buffer, offset, length, position, prot, flags) {
          if (!FS.isFile(stream.node.mode)) {
            throw new FS.ErrnoError(43);
          }
          var ptr = _malloc(length);
  
          assert(offset === 0);
          NODEFS.stream_ops.read(stream, buffer, ptr + offset, length, position);
          
          return { ptr: ptr, allocated: true };
        },msync:function(stream, buffer, offset, length, mmapFlags) {
          if (!FS.isFile(stream.node.mode)) {
            throw new FS.ErrnoError(43);
          }
          if (mmapFlags & 2) {
            // MAP_PRIVATE calls need not to be synced back to underlying fs
            return 0;
          }
  
          var bytesWritten = NODEFS.stream_ops.write(stream, buffer, 0, length, offset, false);
          return 0;
        }}};var FS={root:null,mounts:[],devices:{},streams:[],nextInode:1,nameTable:null,currentPath:"/",initialized:false,ignorePermissions:true,trackingDelegate:{},tracking:{openFlags:{READ:1,WRITE:2}},ErrnoError:null,genericErrors:{},filesystems:null,syncFSRequests:0,handleFSError:function(e) {
        if (!(e instanceof FS.ErrnoError)) throw e + ' : ' + stackTrace();
        return setErrNo(e.errno);
      },lookupPath:function(path, opts) {
        path = PATH_FS.resolve(FS.cwd(), path);
        opts = opts || {};
  
        if (!path) return { path: '', node: null };
  
        var defaults = {
          follow_mount: true,
          recurse_count: 0
        };
        for (var key in defaults) {
          if (opts[key] === undefined) {
            opts[key] = defaults[key];
          }
        }
  
        if (opts.recurse_count > 8) {  // max recursive lookup of 8
          throw new FS.ErrnoError(32);
        }
  
        // split the path
        var parts = PATH.normalizeArray(path.split('/').filter(function(p) {
          return !!p;
        }), false);
  
        // start at the root
        var current = FS.root;
        var current_path = '/';
  
        for (var i = 0; i < parts.length; i++) {
          var islast = (i === parts.length-1);
          if (islast && opts.parent) {
            // stop resolving
            break;
          }
  
          current = FS.lookupNode(current, parts[i]);
          current_path = PATH.join2(current_path, parts[i]);
  
          // jump to the mount's root node if this is a mountpoint
          if (FS.isMountpoint(current)) {
            if (!islast || (islast && opts.follow_mount)) {
              current = current.mounted.root;
            }
          }
  
          // by default, lookupPath will not follow a symlink if it is the final path component.
          // setting opts.follow = true will override this behavior.
          if (!islast || opts.follow) {
            var count = 0;
            while (FS.isLink(current.mode)) {
              var link = FS.readlink(current_path);
              current_path = PATH_FS.resolve(PATH.dirname(current_path), link);
  
              var lookup = FS.lookupPath(current_path, { recurse_count: opts.recurse_count });
              current = lookup.node;
  
              if (count++ > 40) {  // limit max consecutive symlinks to 40 (SYMLOOP_MAX).
                throw new FS.ErrnoError(32);
              }
            }
          }
        }
  
        return { path: current_path, node: current };
      },getPath:function(node) {
        var path;
        while (true) {
          if (FS.isRoot(node)) {
            var mount = node.mount.mountpoint;
            if (!path) return mount;
            return mount[mount.length-1] !== '/' ? mount + '/' + path : mount + path;
          }
          path = path ? node.name + '/' + path : node.name;
          node = node.parent;
        }
      },hashName:function(parentid, name) {
        var hash = 0;
  
  
        for (var i = 0; i < name.length; i++) {
          hash = ((hash << 5) - hash + name.charCodeAt(i)) | 0;
        }
        return ((parentid + hash) >>> 0) % FS.nameTable.length;
      },hashAddNode:function(node) {
        var hash = FS.hashName(node.parent.id, node.name);
        node.name_next = FS.nameTable[hash];
        FS.nameTable[hash] = node;
      },hashRemoveNode:function(node) {
        var hash = FS.hashName(node.parent.id, node.name);
        if (FS.nameTable[hash] === node) {
          FS.nameTable[hash] = node.name_next;
        } else {
          var current = FS.nameTable[hash];
          while (current) {
            if (current.name_next === node) {
              current.name_next = node.name_next;
              break;
            }
            current = current.name_next;
          }
        }
      },lookupNode:function(parent, name) {
        var errCode = FS.mayLookup(parent);
        if (errCode) {
          throw new FS.ErrnoError(errCode, parent);
        }
        var hash = FS.hashName(parent.id, name);
        for (var node = FS.nameTable[hash]; node; node = node.name_next) {
          var nodeName = node.name;
          if (node.parent.id === parent.id && nodeName === name) {
            return node;
          }
        }
        // if we failed to find it in the cache, call into the VFS
        return FS.lookup(parent, name);
      },createNode:function(parent, name, mode, rdev) {
        var node = new FS.FSNode(parent, name, mode, rdev);
  
        FS.hashAddNode(node);
  
        return node;
      },destroyNode:function(node) {
        FS.hashRemoveNode(node);
      },isRoot:function(node) {
        return node === node.parent;
      },isMountpoint:function(node) {
        return !!node.mounted;
      },isFile:function(mode) {
        return (mode & 61440) === 32768;
      },isDir:function(mode) {
        return (mode & 61440) === 16384;
      },isLink:function(mode) {
        return (mode & 61440) === 40960;
      },isChrdev:function(mode) {
        return (mode & 61440) === 8192;
      },isBlkdev:function(mode) {
        return (mode & 61440) === 24576;
      },isFIFO:function(mode) {
        return (mode & 61440) === 4096;
      },isSocket:function(mode) {
        return (mode & 49152) === 49152;
      },flagModes:{"r":0,"rs":1052672,"r+":2,"w":577,"wx":705,"xw":705,"w+":578,"wx+":706,"xw+":706,"a":1089,"ax":1217,"xa":1217,"a+":1090,"ax+":1218,"xa+":1218},modeStringToFlags:function(str) {
        var flags = FS.flagModes[str];
        if (typeof flags === 'undefined') {
          throw new Error('Unknown file open mode: ' + str);
        }
        return flags;
      },flagsToPermissionString:function(flag) {
        var perms = ['r', 'w', 'rw'][flag & 3];
        if ((flag & 512)) {
          perms += 'w';
        }
        return perms;
      },nodePermissions:function(node, perms) {
        if (FS.ignorePermissions) {
          return 0;
        }
        // return 0 if any user, group or owner bits are set.
        if (perms.indexOf('r') !== -1 && !(node.mode & 292)) {
          return 2;
        } else if (perms.indexOf('w') !== -1 && !(node.mode & 146)) {
          return 2;
        } else if (perms.indexOf('x') !== -1 && !(node.mode & 73)) {
          return 2;
        }
        return 0;
      },mayLookup:function(dir) {
        var errCode = FS.nodePermissions(dir, 'x');
        if (errCode) return errCode;
        if (!dir.node_ops.lookup) return 2;
        return 0;
      },mayCreate:function(dir, name) {
        try {
          var node = FS.lookupNode(dir, name);
          return 20;
        } catch (e) {
        }
        return FS.nodePermissions(dir, 'wx');
      },mayDelete:function(dir, name, isdir) {
        var node;
        try {
          node = FS.lookupNode(dir, name);
        } catch (e) {
          return e.errno;
        }
        var errCode = FS.nodePermissions(dir, 'wx');
        if (errCode) {
          return errCode;
        }
        if (isdir) {
          if (!FS.isDir(node.mode)) {
            return 54;
          }
          if (FS.isRoot(node) || FS.getPath(node) === FS.cwd()) {
            return 10;
          }
        } else {
          if (FS.isDir(node.mode)) {
            return 31;
          }
        }
        return 0;
      },mayOpen:function(node, flags) {
        if (!node) {
          return 44;
        }
        if (FS.isLink(node.mode)) {
          return 32;
        } else if (FS.isDir(node.mode)) {
          if (FS.flagsToPermissionString(flags) !== 'r' || // opening for write
              (flags & 512)) { // TODO: check for O_SEARCH? (== search for dir only)
            return 31;
          }
        }
        return FS.nodePermissions(node, FS.flagsToPermissionString(flags));
      },MAX_OPEN_FDS:4096,nextfd:function(fd_start, fd_end) {
        fd_start = fd_start || 0;
        fd_end = fd_end || FS.MAX_OPEN_FDS;
        for (var fd = fd_start; fd <= fd_end; fd++) {
          if (!FS.streams[fd]) {
            return fd;
          }
        }
        throw new FS.ErrnoError(33);
      },getStream:function(fd) {
        return FS.streams[fd];
      },createStream:function(stream, fd_start, fd_end) {
        if (!FS.FSStream) {
          FS.FSStream = /** @constructor */ function(){};
          FS.FSStream.prototype = {
            object: {
              get: function() { return this.node; },
              set: function(val) { this.node = val; }
            },
            isRead: {
              get: function() { return (this.flags & 2097155) !== 1; }
            },
            isWrite: {
              get: function() { return (this.flags & 2097155) !== 0; }
            },
            isAppend: {
              get: function() { return (this.flags & 1024); }
            }
          };
        }
        // clone it, so we can return an instance of FSStream
        var newStream = new FS.FSStream();
        for (var p in stream) {
          newStream[p] = stream[p];
        }
        stream = newStream;
        var fd = FS.nextfd(fd_start, fd_end);
        stream.fd = fd;
        FS.streams[fd] = stream;
        return stream;
      },closeStream:function(fd) {
        FS.streams[fd] = null;
      },chrdev_stream_ops:{open:function(stream) {
          var device = FS.getDevice(stream.node.rdev);
          // override node's stream ops with the device's
          stream.stream_ops = device.stream_ops;
          // forward the open call
          if (stream.stream_ops.open) {
            stream.stream_ops.open(stream);
          }
        },llseek:function() {
          throw new FS.ErrnoError(70);
        }},major:function(dev) {
        return ((dev) >> 8);
      },minor:function(dev) {
        return ((dev) & 0xff);
      },makedev:function(ma, mi) {
        return ((ma) << 8 | (mi));
      },registerDevice:function(dev, ops) {
        FS.devices[dev] = { stream_ops: ops };
      },getDevice:function(dev) {
        return FS.devices[dev];
      },getMounts:function(mount) {
        var mounts = [];
        var check = [mount];
  
        while (check.length) {
          var m = check.pop();
  
          mounts.push(m);
  
          check.push.apply(check, m.mounts);
        }
  
        return mounts;
      },syncfs:function(populate, callback) {
        if (typeof(populate) === 'function') {
          callback = populate;
          populate = false;
        }
  
        FS.syncFSRequests++;
  
        if (FS.syncFSRequests > 1) {
          err('warning: ' + FS.syncFSRequests + ' FS.syncfs operations in flight at once, probably just doing extra work');
        }
  
        var mounts = FS.getMounts(FS.root.mount);
        var completed = 0;
  
        function doCallback(errCode) {
          FS.syncFSRequests--;
          return callback(errCode);
        }
  
        function done(errCode) {
          if (errCode) {
            if (!done.errored) {
              done.errored = true;
              return doCallback(errCode);
            }
            return;
          }
          if (++completed >= mounts.length) {
            doCallback(null);
          }
        };
  
        // sync all mounts
        mounts.forEach(function (mount) {
          if (!mount.type.syncfs) {
            return done(null);
          }
          mount.type.syncfs(mount, populate, done);
        });
      },mount:function(type, opts, mountpoint) {
        var root = mountpoint === '/';
        var pseudo = !mountpoint;
        var node;
  
        if (root && FS.root) {
          throw new FS.ErrnoError(10);
        } else if (!root && !pseudo) {
          var lookup = FS.lookupPath(mountpoint, { follow_mount: false });
  
          mountpoint = lookup.path;  // use the absolute path
          node = lookup.node;
  
          if (FS.isMountpoint(node)) {
            throw new FS.ErrnoError(10);
          }
  
          if (!FS.isDir(node.mode)) {
            throw new FS.ErrnoError(54);
          }
        }
  
        var mount = {
          type: type,
          opts: opts,
          mountpoint: mountpoint,
          mounts: []
        };
  
        // create a root node for the fs
        var mountRoot = type.mount(mount);
        mountRoot.mount = mount;
        mount.root = mountRoot;
  
        if (root) {
          FS.root = mountRoot;
        } else if (node) {
          // set as a mountpoint
          node.mounted = mount;
  
          // add the new mount to the current mount's children
          if (node.mount) {
            node.mount.mounts.push(mount);
          }
        }
  
        return mountRoot;
      },unmount:function (mountpoint) {
        var lookup = FS.lookupPath(mountpoint, { follow_mount: false });
  
        if (!FS.isMountpoint(lookup.node)) {
          throw new FS.ErrnoError(28);
        }
  
        // destroy the nodes for this mount, and all its child mounts
        var node = lookup.node;
        var mount = node.mounted;
        var mounts = FS.getMounts(mount);
  
        Object.keys(FS.nameTable).forEach(function (hash) {
          var current = FS.nameTable[hash];
  
          while (current) {
            var next = current.name_next;
  
            if (mounts.indexOf(current.mount) !== -1) {
              FS.destroyNode(current);
            }
  
            current = next;
          }
        });
  
        // no longer a mountpoint
        node.mounted = null;
  
        // remove this mount from the child mounts
        var idx = node.mount.mounts.indexOf(mount);
        node.mount.mounts.splice(idx, 1);
      },lookup:function(parent, name) {
        return parent.node_ops.lookup(parent, name);
      },mknod:function(path, mode, dev) {
        var lookup = FS.lookupPath(path, { parent: true });
        var parent = lookup.node;
        var name = PATH.basename(path);
        if (!name || name === '.' || name === '..') {
          throw new FS.ErrnoError(28);
        }
        var errCode = FS.mayCreate(parent, name);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        if (!parent.node_ops.mknod) {
          throw new FS.ErrnoError(63);
        }
        return parent.node_ops.mknod(parent, name, mode, dev);
      },create:function(path, mode) {
        mode = mode !== undefined ? mode : 438 /* 0666 */;
        mode &= 4095;
        mode |= 32768;
        return FS.mknod(path, mode, 0);
      },mkdir:function(path, mode) {
        mode = mode !== undefined ? mode : 511 /* 0777 */;
        mode &= 511 | 512;
        mode |= 16384;
        return FS.mknod(path, mode, 0);
      },mkdirTree:function(path, mode) {
        var dirs = path.split('/');
        var d = '';
        for (var i = 0; i < dirs.length; ++i) {
          if (!dirs[i]) continue;
          d += '/' + dirs[i];
          try {
            FS.mkdir(d, mode);
          } catch(e) {
            if (e.errno != 20) throw e;
          }
        }
      },mkdev:function(path, mode, dev) {
        if (typeof(dev) === 'undefined') {
          dev = mode;
          mode = 438 /* 0666 */;
        }
        mode |= 8192;
        return FS.mknod(path, mode, dev);
      },symlink:function(oldpath, newpath) {
        if (!PATH_FS.resolve(oldpath)) {
          throw new FS.ErrnoError(44);
        }
        var lookup = FS.lookupPath(newpath, { parent: true });
        var parent = lookup.node;
        if (!parent) {
          throw new FS.ErrnoError(44);
        }
        var newname = PATH.basename(newpath);
        var errCode = FS.mayCreate(parent, newname);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        if (!parent.node_ops.symlink) {
          throw new FS.ErrnoError(63);
        }
        return parent.node_ops.symlink(parent, newname, oldpath);
      },rename:function(old_path, new_path) {
        var old_dirname = PATH.dirname(old_path);
        var new_dirname = PATH.dirname(new_path);
        var old_name = PATH.basename(old_path);
        var new_name = PATH.basename(new_path);
        // parents must exist
        var lookup, old_dir, new_dir;
        try {
          lookup = FS.lookupPath(old_path, { parent: true });
          old_dir = lookup.node;
          lookup = FS.lookupPath(new_path, { parent: true });
          new_dir = lookup.node;
        } catch (e) {
          throw new FS.ErrnoError(10);
        }
        if (!old_dir || !new_dir) throw new FS.ErrnoError(44);
        // need to be part of the same mount
        if (old_dir.mount !== new_dir.mount) {
          throw new FS.ErrnoError(75);
        }
        // source must exist
        var old_node = FS.lookupNode(old_dir, old_name);
        // old path should not be an ancestor of the new path
        var relative = PATH_FS.relative(old_path, new_dirname);
        if (relative.charAt(0) !== '.') {
          throw new FS.ErrnoError(28);
        }
        // new path should not be an ancestor of the old path
        relative = PATH_FS.relative(new_path, old_dirname);
        if (relative.charAt(0) !== '.') {
          throw new FS.ErrnoError(55);
        }
        // see if the new path already exists
        var new_node;
        try {
          new_node = FS.lookupNode(new_dir, new_name);
        } catch (e) {
          // not fatal
        }
        // early out if nothing needs to change
        if (old_node === new_node) {
          return;
        }
        // we'll need to delete the old entry
        var isdir = FS.isDir(old_node.mode);
        var errCode = FS.mayDelete(old_dir, old_name, isdir);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        // need delete permissions if we'll be overwriting.
        // need create permissions if new doesn't already exist.
        errCode = new_node ?
          FS.mayDelete(new_dir, new_name, isdir) :
          FS.mayCreate(new_dir, new_name);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        if (!old_dir.node_ops.rename) {
          throw new FS.ErrnoError(63);
        }
        if (FS.isMountpoint(old_node) || (new_node && FS.isMountpoint(new_node))) {
          throw new FS.ErrnoError(10);
        }
        // if we are going to change the parent, check write permissions
        if (new_dir !== old_dir) {
          errCode = FS.nodePermissions(old_dir, 'w');
          if (errCode) {
            throw new FS.ErrnoError(errCode);
          }
        }
        try {
          if (FS.trackingDelegate['willMovePath']) {
            FS.trackingDelegate['willMovePath'](old_path, new_path);
          }
        } catch(e) {
          err("FS.trackingDelegate['willMovePath']('"+old_path+"', '"+new_path+"') threw an exception: " + e.message);
        }
        // remove the node from the lookup hash
        FS.hashRemoveNode(old_node);
        // do the underlying fs rename
        try {
          old_dir.node_ops.rename(old_node, new_dir, new_name);
        } catch (e) {
          throw e;
        } finally {
          // add the node back to the hash (in case node_ops.rename
          // changed its name)
          FS.hashAddNode(old_node);
        }
        try {
          if (FS.trackingDelegate['onMovePath']) FS.trackingDelegate['onMovePath'](old_path, new_path);
        } catch(e) {
          err("FS.trackingDelegate['onMovePath']('"+old_path+"', '"+new_path+"') threw an exception: " + e.message);
        }
      },rmdir:function(path) {
        var lookup = FS.lookupPath(path, { parent: true });
        var parent = lookup.node;
        var name = PATH.basename(path);
        var node = FS.lookupNode(parent, name);
        var errCode = FS.mayDelete(parent, name, true);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        if (!parent.node_ops.rmdir) {
          throw new FS.ErrnoError(63);
        }
        if (FS.isMountpoint(node)) {
          throw new FS.ErrnoError(10);
        }
        try {
          if (FS.trackingDelegate['willDeletePath']) {
            FS.trackingDelegate['willDeletePath'](path);
          }
        } catch(e) {
          err("FS.trackingDelegate['willDeletePath']('"+path+"') threw an exception: " + e.message);
        }
        parent.node_ops.rmdir(parent, name);
        FS.destroyNode(node);
        try {
          if (FS.trackingDelegate['onDeletePath']) FS.trackingDelegate['onDeletePath'](path);
        } catch(e) {
          err("FS.trackingDelegate['onDeletePath']('"+path+"') threw an exception: " + e.message);
        }
      },readdir:function(path) {
        var lookup = FS.lookupPath(path, { follow: true });
        var node = lookup.node;
        if (!node.node_ops.readdir) {
          throw new FS.ErrnoError(54);
        }
        return node.node_ops.readdir(node);
      },unlink:function(path) {
        var lookup = FS.lookupPath(path, { parent: true });
        var parent = lookup.node;
        var name = PATH.basename(path);
        var node = FS.lookupNode(parent, name);
        var errCode = FS.mayDelete(parent, name, false);
        if (errCode) {
          // According to POSIX, we should map EISDIR to EPERM, but
          // we instead do what Linux does (and we must, as we use
          // the musl linux libc).
          throw new FS.ErrnoError(errCode);
        }
        if (!parent.node_ops.unlink) {
          throw new FS.ErrnoError(63);
        }
        if (FS.isMountpoint(node)) {
          throw new FS.ErrnoError(10);
        }
        try {
          if (FS.trackingDelegate['willDeletePath']) {
            FS.trackingDelegate['willDeletePath'](path);
          }
        } catch(e) {
          err("FS.trackingDelegate['willDeletePath']('"+path+"') threw an exception: " + e.message);
        }
        parent.node_ops.unlink(parent, name);
        FS.destroyNode(node);
        try {
          if (FS.trackingDelegate['onDeletePath']) FS.trackingDelegate['onDeletePath'](path);
        } catch(e) {
          err("FS.trackingDelegate['onDeletePath']('"+path+"') threw an exception: " + e.message);
        }
      },readlink:function(path) {
        var lookup = FS.lookupPath(path);
        var link = lookup.node;
        if (!link) {
          throw new FS.ErrnoError(44);
        }
        if (!link.node_ops.readlink) {
          throw new FS.ErrnoError(28);
        }
        return PATH_FS.resolve(FS.getPath(link.parent), link.node_ops.readlink(link));
      },stat:function(path, dontFollow) {
        var lookup = FS.lookupPath(path, { follow: !dontFollow });
        var node = lookup.node;
        if (!node) {
          throw new FS.ErrnoError(44);
        }
        if (!node.node_ops.getattr) {
          throw new FS.ErrnoError(63);
        }
        return node.node_ops.getattr(node);
      },lstat:function(path) {
        return FS.stat(path, true);
      },chmod:function(path, mode, dontFollow) {
        var node;
        if (typeof path === 'string') {
          var lookup = FS.lookupPath(path, { follow: !dontFollow });
          node = lookup.node;
        } else {
          node = path;
        }
        if (!node.node_ops.setattr) {
          throw new FS.ErrnoError(63);
        }
        node.node_ops.setattr(node, {
          mode: (mode & 4095) | (node.mode & ~4095),
          timestamp: Date.now()
        });
      },lchmod:function(path, mode) {
        FS.chmod(path, mode, true);
      },fchmod:function(fd, mode) {
        var stream = FS.getStream(fd);
        if (!stream) {
          throw new FS.ErrnoError(8);
        }
        FS.chmod(stream.node, mode);
      },chown:function(path, uid, gid, dontFollow) {
        var node;
        if (typeof path === 'string') {
          var lookup = FS.lookupPath(path, { follow: !dontFollow });
          node = lookup.node;
        } else {
          node = path;
        }
        if (!node.node_ops.setattr) {
          throw new FS.ErrnoError(63);
        }
        node.node_ops.setattr(node, {
          timestamp: Date.now()
          // we ignore the uid / gid for now
        });
      },lchown:function(path, uid, gid) {
        FS.chown(path, uid, gid, true);
      },fchown:function(fd, uid, gid) {
        var stream = FS.getStream(fd);
        if (!stream) {
          throw new FS.ErrnoError(8);
        }
        FS.chown(stream.node, uid, gid);
      },truncate:function(path, len) {
        if (len < 0) {
          throw new FS.ErrnoError(28);
        }
        var node;
        if (typeof path === 'string') {
          var lookup = FS.lookupPath(path, { follow: true });
          node = lookup.node;
        } else {
          node = path;
        }
        if (!node.node_ops.setattr) {
          throw new FS.ErrnoError(63);
        }
        if (FS.isDir(node.mode)) {
          throw new FS.ErrnoError(31);
        }
        if (!FS.isFile(node.mode)) {
          throw new FS.ErrnoError(28);
        }
        var errCode = FS.nodePermissions(node, 'w');
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        node.node_ops.setattr(node, {
          size: len,
          timestamp: Date.now()
        });
      },ftruncate:function(fd, len) {
        var stream = FS.getStream(fd);
        if (!stream) {
          throw new FS.ErrnoError(8);
        }
        if ((stream.flags & 2097155) === 0) {
          throw new FS.ErrnoError(28);
        }
        FS.truncate(stream.node, len);
      },utime:function(path, atime, mtime) {
        var lookup = FS.lookupPath(path, { follow: true });
        var node = lookup.node;
        node.node_ops.setattr(node, {
          timestamp: Math.max(atime, mtime)
        });
      },open:function(path, flags, mode, fd_start, fd_end) {
        if (path === "") {
          throw new FS.ErrnoError(44);
        }
        flags = typeof flags === 'string' ? FS.modeStringToFlags(flags) : flags;
        mode = typeof mode === 'undefined' ? 438 /* 0666 */ : mode;
        if ((flags & 64)) {
          mode = (mode & 4095) | 32768;
        } else {
          mode = 0;
        }
        var node;
        if (typeof path === 'object') {
          node = path;
        } else {
          path = PATH.normalize(path);
          try {
            var lookup = FS.lookupPath(path, {
              follow: !(flags & 131072)
            });
            node = lookup.node;
          } catch (e) {
            // ignore
          }
        }
        // perhaps we need to create the node
        var created = false;
        if ((flags & 64)) {
          if (node) {
            // if O_CREAT and O_EXCL are set, error out if the node already exists
            if ((flags & 128)) {
              throw new FS.ErrnoError(20);
            }
          } else {
            // node doesn't exist, try to create it
            node = FS.mknod(path, mode, 0);
            created = true;
          }
        }
        if (!node) {
          throw new FS.ErrnoError(44);
        }
        // can't truncate a device
        if (FS.isChrdev(node.mode)) {
          flags &= ~512;
        }
        // if asked only for a directory, then this must be one
        if ((flags & 65536) && !FS.isDir(node.mode)) {
          throw new FS.ErrnoError(54);
        }
        // check permissions, if this is not a file we just created now (it is ok to
        // create and write to a file with read-only permissions; it is read-only
        // for later use)
        if (!created) {
          var errCode = FS.mayOpen(node, flags);
          if (errCode) {
            throw new FS.ErrnoError(errCode);
          }
        }
        // do truncation if necessary
        if ((flags & 512)) {
          FS.truncate(node, 0);
        }
        // we've already handled these, don't pass down to the underlying vfs
        flags &= ~(128 | 512 | 131072);
  
        // register the stream with the filesystem
        var stream = FS.createStream({
          node: node,
          path: FS.getPath(node),  // we want the absolute path to the node
          flags: flags,
          seekable: true,
          position: 0,
          stream_ops: node.stream_ops,
          // used by the file family libc calls (fopen, fwrite, ferror, etc.)
          ungotten: [],
          error: false
        }, fd_start, fd_end);
        // call the new stream's open function
        if (stream.stream_ops.open) {
          stream.stream_ops.open(stream);
        }
        if (Module['logReadFiles'] && !(flags & 1)) {
          if (!FS.readFiles) FS.readFiles = {};
          if (!(path in FS.readFiles)) {
            FS.readFiles[path] = 1;
            err("FS.trackingDelegate error on read file: " + path);
          }
        }
        try {
          if (FS.trackingDelegate['onOpenFile']) {
            var trackingFlags = 0;
            if ((flags & 2097155) !== 1) {
              trackingFlags |= FS.tracking.openFlags.READ;
            }
            if ((flags & 2097155) !== 0) {
              trackingFlags |= FS.tracking.openFlags.WRITE;
            }
            FS.trackingDelegate['onOpenFile'](path, trackingFlags);
          }
        } catch(e) {
          err("FS.trackingDelegate['onOpenFile']('"+path+"', flags) threw an exception: " + e.message);
        }
        return stream;
      },close:function(stream) {
        if (FS.isClosed(stream)) {
          throw new FS.ErrnoError(8);
        }
        if (stream.getdents) stream.getdents = null; // free readdir state
        try {
          if (stream.stream_ops.close) {
            stream.stream_ops.close(stream);
          }
        } catch (e) {
          throw e;
        } finally {
          FS.closeStream(stream.fd);
        }
        stream.fd = null;
      },isClosed:function(stream) {
        return stream.fd === null;
      },llseek:function(stream, offset, whence) {
        if (FS.isClosed(stream)) {
          throw new FS.ErrnoError(8);
        }
        if (!stream.seekable || !stream.stream_ops.llseek) {
          throw new FS.ErrnoError(70);
        }
        if (whence != 0 && whence != 1 && whence != 2) {
          throw new FS.ErrnoError(28);
        }
        stream.position = stream.stream_ops.llseek(stream, offset, whence);
        stream.ungotten = [];
        return stream.position;
      },read:function(stream, buffer, offset, length, position) {
        if (length < 0 || position < 0) {
          throw new FS.ErrnoError(28);
        }
        if (FS.isClosed(stream)) {
          throw new FS.ErrnoError(8);
        }
        if ((stream.flags & 2097155) === 1) {
          throw new FS.ErrnoError(8);
        }
        if (FS.isDir(stream.node.mode)) {
          throw new FS.ErrnoError(31);
        }
        if (!stream.stream_ops.read) {
          throw new FS.ErrnoError(28);
        }
        var seeking = typeof position !== 'undefined';
        if (!seeking) {
          position = stream.position;
        } else if (!stream.seekable) {
          throw new FS.ErrnoError(70);
        }
        var bytesRead = stream.stream_ops.read(stream, buffer, offset, length, position);
        if (!seeking) stream.position += bytesRead;
        return bytesRead;
      },write:function(stream, buffer, offset, length, position, canOwn) {
        if (length < 0 || position < 0) {
          throw new FS.ErrnoError(28);
        }
        if (FS.isClosed(stream)) {
          throw new FS.ErrnoError(8);
        }
        if ((stream.flags & 2097155) === 0) {
          throw new FS.ErrnoError(8);
        }
        if (FS.isDir(stream.node.mode)) {
          throw new FS.ErrnoError(31);
        }
        if (!stream.stream_ops.write) {
          throw new FS.ErrnoError(28);
        }
        if (stream.seekable && stream.flags & 1024) {
          // seek to the end before writing in append mode
          FS.llseek(stream, 0, 2);
        }
        var seeking = typeof position !== 'undefined';
        if (!seeking) {
          position = stream.position;
        } else if (!stream.seekable) {
          throw new FS.ErrnoError(70);
        }
        var bytesWritten = stream.stream_ops.write(stream, buffer, offset, length, position, canOwn);
        if (!seeking) stream.position += bytesWritten;
        try {
          if (stream.path && FS.trackingDelegate['onWriteToFile']) FS.trackingDelegate['onWriteToFile'](stream.path);
        } catch(e) {
          err("FS.trackingDelegate['onWriteToFile']('"+stream.path+"') threw an exception: " + e.message);
        }
        return bytesWritten;
      },allocate:function(stream, offset, length) {
        if (FS.isClosed(stream)) {
          throw new FS.ErrnoError(8);
        }
        if (offset < 0 || length <= 0) {
          throw new FS.ErrnoError(28);
        }
        if ((stream.flags & 2097155) === 0) {
          throw new FS.ErrnoError(8);
        }
        if (!FS.isFile(stream.node.mode) && !FS.isDir(stream.node.mode)) {
          throw new FS.ErrnoError(43);
        }
        if (!stream.stream_ops.allocate) {
          throw new FS.ErrnoError(138);
        }
        stream.stream_ops.allocate(stream, offset, length);
      },mmap:function(stream, buffer, offset, length, position, prot, flags) {
        // User requests writing to file (prot & PROT_WRITE != 0).
        // Checking if we have permissions to write to the file unless
        // MAP_PRIVATE flag is set. According to POSIX spec it is possible
        // to write to file opened in read-only mode with MAP_PRIVATE flag,
        // as all modifications will be visible only in the memory of
        // the current process.
        if ((prot & 2) !== 0
            && (flags & 2) === 0
            && (stream.flags & 2097155) !== 2) {
          throw new FS.ErrnoError(2);
        }
        if ((stream.flags & 2097155) === 1) {
          throw new FS.ErrnoError(2);
        }
        if (!stream.stream_ops.mmap) {
          throw new FS.ErrnoError(43);
        }
        return stream.stream_ops.mmap(stream, buffer, offset, length, position, prot, flags);
      },msync:function(stream, buffer, offset, length, mmapFlags) {
        if (!stream || !stream.stream_ops.msync) {
          return 0;
        }
        return stream.stream_ops.msync(stream, buffer, offset, length, mmapFlags);
      },munmap:function(stream) {
        return 0;
      },ioctl:function(stream, cmd, arg) {
        if (!stream.stream_ops.ioctl) {
          throw new FS.ErrnoError(59);
        }
        return stream.stream_ops.ioctl(stream, cmd, arg);
      },readFile:function(path, opts) {
        opts = opts || {};
        opts.flags = opts.flags || 'r';
        opts.encoding = opts.encoding || 'binary';
        if (opts.encoding !== 'utf8' && opts.encoding !== 'binary') {
          throw new Error('Invalid encoding type "' + opts.encoding + '"');
        }
        var ret;
        var stream = FS.open(path, opts.flags);
        var stat = FS.stat(path);
        var length = stat.size;
        var buf = new Uint8Array(length);
        FS.read(stream, buf, 0, length, 0);
        if (opts.encoding === 'utf8') {
          ret = UTF8ArrayToString(buf, 0);
        } else if (opts.encoding === 'binary') {
          ret = buf;
        }
        FS.close(stream);
        return ret;
      },writeFile:function(path, data, opts) {
        opts = opts || {};
        opts.flags = opts.flags || 'w';
        var stream = FS.open(path, opts.flags, opts.mode);
        if (typeof data === 'string') {
          var buf = new Uint8Array(lengthBytesUTF8(data)+1);
          var actualNumBytes = stringToUTF8Array(data, buf, 0, buf.length);
          FS.write(stream, buf, 0, actualNumBytes, undefined, opts.canOwn);
        } else if (ArrayBuffer.isView(data)) {
          FS.write(stream, data, 0, data.byteLength, undefined, opts.canOwn);
        } else {
          throw new Error('Unsupported data type');
        }
        FS.close(stream);
      },cwd:function() {
        return FS.currentPath;
      },chdir:function(path) {
        var lookup = FS.lookupPath(path, { follow: true });
        if (lookup.node === null) {
          throw new FS.ErrnoError(44);
        }
        if (!FS.isDir(lookup.node.mode)) {
          throw new FS.ErrnoError(54);
        }
        var errCode = FS.nodePermissions(lookup.node, 'x');
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        FS.currentPath = lookup.path;
      },createDefaultDirectories:function() {
        FS.mkdir('/tmp');
        FS.mkdir('/home');
        FS.mkdir('/home/web_user');
      },createDefaultDevices:function() {
        // create /dev
        FS.mkdir('/dev');
        // setup /dev/null
        FS.registerDevice(FS.makedev(1, 3), {
          read: function() { return 0; },
          write: function(stream, buffer, offset, length, pos) { return length; }
        });
        FS.mkdev('/dev/null', FS.makedev(1, 3));
        // setup /dev/tty and /dev/tty1
        // stderr needs to print output using Module['printErr']
        // so we register a second tty just for it.
        TTY.register(FS.makedev(5, 0), TTY.default_tty_ops);
        TTY.register(FS.makedev(6, 0), TTY.default_tty1_ops);
        FS.mkdev('/dev/tty', FS.makedev(5, 0));
        FS.mkdev('/dev/tty1', FS.makedev(6, 0));
        // setup /dev/[u]random
        var random_device;
        if (typeof crypto === 'object' && typeof crypto['getRandomValues'] === 'function') {
          // for modern web browsers
          var randomBuffer = new Uint8Array(1);
          random_device = function() { crypto.getRandomValues(randomBuffer); return randomBuffer[0]; };
        } else
        if (ENVIRONMENT_IS_NODE) {
          // for nodejs with or without crypto support included
          try {
            var crypto_module = require('crypto');
            // nodejs has crypto support
            random_device = function() { return crypto_module['randomBytes'](1)[0]; };
          } catch (e) {
            // nodejs doesn't have crypto support
          }
        } else
        {}
        if (!random_device) {
          // we couldn't find a proper implementation, as Math.random() is not suitable for /dev/random, see emscripten-core/emscripten/pull/7096
          random_device = function() { abort("random_device"); };
        }
        FS.createDevice('/dev', 'random', random_device);
        FS.createDevice('/dev', 'urandom', random_device);
        // we're not going to emulate the actual shm device,
        // just create the tmp dirs that reside in it commonly
        FS.mkdir('/dev/shm');
        FS.mkdir('/dev/shm/tmp');
      },createSpecialDirectories:function() {
        // create /proc/self/fd which allows /proc/self/fd/6 => readlink gives the name of the stream for fd 6 (see test_unistd_ttyname)
        FS.mkdir('/proc');
        FS.mkdir('/proc/self');
        FS.mkdir('/proc/self/fd');
        FS.mount({
          mount: function() {
            var node = FS.createNode('/proc/self', 'fd', 16384 | 511 /* 0777 */, 73);
            node.node_ops = {
              lookup: function(parent, name) {
                var fd = +name;
                var stream = FS.getStream(fd);
                if (!stream) throw new FS.ErrnoError(8);
                var ret = {
                  parent: null,
                  mount: { mountpoint: 'fake' },
                  node_ops: { readlink: function() { return stream.path } }
                };
                ret.parent = ret; // make it look like a simple root node
                return ret;
              }
            };
            return node;
          }
        }, {}, '/proc/self/fd');
      },createStandardStreams:function() {
        // TODO deprecate the old functionality of a single
        // input / output callback and that utilizes FS.createDevice
        // and instead require a unique set of stream ops
  
        // by default, we symlink the standard streams to the
        // default tty devices. however, if the standard streams
        // have been overwritten we create a unique device for
        // them instead.
        if (Module['stdin']) {
          FS.createDevice('/dev', 'stdin', Module['stdin']);
        } else {
          FS.symlink('/dev/tty', '/dev/stdin');
        }
        if (Module['stdout']) {
          FS.createDevice('/dev', 'stdout', null, Module['stdout']);
        } else {
          FS.symlink('/dev/tty', '/dev/stdout');
        }
        if (Module['stderr']) {
          FS.createDevice('/dev', 'stderr', null, Module['stderr']);
        } else {
          FS.symlink('/dev/tty1', '/dev/stderr');
        }
  
        // open default streams for the stdin, stdout and stderr devices
        var stdin = FS.open('/dev/stdin', 'r');
        var stdout = FS.open('/dev/stdout', 'w');
        var stderr = FS.open('/dev/stderr', 'w');
      },ensureErrnoError:function() {
        if (FS.ErrnoError) return;
        FS.ErrnoError = /** @this{Object} */ function ErrnoError(errno, node) {
          this.node = node;
          this.setErrno = /** @this{Object} */ function(errno) {
            this.errno = errno;
          };
          this.setErrno(errno);
          this.message = 'FS error';
  
        };
        FS.ErrnoError.prototype = new Error();
        FS.ErrnoError.prototype.constructor = FS.ErrnoError;
        // Some errors may happen quite a bit, to avoid overhead we reuse them (and suffer a lack of stack info)
        [44].forEach(function(code) {
          FS.genericErrors[code] = new FS.ErrnoError(code);
          FS.genericErrors[code].stack = '<generic error, no stack>';
        });
      },staticInit:function() {
        FS.ensureErrnoError();
  
        FS.nameTable = new Array(4096);
  
        FS.mount(MEMFS, {}, '/');
  
        FS.createDefaultDirectories();
        FS.createDefaultDevices();
        FS.createSpecialDirectories();
  
        FS.filesystems = {
          'MEMFS': MEMFS,
          'NODEFS': NODEFS,
        };
      },init:function(input, output, error) {
        FS.init.initialized = true;
  
        FS.ensureErrnoError();
  
        // Allow Module.stdin etc. to provide defaults, if none explicitly passed to us here
        Module['stdin'] = input || Module['stdin'];
        Module['stdout'] = output || Module['stdout'];
        Module['stderr'] = error || Module['stderr'];
  
        FS.createStandardStreams();
      },quit:function() {
        FS.init.initialized = false;
        // force-flush all streams, so we get musl std streams printed out
        var fflush = Module['_fflush'];
        if (fflush) fflush(0);
        // close all of our streams
        for (var i = 0; i < FS.streams.length; i++) {
          var stream = FS.streams[i];
          if (!stream) {
            continue;
          }
          FS.close(stream);
        }
      },getMode:function(canRead, canWrite) {
        var mode = 0;
        if (canRead) mode |= 292 | 73;
        if (canWrite) mode |= 146;
        return mode;
      },joinPath:function(parts, forceRelative) {
        var path = PATH.join.apply(null, parts);
        if (forceRelative && path[0] == '/') path = path.substr(1);
        return path;
      },absolutePath:function(relative, base) {
        return PATH_FS.resolve(base, relative);
      },standardizePath:function(path) {
        return PATH.normalize(path);
      },findObject:function(path, dontResolveLastLink) {
        var ret = FS.analyzePath(path, dontResolveLastLink);
        if (ret.exists) {
          return ret.object;
        } else {
          setErrNo(ret.error);
          return null;
        }
      },analyzePath:function(path, dontResolveLastLink) {
        // operate from within the context of the symlink's target
        try {
          var lookup = FS.lookupPath(path, { follow: !dontResolveLastLink });
          path = lookup.path;
        } catch (e) {
        }
        var ret = {
          isRoot: false, exists: false, error: 0, name: null, path: null, object: null,
          parentExists: false, parentPath: null, parentObject: null
        };
        try {
          var lookup = FS.lookupPath(path, { parent: true });
          ret.parentExists = true;
          ret.parentPath = lookup.path;
          ret.parentObject = lookup.node;
          ret.name = PATH.basename(path);
          lookup = FS.lookupPath(path, { follow: !dontResolveLastLink });
          ret.exists = true;
          ret.path = lookup.path;
          ret.object = lookup.node;
          ret.name = lookup.node.name;
          ret.isRoot = lookup.path === '/';
        } catch (e) {
          ret.error = e.errno;
        };
        return ret;
      },createFolder:function(parent, name, canRead, canWrite) {
        var path = PATH.join2(typeof parent === 'string' ? parent : FS.getPath(parent), name);
        var mode = FS.getMode(canRead, canWrite);
        return FS.mkdir(path, mode);
      },createPath:function(parent, path, canRead, canWrite) {
        parent = typeof parent === 'string' ? parent : FS.getPath(parent);
        var parts = path.split('/').reverse();
        while (parts.length) {
          var part = parts.pop();
          if (!part) continue;
          var current = PATH.join2(parent, part);
          try {
            FS.mkdir(current);
          } catch (e) {
            // ignore EEXIST
          }
          parent = current;
        }
        return current;
      },createFile:function(parent, name, properties, canRead, canWrite) {
        var path = PATH.join2(typeof parent === 'string' ? parent : FS.getPath(parent), name);
        var mode = FS.getMode(canRead, canWrite);
        return FS.create(path, mode);
      },createDataFile:function(parent, name, data, canRead, canWrite, canOwn) {
        var path = name ? PATH.join2(typeof parent === 'string' ? parent : FS.getPath(parent), name) : parent;
        var mode = FS.getMode(canRead, canWrite);
        var node = FS.create(path, mode);
        if (data) {
          if (typeof data === 'string') {
            var arr = new Array(data.length);
            for (var i = 0, len = data.length; i < len; ++i) arr[i] = data.charCodeAt(i);
            data = arr;
          }
          // make sure we can write to the file
          FS.chmod(node, mode | 146);
          var stream = FS.open(node, 'w');
          FS.write(stream, data, 0, data.length, 0, canOwn);
          FS.close(stream);
          FS.chmod(node, mode);
        }
        return node;
      },createDevice:function(parent, name, input, output) {
        var path = PATH.join2(typeof parent === 'string' ? parent : FS.getPath(parent), name);
        var mode = FS.getMode(!!input, !!output);
        if (!FS.createDevice.major) FS.createDevice.major = 64;
        var dev = FS.makedev(FS.createDevice.major++, 0);
        // Create a fake device that a set of stream ops to emulate
        // the old behavior.
        FS.registerDevice(dev, {
          open: function(stream) {
            stream.seekable = false;
          },
          close: function(stream) {
            // flush any pending line data
            if (output && output.buffer && output.buffer.length) {
              output(10);
            }
          },
          read: function(stream, buffer, offset, length, pos /* ignored */) {
            var bytesRead = 0;
            for (var i = 0; i < length; i++) {
              var result;
              try {
                result = input();
              } catch (e) {
                throw new FS.ErrnoError(29);
              }
              if (result === undefined && bytesRead === 0) {
                throw new FS.ErrnoError(6);
              }
              if (result === null || result === undefined) break;
              bytesRead++;
              buffer[offset+i] = result;
            }
            if (bytesRead) {
              stream.node.timestamp = Date.now();
            }
            return bytesRead;
          },
          write: function(stream, buffer, offset, length, pos) {
            for (var i = 0; i < length; i++) {
              try {
                output(buffer[offset+i]);
              } catch (e) {
                throw new FS.ErrnoError(29);
              }
            }
            if (length) {
              stream.node.timestamp = Date.now();
            }
            return i;
          }
        });
        return FS.mkdev(path, mode, dev);
      },createLink:function(parent, name, target, canRead, canWrite) {
        var path = PATH.join2(typeof parent === 'string' ? parent : FS.getPath(parent), name);
        return FS.symlink(target, path);
      },forceLoadFile:function(obj) {
        if (obj.isDevice || obj.isFolder || obj.link || obj.contents) return true;
        var success = true;
        if (typeof XMLHttpRequest !== 'undefined') {
          throw new Error("Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread.");
        } else if (read_) {
          // Command-line.
          try {
            // WARNING: Can't read binary files in V8's d8 or tracemonkey's js, as
            //          read() will try to parse UTF8.
            obj.contents = intArrayFromString(read_(obj.url), true);
            obj.usedBytes = obj.contents.length;
          } catch (e) {
            success = false;
          }
        } else {
          throw new Error('Cannot load without read() or XMLHttpRequest.');
        }
        if (!success) setErrNo(29);
        return success;
      },createLazyFile:function(parent, name, url, canRead, canWrite) {
        // Lazy chunked Uint8Array (implements get and length from Uint8Array). Actual getting is abstracted away for eventual reuse.
        /** @constructor */
        function LazyUint8Array() {
          this.lengthKnown = false;
          this.chunks = []; // Loaded chunks. Index is the chunk number
        }
        LazyUint8Array.prototype.get = /** @this{Object} */ function LazyUint8Array_get(idx) {
          if (idx > this.length-1 || idx < 0) {
            return undefined;
          }
          var chunkOffset = idx % this.chunkSize;
          var chunkNum = (idx / this.chunkSize)|0;
          return this.getter(chunkNum)[chunkOffset];
        };
        LazyUint8Array.prototype.setDataGetter = function LazyUint8Array_setDataGetter(getter) {
          this.getter = getter;
        };
        LazyUint8Array.prototype.cacheLength = function LazyUint8Array_cacheLength() {
          // Find length
          var xhr = new XMLHttpRequest();
          xhr.open('HEAD', url, false);
          xhr.send(null);
          if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304)) throw new Error("Couldn't load " + url + ". Status: " + xhr.status);
          var datalength = Number(xhr.getResponseHeader("Content-length"));
          var header;
          var hasByteServing = (header = xhr.getResponseHeader("Accept-Ranges")) && header === "bytes";
          var usesGzip = (header = xhr.getResponseHeader("Content-Encoding")) && header === "gzip";
  
          var chunkSize = 1024*1024; // Chunk size in bytes
  
          if (!hasByteServing) chunkSize = datalength;
  
          // Function to get a range from the remote URL.
          var doXHR = (function(from, to) {
            if (from > to) throw new Error("invalid range (" + from + ", " + to + ") or no bytes requested!");
            if (to > datalength-1) throw new Error("only " + datalength + " bytes available! programmer error!");
  
            // TODO: Use mozResponseArrayBuffer, responseStream, etc. if available.
            var xhr = new XMLHttpRequest();
            xhr.open('GET', url, false);
            if (datalength !== chunkSize) xhr.setRequestHeader("Range", "bytes=" + from + "-" + to);
  
            // Some hints to the browser that we want binary data.
            if (typeof Uint8Array != 'undefined') xhr.responseType = 'arraybuffer';
            if (xhr.overrideMimeType) {
              xhr.overrideMimeType('text/plain; charset=x-user-defined');
            }
  
            xhr.send(null);
            if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304)) throw new Error("Couldn't load " + url + ". Status: " + xhr.status);
            if (xhr.response !== undefined) {
              return new Uint8Array(/** @type{Array<number>} */(xhr.response || []));
            } else {
              return intArrayFromString(xhr.responseText || '', true);
            }
          });
          var lazyArray = this;
          lazyArray.setDataGetter(function(chunkNum) {
            var start = chunkNum * chunkSize;
            var end = (chunkNum+1) * chunkSize - 1; // including this byte
            end = Math.min(end, datalength-1); // if datalength-1 is selected, this is the last block
            if (typeof(lazyArray.chunks[chunkNum]) === "undefined") {
              lazyArray.chunks[chunkNum] = doXHR(start, end);
            }
            if (typeof(lazyArray.chunks[chunkNum]) === "undefined") throw new Error("doXHR failed!");
            return lazyArray.chunks[chunkNum];
          });
  
          if (usesGzip || !datalength) {
            // if the server uses gzip or doesn't supply the length, we have to download the whole file to get the (uncompressed) length
            chunkSize = datalength = 1; // this will force getter(0)/doXHR do download the whole file
            datalength = this.getter(0).length;
            chunkSize = datalength;
            out("LazyFiles on gzip forces download of the whole file when length is accessed");
          }
  
          this._length = datalength;
          this._chunkSize = chunkSize;
          this.lengthKnown = true;
        };
        if (typeof XMLHttpRequest !== 'undefined') {
          if (!ENVIRONMENT_IS_WORKER) throw 'Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc';
          var lazyArray = new LazyUint8Array();
          Object.defineProperties(lazyArray, {
            length: {
              get: /** @this{Object} */ function() {
                if(!this.lengthKnown) {
                  this.cacheLength();
                }
                return this._length;
              }
            },
            chunkSize: {
              get: /** @this{Object} */ function() {
                if(!this.lengthKnown) {
                  this.cacheLength();
                }
                return this._chunkSize;
              }
            }
          });
  
          var properties = { isDevice: false, contents: lazyArray };
        } else {
          var properties = { isDevice: false, url: url };
        }
  
        var node = FS.createFile(parent, name, properties, canRead, canWrite);
        // This is a total hack, but I want to get this lazy file code out of the
        // core of MEMFS. If we want to keep this lazy file concept I feel it should
        // be its own thin LAZYFS proxying calls to MEMFS.
        if (properties.contents) {
          node.contents = properties.contents;
        } else if (properties.url) {
          node.contents = null;
          node.url = properties.url;
        }
        // Add a function that defers querying the file size until it is asked the first time.
        Object.defineProperties(node, {
          usedBytes: {
            get: /** @this {FSNode} */ function() { return this.contents.length; }
          }
        });
        // override each stream op with one that tries to force load the lazy file first
        var stream_ops = {};
        var keys = Object.keys(node.stream_ops);
        keys.forEach(function(key) {
          var fn = node.stream_ops[key];
          stream_ops[key] = function forceLoadLazyFile() {
            if (!FS.forceLoadFile(node)) {
              throw new FS.ErrnoError(29);
            }
            return fn.apply(null, arguments);
          };
        });
        // use a custom read function
        stream_ops.read = function stream_ops_read(stream, buffer, offset, length, position) {
          if (!FS.forceLoadFile(node)) {
            throw new FS.ErrnoError(29);
          }
          var contents = stream.node.contents;
          if (position >= contents.length)
            return 0;
          var size = Math.min(contents.length - position, length);
          if (contents.slice) { // normal array
            for (var i = 0; i < size; i++) {
              buffer[offset + i] = contents[position + i];
            }
          } else {
            for (var i = 0; i < size; i++) { // LazyUint8Array from sync binary XHR
              buffer[offset + i] = contents.get(position + i);
            }
          }
          return size;
        };
        node.stream_ops = stream_ops;
        return node;
      },createPreloadedFile:function(parent, name, url, canRead, canWrite, onload, onerror, dontCreateFile, canOwn, preFinish) {
        Browser.init(); // XXX perhaps this method should move onto Browser?
        // TODO we should allow people to just pass in a complete filename instead
        // of parent and name being that we just join them anyways
        var fullname = name ? PATH_FS.resolve(PATH.join2(parent, name)) : parent;
        var dep = getUniqueRunDependency('cp ' + fullname); // might have several active requests for the same fullname
        function processData(byteArray) {
          function finish(byteArray) {
            if (preFinish) preFinish();
            if (!dontCreateFile) {
              FS.createDataFile(parent, name, byteArray, canRead, canWrite, canOwn);
            }
            if (onload) onload();
            removeRunDependency(dep);
          }
          var handled = false;
          Module['preloadPlugins'].forEach(function(plugin) {
            if (handled) return;
            if (plugin['canHandle'](fullname)) {
              plugin['handle'](byteArray, fullname, finish, function() {
                if (onerror) onerror();
                removeRunDependency(dep);
              });
              handled = true;
            }
          });
          if (!handled) finish(byteArray);
        }
        addRunDependency(dep);
        if (typeof url == 'string') {
          Browser.asyncLoad(url, function(byteArray) {
            processData(byteArray);
          }, onerror);
        } else {
          processData(url);
        }
      },indexedDB:function() {
        return window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB;
      },DB_NAME:function() {
        return 'EM_FS_' + window.location.pathname;
      },DB_VERSION:20,DB_STORE_NAME:"FILE_DATA",saveFilesToDB:function(paths, onload, onerror) {
        onload = onload || function(){};
        onerror = onerror || function(){};
        var indexedDB = FS.indexedDB();
        try {
          var openRequest = indexedDB.open(FS.DB_NAME(), FS.DB_VERSION);
        } catch (e) {
          return onerror(e);
        }
        openRequest.onupgradeneeded = function openRequest_onupgradeneeded() {
          out('creating db');
          var db = openRequest.result;
          db.createObjectStore(FS.DB_STORE_NAME);
        };
        openRequest.onsuccess = function openRequest_onsuccess() {
          var db = openRequest.result;
          var transaction = db.transaction([FS.DB_STORE_NAME], 'readwrite');
          var files = transaction.objectStore(FS.DB_STORE_NAME);
          var ok = 0, fail = 0, total = paths.length;
          function finish() {
            if (fail == 0) onload(); else onerror();
          }
          paths.forEach(function(path) {
            var putRequest = files.put(FS.analyzePath(path).object.contents, path);
            putRequest.onsuccess = function putRequest_onsuccess() { ok++; if (ok + fail == total) finish() };
            putRequest.onerror = function putRequest_onerror() { fail++; if (ok + fail == total) finish() };
          });
          transaction.onerror = onerror;
        };
        openRequest.onerror = onerror;
      },loadFilesFromDB:function(paths, onload, onerror) {
        onload = onload || function(){};
        onerror = onerror || function(){};
        var indexedDB = FS.indexedDB();
        try {
          var openRequest = indexedDB.open(FS.DB_NAME(), FS.DB_VERSION);
        } catch (e) {
          return onerror(e);
        }
        openRequest.onupgradeneeded = onerror; // no database to load from
        openRequest.onsuccess = function openRequest_onsuccess() {
          var db = openRequest.result;
          try {
            var transaction = db.transaction([FS.DB_STORE_NAME], 'readonly');
          } catch(e) {
            onerror(e);
            return;
          }
          var files = transaction.objectStore(FS.DB_STORE_NAME);
          var ok = 0, fail = 0, total = paths.length;
          function finish() {
            if (fail == 0) onload(); else onerror();
          }
          paths.forEach(function(path) {
            var getRequest = files.get(path);
            getRequest.onsuccess = function getRequest_onsuccess() {
              if (FS.analyzePath(path).exists) {
                FS.unlink(path);
              }
              FS.createDataFile(PATH.dirname(path), PATH.basename(path), getRequest.result, true, true, true);
              ok++;
              if (ok + fail == total) finish();
            };
            getRequest.onerror = function getRequest_onerror() { fail++; if (ok + fail == total) finish() };
          });
          transaction.onerror = onerror;
        };
        openRequest.onerror = onerror;
      }};var SYSCALLS={mappings:{},DEFAULT_POLLMASK:5,umask:511,calculateAt:function(dirfd, path) {
        if (path[0] !== '/') {
          // relative path
          var dir;
          if (dirfd === -100) {
            dir = FS.cwd();
          } else {
            var dirstream = FS.getStream(dirfd);
            if (!dirstream) throw new FS.ErrnoError(8);
            dir = dirstream.path;
          }
          path = PATH.join2(dir, path);
        }
        return path;
      },doStat:function(func, path, buf) {
        try {
          var stat = func(path);
        } catch (e) {
          if (e && e.node && PATH.normalize(path) !== PATH.normalize(FS.getPath(e.node))) {
            // an error occurred while trying to look up the path; we should just report ENOTDIR
            return -54;
          }
          throw e;
        }
        HEAP32[((buf)>>2)]=stat.dev;
        HEAP32[(((buf)+(4))>>2)]=0;
        HEAP32[(((buf)+(8))>>2)]=stat.ino;
        HEAP32[(((buf)+(12))>>2)]=stat.mode;
        HEAP32[(((buf)+(16))>>2)]=stat.nlink;
        HEAP32[(((buf)+(20))>>2)]=stat.uid;
        HEAP32[(((buf)+(24))>>2)]=stat.gid;
        HEAP32[(((buf)+(28))>>2)]=stat.rdev;
        HEAP32[(((buf)+(32))>>2)]=0;
        (tempI64 = [stat.size>>>0,(tempDouble=stat.size,(+(Math_abs(tempDouble))) >= 1.0 ? (tempDouble > 0.0 ? ((Math_min((+(Math_floor((tempDouble)/4294967296.0))), 4294967295.0))|0)>>>0 : (~~((+(Math_ceil((tempDouble - +(((~~(tempDouble)))>>>0))/4294967296.0)))))>>>0) : 0)],HEAP32[(((buf)+(40))>>2)]=tempI64[0],HEAP32[(((buf)+(44))>>2)]=tempI64[1]);
        HEAP32[(((buf)+(48))>>2)]=4096;
        HEAP32[(((buf)+(52))>>2)]=stat.blocks;
        HEAP32[(((buf)+(56))>>2)]=(stat.atime.getTime() / 1000)|0;
        HEAP32[(((buf)+(60))>>2)]=0;
        HEAP32[(((buf)+(64))>>2)]=(stat.mtime.getTime() / 1000)|0;
        HEAP32[(((buf)+(68))>>2)]=0;
        HEAP32[(((buf)+(72))>>2)]=(stat.ctime.getTime() / 1000)|0;
        HEAP32[(((buf)+(76))>>2)]=0;
        (tempI64 = [stat.ino>>>0,(tempDouble=stat.ino,(+(Math_abs(tempDouble))) >= 1.0 ? (tempDouble > 0.0 ? ((Math_min((+(Math_floor((tempDouble)/4294967296.0))), 4294967295.0))|0)>>>0 : (~~((+(Math_ceil((tempDouble - +(((~~(tempDouble)))>>>0))/4294967296.0)))))>>>0) : 0)],HEAP32[(((buf)+(80))>>2)]=tempI64[0],HEAP32[(((buf)+(84))>>2)]=tempI64[1]);
        return 0;
      },doMsync:function(addr, stream, len, flags, offset) {
        var buffer = HEAPU8.slice(addr, addr + len);
        FS.msync(stream, buffer, offset, len, flags);
      },doMkdir:function(path, mode) {
        // remove a trailing slash, if one - /a/b/ has basename of '', but
        // we want to create b in the context of this function
        path = PATH.normalize(path);
        if (path[path.length-1] === '/') path = path.substr(0, path.length-1);
        FS.mkdir(path, mode, 0);
        return 0;
      },doMknod:function(path, mode, dev) {
        // we don't want this in the JS API as it uses mknod to create all nodes.
        switch (mode & 61440) {
          case 32768:
          case 8192:
          case 24576:
          case 4096:
          case 49152:
            break;
          default: return -28;
        }
        FS.mknod(path, mode, dev);
        return 0;
      },doReadlink:function(path, buf, bufsize) {
        if (bufsize <= 0) return -28;
        var ret = FS.readlink(path);
  
        var len = Math.min(bufsize, lengthBytesUTF8(ret));
        var endChar = HEAP8[buf+len];
        stringToUTF8(ret, buf, bufsize+1);
        // readlink is one of the rare functions that write out a C string, but does never append a null to the output buffer(!)
        // stringToUTF8() always appends a null byte, so restore the character under the null byte after the write.
        HEAP8[buf+len] = endChar;
  
        return len;
      },doAccess:function(path, amode) {
        if (amode & ~7) {
          // need a valid mode
          return -28;
        }
        var node;
        var lookup = FS.lookupPath(path, { follow: true });
        node = lookup.node;
        if (!node) {
          return -44;
        }
        var perms = '';
        if (amode & 4) perms += 'r';
        if (amode & 2) perms += 'w';
        if (amode & 1) perms += 'x';
        if (perms /* otherwise, they've just passed F_OK */ && FS.nodePermissions(node, perms)) {
          return -2;
        }
        return 0;
      },doDup:function(path, flags, suggestFD) {
        var suggest = FS.getStream(suggestFD);
        if (suggest) FS.close(suggest);
        return FS.open(path, flags, 0, suggestFD, suggestFD).fd;
      },doReadv:function(stream, iov, iovcnt, offset) {
        var ret = 0;
        for (var i = 0; i < iovcnt; i++) {
          var ptr = HEAP32[(((iov)+(i*8))>>2)];
          var len = HEAP32[(((iov)+(i*8 + 4))>>2)];
          var curr = FS.read(stream, HEAP8,ptr, len, offset);
          if (curr < 0) return -1;
          ret += curr;
          if (curr < len) break; // nothing more to read
        }
        return ret;
      },doWritev:function(stream, iov, iovcnt, offset) {
        var ret = 0;
        for (var i = 0; i < iovcnt; i++) {
          var ptr = HEAP32[(((iov)+(i*8))>>2)];
          var len = HEAP32[(((iov)+(i*8 + 4))>>2)];
          var curr = FS.write(stream, HEAP8,ptr, len, offset);
          if (curr < 0) return -1;
          ret += curr;
        }
        return ret;
      },varargs:undefined,get:function() {
        SYSCALLS.varargs += 4;
        var ret = HEAP32[(((SYSCALLS.varargs)-(4))>>2)];
        return ret;
      },getStr:function(ptr) {
        var ret = UTF8ToString(ptr);
        return ret;
      },getStreamFromFD:function(fd) {
        var stream = FS.getStream(fd);
        if (!stream) throw new FS.ErrnoError(8);
        return stream;
      },get64:function(low, high) {
        return low;
      }};function ___sys_fstat64(fd, buf) {try {
  
      var stream = SYSCALLS.getStreamFromFD(fd);
      return SYSCALLS.doStat(FS.stat, stream.path, buf);
    } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
  }

  function ___sys_ftruncate64(fd, zero, low, high) {try {
  
      var length = SYSCALLS.get64(low, high);
      FS.ftruncate(fd, length);
      return 0;
    } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
  }

  
  function syscallMmap2(addr, len, prot, flags, fd, off) {
      off <<= 12; // undo pgoffset
      var ptr;
      var allocated = false;
  
      // addr argument must be page aligned if MAP_FIXED flag is set.
      if ((flags & 16) !== 0 && (addr % 16384) !== 0) {
        return -28;
      }
  
      // MAP_ANONYMOUS (aka MAP_ANON) isn't actually defined by POSIX spec,
      // but it is widely used way to allocate memory pages on Linux, BSD and Mac.
      // In this case fd argument is ignored.
      if ((flags & 32) !== 0) {
        ptr = _memalign(16384, len);
        if (!ptr) return -48;
        _memset(ptr, 0, len);
        allocated = true;
      } else {
        var info = FS.getStream(fd);
        if (!info) return -8;
        var res = FS.mmap(info, HEAPU8, addr, len, off, prot, flags);
        ptr = res.ptr;
        allocated = res.allocated;
      }
      SYSCALLS.mappings[ptr] = { malloc: ptr, len: len, allocated: allocated, fd: fd, prot: prot, flags: flags, offset: off };
      return ptr;
    }function ___sys_mmap2(addr, len, prot, flags, fd, off) {try {
  
      return syscallMmap2(addr, len, prot, flags, fd, off);
    } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
  }

  
  function syscallMunmap(addr, len) {
      if ((addr | 0) === -1 || len === 0) {
        return -28;
      }
      // TODO: support unmmap'ing parts of allocations
      var info = SYSCALLS.mappings[addr];
      if (!info) return 0;
      if (len === info.len) {
        var stream = FS.getStream(info.fd);
        if (info.prot & 2) {
          SYSCALLS.doMsync(addr, stream, len, info.flags, info.offset);
        }
        FS.munmap(stream);
        SYSCALLS.mappings[addr] = null;
        if (info.allocated) {
          _free(info.malloc);
        }
      }
      return 0;
    }function ___sys_munmap(addr, len) {try {
  
      return syscallMunmap(addr, len);
    } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
  }

  function ___sys_open(path, flags, varargs) {SYSCALLS.varargs = varargs;
  try {
  
      var pathname = SYSCALLS.getStr(path);
      var mode = SYSCALLS.get();
      var stream = FS.open(pathname, flags, mode);
      return stream.fd;
    } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
  }

  function ___sys_read(fd, buf, count) {try {
  
      var stream = SYSCALLS.getStreamFromFD(fd);
      return FS.read(stream, HEAP8,buf, count);
    } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
  }

  function ___sys_stat64(path, buf) {try {
  
      path = SYSCALLS.getStr(path);
      return SYSCALLS.doStat(FS.stat, path, buf);
    } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
  }

  
  function getShiftFromSize(size) {
      switch (size) {
          case 1: return 0;
          case 2: return 1;
          case 4: return 2;
          case 8: return 3;
          default:
              throw new TypeError('Unknown type size: ' + size);
      }
    }
  
  
  
  function embind_init_charCodes() {
      var codes = new Array(256);
      for (var i = 0; i < 256; ++i) {
          codes[i] = String.fromCharCode(i);
      }
      embind_charCodes = codes;
    }var embind_charCodes=undefined;function readLatin1String(ptr) {
      var ret = "";
      var c = ptr;
      while (HEAPU8[c]) {
          ret += embind_charCodes[HEAPU8[c++]];
      }
      return ret;
    }
  
  
  var awaitingDependencies={};
  
  var registeredTypes={};
  
  var typeDependencies={};
  
  
  
  
  
  
  var char_0=48;
  
  var char_9=57;function makeLegalFunctionName(name) {
      if (undefined === name) {
          return '_unknown';
      }
      name = name.replace(/[^a-zA-Z0-9_]/g, '$');
      var f = name.charCodeAt(0);
      if (f >= char_0 && f <= char_9) {
          return '_' + name;
      } else {
          return name;
      }
    }function createNamedFunction(name, body) {
      name = makeLegalFunctionName(name);
      /*jshint evil:true*/
      return new Function(
          "body",
          "return function " + name + "() {\n" +
          "    \"use strict\";" +
          "    return body.apply(this, arguments);\n" +
          "};\n"
      )(body);
    }function extendError(baseErrorType, errorName) {
      var errorClass = createNamedFunction(errorName, function(message) {
          this.name = errorName;
          this.message = message;
  
          var stack = (new Error(message)).stack;
          if (stack !== undefined) {
              this.stack = this.toString() + '\n' +
                  stack.replace(/^Error(:[^\n]*)?\n/, '');
          }
      });
      errorClass.prototype = Object.create(baseErrorType.prototype);
      errorClass.prototype.constructor = errorClass;
      errorClass.prototype.toString = function() {
          if (this.message === undefined) {
              return this.name;
          } else {
              return this.name + ': ' + this.message;
          }
      };
  
      return errorClass;
    }var BindingError=undefined;function throwBindingError(message) {
      throw new BindingError(message);
    }
  
  
  
  var InternalError=undefined;function throwInternalError(message) {
      throw new InternalError(message);
    }function whenDependentTypesAreResolved(myTypes, dependentTypes, getTypeConverters) {
      myTypes.forEach(function(type) {
          typeDependencies[type] = dependentTypes;
      });
  
      function onComplete(typeConverters) {
          var myTypeConverters = getTypeConverters(typeConverters);
          if (myTypeConverters.length !== myTypes.length) {
              throwInternalError('Mismatched type converter count');
          }
          for (var i = 0; i < myTypes.length; ++i) {
              registerType(myTypes[i], myTypeConverters[i]);
          }
      }
  
      var typeConverters = new Array(dependentTypes.length);
      var unregisteredTypes = [];
      var registered = 0;
      dependentTypes.forEach(function(dt, i) {
          if (registeredTypes.hasOwnProperty(dt)) {
              typeConverters[i] = registeredTypes[dt];
          } else {
              unregisteredTypes.push(dt);
              if (!awaitingDependencies.hasOwnProperty(dt)) {
                  awaitingDependencies[dt] = [];
              }
              awaitingDependencies[dt].push(function() {
                  typeConverters[i] = registeredTypes[dt];
                  ++registered;
                  if (registered === unregisteredTypes.length) {
                      onComplete(typeConverters);
                  }
              });
          }
      });
      if (0 === unregisteredTypes.length) {
          onComplete(typeConverters);
      }
    }/** @param {Object=} options */
  function registerType(rawType, registeredInstance, options) {
      options = options || {};
  
      if (!('argPackAdvance' in registeredInstance)) {
          throw new TypeError('registerType registeredInstance requires argPackAdvance');
      }
  
      var name = registeredInstance.name;
      if (!rawType) {
          throwBindingError('type "' + name + '" must have a positive integer typeid pointer');
      }
      if (registeredTypes.hasOwnProperty(rawType)) {
          if (options.ignoreDuplicateRegistrations) {
              return;
          } else {
              throwBindingError("Cannot register type '" + name + "' twice");
          }
      }
  
      registeredTypes[rawType] = registeredInstance;
      delete typeDependencies[rawType];
  
      if (awaitingDependencies.hasOwnProperty(rawType)) {
          var callbacks = awaitingDependencies[rawType];
          delete awaitingDependencies[rawType];
          callbacks.forEach(function(cb) {
              cb();
          });
      }
    }function __embind_register_bool(rawType, name, size, trueValue, falseValue) {
      var shift = getShiftFromSize(size);
  
      name = readLatin1String(name);
      registerType(rawType, {
          name: name,
          'fromWireType': function(wt) {
              // ambiguous emscripten ABI: sometimes return values are
              // true or false, and sometimes integers (0 or 1)
              return !!wt;
          },
          'toWireType': function(destructors, o) {
              return o ? trueValue : falseValue;
          },
          'argPackAdvance': 8,
          'readValueFromPointer': function(pointer) {
              // TODO: if heap is fixed (like in asm.js) this could be executed outside
              var heap;
              if (size === 1) {
                  heap = HEAP8;
              } else if (size === 2) {
                  heap = HEAP16;
              } else if (size === 4) {
                  heap = HEAP32;
              } else {
                  throw new TypeError("Unknown boolean type size: " + name);
              }
              return this['fromWireType'](heap[pointer >> shift]);
          },
          destructorFunction: null, // This type does not need a destructor
      });
    }

  
  
  
  function ClassHandle_isAliasOf(other) {
      if (!(this instanceof ClassHandle)) {
          return false;
      }
      if (!(other instanceof ClassHandle)) {
          return false;
      }
  
      var leftClass = this.$$.ptrType.registeredClass;
      var left = this.$$.ptr;
      var rightClass = other.$$.ptrType.registeredClass;
      var right = other.$$.ptr;
  
      while (leftClass.baseClass) {
          left = leftClass.upcast(left);
          leftClass = leftClass.baseClass;
      }
  
      while (rightClass.baseClass) {
          right = rightClass.upcast(right);
          rightClass = rightClass.baseClass;
      }
  
      return leftClass === rightClass && left === right;
    }
  
  
  function shallowCopyInternalPointer(o) {
      return {
          count: o.count,
          deleteScheduled: o.deleteScheduled,
          preservePointerOnDelete: o.preservePointerOnDelete,
          ptr: o.ptr,
          ptrType: o.ptrType,
          smartPtr: o.smartPtr,
          smartPtrType: o.smartPtrType,
      };
    }
  
  function throwInstanceAlreadyDeleted(obj) {
      function getInstanceTypeName(handle) {
        return handle.$$.ptrType.registeredClass.name;
      }
      throwBindingError(getInstanceTypeName(obj) + ' instance already deleted');
    }
  
  
  var finalizationGroup=false;
  
  function detachFinalizer(handle) {}
  
  
  function runDestructor($$) {
      if ($$.smartPtr) {
          $$.smartPtrType.rawDestructor($$.smartPtr);
      } else {
          $$.ptrType.registeredClass.rawDestructor($$.ptr);
      }
    }function releaseClassHandle($$) {
      $$.count.value -= 1;
      var toDelete = 0 === $$.count.value;
      if (toDelete) {
          runDestructor($$);
      }
    }function attachFinalizer(handle) {
      if ('undefined' === typeof FinalizationGroup) {
          attachFinalizer = function (handle) { return handle; };
          return handle;
      }
      // If the running environment has a FinalizationGroup (see
      // https://github.com/tc39/proposal-weakrefs), then attach finalizers
      // for class handles.  We check for the presence of FinalizationGroup
      // at run-time, not build-time.
      finalizationGroup = new FinalizationGroup(function (iter) {
          for (var result = iter.next(); !result.done; result = iter.next()) {
              var $$ = result.value;
              if (!$$.ptr) {
                  console.warn('object already deleted: ' + $$.ptr);
              } else {
                  releaseClassHandle($$);
              }
          }
      });
      attachFinalizer = function(handle) {
          finalizationGroup.register(handle, handle.$$, handle.$$);
          return handle;
      };
      detachFinalizer = function(handle) {
          finalizationGroup.unregister(handle.$$);
      };
      return attachFinalizer(handle);
    }function ClassHandle_clone() {
      if (!this.$$.ptr) {
          throwInstanceAlreadyDeleted(this);
      }
  
      if (this.$$.preservePointerOnDelete) {
          this.$$.count.value += 1;
          return this;
      } else {
          var clone = attachFinalizer(Object.create(Object.getPrototypeOf(this), {
              $$: {
                  value: shallowCopyInternalPointer(this.$$),
              }
          }));
  
          clone.$$.count.value += 1;
          clone.$$.deleteScheduled = false;
          return clone;
      }
    }
  
  function ClassHandle_delete() {
      if (!this.$$.ptr) {
          throwInstanceAlreadyDeleted(this);
      }
  
      if (this.$$.deleteScheduled && !this.$$.preservePointerOnDelete) {
          throwBindingError('Object already scheduled for deletion');
      }
  
      detachFinalizer(this);
      releaseClassHandle(this.$$);
  
      if (!this.$$.preservePointerOnDelete) {
          this.$$.smartPtr = undefined;
          this.$$.ptr = undefined;
      }
    }
  
  function ClassHandle_isDeleted() {
      return !this.$$.ptr;
    }
  
  
  var delayFunction=undefined;
  
  var deletionQueue=[];
  
  function flushPendingDeletes() {
      while (deletionQueue.length) {
          var obj = deletionQueue.pop();
          obj.$$.deleteScheduled = false;
          obj['delete']();
      }
    }function ClassHandle_deleteLater() {
      if (!this.$$.ptr) {
          throwInstanceAlreadyDeleted(this);
      }
      if (this.$$.deleteScheduled && !this.$$.preservePointerOnDelete) {
          throwBindingError('Object already scheduled for deletion');
      }
      deletionQueue.push(this);
      if (deletionQueue.length === 1 && delayFunction) {
          delayFunction(flushPendingDeletes);
      }
      this.$$.deleteScheduled = true;
      return this;
    }function init_ClassHandle() {
      ClassHandle.prototype['isAliasOf'] = ClassHandle_isAliasOf;
      ClassHandle.prototype['clone'] = ClassHandle_clone;
      ClassHandle.prototype['delete'] = ClassHandle_delete;
      ClassHandle.prototype['isDeleted'] = ClassHandle_isDeleted;
      ClassHandle.prototype['deleteLater'] = ClassHandle_deleteLater;
    }function ClassHandle() {
    }
  
  var registeredPointers={};
  
  
  function ensureOverloadTable(proto, methodName, humanName) {
      if (undefined === proto[methodName].overloadTable) {
          var prevFunc = proto[methodName];
          // Inject an overload resolver function that routes to the appropriate overload based on the number of arguments.
          proto[methodName] = function() {
              // TODO This check can be removed in -O3 level "unsafe" optimizations.
              if (!proto[methodName].overloadTable.hasOwnProperty(arguments.length)) {
                  throwBindingError("Function '" + humanName + "' called with an invalid number of arguments (" + arguments.length + ") - expects one of (" + proto[methodName].overloadTable + ")!");
              }
              return proto[methodName].overloadTable[arguments.length].apply(this, arguments);
          };
          // Move the previous function into the overload table.
          proto[methodName].overloadTable = [];
          proto[methodName].overloadTable[prevFunc.argCount] = prevFunc;
      }
    }/** @param {number=} numArguments */
  function exposePublicSymbol(name, value, numArguments) {
      if (Module.hasOwnProperty(name)) {
          if (undefined === numArguments || (undefined !== Module[name].overloadTable && undefined !== Module[name].overloadTable[numArguments])) {
              throwBindingError("Cannot register public name '" + name + "' twice");
          }
  
          // We are exposing a function with the same name as an existing function. Create an overload table and a function selector
          // that routes between the two.
          ensureOverloadTable(Module, name, name);
          if (Module.hasOwnProperty(numArguments)) {
              throwBindingError("Cannot register multiple overloads of a function with the same number of arguments (" + numArguments + ")!");
          }
          // Add the new function into the overload table.
          Module[name].overloadTable[numArguments] = value;
      }
      else {
          Module[name] = value;
          if (undefined !== numArguments) {
              Module[name].numArguments = numArguments;
          }
      }
    }
  
  /** @constructor */
  function RegisteredClass(
      name,
      constructor,
      instancePrototype,
      rawDestructor,
      baseClass,
      getActualType,
      upcast,
      downcast
    ) {
      this.name = name;
      this.constructor = constructor;
      this.instancePrototype = instancePrototype;
      this.rawDestructor = rawDestructor;
      this.baseClass = baseClass;
      this.getActualType = getActualType;
      this.upcast = upcast;
      this.downcast = downcast;
      this.pureVirtualFunctions = [];
    }
  
  
  
  function upcastPointer(ptr, ptrClass, desiredClass) {
      while (ptrClass !== desiredClass) {
          if (!ptrClass.upcast) {
              throwBindingError("Expected null or instance of " + desiredClass.name + ", got an instance of " + ptrClass.name);
          }
          ptr = ptrClass.upcast(ptr);
          ptrClass = ptrClass.baseClass;
      }
      return ptr;
    }function constNoSmartPtrRawPointerToWireType(destructors, handle) {
      if (handle === null) {
          if (this.isReference) {
              throwBindingError('null is not a valid ' + this.name);
          }
          return 0;
      }
  
      if (!handle.$$) {
          throwBindingError('Cannot pass "' + _embind_repr(handle) + '" as a ' + this.name);
      }
      if (!handle.$$.ptr) {
          throwBindingError('Cannot pass deleted object as a pointer of type ' + this.name);
      }
      var handleClass = handle.$$.ptrType.registeredClass;
      var ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);
      return ptr;
    }
  
  function genericPointerToWireType(destructors, handle) {
      var ptr;
      if (handle === null) {
          if (this.isReference) {
              throwBindingError('null is not a valid ' + this.name);
          }
  
          if (this.isSmartPointer) {
              ptr = this.rawConstructor();
              if (destructors !== null) {
                  destructors.push(this.rawDestructor, ptr);
              }
              return ptr;
          } else {
              return 0;
          }
      }
  
      if (!handle.$$) {
          throwBindingError('Cannot pass "' + _embind_repr(handle) + '" as a ' + this.name);
      }
      if (!handle.$$.ptr) {
          throwBindingError('Cannot pass deleted object as a pointer of type ' + this.name);
      }
      if (!this.isConst && handle.$$.ptrType.isConst) {
          throwBindingError('Cannot convert argument of type ' + (handle.$$.smartPtrType ? handle.$$.smartPtrType.name : handle.$$.ptrType.name) + ' to parameter type ' + this.name);
      }
      var handleClass = handle.$$.ptrType.registeredClass;
      ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);
  
      if (this.isSmartPointer) {
          // TODO: this is not strictly true
          // We could support BY_EMVAL conversions from raw pointers to smart pointers
          // because the smart pointer can hold a reference to the handle
          if (undefined === handle.$$.smartPtr) {
              throwBindingError('Passing raw pointer to smart pointer is illegal');
          }
  
          switch (this.sharingPolicy) {
              case 0: // NONE
                  // no upcasting
                  if (handle.$$.smartPtrType === this) {
                      ptr = handle.$$.smartPtr;
                  } else {
                      throwBindingError('Cannot convert argument of type ' + (handle.$$.smartPtrType ? handle.$$.smartPtrType.name : handle.$$.ptrType.name) + ' to parameter type ' + this.name);
                  }
                  break;
  
              case 1: // INTRUSIVE
                  ptr = handle.$$.smartPtr;
                  break;
  
              case 2: // BY_EMVAL
                  if (handle.$$.smartPtrType === this) {
                      ptr = handle.$$.smartPtr;
                  } else {
                      var clonedHandle = handle['clone']();
                      ptr = this.rawShare(
                          ptr,
                          __emval_register(function() {
                              clonedHandle['delete']();
                          })
                      );
                      if (destructors !== null) {
                          destructors.push(this.rawDestructor, ptr);
                      }
                  }
                  break;
  
              default:
                  throwBindingError('Unsupporting sharing policy');
          }
      }
      return ptr;
    }
  
  function nonConstNoSmartPtrRawPointerToWireType(destructors, handle) {
      if (handle === null) {
          if (this.isReference) {
              throwBindingError('null is not a valid ' + this.name);
          }
          return 0;
      }
  
      if (!handle.$$) {
          throwBindingError('Cannot pass "' + _embind_repr(handle) + '" as a ' + this.name);
      }
      if (!handle.$$.ptr) {
          throwBindingError('Cannot pass deleted object as a pointer of type ' + this.name);
      }
      if (handle.$$.ptrType.isConst) {
          throwBindingError('Cannot convert argument of type ' + handle.$$.ptrType.name + ' to parameter type ' + this.name);
      }
      var handleClass = handle.$$.ptrType.registeredClass;
      var ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);
      return ptr;
    }
  
  
  function simpleReadValueFromPointer(pointer) {
      return this['fromWireType'](HEAPU32[pointer >> 2]);
    }
  
  function RegisteredPointer_getPointee(ptr) {
      if (this.rawGetPointee) {
          ptr = this.rawGetPointee(ptr);
      }
      return ptr;
    }
  
  function RegisteredPointer_destructor(ptr) {
      if (this.rawDestructor) {
          this.rawDestructor(ptr);
      }
    }
  
  function RegisteredPointer_deleteObject(handle) {
      if (handle !== null) {
          handle['delete']();
      }
    }
  
  
  function downcastPointer(ptr, ptrClass, desiredClass) {
      if (ptrClass === desiredClass) {
          return ptr;
      }
      if (undefined === desiredClass.baseClass) {
          return null; // no conversion
      }
  
      var rv = downcastPointer(ptr, ptrClass, desiredClass.baseClass);
      if (rv === null) {
          return null;
      }
      return desiredClass.downcast(rv);
    }
  
  
  
  
  function getInheritedInstanceCount() {
      return Object.keys(registeredInstances).length;
    }
  
  function getLiveInheritedInstances() {
      var rv = [];
      for (var k in registeredInstances) {
          if (registeredInstances.hasOwnProperty(k)) {
              rv.push(registeredInstances[k]);
          }
      }
      return rv;
    }
  
  function setDelayFunction(fn) {
      delayFunction = fn;
      if (deletionQueue.length && delayFunction) {
          delayFunction(flushPendingDeletes);
      }
    }function init_embind() {
      Module['getInheritedInstanceCount'] = getInheritedInstanceCount;
      Module['getLiveInheritedInstances'] = getLiveInheritedInstances;
      Module['flushPendingDeletes'] = flushPendingDeletes;
      Module['setDelayFunction'] = setDelayFunction;
    }var registeredInstances={};
  
  function getBasestPointer(class_, ptr) {
      if (ptr === undefined) {
          throwBindingError('ptr should not be undefined');
      }
      while (class_.baseClass) {
          ptr = class_.upcast(ptr);
          class_ = class_.baseClass;
      }
      return ptr;
    }function getInheritedInstance(class_, ptr) {
      ptr = getBasestPointer(class_, ptr);
      return registeredInstances[ptr];
    }
  
  function makeClassHandle(prototype, record) {
      if (!record.ptrType || !record.ptr) {
          throwInternalError('makeClassHandle requires ptr and ptrType');
      }
      var hasSmartPtrType = !!record.smartPtrType;
      var hasSmartPtr = !!record.smartPtr;
      if (hasSmartPtrType !== hasSmartPtr) {
          throwInternalError('Both smartPtrType and smartPtr must be specified');
      }
      record.count = { value: 1 };
      return attachFinalizer(Object.create(prototype, {
          $$: {
              value: record,
          },
      }));
    }function RegisteredPointer_fromWireType(ptr) {
      // ptr is a raw pointer (or a raw smartpointer)
  
      // rawPointer is a maybe-null raw pointer
      var rawPointer = this.getPointee(ptr);
      if (!rawPointer) {
          this.destructor(ptr);
          return null;
      }
  
      var registeredInstance = getInheritedInstance(this.registeredClass, rawPointer);
      if (undefined !== registeredInstance) {
          // JS object has been neutered, time to repopulate it
          if (0 === registeredInstance.$$.count.value) {
              registeredInstance.$$.ptr = rawPointer;
              registeredInstance.$$.smartPtr = ptr;
              return registeredInstance['clone']();
          } else {
              // else, just increment reference count on existing object
              // it already has a reference to the smart pointer
              var rv = registeredInstance['clone']();
              this.destructor(ptr);
              return rv;
          }
      }
  
      function makeDefaultHandle() {
          if (this.isSmartPointer) {
              return makeClassHandle(this.registeredClass.instancePrototype, {
                  ptrType: this.pointeeType,
                  ptr: rawPointer,
                  smartPtrType: this,
                  smartPtr: ptr,
              });
          } else {
              return makeClassHandle(this.registeredClass.instancePrototype, {
                  ptrType: this,
                  ptr: ptr,
              });
          }
      }
  
      var actualType = this.registeredClass.getActualType(rawPointer);
      var registeredPointerRecord = registeredPointers[actualType];
      if (!registeredPointerRecord) {
          return makeDefaultHandle.call(this);
      }
  
      var toType;
      if (this.isConst) {
          toType = registeredPointerRecord.constPointerType;
      } else {
          toType = registeredPointerRecord.pointerType;
      }
      var dp = downcastPointer(
          rawPointer,
          this.registeredClass,
          toType.registeredClass);
      if (dp === null) {
          return makeDefaultHandle.call(this);
      }
      if (this.isSmartPointer) {
          return makeClassHandle(toType.registeredClass.instancePrototype, {
              ptrType: toType,
              ptr: dp,
              smartPtrType: this,
              smartPtr: ptr,
          });
      } else {
          return makeClassHandle(toType.registeredClass.instancePrototype, {
              ptrType: toType,
              ptr: dp,
          });
      }
    }function init_RegisteredPointer() {
      RegisteredPointer.prototype.getPointee = RegisteredPointer_getPointee;
      RegisteredPointer.prototype.destructor = RegisteredPointer_destructor;
      RegisteredPointer.prototype['argPackAdvance'] = 8;
      RegisteredPointer.prototype['readValueFromPointer'] = simpleReadValueFromPointer;
      RegisteredPointer.prototype['deleteObject'] = RegisteredPointer_deleteObject;
      RegisteredPointer.prototype['fromWireType'] = RegisteredPointer_fromWireType;
    }/** @constructor
      @param {*=} pointeeType,
      @param {*=} sharingPolicy,
      @param {*=} rawGetPointee,
      @param {*=} rawConstructor,
      @param {*=} rawShare,
      @param {*=} rawDestructor,
       */
  function RegisteredPointer(
      name,
      registeredClass,
      isReference,
      isConst,
  
      // smart pointer properties
      isSmartPointer,
      pointeeType,
      sharingPolicy,
      rawGetPointee,
      rawConstructor,
      rawShare,
      rawDestructor
    ) {
      this.name = name;
      this.registeredClass = registeredClass;
      this.isReference = isReference;
      this.isConst = isConst;
  
      // smart pointer properties
      this.isSmartPointer = isSmartPointer;
      this.pointeeType = pointeeType;
      this.sharingPolicy = sharingPolicy;
      this.rawGetPointee = rawGetPointee;
      this.rawConstructor = rawConstructor;
      this.rawShare = rawShare;
      this.rawDestructor = rawDestructor;
  
      if (!isSmartPointer && registeredClass.baseClass === undefined) {
          if (isConst) {
              this['toWireType'] = constNoSmartPtrRawPointerToWireType;
              this.destructorFunction = null;
          } else {
              this['toWireType'] = nonConstNoSmartPtrRawPointerToWireType;
              this.destructorFunction = null;
          }
      } else {
          this['toWireType'] = genericPointerToWireType;
          // Here we must leave this.destructorFunction undefined, since whether genericPointerToWireType returns
          // a pointer that needs to be freed up is runtime-dependent, and cannot be evaluated at registration time.
          // TODO: Create an alternative mechanism that allows removing the use of var destructors = []; array in
          //       craftInvokerFunction altogether.
      }
    }
  
  /** @param {number=} numArguments */
  function replacePublicSymbol(name, value, numArguments) {
      if (!Module.hasOwnProperty(name)) {
          throwInternalError('Replacing nonexistant public symbol');
      }
      // If there's an overload table for this symbol, replace the symbol in the overload table instead.
      if (undefined !== Module[name].overloadTable && undefined !== numArguments) {
          Module[name].overloadTable[numArguments] = value;
      }
      else {
          Module[name] = value;
          Module[name].argCount = numArguments;
      }
    }
  
  function embind__requireFunction(signature, rawFunction) {
      signature = readLatin1String(signature);
  
      function makeDynCaller(dynCall) {
          var args = [];
          for (var i = 1; i < signature.length; ++i) {
              args.push('a' + i);
          }
  
          var name = 'dynCall_' + signature + '_' + rawFunction;
          var body = 'return function ' + name + '(' + args.join(', ') + ') {\n';
          body    += '    return dynCall(rawFunction' + (args.length ? ', ' : '') + args.join(', ') + ');\n';
          body    += '};\n';
  
          return (new Function('dynCall', 'rawFunction', body))(dynCall, rawFunction);
      }
  
      var dc = Module['dynCall_' + signature];
      var fp = makeDynCaller(dc);
  
      if (typeof fp !== "function") {
          throwBindingError("unknown function pointer with signature " + signature + ": " + rawFunction);
      }
      return fp;
    }
  
  
  var UnboundTypeError=undefined;
  
  function getTypeName(type) {
      var ptr = ___getTypeName(type);
      var rv = readLatin1String(ptr);
      _free(ptr);
      return rv;
    }function throwUnboundTypeError(message, types) {
      var unboundTypes = [];
      var seen = {};
      function visit(type) {
          if (seen[type]) {
              return;
          }
          if (registeredTypes[type]) {
              return;
          }
          if (typeDependencies[type]) {
              typeDependencies[type].forEach(visit);
              return;
          }
          unboundTypes.push(type);
          seen[type] = true;
      }
      types.forEach(visit);
  
      throw new UnboundTypeError(message + ': ' + unboundTypes.map(getTypeName).join([', ']));
    }function __embind_register_class(
      rawType,
      rawPointerType,
      rawConstPointerType,
      baseClassRawType,
      getActualTypeSignature,
      getActualType,
      upcastSignature,
      upcast,
      downcastSignature,
      downcast,
      name,
      destructorSignature,
      rawDestructor
    ) {
      name = readLatin1String(name);
      getActualType = embind__requireFunction(getActualTypeSignature, getActualType);
      if (upcast) {
          upcast = embind__requireFunction(upcastSignature, upcast);
      }
      if (downcast) {
          downcast = embind__requireFunction(downcastSignature, downcast);
      }
      rawDestructor = embind__requireFunction(destructorSignature, rawDestructor);
      var legalFunctionName = makeLegalFunctionName(name);
  
      exposePublicSymbol(legalFunctionName, function() {
          // this code cannot run if baseClassRawType is zero
          throwUnboundTypeError('Cannot construct ' + name + ' due to unbound types', [baseClassRawType]);
      });
  
      whenDependentTypesAreResolved(
          [rawType, rawPointerType, rawConstPointerType],
          baseClassRawType ? [baseClassRawType] : [],
          function(base) {
              base = base[0];
  
              var baseClass;
              var basePrototype;
              if (baseClassRawType) {
                  baseClass = base.registeredClass;
                  basePrototype = baseClass.instancePrototype;
              } else {
                  basePrototype = ClassHandle.prototype;
              }
  
              var constructor = createNamedFunction(legalFunctionName, function() {
                  if (Object.getPrototypeOf(this) !== instancePrototype) {
                      throw new BindingError("Use 'new' to construct " + name);
                  }
                  if (undefined === registeredClass.constructor_body) {
                      throw new BindingError(name + " has no accessible constructor");
                  }
                  var body = registeredClass.constructor_body[arguments.length];
                  if (undefined === body) {
                      throw new BindingError("Tried to invoke ctor of " + name + " with invalid number of parameters (" + arguments.length + ") - expected (" + Object.keys(registeredClass.constructor_body).toString() + ") parameters instead!");
                  }
                  return body.apply(this, arguments);
              });
  
              var instancePrototype = Object.create(basePrototype, {
                  constructor: { value: constructor },
              });
  
              constructor.prototype = instancePrototype;
  
              var registeredClass = new RegisteredClass(
                  name,
                  constructor,
                  instancePrototype,
                  rawDestructor,
                  baseClass,
                  getActualType,
                  upcast,
                  downcast);
  
              var referenceConverter = new RegisteredPointer(
                  name,
                  registeredClass,
                  true,
                  false,
                  false);
  
              var pointerConverter = new RegisteredPointer(
                  name + '*',
                  registeredClass,
                  false,
                  false,
                  false);
  
              var constPointerConverter = new RegisteredPointer(
                  name + ' const*',
                  registeredClass,
                  false,
                  true,
                  false);
  
              registeredPointers[rawType] = {
                  pointerType: pointerConverter,
                  constPointerType: constPointerConverter
              };
  
              replacePublicSymbol(legalFunctionName, constructor);
  
              return [referenceConverter, pointerConverter, constPointerConverter];
          }
      );
    }

  
  function heap32VectorToArray(count, firstElement) {
      var array = [];
      for (var i = 0; i < count; i++) {
          array.push(HEAP32[(firstElement >> 2) + i]);
      }
      return array;
    }
  
  function runDestructors(destructors) {
      while (destructors.length) {
          var ptr = destructors.pop();
          var del = destructors.pop();
          del(ptr);
      }
    }function __embind_register_class_constructor(
      rawClassType,
      argCount,
      rawArgTypesAddr,
      invokerSignature,
      invoker,
      rawConstructor
    ) {
      assert(argCount > 0);
      var rawArgTypes = heap32VectorToArray(argCount, rawArgTypesAddr);
      invoker = embind__requireFunction(invokerSignature, invoker);
      var args = [rawConstructor];
      var destructors = [];
  
      whenDependentTypesAreResolved([], [rawClassType], function(classType) {
          classType = classType[0];
          var humanName = 'constructor ' + classType.name;
  
          if (undefined === classType.registeredClass.constructor_body) {
              classType.registeredClass.constructor_body = [];
          }
          if (undefined !== classType.registeredClass.constructor_body[argCount - 1]) {
              throw new BindingError("Cannot register multiple constructors with identical number of parameters (" + (argCount-1) + ") for class '" + classType.name + "'! Overload resolution is currently only performed using the parameter count, not actual type info!");
          }
          classType.registeredClass.constructor_body[argCount - 1] = function unboundTypeHandler() {
              throwUnboundTypeError('Cannot construct ' + classType.name + ' due to unbound types', rawArgTypes);
          };
  
          whenDependentTypesAreResolved([], rawArgTypes, function(argTypes) {
              classType.registeredClass.constructor_body[argCount - 1] = function constructor_body() {
                  if (arguments.length !== argCount - 1) {
                      throwBindingError(humanName + ' called with ' + arguments.length + ' arguments, expected ' + (argCount-1));
                  }
                  destructors.length = 0;
                  args.length = argCount;
                  for (var i = 1; i < argCount; ++i) {
                      args[i] = argTypes[i]['toWireType'](destructors, arguments[i - 1]);
                  }
  
                  var ptr = invoker.apply(null, args);
                  runDestructors(destructors);
  
                  return argTypes[0]['fromWireType'](ptr);
              };
              return [];
          });
          return [];
      });
    }

  
  
  function new_(constructor, argumentList) {
      if (!(constructor instanceof Function)) {
          throw new TypeError('new_ called with constructor type ' + typeof(constructor) + " which is not a function");
      }
  
      /*
       * Previously, the following line was just:
  
       function dummy() {};
  
       * Unfortunately, Chrome was preserving 'dummy' as the object's name, even though at creation, the 'dummy' has the
       * correct constructor name.  Thus, objects created with IMVU.new would show up in the debugger as 'dummy', which
       * isn't very helpful.  Using IMVU.createNamedFunction addresses the issue.  Doublely-unfortunately, there's no way
       * to write a test for this behavior.  -NRD 2013.02.22
       */
      var dummy = createNamedFunction(constructor.name || 'unknownFunctionName', function(){});
      dummy.prototype = constructor.prototype;
      var obj = new dummy;
  
      var r = constructor.apply(obj, argumentList);
      return (r instanceof Object) ? r : obj;
    }function craftInvokerFunction(humanName, argTypes, classType, cppInvokerFunc, cppTargetFunc) {
      // humanName: a human-readable string name for the function to be generated.
      // argTypes: An array that contains the embind type objects for all types in the function signature.
      //    argTypes[0] is the type object for the function return value.
      //    argTypes[1] is the type object for function this object/class type, or null if not crafting an invoker for a class method.
      //    argTypes[2...] are the actual function parameters.
      // classType: The embind type object for the class to be bound, or null if this is not a method of a class.
      // cppInvokerFunc: JS Function object to the C++-side function that interops into C++ code.
      // cppTargetFunc: Function pointer (an integer to FUNCTION_TABLE) to the target C++ function the cppInvokerFunc will end up calling.
      var argCount = argTypes.length;
  
      if (argCount < 2) {
          throwBindingError("argTypes array size mismatch! Must at least get return value and 'this' types!");
      }
  
      var isClassMethodFunc = (argTypes[1] !== null && classType !== null);
  
      // Free functions with signature "void function()" do not need an invoker that marshalls between wire types.
  // TODO: This omits argument count check - enable only at -O3 or similar.
  //    if (ENABLE_UNSAFE_OPTS && argCount == 2 && argTypes[0].name == "void" && !isClassMethodFunc) {
  //       return FUNCTION_TABLE[fn];
  //    }
  
  
      // Determine if we need to use a dynamic stack to store the destructors for the function parameters.
      // TODO: Remove this completely once all function invokers are being dynamically generated.
      var needsDestructorStack = false;
  
      for(var i = 1; i < argTypes.length; ++i) { // Skip return value at index 0 - it's not deleted here.
          if (argTypes[i] !== null && argTypes[i].destructorFunction === undefined) { // The type does not define a destructor function - must use dynamic stack
              needsDestructorStack = true;
              break;
          }
      }
  
      var returns = (argTypes[0].name !== "void");
  
      var argsList = "";
      var argsListWired = "";
      for(var i = 0; i < argCount - 2; ++i) {
          argsList += (i!==0?", ":"")+"arg"+i;
          argsListWired += (i!==0?", ":"")+"arg"+i+"Wired";
      }
  
      var invokerFnBody =
          "return function "+makeLegalFunctionName(humanName)+"("+argsList+") {\n" +
          "if (arguments.length !== "+(argCount - 2)+") {\n" +
              "throwBindingError('function "+humanName+" called with ' + arguments.length + ' arguments, expected "+(argCount - 2)+" args!');\n" +
          "}\n";
  
  
      if (needsDestructorStack) {
          invokerFnBody +=
              "var destructors = [];\n";
      }
  
      var dtorStack = needsDestructorStack ? "destructors" : "null";
      var args1 = ["throwBindingError", "invoker", "fn", "runDestructors", "retType", "classParam"];
      var args2 = [throwBindingError, cppInvokerFunc, cppTargetFunc, runDestructors, argTypes[0], argTypes[1]];
  
  
      if (isClassMethodFunc) {
          invokerFnBody += "var thisWired = classParam.toWireType("+dtorStack+", this);\n";
      }
  
      for(var i = 0; i < argCount - 2; ++i) {
          invokerFnBody += "var arg"+i+"Wired = argType"+i+".toWireType("+dtorStack+", arg"+i+"); // "+argTypes[i+2].name+"\n";
          args1.push("argType"+i);
          args2.push(argTypes[i+2]);
      }
  
      if (isClassMethodFunc) {
          argsListWired = "thisWired" + (argsListWired.length > 0 ? ", " : "") + argsListWired;
      }
  
      invokerFnBody +=
          (returns?"var rv = ":"") + "invoker(fn"+(argsListWired.length>0?", ":"")+argsListWired+");\n";
  
      if (needsDestructorStack) {
          invokerFnBody += "runDestructors(destructors);\n";
      } else {
          for(var i = isClassMethodFunc?1:2; i < argTypes.length; ++i) { // Skip return value at index 0 - it's not deleted here. Also skip class type if not a method.
              var paramName = (i === 1 ? "thisWired" : ("arg"+(i - 2)+"Wired"));
              if (argTypes[i].destructorFunction !== null) {
                  invokerFnBody += paramName+"_dtor("+paramName+"); // "+argTypes[i].name+"\n";
                  args1.push(paramName+"_dtor");
                  args2.push(argTypes[i].destructorFunction);
              }
          }
      }
  
      if (returns) {
          invokerFnBody += "var ret = retType.fromWireType(rv);\n" +
                           "return ret;\n";
      } else {
      }
      invokerFnBody += "}\n";
  
      args1.push(invokerFnBody);
  
      var invokerFunction = new_(Function, args1).apply(null, args2);
      return invokerFunction;
    }function __embind_register_class_function(
      rawClassType,
      methodName,
      argCount,
      rawArgTypesAddr, // [ReturnType, ThisType, Args...]
      invokerSignature,
      rawInvoker,
      context,
      isPureVirtual
    ) {
      var rawArgTypes = heap32VectorToArray(argCount, rawArgTypesAddr);
      methodName = readLatin1String(methodName);
      rawInvoker = embind__requireFunction(invokerSignature, rawInvoker);
  
      whenDependentTypesAreResolved([], [rawClassType], function(classType) {
          classType = classType[0];
          var humanName = classType.name + '.' + methodName;
  
          if (isPureVirtual) {
              classType.registeredClass.pureVirtualFunctions.push(methodName);
          }
  
          function unboundTypesHandler() {
              throwUnboundTypeError('Cannot call ' + humanName + ' due to unbound types', rawArgTypes);
          }
  
          var proto = classType.registeredClass.instancePrototype;
          var method = proto[methodName];
          if (undefined === method || (undefined === method.overloadTable && method.className !== classType.name && method.argCount === argCount - 2)) {
              // This is the first overload to be registered, OR we are replacing a function in the base class with a function in the derived class.
              unboundTypesHandler.argCount = argCount - 2;
              unboundTypesHandler.className = classType.name;
              proto[methodName] = unboundTypesHandler;
          } else {
              // There was an existing function with the same name registered. Set up a function overload routing table.
              ensureOverloadTable(proto, methodName, humanName);
              proto[methodName].overloadTable[argCount - 2] = unboundTypesHandler;
          }
  
          whenDependentTypesAreResolved([], rawArgTypes, function(argTypes) {
  
              var memberFunction = craftInvokerFunction(humanName, argTypes, classType, rawInvoker, context);
  
              // Replace the initial unbound-handler-stub function with the appropriate member function, now that all types
              // are resolved. If multiple overloads are registered for this function, the function goes into an overload table.
              if (undefined === proto[methodName].overloadTable) {
                  // Set argCount in case an overload is registered later
                  memberFunction.argCount = argCount - 2;
                  proto[methodName] = memberFunction;
              } else {
                  proto[methodName].overloadTable[argCount - 2] = memberFunction;
              }
  
              return [];
          });
          return [];
      });
    }

  
  function validateThis(this_, classType, humanName) {
      if (!(this_ instanceof Object)) {
          throwBindingError(humanName + ' with invalid "this": ' + this_);
      }
      if (!(this_ instanceof classType.registeredClass.constructor)) {
          throwBindingError(humanName + ' incompatible with "this" of type ' + this_.constructor.name);
      }
      if (!this_.$$.ptr) {
          throwBindingError('cannot call emscripten binding method ' + humanName + ' on deleted object');
      }
  
      // todo: kill this
      return upcastPointer(
          this_.$$.ptr,
          this_.$$.ptrType.registeredClass,
          classType.registeredClass);
    }function __embind_register_class_property(
      classType,
      fieldName,
      getterReturnType,
      getterSignature,
      getter,
      getterContext,
      setterArgumentType,
      setterSignature,
      setter,
      setterContext
    ) {
      fieldName = readLatin1String(fieldName);
      getter = embind__requireFunction(getterSignature, getter);
  
      whenDependentTypesAreResolved([], [classType], function(classType) {
          classType = classType[0];
          var humanName = classType.name + '.' + fieldName;
          var desc = {
              get: function() {
                  throwUnboundTypeError('Cannot access ' + humanName + ' due to unbound types', [getterReturnType, setterArgumentType]);
              },
              enumerable: true,
              configurable: true
          };
          if (setter) {
              desc.set = function() {
                  throwUnboundTypeError('Cannot access ' + humanName + ' due to unbound types', [getterReturnType, setterArgumentType]);
              };
          } else {
              desc.set = function(v) {
                  throwBindingError(humanName + ' is a read-only property');
              };
          }
  
          Object.defineProperty(classType.registeredClass.instancePrototype, fieldName, desc);
  
          whenDependentTypesAreResolved(
              [],
              (setter ? [getterReturnType, setterArgumentType] : [getterReturnType]),
          function(types) {
              var getterReturnType = types[0];
              var desc = {
                  get: function() {
                      var ptr = validateThis(this, classType, humanName + ' getter');
                      return getterReturnType['fromWireType'](getter(getterContext, ptr));
                  },
                  enumerable: true
              };
  
              if (setter) {
                  setter = embind__requireFunction(setterSignature, setter);
                  var setterArgumentType = types[1];
                  desc.set = function(v) {
                      var ptr = validateThis(this, classType, humanName + ' setter');
                      var destructors = [];
                      setter(setterContext, ptr, setterArgumentType['toWireType'](destructors, v));
                      runDestructors(destructors);
                  };
              }
  
              Object.defineProperty(classType.registeredClass.instancePrototype, fieldName, desc);
              return [];
          });
  
          return [];
      });
    }

  function __embind_register_constant(name, type, value) {
      name = readLatin1String(name);
      whenDependentTypesAreResolved([], [type], function(type) {
          type = type[0];
          Module[name] = type['fromWireType'](value);
          return [];
      });
    }

  
  
  var emval_free_list=[];
  
  var emval_handle_array=[{},{value:undefined},{value:null},{value:true},{value:false}];function __emval_decref(handle) {
      if (handle > 4 && 0 === --emval_handle_array[handle].refcount) {
          emval_handle_array[handle] = undefined;
          emval_free_list.push(handle);
      }
    }
  
  
  
  function count_emval_handles() {
      var count = 0;
      for (var i = 5; i < emval_handle_array.length; ++i) {
          if (emval_handle_array[i] !== undefined) {
              ++count;
          }
      }
      return count;
    }
  
  function get_first_emval() {
      for (var i = 5; i < emval_handle_array.length; ++i) {
          if (emval_handle_array[i] !== undefined) {
              return emval_handle_array[i];
          }
      }
      return null;
    }function init_emval() {
      Module['count_emval_handles'] = count_emval_handles;
      Module['get_first_emval'] = get_first_emval;
    }function __emval_register(value) {
  
      switch(value){
        case undefined :{ return 1; }
        case null :{ return 2; }
        case true :{ return 3; }
        case false :{ return 4; }
        default:{
          var handle = emval_free_list.length ?
              emval_free_list.pop() :
              emval_handle_array.length;
  
          emval_handle_array[handle] = {refcount: 1, value: value};
          return handle;
          }
        }
    }function __embind_register_emval(rawType, name) {
      name = readLatin1String(name);
      registerType(rawType, {
          name: name,
          'fromWireType': function(handle) {
              var rv = emval_handle_array[handle].value;
              __emval_decref(handle);
              return rv;
          },
          'toWireType': function(destructors, value) {
              return __emval_register(value);
          },
          'argPackAdvance': 8,
          'readValueFromPointer': simpleReadValueFromPointer,
          destructorFunction: null, // This type does not need a destructor
  
          // TODO: do we need a deleteObject here?  write a test where
          // emval is passed into JS via an interface
      });
    }

  
  function _embind_repr(v) {
      if (v === null) {
          return 'null';
      }
      var t = typeof v;
      if (t === 'object' || t === 'array' || t === 'function') {
          return v.toString();
      } else {
          return '' + v;
      }
    }
  
  function floatReadValueFromPointer(name, shift) {
      switch (shift) {
          case 2: return function(pointer) {
              return this['fromWireType'](HEAPF32[pointer >> 2]);
          };
          case 3: return function(pointer) {
              return this['fromWireType'](HEAPF64[pointer >> 3]);
          };
          default:
              throw new TypeError("Unknown float type: " + name);
      }
    }function __embind_register_float(rawType, name, size) {
      var shift = getShiftFromSize(size);
      name = readLatin1String(name);
      registerType(rawType, {
          name: name,
          'fromWireType': function(value) {
              return value;
          },
          'toWireType': function(destructors, value) {
              // todo: Here we have an opportunity for -O3 level "unsafe" optimizations: we could
              // avoid the following if() and assume value is of proper type.
              if (typeof value !== "number" && typeof value !== "boolean") {
                  throw new TypeError('Cannot convert "' + _embind_repr(value) + '" to ' + this.name);
              }
              return value;
          },
          'argPackAdvance': 8,
          'readValueFromPointer': floatReadValueFromPointer(name, shift),
          destructorFunction: null, // This type does not need a destructor
      });
    }

  function __embind_register_function(name, argCount, rawArgTypesAddr, signature, rawInvoker, fn) {
      var argTypes = heap32VectorToArray(argCount, rawArgTypesAddr);
      name = readLatin1String(name);
  
      rawInvoker = embind__requireFunction(signature, rawInvoker);
  
      exposePublicSymbol(name, function() {
          throwUnboundTypeError('Cannot call ' + name + ' due to unbound types', argTypes);
      }, argCount - 1);
  
      whenDependentTypesAreResolved([], argTypes, function(argTypes) {
          var invokerArgsArray = [argTypes[0] /* return value */, null /* no class 'this'*/].concat(argTypes.slice(1) /* actual params */);
          replacePublicSymbol(name, craftInvokerFunction(name, invokerArgsArray, null /* no class 'this'*/, rawInvoker, fn), argCount - 1);
          return [];
      });
    }

  
  function integerReadValueFromPointer(name, shift, signed) {
      // integers are quite common, so generate very specialized functions
      switch (shift) {
          case 0: return signed ?
              function readS8FromPointer(pointer) { return HEAP8[pointer]; } :
              function readU8FromPointer(pointer) { return HEAPU8[pointer]; };
          case 1: return signed ?
              function readS16FromPointer(pointer) { return HEAP16[pointer >> 1]; } :
              function readU16FromPointer(pointer) { return HEAPU16[pointer >> 1]; };
          case 2: return signed ?
              function readS32FromPointer(pointer) { return HEAP32[pointer >> 2]; } :
              function readU32FromPointer(pointer) { return HEAPU32[pointer >> 2]; };
          default:
              throw new TypeError("Unknown integer type: " + name);
      }
    }function __embind_register_integer(primitiveType, name, size, minRange, maxRange) {
      name = readLatin1String(name);
      if (maxRange === -1) { // LLVM doesn't have signed and unsigned 32-bit types, so u32 literals come out as 'i32 -1'. Always treat those as max u32.
          maxRange = 4294967295;
      }
  
      var shift = getShiftFromSize(size);
  
      var fromWireType = function(value) {
          return value;
      };
  
      if (minRange === 0) {
          var bitshift = 32 - 8*size;
          fromWireType = function(value) {
              return (value << bitshift) >>> bitshift;
          };
      }
  
      var isUnsignedType = (name.indexOf('unsigned') != -1);
  
      registerType(primitiveType, {
          name: name,
          'fromWireType': fromWireType,
          'toWireType': function(destructors, value) {
              // todo: Here we have an opportunity for -O3 level "unsafe" optimizations: we could
              // avoid the following two if()s and assume value is of proper type.
              if (typeof value !== "number" && typeof value !== "boolean") {
                  throw new TypeError('Cannot convert "' + _embind_repr(value) + '" to ' + this.name);
              }
              if (value < minRange || value > maxRange) {
                  throw new TypeError('Passing a number "' + _embind_repr(value) + '" from JS side to C/C++ side to an argument of type "' + name + '", which is outside the valid range [' + minRange + ', ' + maxRange + ']!');
              }
              return isUnsignedType ? (value >>> 0) : (value | 0);
          },
          'argPackAdvance': 8,
          'readValueFromPointer': integerReadValueFromPointer(name, shift, minRange !== 0),
          destructorFunction: null, // This type does not need a destructor
      });
    }

  function __embind_register_memory_view(rawType, dataTypeIndex, name) {
      var typeMapping = [
          Int8Array,
          Uint8Array,
          Int16Array,
          Uint16Array,
          Int32Array,
          Uint32Array,
          Float32Array,
          Float64Array,
      ];
  
      var TA = typeMapping[dataTypeIndex];
  
      function decodeMemoryView(handle) {
          handle = handle >> 2;
          var heap = HEAPU32;
          var size = heap[handle]; // in elements
          var data = heap[handle + 1]; // byte offset into emscripten heap
          return new TA(buffer, data, size);
      }
  
      name = readLatin1String(name);
      registerType(rawType, {
          name: name,
          'fromWireType': decodeMemoryView,
          'argPackAdvance': 8,
          'readValueFromPointer': decodeMemoryView,
      }, {
          ignoreDuplicateRegistrations: true,
      });
    }

  function __embind_register_std_string(rawType, name) {
      name = readLatin1String(name);
      var stdStringIsUTF8
      //process only std::string bindings with UTF8 support, in contrast to e.g. std::basic_string<unsigned char>
      = (name === "std::string");
  
      registerType(rawType, {
          name: name,
          'fromWireType': function(value) {
              var length = HEAPU32[value >> 2];
  
              var str;
              if (stdStringIsUTF8) {
                  //ensure null termination at one-past-end byte if not present yet
                  var endChar = HEAPU8[value + 4 + length];
                  var endCharSwap = 0;
                  if (endChar != 0) {
                      endCharSwap = endChar;
                      HEAPU8[value + 4 + length] = 0;
                  }
  
                  var decodeStartPtr = value + 4;
                  // Looping here to support possible embedded '0' bytes
                  for (var i = 0; i <= length; ++i) {
                      var currentBytePtr = value + 4 + i;
                      if (HEAPU8[currentBytePtr] == 0) {
                          var stringSegment = UTF8ToString(decodeStartPtr);
                          if (str === undefined) {
                              str = stringSegment;
                          } else {
                              str += String.fromCharCode(0);
                              str += stringSegment;
                          }
                          decodeStartPtr = currentBytePtr + 1;
                      }
                  }
  
                  if (endCharSwap != 0) {
                      HEAPU8[value + 4 + length] = endCharSwap;
                  }
              } else {
                  var a = new Array(length);
                  for (var i = 0; i < length; ++i) {
                      a[i] = String.fromCharCode(HEAPU8[value + 4 + i]);
                  }
                  str = a.join('');
              }
  
              _free(value);
  
              return str;
          },
          'toWireType': function(destructors, value) {
              if (value instanceof ArrayBuffer) {
                  value = new Uint8Array(value);
              }
  
              var getLength;
              var valueIsOfTypeString = (typeof value === 'string');
  
              if (!(valueIsOfTypeString || value instanceof Uint8Array || value instanceof Uint8ClampedArray || value instanceof Int8Array)) {
                  throwBindingError('Cannot pass non-string to std::string');
              }
              if (stdStringIsUTF8 && valueIsOfTypeString) {
                  getLength = function() {return lengthBytesUTF8(value);};
              } else {
                  getLength = function() {return value.length;};
              }
  
              // assumes 4-byte alignment
              var length = getLength();
              var ptr = _malloc(4 + length + 1);
              HEAPU32[ptr >> 2] = length;
              if (stdStringIsUTF8 && valueIsOfTypeString) {
                  stringToUTF8(value, ptr + 4, length + 1);
              } else {
                  if (valueIsOfTypeString) {
                      for (var i = 0; i < length; ++i) {
                          var charCode = value.charCodeAt(i);
                          if (charCode > 255) {
                              _free(ptr);
                              throwBindingError('String has UTF-16 code units that do not fit in 8 bits');
                          }
                          HEAPU8[ptr + 4 + i] = charCode;
                      }
                  } else {
                      for (var i = 0; i < length; ++i) {
                          HEAPU8[ptr + 4 + i] = value[i];
                      }
                  }
              }
  
              if (destructors !== null) {
                  destructors.push(_free, ptr);
              }
              return ptr;
          },
          'argPackAdvance': 8,
          'readValueFromPointer': simpleReadValueFromPointer,
          destructorFunction: function(ptr) { _free(ptr); },
      });
    }

  function __embind_register_std_wstring(rawType, charSize, name) {
      name = readLatin1String(name);
      var decodeString, encodeString, getHeap, lengthBytesUTF, shift;
      if (charSize === 2) {
          decodeString = UTF16ToString;
          encodeString = stringToUTF16;
          lengthBytesUTF = lengthBytesUTF16;
          getHeap = function() { return HEAPU16; };
          shift = 1;
      } else if (charSize === 4) {
          decodeString = UTF32ToString;
          encodeString = stringToUTF32;
          lengthBytesUTF = lengthBytesUTF32;
          getHeap = function() { return HEAPU32; };
          shift = 2;
      }
      registerType(rawType, {
          name: name,
          'fromWireType': function(value) {
              // Code mostly taken from _embind_register_std_string fromWireType
              var length = HEAPU32[value >> 2];
              var HEAP = getHeap();
              var str;
              // Ensure null termination at one-past-end byte if not present yet
              var endChar = HEAP[(value + 4 + length * charSize) >> shift];
              var endCharSwap = 0;
              if (endChar != 0) {
                  endCharSwap = endChar;
                  HEAP[(value + 4 + length * charSize) >> shift] = 0;
              }
  
              var decodeStartPtr = value + 4;
              // Looping here to support possible embedded '0' bytes
              for (var i = 0; i <= length; ++i) {
                  var currentBytePtr = value + 4 + i * charSize;
                  if (HEAP[currentBytePtr >> shift] == 0) {
                      var stringSegment = decodeString(decodeStartPtr);
                      if (str === undefined) {
                          str = stringSegment;
                      } else {
                          str += String.fromCharCode(0);
                          str += stringSegment;
                      }
                      decodeStartPtr = currentBytePtr + charSize;
                  }
              }
  
              if (endCharSwap != 0) {
                  HEAP[(value + 4 + length * charSize) >> shift] = endCharSwap;
              }
  
              _free(value);
  
              return str;
          },
          'toWireType': function(destructors, value) {
              if (!(typeof value === 'string')) {
                  throwBindingError('Cannot pass non-string to C++ string type ' + name);
              }
  
              // assumes 4-byte alignment
              var length = lengthBytesUTF(value);
              var ptr = _malloc(4 + length + charSize);
              HEAPU32[ptr >> 2] = length >> shift;
  
              encodeString(value, ptr + 4, length + charSize);
  
              if (destructors !== null) {
                  destructors.push(_free, ptr);
              }
              return ptr;
          },
          'argPackAdvance': 8,
          'readValueFromPointer': simpleReadValueFromPointer,
          destructorFunction: function(ptr) { _free(ptr); },
      });
    }

  function __embind_register_void(rawType, name) {
      name = readLatin1String(name);
      registerType(rawType, {
          isVoid: true, // void return values can be optimized out sometimes
          name: name,
          'argPackAdvance': 0,
          'fromWireType': function() {
              return undefined;
          },
          'toWireType': function(destructors, o) {
              // TODO: assert if anything else is given?
              return undefined;
          },
      });
    }


  function __emval_incref(handle) {
      if (handle > 4) {
          emval_handle_array[handle].refcount += 1;
      }
    }

  
  
  var emval_symbols={};function getStringOrSymbol(address) {
      var symbol = emval_symbols[address];
      if (symbol === undefined) {
          return readLatin1String(address);
      } else {
          return symbol;
      }
    }function __emval_new_cstring(v) {
      return __emval_register(getStringOrSymbol(v));
    }

  function __emval_new_object() {
      return __emval_register({});
    }

  
  function requireHandle(handle) {
      if (!handle) {
          throwBindingError('Cannot use deleted val. handle = ' + handle);
      }
      return emval_handle_array[handle].value;
    }function __emval_set_property(handle, key, value) {
      handle = requireHandle(handle);
      key = requireHandle(key);
      value = requireHandle(value);
      handle[key] = value;
    }

  
  function requireRegisteredType(rawType, humanName) {
      var impl = registeredTypes[rawType];
      if (undefined === impl) {
          throwBindingError(humanName + " has unknown type " + getTypeName(rawType));
      }
      return impl;
    }function __emval_take_value(type, argv) {
      type = requireRegisteredType(type, '_emval_take_value');
      var v = type['readValueFromPointer'](argv);
      return __emval_register(v);
    }

  function _abort() {
      abort();
    }

  function _emscripten_get_sbrk_ptr() {
      return 58736;
    }

  function _emscripten_memcpy_big(dest, src, num) {
      HEAPU8.copyWithin(dest, src, src + num);
    }

  
  function _emscripten_get_heap_size() {
      return HEAPU8.length;
    }
  
  function emscripten_realloc_buffer(size) {
      try {
        // round size grow request up to wasm page size (fixed 64KB per spec)
        wasmMemory.grow((size - buffer.byteLength + 65535) >>> 16); // .grow() takes a delta compared to the previous size
        updateGlobalBufferAndViews(wasmMemory.buffer);
        return 1 /*success*/;
      } catch(e) {
      }
    }function _emscripten_resize_heap(requestedSize) {
      requestedSize = requestedSize >>> 0;
      var oldSize = _emscripten_get_heap_size();
      // With pthreads, races can happen (another thread might increase the size in between), so return a failure, and let the caller retry.
  
  
      var PAGE_MULTIPLE = 65536;
  
      // Memory resize rules:
      // 1. When resizing, always produce a resized heap that is at least 16MB (to avoid tiny heap sizes receiving lots of repeated resizes at startup)
      // 2. Always increase heap size to at least the requested size, rounded up to next page multiple.
      // 3a. If MEMORY_GROWTH_LINEAR_STEP == -1, excessively resize the heap geometrically: increase the heap size according to 
      //                                         MEMORY_GROWTH_GEOMETRIC_STEP factor (default +20%),
      //                                         At most overreserve by MEMORY_GROWTH_GEOMETRIC_CAP bytes (default 96MB).
      // 3b. If MEMORY_GROWTH_LINEAR_STEP != -1, excessively resize the heap linearly: increase the heap size by at least MEMORY_GROWTH_LINEAR_STEP bytes.
      // 4. Max size for the heap is capped at 2048MB-PAGE_MULTIPLE, or by MAXIMUM_MEMORY, or by ASAN limit, depending on which is smallest
      // 5. If we were unable to allocate as much memory, it may be due to over-eager decision to excessively reserve due to (3) above.
      //    Hence if an allocation fails, cut down on the amount of excess growth, in an attempt to succeed to perform a smaller allocation.
  
      // A limit was set for how much we can grow. We should not exceed that
      // (the wasm binary specifies it, so if we tried, we'd fail anyhow).
      var maxHeapSize = 2147483648;
      if (requestedSize > maxHeapSize) {
        return false;
      }
  
      var minHeapSize = 16777216;
  
      // Loop through potential heap size increases. If we attempt a too eager reservation that fails, cut down on the
      // attempted size and reserve a smaller bump instead. (max 3 times, chosen somewhat arbitrarily)
      for(var cutDown = 1; cutDown <= 4; cutDown *= 2) {
        var overGrownHeapSize = oldSize * (1 + 0.2 / cutDown); // ensure geometric growth
        // but limit overreserving (default to capping at +96MB overgrowth at most)
        overGrownHeapSize = Math.min(overGrownHeapSize, requestedSize + 100663296 );
  
  
        var newSize = Math.min(maxHeapSize, alignUp(Math.max(minHeapSize, requestedSize, overGrownHeapSize), PAGE_MULTIPLE));
  
        var replacement = emscripten_realloc_buffer(newSize);
        if (replacement) {
  
          return true;
        }
      }
      return false;
    }

  function _exit(status) {
      // void _exit(int status);
      // http://pubs.opengroup.org/onlinepubs/000095399/functions/exit.html
      exit(status);
    }

  function _fd_close(fd) {try {
  
      var stream = SYSCALLS.getStreamFromFD(fd);
      FS.close(stream);
      return 0;
    } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return e.errno;
  }
  }

  function _fd_fdstat_get(fd, pbuf) {try {
  
      var stream = SYSCALLS.getStreamFromFD(fd);
      // All character devices are terminals (other things a Linux system would
      // assume is a character device, like the mouse, we have special APIs for).
      var type = stream.tty ? 2 :
                 FS.isDir(stream.mode) ? 3 :
                 FS.isLink(stream.mode) ? 7 :
                 4;
      HEAP8[((pbuf)>>0)]=type;
      // TODO HEAP16[(((pbuf)+(2))>>1)]=?;
      // TODO (tempI64 = [?>>>0,(tempDouble=?,(+(Math_abs(tempDouble))) >= 1.0 ? (tempDouble > 0.0 ? ((Math_min((+(Math_floor((tempDouble)/4294967296.0))), 4294967295.0))|0)>>>0 : (~~((+(Math_ceil((tempDouble - +(((~~(tempDouble)))>>>0))/4294967296.0)))))>>>0) : 0)],HEAP32[(((pbuf)+(8))>>2)]=tempI64[0],HEAP32[(((pbuf)+(12))>>2)]=tempI64[1]);
      // TODO (tempI64 = [?>>>0,(tempDouble=?,(+(Math_abs(tempDouble))) >= 1.0 ? (tempDouble > 0.0 ? ((Math_min((+(Math_floor((tempDouble)/4294967296.0))), 4294967295.0))|0)>>>0 : (~~((+(Math_ceil((tempDouble - +(((~~(tempDouble)))>>>0))/4294967296.0)))))>>>0) : 0)],HEAP32[(((pbuf)+(16))>>2)]=tempI64[0],HEAP32[(((pbuf)+(20))>>2)]=tempI64[1]);
      return 0;
    } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return e.errno;
  }
  }

  function _fd_seek(fd, offset_low, offset_high, whence, newOffset) {try {
  
      
      var stream = SYSCALLS.getStreamFromFD(fd);
      var HIGH_OFFSET = 0x100000000; // 2^32
      // use an unsigned operator on low and shift high by 32-bits
      var offset = offset_high * HIGH_OFFSET + (offset_low >>> 0);
  
      var DOUBLE_LIMIT = 0x20000000000000; // 2^53
      // we also check for equality since DOUBLE_LIMIT + 1 == DOUBLE_LIMIT
      if (offset <= -DOUBLE_LIMIT || offset >= DOUBLE_LIMIT) {
        return -61;
      }
  
      FS.llseek(stream, offset, whence);
      (tempI64 = [stream.position>>>0,(tempDouble=stream.position,(+(Math_abs(tempDouble))) >= 1.0 ? (tempDouble > 0.0 ? ((Math_min((+(Math_floor((tempDouble)/4294967296.0))), 4294967295.0))|0)>>>0 : (~~((+(Math_ceil((tempDouble - +(((~~(tempDouble)))>>>0))/4294967296.0)))))>>>0) : 0)],HEAP32[((newOffset)>>2)]=tempI64[0],HEAP32[(((newOffset)+(4))>>2)]=tempI64[1]);
      if (stream.getdents && offset === 0 && whence === 0) stream.getdents = null; // reset readdir state
      return 0;
    } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return e.errno;
  }
  }

  function _fd_write(fd, iov, iovcnt, pnum) {try {
  
      var stream = SYSCALLS.getStreamFromFD(fd);
      var num = SYSCALLS.doWritev(stream, iov, iovcnt);
      HEAP32[((pnum)>>2)]=num
      return 0;
    } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return e.errno;
  }
  }

  function _raise(sig) {
    setErrNo(ERRNO_CODES.ENOSYS);
      return -1;
    }

  function _setTempRet0($i) {
      setTempRet0(($i) | 0);
    }
var FSNode = /** @constructor */ function(parent, name, mode, rdev) {
    if (!parent) {
      parent = this;  // root node sets parent to itself
    }
    this.parent = parent;
    this.mount = parent.mount;
    this.mounted = null;
    this.id = FS.nextInode++;
    this.name = name;
    this.mode = mode;
    this.node_ops = {};
    this.stream_ops = {};
    this.rdev = rdev;
  };
  var readMode = 292/*292*/ | 73/*73*/;
  var writeMode = 146/*146*/;
  Object.defineProperties(FSNode.prototype, {
   read: {
    get: /** @this{FSNode} */function() {
     return (this.mode & readMode) === readMode;
    },
    set: /** @this{FSNode} */function(val) {
     val ? this.mode |= readMode : this.mode &= ~readMode;
    }
   },
   write: {
    get: /** @this{FSNode} */function() {
     return (this.mode & writeMode) === writeMode;
    },
    set: /** @this{FSNode} */function(val) {
     val ? this.mode |= writeMode : this.mode &= ~writeMode;
    }
   },
   isFolder: {
    get: /** @this{FSNode} */function() {
     return FS.isDir(this.mode);
    }
   },
   isDevice: {
    get: /** @this{FSNode} */function() {
     return FS.isChrdev(this.mode);
    }
   }
  });
  FS.FSNode = FSNode;
  FS.staticInit();;
if (ENVIRONMENT_IS_NODE) { var fs = require("fs"); var NODEJS_PATH = require("path"); NODEFS.staticInit(); };
embind_init_charCodes();
BindingError = Module['BindingError'] = extendError(Error, 'BindingError');;
InternalError = Module['InternalError'] = extendError(Error, 'InternalError');;
init_ClassHandle();
init_RegisteredPointer();
init_embind();;
UnboundTypeError = Module['UnboundTypeError'] = extendError(Error, 'UnboundTypeError');;
init_emval();;
var ASSERTIONS = false;

/**
 * @license
 * Copyright 2017 The Emscripten Authors
 * SPDX-License-Identifier: MIT
 */

/** @type {function(string, boolean=, number=)} */
function intArrayFromString(stringy, dontAddNull, length) {
  var len = length > 0 ? length : lengthBytesUTF8(stringy)+1;
  var u8array = new Array(len);
  var numBytesWritten = stringToUTF8Array(stringy, u8array, 0, u8array.length);
  if (dontAddNull) u8array.length = numBytesWritten;
  return u8array;
}

function intArrayToString(array) {
  var ret = [];
  for (var i = 0; i < array.length; i++) {
    var chr = array[i];
    if (chr > 0xFF) {
      if (ASSERTIONS) {
        assert(false, 'Character code ' + chr + ' (' + String.fromCharCode(chr) + ')  at offset ' + i + ' not in 0x00-0xFF.');
      }
      chr &= 0xFF;
    }
    ret.push(String.fromCharCode(chr));
  }
  return ret.join('');
}


// Copied from https://github.com/strophe/strophejs/blob/e06d027/src/polyfills.js#L149

// This code was written by Tyler Akins and has been placed in the
// public domain.  It would be nice if you left this header intact.
// Base64 code from Tyler Akins -- http://rumkin.com

/**
 * Decodes a base64 string.
 * @param {string} input The string to decode.
 */
var decodeBase64 = typeof atob === 'function' ? atob : function (input) {
  var keyStr = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';

  var output = '';
  var chr1, chr2, chr3;
  var enc1, enc2, enc3, enc4;
  var i = 0;
  // remove all characters that are not A-Z, a-z, 0-9, +, /, or =
  input = input.replace(/[^A-Za-z0-9\+\/\=]/g, '');
  do {
    enc1 = keyStr.indexOf(input.charAt(i++));
    enc2 = keyStr.indexOf(input.charAt(i++));
    enc3 = keyStr.indexOf(input.charAt(i++));
    enc4 = keyStr.indexOf(input.charAt(i++));

    chr1 = (enc1 << 2) | (enc2 >> 4);
    chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);
    chr3 = ((enc3 & 3) << 6) | enc4;

    output = output + String.fromCharCode(chr1);

    if (enc3 !== 64) {
      output = output + String.fromCharCode(chr2);
    }
    if (enc4 !== 64) {
      output = output + String.fromCharCode(chr3);
    }
  } while (i < input.length);
  return output;
};

// Converts a string of base64 into a byte array.
// Throws error on invalid input.
function intArrayFromBase64(s) {
  if (typeof ENVIRONMENT_IS_NODE === 'boolean' && ENVIRONMENT_IS_NODE) {
    var buf;
    try {
      // TODO: Update Node.js externs, Closure does not recognize the following Buffer.from()
      /**@suppress{checkTypes}*/
      buf = Buffer.from(s, 'base64');
    } catch (_) {
      buf = new Buffer(s, 'base64');
    }
    return new Uint8Array(buf['buffer'], buf['byteOffset'], buf['byteLength']);
  }

  try {
    var decoded = decodeBase64(s);
    var bytes = new Uint8Array(decoded.length);
    for (var i = 0 ; i < decoded.length ; ++i) {
      bytes[i] = decoded.charCodeAt(i);
    }
    return bytes;
  } catch (_) {
    throw new Error('Converting base64 string to bytes failed.');
  }
}

// If filename is a base64 data URI, parses and returns data (Buffer on node,
// Uint8Array otherwise). If filename is not a base64 data URI, returns undefined.
function tryParseAsDataURI(filename) {
  if (!isDataURI(filename)) {
    return;
  }

  return intArrayFromBase64(filename.slice(dataURIPrefix.length));
}


var asmGlobalArg = {};
var asmLibraryArg = { "__cxa_allocate_exception": ___cxa_allocate_exception, "__cxa_throw": ___cxa_throw, "__sys_fstat64": ___sys_fstat64, "__sys_ftruncate64": ___sys_ftruncate64, "__sys_mmap2": ___sys_mmap2, "__sys_munmap": ___sys_munmap, "__sys_open": ___sys_open, "__sys_read": ___sys_read, "__sys_stat64": ___sys_stat64, "_embind_register_bool": __embind_register_bool, "_embind_register_class": __embind_register_class, "_embind_register_class_constructor": __embind_register_class_constructor, "_embind_register_class_function": __embind_register_class_function, "_embind_register_class_property": __embind_register_class_property, "_embind_register_constant": __embind_register_constant, "_embind_register_emval": __embind_register_emval, "_embind_register_float": __embind_register_float, "_embind_register_function": __embind_register_function, "_embind_register_integer": __embind_register_integer, "_embind_register_memory_view": __embind_register_memory_view, "_embind_register_std_string": __embind_register_std_string, "_embind_register_std_wstring": __embind_register_std_wstring, "_embind_register_void": __embind_register_void, "_emval_decref": __emval_decref, "_emval_incref": __emval_incref, "_emval_new_cstring": __emval_new_cstring, "_emval_new_object": __emval_new_object, "_emval_set_property": __emval_set_property, "_emval_take_value": __emval_take_value, "abort": _abort, "emscripten_get_sbrk_ptr": _emscripten_get_sbrk_ptr, "emscripten_memcpy_big": _emscripten_memcpy_big, "emscripten_resize_heap": _emscripten_resize_heap, "exit": _exit, "fd_close": _fd_close, "fd_fdstat_get": _fd_fdstat_get, "fd_seek": _fd_seek, "fd_write": _fd_write, "memory": wasmMemory, "raise": _raise, "setTempRet0": _setTempRet0, "table": wasmTable };
var asm = createWasm();
Module["asm"] = asm;
/** @type {function(...*):?} */
var ___wasm_call_ctors = Module["___wasm_call_ctors"] = function() {
  return (___wasm_call_ctors = Module["___wasm_call_ctors"] = Module["asm"]["__wasm_call_ctors"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var _malloc = Module["_malloc"] = function() {
  return (_malloc = Module["_malloc"] = Module["asm"]["malloc"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var _free = Module["_free"] = function() {
  return (_free = Module["_free"] = Module["asm"]["free"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var _memset = Module["_memset"] = function() {
  return (_memset = Module["_memset"] = Module["asm"]["memset"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var ___errno_location = Module["___errno_location"] = function() {
  return (___errno_location = Module["___errno_location"] = Module["asm"]["__errno_location"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var _setThrew = Module["_setThrew"] = function() {
  return (_setThrew = Module["_setThrew"] = Module["asm"]["setThrew"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var ___getTypeName = Module["___getTypeName"] = function() {
  return (___getTypeName = Module["___getTypeName"] = Module["asm"]["__getTypeName"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var ___embind_register_native_and_builtin_types = Module["___embind_register_native_and_builtin_types"] = function() {
  return (___embind_register_native_and_builtin_types = Module["___embind_register_native_and_builtin_types"] = Module["asm"]["__embind_register_native_and_builtin_types"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var _memalign = Module["_memalign"] = function() {
  return (_memalign = Module["_memalign"] = Module["asm"]["memalign"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var stackSave = Module["stackSave"] = function() {
  return (stackSave = Module["stackSave"] = Module["asm"]["stackSave"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var stackAlloc = Module["stackAlloc"] = function() {
  return (stackAlloc = Module["stackAlloc"] = Module["asm"]["stackAlloc"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var stackRestore = Module["stackRestore"] = function() {
  return (stackRestore = Module["stackRestore"] = Module["asm"]["stackRestore"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var __growWasmMemory = Module["__growWasmMemory"] = function() {
  return (__growWasmMemory = Module["__growWasmMemory"] = Module["asm"]["__growWasmMemory"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var dynCall_ii = Module["dynCall_ii"] = function() {
  return (dynCall_ii = Module["dynCall_ii"] = Module["asm"]["dynCall_ii"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var dynCall_iiii = Module["dynCall_iiii"] = function() {
  return (dynCall_iiii = Module["dynCall_iiii"] = Module["asm"]["dynCall_iiii"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var dynCall_iii = Module["dynCall_iii"] = function() {
  return (dynCall_iii = Module["dynCall_iii"] = Module["asm"]["dynCall_iii"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var dynCall_i = Module["dynCall_i"] = function() {
  return (dynCall_i = Module["dynCall_i"] = Module["asm"]["dynCall_i"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var dynCall_vi = Module["dynCall_vi"] = function() {
  return (dynCall_vi = Module["dynCall_vi"] = Module["asm"]["dynCall_vi"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var dynCall_iiiii = Module["dynCall_iiiii"] = function() {
  return (dynCall_iiiii = Module["dynCall_iiiii"] = Module["asm"]["dynCall_iiiii"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var dynCall_iiiiii = Module["dynCall_iiiiii"] = function() {
  return (dynCall_iiiiii = Module["dynCall_iiiiii"] = Module["asm"]["dynCall_iiiiii"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var dynCall_iiiiiii = Module["dynCall_iiiiiii"] = function() {
  return (dynCall_iiiiiii = Module["dynCall_iiiiiii"] = Module["asm"]["dynCall_iiiiiii"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var dynCall_iij = Module["dynCall_iij"] = function() {
  return (dynCall_iij = Module["dynCall_iij"] = Module["asm"]["dynCall_iij"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var dynCall_iijjiii = Module["dynCall_iijjiii"] = function() {
  return (dynCall_iijjiii = Module["dynCall_iijjiii"] = Module["asm"]["dynCall_iijjiii"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var dynCall_vii = Module["dynCall_vii"] = function() {
  return (dynCall_vii = Module["dynCall_vii"] = Module["asm"]["dynCall_vii"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var dynCall_viii = Module["dynCall_viii"] = function() {
  return (dynCall_viii = Module["dynCall_viii"] = Module["asm"]["dynCall_viii"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var dynCall_viiiiii = Module["dynCall_viiiiii"] = function() {
  return (dynCall_viiiiii = Module["dynCall_viiiiii"] = Module["asm"]["dynCall_viiiiii"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var dynCall_iijj = Module["dynCall_iijj"] = function() {
  return (dynCall_iijj = Module["dynCall_iijj"] = Module["asm"]["dynCall_iijj"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var dynCall_jiji = Module["dynCall_jiji"] = function() {
  return (dynCall_jiji = Module["dynCall_jiji"] = Module["asm"]["dynCall_jiji"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var dynCall_iidiiii = Module["dynCall_iidiiii"] = function() {
  return (dynCall_iidiiii = Module["dynCall_iidiiii"] = Module["asm"]["dynCall_iidiiii"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var dynCall_viiiii = Module["dynCall_viiiii"] = function() {
  return (dynCall_viiiii = Module["dynCall_viiiii"] = Module["asm"]["dynCall_viiiii"]).apply(null, arguments);
};

/** @type {function(...*):?} */
var dynCall_viiii = Module["dynCall_viiii"] = function() {
  return (dynCall_viiii = Module["dynCall_viiii"] = Module["asm"]["dynCall_viiii"]).apply(null, arguments);
};



/**
 * @license
 * Copyright 2010 The Emscripten Authors
 * SPDX-License-Identifier: MIT
 */

// === Auto-generated postamble setup entry stuff ===

Module['asm'] = asm;




























































































Module["FS"] = FS;








































































































































var calledRun;

// Modularize mode returns a function, which can be called to
// create instances. The instances provide a then() method,
// must like a Promise, that receives a callback. The callback
// is called when the module is ready to run, with the module
// as a parameter. (Like a Promise, it also returns the module
// so you can use the output of .then(..)).
Module['then'] = function(func) {
  // We may already be ready to run code at this time. if
  // so, just queue a call to the callback.
  if (calledRun) {
    func(Module);
  } else {
    // we are not ready to call then() yet. we must call it
    // at the same time we would call onRuntimeInitialized.
    var old = Module['onRuntimeInitialized'];
    Module['onRuntimeInitialized'] = function() {
      if (old) old();
      func(Module);
    };
  }
  return Module;
};

/**
 * @constructor
 * @this {ExitStatus}
 */
function ExitStatus(status) {
  this.name = "ExitStatus";
  this.message = "Program terminated with exit(" + status + ")";
  this.status = status;
}

var calledMain = false;


dependenciesFulfilled = function runCaller() {
  // If run has never been called, and we should call run (INVOKE_RUN is true, and Module.noInitialRun is not false)
  if (!calledRun) run();
  if (!calledRun) dependenciesFulfilled = runCaller; // try this again later, after new deps are fulfilled
};





/** @type {function(Array=)} */
function run(args) {
  args = args || arguments_;

  if (runDependencies > 0) {
    return;
  }


  preRun();

  if (runDependencies > 0) return; // a preRun added a dependency, run will be called later

  function doRun() {
    // run may have just been called through dependencies being fulfilled just in this very frame,
    // or while the async setStatus time below was happening
    if (calledRun) return;
    calledRun = true;
    Module['calledRun'] = true;

    if (ABORT) return;

    initRuntime();

    preMain();

    if (Module['onRuntimeInitialized']) Module['onRuntimeInitialized']();


    postRun();
  }

  if (Module['setStatus']) {
    Module['setStatus']('Running...');
    setTimeout(function() {
      setTimeout(function() {
        Module['setStatus']('');
      }, 1);
      doRun();
    }, 1);
  } else
  {
    doRun();
  }
}
Module['run'] = run;


/** @param {boolean|number=} implicit */
function exit(status, implicit) {

  // if this is just main exit-ing implicitly, and the status is 0, then we
  // don't need to do anything here and can just leave. if the status is
  // non-zero, though, then we need to report it.
  // (we may have warned about this earlier, if a situation justifies doing so)
  if (implicit && noExitRuntime && status === 0) {
    return;
  }

  if (noExitRuntime) {
  } else {

    ABORT = true;
    EXITSTATUS = status;

    exitRuntime();

    if (Module['onExit']) Module['onExit'](status);
  }

  quit_(status, new ExitStatus(status));
}

if (Module['preInit']) {
  if (typeof Module['preInit'] == 'function') Module['preInit'] = [Module['preInit']];
  while (Module['preInit'].length > 0) {
    Module['preInit'].pop()();
  }
}


  noExitRuntime = true;

run();





// {{MODULE_ADDITIONS}}



function ___syscall140(which, varargs) {
  SYSCALLS.varargs = varargs;
  try {
    // llseek
    var stream = SYSCALLS.getStreamFromFD(), offset_high = SYSCALLS.get(), offset_low = SYSCALLS.get(), result = SYSCALLS.get(), whence = SYSCALLS.get();
    // NOTE: offset_high is unused - Emscripten's off_t is 32-bit

    // Ugly workaround for seeking >= 2 ** 31 bytes
    //
    // If whence is SEEK_SET, assume the value cannot be negative. This permits
    // SEEK_SET to seek to offsets >= 2 ** 31 and <= 2 ** 32.
    //
    // This workaround does *not* account for cases where offsets used with
    // SEEK_CUR or SEEK_END are >= 2 ** 31. Such cases will produce unexpected
    // behavior.
    var offset = whence === 0 ? offset_low >>> 0 : offset_low;

    FS.llseek(stream, offset, whence);
    HEAP32[((result)>>2)]=stream.position;
    if (stream.getdents && offset === 0 && whence === 0) stream.getdents = null; // reset readdir state
    return 0;
  } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
}



  return StormLib
}
);
})();
if (typeof exports === 'object' && typeof module === 'object')
      module.exports = StormLib;
    else if (typeof define === 'function' && define['amd'])
      define([], function() { return StormLib; });
    else if (typeof exports === 'object')
      exports["StormLib"] = StormLib;
    
}).call(this)}).call(this,require('_process'),require("buffer").Buffer,"/node_modules/@wowserhq/stormjs/dist/stormlib.release.js",arguments[3],arguments[4],arguments[5],arguments[6],"/node_modules/@wowserhq/stormjs/dist")
},{"_process":159,"buffer":72,"crypto":80,"fs":70,"path":152}],9:[function(require,module,exports){
'use strict';

const asn1 = exports;

asn1.bignum = require('bn.js');

asn1.define = require('./asn1/api').define;
asn1.base = require('./asn1/base');
asn1.constants = require('./asn1/constants');
asn1.decoders = require('./asn1/decoders');
asn1.encoders = require('./asn1/encoders');

},{"./asn1/api":10,"./asn1/base":12,"./asn1/constants":16,"./asn1/decoders":18,"./asn1/encoders":21,"bn.js":23}],10:[function(require,module,exports){
'use strict';

const encoders = require('./encoders');
const decoders = require('./decoders');
const inherits = require('inherits');

const api = exports;

api.define = function define(name, body) {
  return new Entity(name, body);
};

function Entity(name, body) {
  this.name = name;
  this.body = body;

  this.decoders = {};
  this.encoders = {};
}

Entity.prototype._createNamed = function createNamed(Base) {
  const name = this.name;

  function Generated(entity) {
    this._initNamed(entity, name);
  }
  inherits(Generated, Base);
  Generated.prototype._initNamed = function _initNamed(entity, name) {
    Base.call(this, entity, name);
  };

  return new Generated(this);
};

Entity.prototype._getDecoder = function _getDecoder(enc) {
  enc = enc || 'der';
  // Lazily create decoder
  if (!this.decoders.hasOwnProperty(enc))
    this.decoders[enc] = this._createNamed(decoders[enc]);
  return this.decoders[enc];
};

Entity.prototype.decode = function decode(data, enc, options) {
  return this._getDecoder(enc).decode(data, options);
};

Entity.prototype._getEncoder = function _getEncoder(enc) {
  enc = enc || 'der';
  // Lazily create encoder
  if (!this.encoders.hasOwnProperty(enc))
    this.encoders[enc] = this._createNamed(encoders[enc]);
  return this.encoders[enc];
};

Entity.prototype.encode = function encode(data, enc, /* internal */ reporter) {
  return this._getEncoder(enc).encode(data, reporter);
};

},{"./decoders":18,"./encoders":21,"inherits":141}],11:[function(require,module,exports){
'use strict';

const inherits = require('inherits');
const Reporter = require('../base/reporter').Reporter;
const Buffer = require('safer-buffer').Buffer;

function DecoderBuffer(base, options) {
  Reporter.call(this, options);
  if (!Buffer.isBuffer(base)) {
    this.error('Input not Buffer');
    return;
  }

  this.base = base;
  this.offset = 0;
  this.length = base.length;
}
inherits(DecoderBuffer, Reporter);
exports.DecoderBuffer = DecoderBuffer;

DecoderBuffer.isDecoderBuffer = function isDecoderBuffer(data) {
  if (data instanceof DecoderBuffer) {
    return true;
  }

  // Or accept compatible API
  const isCompatible = typeof data === 'object' &&
    Buffer.isBuffer(data.base) &&
    data.constructor.name === 'DecoderBuffer' &&
    typeof data.offset === 'number' &&
    typeof data.length === 'number' &&
    typeof data.save === 'function' &&
    typeof data.restore === 'function' &&
    typeof data.isEmpty === 'function' &&
    typeof data.readUInt8 === 'function' &&
    typeof data.skip === 'function' &&
    typeof data.raw === 'function';

  return isCompatible;
};

DecoderBuffer.prototype.save = function save() {
  return { offset: this.offset, reporter: Reporter.prototype.save.call(this) };
};

DecoderBuffer.prototype.restore = function restore(save) {
  // Return skipped data
  const res = new DecoderBuffer(this.base);
  res.offset = save.offset;
  res.length = this.offset;

  this.offset = save.offset;
  Reporter.prototype.restore.call(this, save.reporter);

  return res;
};

DecoderBuffer.prototype.isEmpty = function isEmpty() {
  return this.offset === this.length;
};

DecoderBuffer.prototype.readUInt8 = function readUInt8(fail) {
  if (this.offset + 1 <= this.length)
    return this.base.readUInt8(this.offset++, true);
  else
    return this.error(fail || 'DecoderBuffer overrun');
};

DecoderBuffer.prototype.skip = function skip(bytes, fail) {
  if (!(this.offset + bytes <= this.length))
    return this.error(fail || 'DecoderBuffer overrun');

  const res = new DecoderBuffer(this.base);

  // Share reporter state
  res._reporterState = this._reporterState;

  res.offset = this.offset;
  res.length = this.offset + bytes;
  this.offset += bytes;
  return res;
};

DecoderBuffer.prototype.raw = function raw(save) {
  return this.base.slice(save ? save.offset : this.offset, this.length);
};

function EncoderBuffer(value, reporter) {
  if (Array.isArray(value)) {
    this.length = 0;
    this.value = value.map(function(item) {
      if (!EncoderBuffer.isEncoderBuffer(item))
        item = new EncoderBuffer(item, reporter);
      this.length += item.length;
      return item;
    }, this);
  } else if (typeof value === 'number') {
    if (!(0 <= value && value <= 0xff))
      return reporter.error('non-byte EncoderBuffer value');
    this.value = value;
    this.length = 1;
  } else if (typeof value === 'string') {
    this.value = value;
    this.length = Buffer.byteLength(value);
  } else if (Buffer.isBuffer(value)) {
    this.value = value;
    this.length = value.length;
  } else {
    return reporter.error('Unsupported type: ' + typeof value);
  }
}
exports.EncoderBuffer = EncoderBuffer;

EncoderBuffer.isEncoderBuffer = function isEncoderBuffer(data) {
  if (data instanceof EncoderBuffer) {
    return true;
  }

  // Or accept compatible API
  const isCompatible = typeof data === 'object' &&
    data.constructor.name === 'EncoderBuffer' &&
    typeof data.length === 'number' &&
    typeof data.join === 'function';

  return isCompatible;
};

EncoderBuffer.prototype.join = function join(out, offset) {
  if (!out)
    out = Buffer.alloc(this.length);
  if (!offset)
    offset = 0;

  if (this.length === 0)
    return out;

  if (Array.isArray(this.value)) {
    this.value.forEach(function(item) {
      item.join(out, offset);
      offset += item.length;
    });
  } else {
    if (typeof this.value === 'number')
      out[offset] = this.value;
    else if (typeof this.value === 'string')
      out.write(this.value, offset);
    else if (Buffer.isBuffer(this.value))
      this.value.copy(out, offset);
    offset += this.length;
  }

  return out;
};

},{"../base/reporter":14,"inherits":141,"safer-buffer":171}],12:[function(require,module,exports){
'use strict';

const base = exports;

base.Reporter = require('./reporter').Reporter;
base.DecoderBuffer = require('./buffer').DecoderBuffer;
base.EncoderBuffer = require('./buffer').EncoderBuffer;
base.Node = require('./node');

},{"./buffer":11,"./node":13,"./reporter":14}],13:[function(require,module,exports){
'use strict';

const Reporter = require('../base/reporter').Reporter;
const EncoderBuffer = require('../base/buffer').EncoderBuffer;
const DecoderBuffer = require('../base/buffer').DecoderBuffer;
const assert = require('minimalistic-assert');

// Supported tags
const tags = [
  'seq', 'seqof', 'set', 'setof', 'objid', 'bool',
  'gentime', 'utctime', 'null_', 'enum', 'int', 'objDesc',
  'bitstr', 'bmpstr', 'charstr', 'genstr', 'graphstr', 'ia5str', 'iso646str',
  'numstr', 'octstr', 'printstr', 't61str', 'unistr', 'utf8str', 'videostr'
];

// Public methods list
const methods = [
  'key', 'obj', 'use', 'optional', 'explicit', 'implicit', 'def', 'choice',
  'any', 'contains'
].concat(tags);

// Overrided methods list
const overrided = [
  '_peekTag', '_decodeTag', '_use',
  '_decodeStr', '_decodeObjid', '_decodeTime',
  '_decodeNull', '_decodeInt', '_decodeBool', '_decodeList',

  '_encodeComposite', '_encodeStr', '_encodeObjid', '_encodeTime',
  '_encodeNull', '_encodeInt', '_encodeBool'
];

function Node(enc, parent, name) {
  const state = {};
  this._baseState = state;

  state.name = name;
  state.enc = enc;

  state.parent = parent || null;
  state.children = null;

  // State
  state.tag = null;
  state.args = null;
  state.reverseArgs = null;
  state.choice = null;
  state.optional = false;
  state.any = false;
  state.obj = false;
  state.use = null;
  state.useDecoder = null;
  state.key = null;
  state['default'] = null;
  state.explicit = null;
  state.implicit = null;
  state.contains = null;

  // Should create new instance on each method
  if (!state.parent) {
    state.children = [];
    this._wrap();
  }
}
module.exports = Node;

const stateProps = [
  'enc', 'parent', 'children', 'tag', 'args', 'reverseArgs', 'choice',
  'optional', 'any', 'obj', 'use', 'alteredUse', 'key', 'default', 'explicit',
  'implicit', 'contains'
];

Node.prototype.clone = function clone() {
  const state = this._baseState;
  const cstate = {};
  stateProps.forEach(function(prop) {
    cstate[prop] = state[prop];
  });
  const res = new this.constructor(cstate.parent);
  res._baseState = cstate;
  return res;
};

Node.prototype._wrap = function wrap() {
  const state = this._baseState;
  methods.forEach(function(method) {
    this[method] = function _wrappedMethod() {
      const clone = new this.constructor(this);
      state.children.push(clone);
      return clone[method].apply(clone, arguments);
    };
  }, this);
};

Node.prototype._init = function init(body) {
  const state = this._baseState;

  assert(state.parent === null);
  body.call(this);

  // Filter children
  state.children = state.children.filter(function(child) {
    return child._baseState.parent === this;
  }, this);
  assert.equal(state.children.length, 1, 'Root node can have only one child');
};

Node.prototype._useArgs = function useArgs(args) {
  const state = this._baseState;

  // Filter children and args
  const children = args.filter(function(arg) {
    return arg instanceof this.constructor;
  }, this);
  args = args.filter(function(arg) {
    return !(arg instanceof this.constructor);
  }, this);

  if (children.length !== 0) {
    assert(state.children === null);
    state.children = children;

    // Replace parent to maintain backward link
    children.forEach(function(child) {
      child._baseState.parent = this;
    }, this);
  }
  if (args.length !== 0) {
    assert(state.args === null);
    state.args = args;
    state.reverseArgs = args.map(function(arg) {
      if (typeof arg !== 'object' || arg.constructor !== Object)
        return arg;

      const res = {};
      Object.keys(arg).forEach(function(key) {
        if (key == (key | 0))
          key |= 0;
        const value = arg[key];
        res[value] = key;
      });
      return res;
    });
  }
};

//
// Overrided methods
//

overrided.forEach(function(method) {
  Node.prototype[method] = function _overrided() {
    const state = this._baseState;
    throw new Error(method + ' not implemented for encoding: ' + state.enc);
  };
});

//
// Public methods
//

tags.forEach(function(tag) {
  Node.prototype[tag] = function _tagMethod() {
    const state = this._baseState;
    const args = Array.prototype.slice.call(arguments);

    assert(state.tag === null);
    state.tag = tag;

    this._useArgs(args);

    return this;
  };
});

Node.prototype.use = function use(item) {
  assert(item);
  const state = this._baseState;

  assert(state.use === null);
  state.use = item;

  return this;
};

Node.prototype.optional = function optional() {
  const state = this._baseState;

  state.optional = true;

  return this;
};

Node.prototype.def = function def(val) {
  const state = this._baseState;

  assert(state['default'] === null);
  state['default'] = val;
  state.optional = true;

  return this;
};

Node.prototype.explicit = function explicit(num) {
  const state = this._baseState;

  assert(state.explicit === null && state.implicit === null);
  state.explicit = num;

  return this;
};

Node.prototype.implicit = function implicit(num) {
  const state = this._baseState;

  assert(state.explicit === null && state.implicit === null);
  state.implicit = num;

  return this;
};

Node.prototype.obj = function obj() {
  const state = this._baseState;
  const args = Array.prototype.slice.call(arguments);

  state.obj = true;

  if (args.length !== 0)
    this._useArgs(args);

  return this;
};

Node.prototype.key = function key(newKey) {
  const state = this._baseState;

  assert(state.key === null);
  state.key = newKey;

  return this;
};

Node.prototype.any = function any() {
  const state = this._baseState;

  state.any = true;

  return this;
};

Node.prototype.choice = function choice(obj) {
  const state = this._baseState;

  assert(state.choice === null);
  state.choice = obj;
  this._useArgs(Object.keys(obj).map(function(key) {
    return obj[key];
  }));

  return this;
};

Node.prototype.contains = function contains(item) {
  const state = this._baseState;

  assert(state.use === null);
  state.contains = item;

  return this;
};

//
// Decoding
//

Node.prototype._decode = function decode(input, options) {
  const state = this._baseState;

  // Decode root node
  if (state.parent === null)
    return input.wrapResult(state.children[0]._decode(input, options));

  let result = state['default'];
  let present = true;

  let prevKey = null;
  if (state.key !== null)
    prevKey = input.enterKey(state.key);

  // Check if tag is there
  if (state.optional) {
    let tag = null;
    if (state.explicit !== null)
      tag = state.explicit;
    else if (state.implicit !== null)
      tag = state.implicit;
    else if (state.tag !== null)
      tag = state.tag;

    if (tag === null && !state.any) {
      // Trial and Error
      const save = input.save();
      try {
        if (state.choice === null)
          this._decodeGeneric(state.tag, input, options);
        else
          this._decodeChoice(input, options);
        present = true;
      } catch (e) {
        present = false;
      }
      input.restore(save);
    } else {
      present = this._peekTag(input, tag, state.any);

      if (input.isError(present))
        return present;
    }
  }

  // Push object on stack
  let prevObj;
  if (state.obj && present)
    prevObj = input.enterObject();

  if (present) {
    // Unwrap explicit values
    if (state.explicit !== null) {
      const explicit = this._decodeTag(input, state.explicit);
      if (input.isError(explicit))
        return explicit;
      input = explicit;
    }

    const start = input.offset;

    // Unwrap implicit and normal values
    if (state.use === null && state.choice === null) {
      let save;
      if (state.any)
        save = input.save();
      const body = this._decodeTag(
        input,
        state.implicit !== null ? state.implicit : state.tag,
        state.any
      );
      if (input.isError(body))
        return body;

      if (state.any)
        result = input.raw(save);
      else
        input = body;
    }

    if (options && options.track && state.tag !== null)
      options.track(input.path(), start, input.length, 'tagged');

    if (options && options.track && state.tag !== null)
      options.track(input.path(), input.offset, input.length, 'content');

    // Select proper method for tag
    if (state.any) {
      // no-op
    } else if (state.choice === null) {
      result = this._decodeGeneric(state.tag, input, options);
    } else {
      result = this._decodeChoice(input, options);
    }

    if (input.isError(result))
      return result;

    // Decode children
    if (!state.any && state.choice === null && state.children !== null) {
      state.children.forEach(function decodeChildren(child) {
        // NOTE: We are ignoring errors here, to let parser continue with other
        // parts of encoded data
        child._decode(input, options);
      });
    }

    // Decode contained/encoded by schema, only in bit or octet strings
    if (state.contains && (state.tag === 'octstr' || state.tag === 'bitstr')) {
      const data = new DecoderBuffer(result);
      result = this._getUse(state.contains, input._reporterState.obj)
        ._decode(data, options);
    }
  }

  // Pop object
  if (state.obj && present)
    result = input.leaveObject(prevObj);

  // Set key
  if (state.key !== null && (result !== null || present === true))
    input.leaveKey(prevKey, state.key, result);
  else if (prevKey !== null)
    input.exitKey(prevKey);

  return result;
};

Node.prototype._decodeGeneric = function decodeGeneric(tag, input, options) {
  const state = this._baseState;

  if (tag === 'seq' || tag === 'set')
    return null;
  if (tag === 'seqof' || tag === 'setof')
    return this._decodeList(input, tag, state.args[0], options);
  else if (/str$/.test(tag))
    return this._decodeStr(input, tag, options);
  else if (tag === 'objid' && state.args)
    return this._decodeObjid(input, state.args[0], state.args[1], options);
  else if (tag === 'objid')
    return this._decodeObjid(input, null, null, options);
  else if (tag === 'gentime' || tag === 'utctime')
    return this._decodeTime(input, tag, options);
  else if (tag === 'null_')
    return this._decodeNull(input, options);
  else if (tag === 'bool')
    return this._decodeBool(input, options);
  else if (tag === 'objDesc')
    return this._decodeStr(input, tag, options);
  else if (tag === 'int' || tag === 'enum')
    return this._decodeInt(input, state.args && state.args[0], options);

  if (state.use !== null) {
    return this._getUse(state.use, input._reporterState.obj)
      ._decode(input, options);
  } else {
    return input.error('unknown tag: ' + tag);
  }
};

Node.prototype._getUse = function _getUse(entity, obj) {

  const state = this._baseState;
  // Create altered use decoder if implicit is set
  state.useDecoder = this._use(entity, obj);
  assert(state.useDecoder._baseState.parent === null);
  state.useDecoder = state.useDecoder._baseState.children[0];
  if (state.implicit !== state.useDecoder._baseState.implicit) {
    state.useDecoder = state.useDecoder.clone();
    state.useDecoder._baseState.implicit = state.implicit;
  }
  return state.useDecoder;
};

Node.prototype._decodeChoice = function decodeChoice(input, options) {
  const state = this._baseState;
  let result = null;
  let match = false;

  Object.keys(state.choice).some(function(key) {
    const save = input.save();
    const node = state.choice[key];
    try {
      const value = node._decode(input, options);
      if (input.isError(value))
        return false;

      result = { type: key, value: value };
      match = true;
    } catch (e) {
      input.restore(save);
      return false;
    }
    return true;
  }, this);

  if (!match)
    return input.error('Choice not matched');

  return result;
};

//
// Encoding
//

Node.prototype._createEncoderBuffer = function createEncoderBuffer(data) {
  return new EncoderBuffer(data, this.reporter);
};

Node.prototype._encode = function encode(data, reporter, parent) {
  const state = this._baseState;
  if (state['default'] !== null && state['default'] === data)
    return;

  const result = this._encodeValue(data, reporter, parent);
  if (result === undefined)
    return;

  if (this._skipDefault(result, reporter, parent))
    return;

  return result;
};

Node.prototype._encodeValue = function encode(data, reporter, parent) {
  const state = this._baseState;

  // Decode root node
  if (state.parent === null)
    return state.children[0]._encode(data, reporter || new Reporter());

  let result = null;

  // Set reporter to share it with a child class
  this.reporter = reporter;

  // Check if data is there
  if (state.optional && data === undefined) {
    if (state['default'] !== null)
      data = state['default'];
    else
      return;
  }

  // Encode children first
  let content = null;
  let primitive = false;
  if (state.any) {
    // Anything that was given is translated to buffer
    result = this._createEncoderBuffer(data);
  } else if (state.choice) {
    result = this._encodeChoice(data, reporter);
  } else if (state.contains) {
    content = this._getUse(state.contains, parent)._encode(data, reporter);
    primitive = true;
  } else if (state.children) {
    content = state.children.map(function(child) {
      if (child._baseState.tag === 'null_')
        return child._encode(null, reporter, data);

      if (child._baseState.key === null)
        return reporter.error('Child should have a key');
      const prevKey = reporter.enterKey(child._baseState.key);

      if (typeof data !== 'object')
        return reporter.error('Child expected, but input is not object');

      const res = child._encode(data[child._baseState.key], reporter, data);
      reporter.leaveKey(prevKey);

      return res;
    }, this).filter(function(child) {
      return child;
    });
    content = this._createEncoderBuffer(content);
  } else {
    if (state.tag === 'seqof' || state.tag === 'setof') {
      // TODO(indutny): this should be thrown on DSL level
      if (!(state.args && state.args.length === 1))
        return reporter.error('Too many args for : ' + state.tag);

      if (!Array.isArray(data))
        return reporter.error('seqof/setof, but data is not Array');

      const child = this.clone();
      child._baseState.implicit = null;
      content = this._createEncoderBuffer(data.map(function(item) {
        const state = this._baseState;

        return this._getUse(state.args[0], data)._encode(item, reporter);
      }, child));
    } else if (state.use !== null) {
      result = this._getUse(state.use, parent)._encode(data, reporter);
    } else {
      content = this._encodePrimitive(state.tag, data);
      primitive = true;
    }
  }

  // Encode data itself
  if (!state.any && state.choice === null) {
    const tag = state.implicit !== null ? state.implicit : state.tag;
    const cls = state.implicit === null ? 'universal' : 'context';

    if (tag === null) {
      if (state.use === null)
        reporter.error('Tag could be omitted only for .use()');
    } else {
      if (state.use === null)
        result = this._encodeComposite(tag, primitive, cls, content);
    }
  }

  // Wrap in explicit
  if (state.explicit !== null)
    result = this._encodeComposite(state.explicit, false, 'context', result);

  return result;
};

Node.prototype._encodeChoice = function encodeChoice(data, reporter) {
  const state = this._baseState;

  const node = state.choice[data.type];
  if (!node) {
    assert(
      false,
      data.type + ' not found in ' +
            JSON.stringify(Object.keys(state.choice)));
  }
  return node._encode(data.value, reporter);
};

Node.prototype._encodePrimitive = function encodePrimitive(tag, data) {
  const state = this._baseState;

  if (/str$/.test(tag))
    return this._encodeStr(data, tag);
  else if (tag === 'objid' && state.args)
    return this._encodeObjid(data, state.reverseArgs[0], state.args[1]);
  else if (tag === 'objid')
    return this._encodeObjid(data, null, null);
  else if (tag === 'gentime' || tag === 'utctime')
    return this._encodeTime(data, tag);
  else if (tag === 'null_')
    return this._encodeNull();
  else if (tag === 'int' || tag === 'enum')
    return this._encodeInt(data, state.args && state.reverseArgs[0]);
  else if (tag === 'bool')
    return this._encodeBool(data);
  else if (tag === 'objDesc')
    return this._encodeStr(data, tag);
  else
    throw new Error('Unsupported tag: ' + tag);
};

Node.prototype._isNumstr = function isNumstr(str) {
  return /^[0-9 ]*$/.test(str);
};

Node.prototype._isPrintstr = function isPrintstr(str) {
  return /^[A-Za-z0-9 '()+,-./:=?]*$/.test(str);
};

},{"../base/buffer":11,"../base/reporter":14,"minimalistic-assert":145}],14:[function(require,module,exports){
'use strict';

const inherits = require('inherits');

function Reporter(options) {
  this._reporterState = {
    obj: null,
    path: [],
    options: options || {},
    errors: []
  };
}
exports.Reporter = Reporter;

Reporter.prototype.isError = function isError(obj) {
  return obj instanceof ReporterError;
};

Reporter.prototype.save = function save() {
  const state = this._reporterState;

  return { obj: state.obj, pathLen: state.path.length };
};

Reporter.prototype.restore = function restore(data) {
  const state = this._reporterState;

  state.obj = data.obj;
  state.path = state.path.slice(0, data.pathLen);
};

Reporter.prototype.enterKey = function enterKey(key) {
  return this._reporterState.path.push(key);
};

Reporter.prototype.exitKey = function exitKey(index) {
  const state = this._reporterState;

  state.path = state.path.slice(0, index - 1);
};

Reporter.prototype.leaveKey = function leaveKey(index, key, value) {
  const state = this._reporterState;

  this.exitKey(index);
  if (state.obj !== null)
    state.obj[key] = value;
};

Reporter.prototype.path = function path() {
  return this._reporterState.path.join('/');
};

Reporter.prototype.enterObject = function enterObject() {
  const state = this._reporterState;

  const prev = state.obj;
  state.obj = {};
  return prev;
};

Reporter.prototype.leaveObject = function leaveObject(prev) {
  const state = this._reporterState;

  const now = state.obj;
  state.obj = prev;
  return now;
};

Reporter.prototype.error = function error(msg) {
  let err;
  const state = this._reporterState;

  const inherited = msg instanceof ReporterError;
  if (inherited) {
    err = msg;
  } else {
    err = new ReporterError(state.path.map(function(elem) {
      return '[' + JSON.stringify(elem) + ']';
    }).join(''), msg.message || msg, msg.stack);
  }

  if (!state.options.partial)
    throw err;

  if (!inherited)
    state.errors.push(err);

  return err;
};

Reporter.prototype.wrapResult = function wrapResult(result) {
  const state = this._reporterState;
  if (!state.options.partial)
    return result;

  return {
    result: this.isError(result) ? null : result,
    errors: state.errors
  };
};

function ReporterError(path, msg) {
  this.path = path;
  this.rethrow(msg);
}
inherits(ReporterError, Error);

ReporterError.prototype.rethrow = function rethrow(msg) {
  this.message = msg + ' at: ' + (this.path || '(shallow)');
  if (Error.captureStackTrace)
    Error.captureStackTrace(this, ReporterError);

  if (!this.stack) {
    try {
      // IE only adds stack when thrown
      throw new Error(this.message);
    } catch (e) {
      this.stack = e.stack;
    }
  }
  return this;
};

},{"inherits":141}],15:[function(require,module,exports){
'use strict';

// Helper
function reverse(map) {
  const res = {};

  Object.keys(map).forEach(function(key) {
    // Convert key to integer if it is stringified
    if ((key | 0) == key)
      key = key | 0;

    const value = map[key];
    res[value] = key;
  });

  return res;
}

exports.tagClass = {
  0: 'universal',
  1: 'application',
  2: 'context',
  3: 'private'
};
exports.tagClassByName = reverse(exports.tagClass);

exports.tag = {
  0x00: 'end',
  0x01: 'bool',
  0x02: 'int',
  0x03: 'bitstr',
  0x04: 'octstr',
  0x05: 'null_',
  0x06: 'objid',
  0x07: 'objDesc',
  0x08: 'external',
  0x09: 'real',
  0x0a: 'enum',
  0x0b: 'embed',
  0x0c: 'utf8str',
  0x0d: 'relativeOid',
  0x10: 'seq',
  0x11: 'set',
  0x12: 'numstr',
  0x13: 'printstr',
  0x14: 't61str',
  0x15: 'videostr',
  0x16: 'ia5str',
  0x17: 'utctime',
  0x18: 'gentime',
  0x19: 'graphstr',
  0x1a: 'iso646str',
  0x1b: 'genstr',
  0x1c: 'unistr',
  0x1d: 'charstr',
  0x1e: 'bmpstr'
};
exports.tagByName = reverse(exports.tag);

},{}],16:[function(require,module,exports){
'use strict';

const constants = exports;

// Helper
constants._reverse = function reverse(map) {
  const res = {};

  Object.keys(map).forEach(function(key) {
    // Convert key to integer if it is stringified
    if ((key | 0) == key)
      key = key | 0;

    const value = map[key];
    res[value] = key;
  });

  return res;
};

constants.der = require('./der');

},{"./der":15}],17:[function(require,module,exports){
'use strict';

const inherits = require('inherits');

const bignum = require('bn.js');
const DecoderBuffer = require('../base/buffer').DecoderBuffer;
const Node = require('../base/node');

// Import DER constants
const der = require('../constants/der');

function DERDecoder(entity) {
  this.enc = 'der';
  this.name = entity.name;
  this.entity = entity;

  // Construct base tree
  this.tree = new DERNode();
  this.tree._init(entity.body);
}
module.exports = DERDecoder;

DERDecoder.prototype.decode = function decode(data, options) {
  if (!DecoderBuffer.isDecoderBuffer(data)) {
    data = new DecoderBuffer(data, options);
  }

  return this.tree._decode(data, options);
};

// Tree methods

function DERNode(parent) {
  Node.call(this, 'der', parent);
}
inherits(DERNode, Node);

DERNode.prototype._peekTag = function peekTag(buffer, tag, any) {
  if (buffer.isEmpty())
    return false;

  const state = buffer.save();
  const decodedTag = derDecodeTag(buffer, 'Failed to peek tag: "' + tag + '"');
  if (buffer.isError(decodedTag))
    return decodedTag;

  buffer.restore(state);

  return decodedTag.tag === tag || decodedTag.tagStr === tag ||
    (decodedTag.tagStr + 'of') === tag || any;
};

DERNode.prototype._decodeTag = function decodeTag(buffer, tag, any) {
  const decodedTag = derDecodeTag(buffer,
    'Failed to decode tag of "' + tag + '"');
  if (buffer.isError(decodedTag))
    return decodedTag;

  let len = derDecodeLen(buffer,
    decodedTag.primitive,
    'Failed to get length of "' + tag + '"');

  // Failure
  if (buffer.isError(len))
    return len;

  if (!any &&
      decodedTag.tag !== tag &&
      decodedTag.tagStr !== tag &&
      decodedTag.tagStr + 'of' !== tag) {
    return buffer.error('Failed to match tag: "' + tag + '"');
  }

  if (decodedTag.primitive || len !== null)
    return buffer.skip(len, 'Failed to match body of: "' + tag + '"');

  // Indefinite length... find END tag
  const state = buffer.save();
  const res = this._skipUntilEnd(
    buffer,
    'Failed to skip indefinite length body: "' + this.tag + '"');
  if (buffer.isError(res))
    return res;

  len = buffer.offset - state.offset;
  buffer.restore(state);
  return buffer.skip(len, 'Failed to match body of: "' + tag + '"');
};

DERNode.prototype._skipUntilEnd = function skipUntilEnd(buffer, fail) {
  for (;;) {
    const tag = derDecodeTag(buffer, fail);
    if (buffer.isError(tag))
      return tag;
    const len = derDecodeLen(buffer, tag.primitive, fail);
    if (buffer.isError(len))
      return len;

    let res;
    if (tag.primitive || len !== null)
      res = buffer.skip(len);
    else
      res = this._skipUntilEnd(buffer, fail);

    // Failure
    if (buffer.isError(res))
      return res;

    if (tag.tagStr === 'end')
      break;
  }
};

DERNode.prototype._decodeList = function decodeList(buffer, tag, decoder,
  options) {
  const result = [];
  while (!buffer.isEmpty()) {
    const possibleEnd = this._peekTag(buffer, 'end');
    if (buffer.isError(possibleEnd))
      return possibleEnd;

    const res = decoder.decode(buffer, 'der', options);
    if (buffer.isError(res) && possibleEnd)
      break;
    result.push(res);
  }
  return result;
};

DERNode.prototype._decodeStr = function decodeStr(buffer, tag) {
  if (tag === 'bitstr') {
    const unused = buffer.readUInt8();
    if (buffer.isError(unused))
      return unused;
    return { unused: unused, data: buffer.raw() };
  } else if (tag === 'bmpstr') {
    const raw = buffer.raw();
    if (raw.length % 2 === 1)
      return buffer.error('Decoding of string type: bmpstr length mismatch');

    let str = '';
    for (let i = 0; i < raw.length / 2; i++) {
      str += String.fromCharCode(raw.readUInt16BE(i * 2));
    }
    return str;
  } else if (tag === 'numstr') {
    const numstr = buffer.raw().toString('ascii');
    if (!this._isNumstr(numstr)) {
      return buffer.error('Decoding of string type: ' +
                          'numstr unsupported characters');
    }
    return numstr;
  } else if (tag === 'octstr') {
    return buffer.raw();
  } else if (tag === 'objDesc') {
    return buffer.raw();
  } else if (tag === 'printstr') {
    const printstr = buffer.raw().toString('ascii');
    if (!this._isPrintstr(printstr)) {
      return buffer.error('Decoding of string type: ' +
                          'printstr unsupported characters');
    }
    return printstr;
  } else if (/str$/.test(tag)) {
    return buffer.raw().toString();
  } else {
    return buffer.error('Decoding of string type: ' + tag + ' unsupported');
  }
};

DERNode.prototype._decodeObjid = function decodeObjid(buffer, values, relative) {
  let result;
  const identifiers = [];
  let ident = 0;
  let subident = 0;
  while (!buffer.isEmpty()) {
    subident = buffer.readUInt8();
    ident <<= 7;
    ident |= subident & 0x7f;
    if ((subident & 0x80) === 0) {
      identifiers.push(ident);
      ident = 0;
    }
  }
  if (subident & 0x80)
    identifiers.push(ident);

  const first = (identifiers[0] / 40) | 0;
  const second = identifiers[0] % 40;

  if (relative)
    result = identifiers;
  else
    result = [first, second].concat(identifiers.slice(1));

  if (values) {
    let tmp = values[result.join(' ')];
    if (tmp === undefined)
      tmp = values[result.join('.')];
    if (tmp !== undefined)
      result = tmp;
  }

  return result;
};

DERNode.prototype._decodeTime = function decodeTime(buffer, tag) {
  const str = buffer.raw().toString();

  let year;
  let mon;
  let day;
  let hour;
  let min;
  let sec;
  if (tag === 'gentime') {
    year = str.slice(0, 4) | 0;
    mon = str.slice(4, 6) | 0;
    day = str.slice(6, 8) | 0;
    hour = str.slice(8, 10) | 0;
    min = str.slice(10, 12) | 0;
    sec = str.slice(12, 14) | 0;
  } else if (tag === 'utctime') {
    year = str.slice(0, 2) | 0;
    mon = str.slice(2, 4) | 0;
    day = str.slice(4, 6) | 0;
    hour = str.slice(6, 8) | 0;
    min = str.slice(8, 10) | 0;
    sec = str.slice(10, 12) | 0;
    if (year < 70)
      year = 2000 + year;
    else
      year = 1900 + year;
  } else {
    return buffer.error('Decoding ' + tag + ' time is not supported yet');
  }

  return Date.UTC(year, mon - 1, day, hour, min, sec, 0);
};

DERNode.prototype._decodeNull = function decodeNull() {
  return null;
};

DERNode.prototype._decodeBool = function decodeBool(buffer) {
  const res = buffer.readUInt8();
  if (buffer.isError(res))
    return res;
  else
    return res !== 0;
};

DERNode.prototype._decodeInt = function decodeInt(buffer, values) {
  // Bigint, return as it is (assume big endian)
  const raw = buffer.raw();
  let res = new bignum(raw);

  if (values)
    res = values[res.toString(10)] || res;

  return res;
};

DERNode.prototype._use = function use(entity, obj) {
  if (typeof entity === 'function')
    entity = entity(obj);
  return entity._getDecoder('der').tree;
};

// Utility methods

function derDecodeTag(buf, fail) {
  let tag = buf.readUInt8(fail);
  if (buf.isError(tag))
    return tag;

  const cls = der.tagClass[tag >> 6];
  const primitive = (tag & 0x20) === 0;

  // Multi-octet tag - load
  if ((tag & 0x1f) === 0x1f) {
    let oct = tag;
    tag = 0;
    while ((oct & 0x80) === 0x80) {
      oct = buf.readUInt8(fail);
      if (buf.isError(oct))
        return oct;

      tag <<= 7;
      tag |= oct & 0x7f;
    }
  } else {
    tag &= 0x1f;
  }
  const tagStr = der.tag[tag];

  return {
    cls: cls,
    primitive: primitive,
    tag: tag,
    tagStr: tagStr
  };
}

function derDecodeLen(buf, primitive, fail) {
  let len = buf.readUInt8(fail);
  if (buf.isError(len))
    return len;

  // Indefinite form
  if (!primitive && len === 0x80)
    return null;

  // Definite form
  if ((len & 0x80) === 0) {
    // Short form
    return len;
  }

  // Long form
  const num = len & 0x7f;
  if (num > 4)
    return buf.error('length octect is too long');

  len = 0;
  for (let i = 0; i < num; i++) {
    len <<= 8;
    const j = buf.readUInt8(fail);
    if (buf.isError(j))
      return j;
    len |= j;
  }

  return len;
}

},{"../base/buffer":11,"../base/node":13,"../constants/der":15,"bn.js":23,"inherits":141}],18:[function(require,module,exports){
'use strict';

const decoders = exports;

decoders.der = require('./der');
decoders.pem = require('./pem');

},{"./der":17,"./pem":19}],19:[function(require,module,exports){
'use strict';

const inherits = require('inherits');
const Buffer = require('safer-buffer').Buffer;

const DERDecoder = require('./der');

function PEMDecoder(entity) {
  DERDecoder.call(this, entity);
  this.enc = 'pem';
}
inherits(PEMDecoder, DERDecoder);
module.exports = PEMDecoder;

PEMDecoder.prototype.decode = function decode(data, options) {
  const lines = data.toString().split(/[\r\n]+/g);

  const label = options.label.toUpperCase();

  const re = /^-----(BEGIN|END) ([^-]+)-----$/;
  let start = -1;
  let end = -1;
  for (let i = 0; i < lines.length; i++) {
    const match = lines[i].match(re);
    if (match === null)
      continue;

    if (match[2] !== label)
      continue;

    if (start === -1) {
      if (match[1] !== 'BEGIN')
        break;
      start = i;
    } else {
      if (match[1] !== 'END')
        break;
      end = i;
      break;
    }
  }
  if (start === -1 || end === -1)
    throw new Error('PEM section not found for: ' + label);

  const base64 = lines.slice(start + 1, end).join('');
  // Remove excessive symbols
  base64.replace(/[^a-z0-9+/=]+/gi, '');

  const input = Buffer.from(base64, 'base64');
  return DERDecoder.prototype.decode.call(this, input, options);
};

},{"./der":17,"inherits":141,"safer-buffer":171}],20:[function(require,module,exports){
'use strict';

const inherits = require('inherits');
const Buffer = require('safer-buffer').Buffer;
const Node = require('../base/node');

// Import DER constants
const der = require('../constants/der');

function DEREncoder(entity) {
  this.enc = 'der';
  this.name = entity.name;
  this.entity = entity;

  // Construct base tree
  this.tree = new DERNode();
  this.tree._init(entity.body);
}
module.exports = DEREncoder;

DEREncoder.prototype.encode = function encode(data, reporter) {
  return this.tree._encode(data, reporter).join();
};

// Tree methods

function DERNode(parent) {
  Node.call(this, 'der', parent);
}
inherits(DERNode, Node);

DERNode.prototype._encodeComposite = function encodeComposite(tag,
  primitive,
  cls,
  content) {
  const encodedTag = encodeTag(tag, primitive, cls, this.reporter);

  // Short form
  if (content.length < 0x80) {
    const header = Buffer.alloc(2);
    header[0] = encodedTag;
    header[1] = content.length;
    return this._createEncoderBuffer([ header, content ]);
  }

  // Long form
  // Count octets required to store length
  let lenOctets = 1;
  for (let i = content.length; i >= 0x100; i >>= 8)
    lenOctets++;

  const header = Buffer.alloc(1 + 1 + lenOctets);
  header[0] = encodedTag;
  header[1] = 0x80 | lenOctets;

  for (let i = 1 + lenOctets, j = content.length; j > 0; i--, j >>= 8)
    header[i] = j & 0xff;

  return this._createEncoderBuffer([ header, content ]);
};

DERNode.prototype._encodeStr = function encodeStr(str, tag) {
  if (tag === 'bitstr') {
    return this._createEncoderBuffer([ str.unused | 0, str.data ]);
  } else if (tag === 'bmpstr') {
    const buf = Buffer.alloc(str.length * 2);
    for (let i = 0; i < str.length; i++) {
      buf.writeUInt16BE(str.charCodeAt(i), i * 2);
    }
    return this._createEncoderBuffer(buf);
  } else if (tag === 'numstr') {
    if (!this._isNumstr(str)) {
      return this.reporter.error('Encoding of string type: numstr supports ' +
                                 'only digits and space');
    }
    return this._createEncoderBuffer(str);
  } else if (tag === 'printstr') {
    if (!this._isPrintstr(str)) {
      return this.reporter.error('Encoding of string type: printstr supports ' +
                                 'only latin upper and lower case letters, ' +
                                 'digits, space, apostrophe, left and rigth ' +
                                 'parenthesis, plus sign, comma, hyphen, ' +
                                 'dot, slash, colon, equal sign, ' +
                                 'question mark');
    }
    return this._createEncoderBuffer(str);
  } else if (/str$/.test(tag)) {
    return this._createEncoderBuffer(str);
  } else if (tag === 'objDesc') {
    return this._createEncoderBuffer(str);
  } else {
    return this.reporter.error('Encoding of string type: ' + tag +
                               ' unsupported');
  }
};

DERNode.prototype._encodeObjid = function encodeObjid(id, values, relative) {
  if (typeof id === 'string') {
    if (!values)
      return this.reporter.error('string objid given, but no values map found');
    if (!values.hasOwnProperty(id))
      return this.reporter.error('objid not found in values map');
    id = values[id].split(/[\s.]+/g);
    for (let i = 0; i < id.length; i++)
      id[i] |= 0;
  } else if (Array.isArray(id)) {
    id = id.slice();
    for (let i = 0; i < id.length; i++)
      id[i] |= 0;
  }

  if (!Array.isArray(id)) {
    return this.reporter.error('objid() should be either array or string, ' +
                               'got: ' + JSON.stringify(id));
  }

  if (!relative) {
    if (id[1] >= 40)
      return this.reporter.error('Second objid identifier OOB');
    id.splice(0, 2, id[0] * 40 + id[1]);
  }

  // Count number of octets
  let size = 0;
  for (let i = 0; i < id.length; i++) {
    let ident = id[i];
    for (size++; ident >= 0x80; ident >>= 7)
      size++;
  }

  const objid = Buffer.alloc(size);
  let offset = objid.length - 1;
  for (let i = id.length - 1; i >= 0; i--) {
    let ident = id[i];
    objid[offset--] = ident & 0x7f;
    while ((ident >>= 7) > 0)
      objid[offset--] = 0x80 | (ident & 0x7f);
  }

  return this._createEncoderBuffer(objid);
};

function two(num) {
  if (num < 10)
    return '0' + num;
  else
    return num;
}

DERNode.prototype._encodeTime = function encodeTime(time, tag) {
  let str;
  const date = new Date(time);

  if (tag === 'gentime') {
    str = [
      two(date.getUTCFullYear()),
      two(date.getUTCMonth() + 1),
      two(date.getUTCDate()),
      two(date.getUTCHours()),
      two(date.getUTCMinutes()),
      two(date.getUTCSeconds()),
      'Z'
    ].join('');
  } else if (tag === 'utctime') {
    str = [
      two(date.getUTCFullYear() % 100),
      two(date.getUTCMonth() + 1),
      two(date.getUTCDate()),
      two(date.getUTCHours()),
      two(date.getUTCMinutes()),
      two(date.getUTCSeconds()),
      'Z'
    ].join('');
  } else {
    this.reporter.error('Encoding ' + tag + ' time is not supported yet');
  }

  return this._encodeStr(str, 'octstr');
};

DERNode.prototype._encodeNull = function encodeNull() {
  return this._createEncoderBuffer('');
};

DERNode.prototype._encodeInt = function encodeInt(num, values) {
  if (typeof num === 'string') {
    if (!values)
      return this.reporter.error('String int or enum given, but no values map');
    if (!values.hasOwnProperty(num)) {
      return this.reporter.error('Values map doesn\'t contain: ' +
                                 JSON.stringify(num));
    }
    num = values[num];
  }

  // Bignum, assume big endian
  if (typeof num !== 'number' && !Buffer.isBuffer(num)) {
    const numArray = num.toArray();
    if (!num.sign && numArray[0] & 0x80) {
      numArray.unshift(0);
    }
    num = Buffer.from(numArray);
  }

  if (Buffer.isBuffer(num)) {
    let size = num.length;
    if (num.length === 0)
      size++;

    const out = Buffer.alloc(size);
    num.copy(out);
    if (num.length === 0)
      out[0] = 0;
    return this._createEncoderBuffer(out);
  }

  if (num < 0x80)
    return this._createEncoderBuffer(num);

  if (num < 0x100)
    return this._createEncoderBuffer([0, num]);

  let size = 1;
  for (let i = num; i >= 0x100; i >>= 8)
    size++;

  const out = new Array(size);
  for (let i = out.length - 1; i >= 0; i--) {
    out[i] = num & 0xff;
    num >>= 8;
  }
  if(out[0] & 0x80) {
    out.unshift(0);
  }

  return this._createEncoderBuffer(Buffer.from(out));
};

DERNode.prototype._encodeBool = function encodeBool(value) {
  return this._createEncoderBuffer(value ? 0xff : 0);
};

DERNode.prototype._use = function use(entity, obj) {
  if (typeof entity === 'function')
    entity = entity(obj);
  return entity._getEncoder('der').tree;
};

DERNode.prototype._skipDefault = function skipDefault(dataBuffer, reporter, parent) {
  const state = this._baseState;
  let i;
  if (state['default'] === null)
    return false;

  const data = dataBuffer.join();
  if (state.defaultBuffer === undefined)
    state.defaultBuffer = this._encodeValue(state['default'], reporter, parent).join();

  if (data.length !== state.defaultBuffer.length)
    return false;

  for (i=0; i < data.length; i++)
    if (data[i] !== state.defaultBuffer[i])
      return false;

  return true;
};

// Utility methods

function encodeTag(tag, primitive, cls, reporter) {
  let res;

  if (tag === 'seqof')
    tag = 'seq';
  else if (tag === 'setof')
    tag = 'set';

  if (der.tagByName.hasOwnProperty(tag))
    res = der.tagByName[tag];
  else if (typeof tag === 'number' && (tag | 0) === tag)
    res = tag;
  else
    return reporter.error('Unknown tag: ' + tag);

  if (res >= 0x1f)
    return reporter.error('Multi-octet tag encoding unsupported');

  if (!primitive)
    res |= 0x20;

  res |= (der.tagClassByName[cls || 'universal'] << 6);

  return res;
}

},{"../base/node":13,"../constants/der":15,"inherits":141,"safer-buffer":171}],21:[function(require,module,exports){
'use strict';

const encoders = exports;

encoders.der = require('./der');
encoders.pem = require('./pem');

},{"./der":20,"./pem":22}],22:[function(require,module,exports){
'use strict';

const inherits = require('inherits');

const DEREncoder = require('./der');

function PEMEncoder(entity) {
  DEREncoder.call(this, entity);
  this.enc = 'pem';
}
inherits(PEMEncoder, DEREncoder);
module.exports = PEMEncoder;

PEMEncoder.prototype.encode = function encode(data, options) {
  const buf = DEREncoder.prototype.encode.call(this, data);

  const p = buf.toString('base64');
  const out = [ '-----BEGIN ' + options.label + '-----' ];
  for (let i = 0; i < p.length; i += 64)
    out.push(p.slice(i, i + 64));
  out.push('-----END ' + options.label + '-----');
  return out.join('\n');
};

},{"./der":20,"inherits":141}],23:[function(require,module,exports){
(function (module, exports) {
  'use strict';

  // Utils
  function assert (val, msg) {
    if (!val) throw new Error(msg || 'Assertion failed');
  }

  // Could use `inherits` module, but don't want to move from single file
  // architecture yet.
  function inherits (ctor, superCtor) {
    ctor.super_ = superCtor;
    var TempCtor = function () {};
    TempCtor.prototype = superCtor.prototype;
    ctor.prototype = new TempCtor();
    ctor.prototype.constructor = ctor;
  }

  // BN

  function BN (number, base, endian) {
    if (BN.isBN(number)) {
      return number;
    }

    this.negative = 0;
    this.words = null;
    this.length = 0;

    // Reduction context
    this.red = null;

    if (number !== null) {
      if (base === 'le' || base === 'be') {
        endian = base;
        base = 10;
      }

      this._init(number || 0, base || 10, endian || 'be');
    }
  }
  if (typeof module === 'object') {
    module.exports = BN;
  } else {
    exports.BN = BN;
  }

  BN.BN = BN;
  BN.wordSize = 26;

  var Buffer;
  try {
    if (typeof window !== 'undefined' && typeof window.Buffer !== 'undefined') {
      Buffer = window.Buffer;
    } else {
      Buffer = require('buffer').Buffer;
    }
  } catch (e) {
  }

  BN.isBN = function isBN (num) {
    if (num instanceof BN) {
      return true;
    }

    return num !== null && typeof num === 'object' &&
      num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
  };

  BN.max = function max (left, right) {
    if (left.cmp(right) > 0) return left;
    return right;
  };

  BN.min = function min (left, right) {
    if (left.cmp(right) < 0) return left;
    return right;
  };

  BN.prototype._init = function init (number, base, endian) {
    if (typeof number === 'number') {
      return this._initNumber(number, base, endian);
    }

    if (typeof number === 'object') {
      return this._initArray(number, base, endian);
    }

    if (base === 'hex') {
      base = 16;
    }
    assert(base === (base | 0) && base >= 2 && base <= 36);

    number = number.toString().replace(/\s+/g, '');
    var start = 0;
    if (number[0] === '-') {
      start++;
      this.negative = 1;
    }

    if (start < number.length) {
      if (base === 16) {
        this._parseHex(number, start, endian);
      } else {
        this._parseBase(number, base, start);
        if (endian === 'le') {
          this._initArray(this.toArray(), base, endian);
        }
      }
    }
  };

  BN.prototype._initNumber = function _initNumber (number, base, endian) {
    if (number < 0) {
      this.negative = 1;
      number = -number;
    }
    if (number < 0x4000000) {
      this.words = [ number & 0x3ffffff ];
      this.length = 1;
    } else if (number < 0x10000000000000) {
      this.words = [
        number & 0x3ffffff,
        (number / 0x4000000) & 0x3ffffff
      ];
      this.length = 2;
    } else {
      assert(number < 0x20000000000000); // 2 ^ 53 (unsafe)
      this.words = [
        number & 0x3ffffff,
        (number / 0x4000000) & 0x3ffffff,
        1
      ];
      this.length = 3;
    }

    if (endian !== 'le') return;

    // Reverse the bytes
    this._initArray(this.toArray(), base, endian);
  };

  BN.prototype._initArray = function _initArray (number, base, endian) {
    // Perhaps a Uint8Array
    assert(typeof number.length === 'number');
    if (number.length <= 0) {
      this.words = [ 0 ];
      this.length = 1;
      return this;
    }

    this.length = Math.ceil(number.length / 3);
    this.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      this.words[i] = 0;
    }

    var j, w;
    var off = 0;
    if (endian === 'be') {
      for (i = number.length - 1, j = 0; i >= 0; i -= 3) {
        w = number[i] | (number[i - 1] << 8) | (number[i - 2] << 16);
        this.words[j] |= (w << off) & 0x3ffffff;
        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
        off += 24;
        if (off >= 26) {
          off -= 26;
          j++;
        }
      }
    } else if (endian === 'le') {
      for (i = 0, j = 0; i < number.length; i += 3) {
        w = number[i] | (number[i + 1] << 8) | (number[i + 2] << 16);
        this.words[j] |= (w << off) & 0x3ffffff;
        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
        off += 24;
        if (off >= 26) {
          off -= 26;
          j++;
        }
      }
    }
    return this.strip();
  };

  function parseHex4Bits (string, index) {
    var c = string.charCodeAt(index);
    // 'A' - 'F'
    if (c >= 65 && c <= 70) {
      return c - 55;
    // 'a' - 'f'
    } else if (c >= 97 && c <= 102) {
      return c - 87;
    // '0' - '9'
    } else {
      return (c - 48) & 0xf;
    }
  }

  function parseHexByte (string, lowerBound, index) {
    var r = parseHex4Bits(string, index);
    if (index - 1 >= lowerBound) {
      r |= parseHex4Bits(string, index - 1) << 4;
    }
    return r;
  }

  BN.prototype._parseHex = function _parseHex (number, start, endian) {
    // Create possibly bigger array to ensure that it fits the number
    this.length = Math.ceil((number.length - start) / 6);
    this.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      this.words[i] = 0;
    }

    // 24-bits chunks
    var off = 0;
    var j = 0;

    var w;
    if (endian === 'be') {
      for (i = number.length - 1; i >= start; i -= 2) {
        w = parseHexByte(number, start, i) << off;
        this.words[j] |= w & 0x3ffffff;
        if (off >= 18) {
          off -= 18;
          j += 1;
          this.words[j] |= w >>> 26;
        } else {
          off += 8;
        }
      }
    } else {
      var parseLength = number.length - start;
      for (i = parseLength % 2 === 0 ? start + 1 : start; i < number.length; i += 2) {
        w = parseHexByte(number, start, i) << off;
        this.words[j] |= w & 0x3ffffff;
        if (off >= 18) {
          off -= 18;
          j += 1;
          this.words[j] |= w >>> 26;
        } else {
          off += 8;
        }
      }
    }

    this.strip();
  };

  function parseBase (str, start, end, mul) {
    var r = 0;
    var len = Math.min(str.length, end);
    for (var i = start; i < len; i++) {
      var c = str.charCodeAt(i) - 48;

      r *= mul;

      // 'a'
      if (c >= 49) {
        r += c - 49 + 0xa;

      // 'A'
      } else if (c >= 17) {
        r += c - 17 + 0xa;

      // '0' - '9'
      } else {
        r += c;
      }
    }
    return r;
  }

  BN.prototype._parseBase = function _parseBase (number, base, start) {
    // Initialize as zero
    this.words = [ 0 ];
    this.length = 1;

    // Find length of limb in base
    for (var limbLen = 0, limbPow = 1; limbPow <= 0x3ffffff; limbPow *= base) {
      limbLen++;
    }
    limbLen--;
    limbPow = (limbPow / base) | 0;

    var total = number.length - start;
    var mod = total % limbLen;
    var end = Math.min(total, total - mod) + start;

    var word = 0;
    for (var i = start; i < end; i += limbLen) {
      word = parseBase(number, i, i + limbLen, base);

      this.imuln(limbPow);
      if (this.words[0] + word < 0x4000000) {
        this.words[0] += word;
      } else {
        this._iaddn(word);
      }
    }

    if (mod !== 0) {
      var pow = 1;
      word = parseBase(number, i, number.length, base);

      for (i = 0; i < mod; i++) {
        pow *= base;
      }

      this.imuln(pow);
      if (this.words[0] + word < 0x4000000) {
        this.words[0] += word;
      } else {
        this._iaddn(word);
      }
    }

    this.strip();
  };

  BN.prototype.copy = function copy (dest) {
    dest.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      dest.words[i] = this.words[i];
    }
    dest.length = this.length;
    dest.negative = this.negative;
    dest.red = this.red;
  };

  BN.prototype.clone = function clone () {
    var r = new BN(null);
    this.copy(r);
    return r;
  };

  BN.prototype._expand = function _expand (size) {
    while (this.length < size) {
      this.words[this.length++] = 0;
    }
    return this;
  };

  // Remove leading `0` from `this`
  BN.prototype.strip = function strip () {
    while (this.length > 1 && this.words[this.length - 1] === 0) {
      this.length--;
    }
    return this._normSign();
  };

  BN.prototype._normSign = function _normSign () {
    // -0 = 0
    if (this.length === 1 && this.words[0] === 0) {
      this.negative = 0;
    }
    return this;
  };

  BN.prototype.inspect = function inspect () {
    return (this.red ? '<BN-R: ' : '<BN: ') + this.toString(16) + '>';
  };

  /*

  var zeros = [];
  var groupSizes = [];
  var groupBases = [];

  var s = '';
  var i = -1;
  while (++i < BN.wordSize) {
    zeros[i] = s;
    s += '0';
  }
  groupSizes[0] = 0;
  groupSizes[1] = 0;
  groupBases[0] = 0;
  groupBases[1] = 0;
  var base = 2 - 1;
  while (++base < 36 + 1) {
    var groupSize = 0;
    var groupBase = 1;
    while (groupBase < (1 << BN.wordSize) / base) {
      groupBase *= base;
      groupSize += 1;
    }
    groupSizes[base] = groupSize;
    groupBases[base] = groupBase;
  }

  */

  var zeros = [
    '',
    '0',
    '00',
    '000',
    '0000',
    '00000',
    '000000',
    '0000000',
    '00000000',
    '000000000',
    '0000000000',
    '00000000000',
    '000000000000',
    '0000000000000',
    '00000000000000',
    '000000000000000',
    '0000000000000000',
    '00000000000000000',
    '000000000000000000',
    '0000000000000000000',
    '00000000000000000000',
    '000000000000000000000',
    '0000000000000000000000',
    '00000000000000000000000',
    '000000000000000000000000',
    '0000000000000000000000000'
  ];

  var groupSizes = [
    0, 0,
    25, 16, 12, 11, 10, 9, 8,
    8, 7, 7, 7, 7, 6, 6,
    6, 6, 6, 6, 6, 5, 5,
    5, 5, 5, 5, 5, 5, 5,
    5, 5, 5, 5, 5, 5, 5
  ];

  var groupBases = [
    0, 0,
    33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216,
    43046721, 10000000, 19487171, 35831808, 62748517, 7529536, 11390625,
    16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632,
    6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149,
    24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176
  ];

  BN.prototype.toString = function toString (base, padding) {
    base = base || 10;
    padding = padding | 0 || 1;

    var out;
    if (base === 16 || base === 'hex') {
      out = '';
      var off = 0;
      var carry = 0;
      for (var i = 0; i < this.length; i++) {
        var w = this.words[i];
        var word = (((w << off) | carry) & 0xffffff).toString(16);
        carry = (w >>> (24 - off)) & 0xffffff;
        if (carry !== 0 || i !== this.length - 1) {
          out = zeros[6 - word.length] + word + out;
        } else {
          out = word + out;
        }
        off += 2;
        if (off >= 26) {
          off -= 26;
          i--;
        }
      }
      if (carry !== 0) {
        out = carry.toString(16) + out;
      }
      while (out.length % padding !== 0) {
        out = '0' + out;
      }
      if (this.negative !== 0) {
        out = '-' + out;
      }
      return out;
    }

    if (base === (base | 0) && base >= 2 && base <= 36) {
      // var groupSize = Math.floor(BN.wordSize * Math.LN2 / Math.log(base));
      var groupSize = groupSizes[base];
      // var groupBase = Math.pow(base, groupSize);
      var groupBase = groupBases[base];
      out = '';
      var c = this.clone();
      c.negative = 0;
      while (!c.isZero()) {
        var r = c.modn(groupBase).toString(base);
        c = c.idivn(groupBase);

        if (!c.isZero()) {
          out = zeros[groupSize - r.length] + r + out;
        } else {
          out = r + out;
        }
      }
      if (this.isZero()) {
        out = '0' + out;
      }
      while (out.length % padding !== 0) {
        out = '0' + out;
      }
      if (this.negative !== 0) {
        out = '-' + out;
      }
      return out;
    }

    assert(false, 'Base should be between 2 and 36');
  };

  BN.prototype.toNumber = function toNumber () {
    var ret = this.words[0];
    if (this.length === 2) {
      ret += this.words[1] * 0x4000000;
    } else if (this.length === 3 && this.words[2] === 0x01) {
      // NOTE: at this stage it is known that the top bit is set
      ret += 0x10000000000000 + (this.words[1] * 0x4000000);
    } else if (this.length > 2) {
      assert(false, 'Number can only safely store up to 53 bits');
    }
    return (this.negative !== 0) ? -ret : ret;
  };

  BN.prototype.toJSON = function toJSON () {
    return this.toString(16);
  };

  BN.prototype.toBuffer = function toBuffer (endian, length) {
    assert(typeof Buffer !== 'undefined');
    return this.toArrayLike(Buffer, endian, length);
  };

  BN.prototype.toArray = function toArray (endian, length) {
    return this.toArrayLike(Array, endian, length);
  };

  BN.prototype.toArrayLike = function toArrayLike (ArrayType, endian, length) {
    var byteLength = this.byteLength();
    var reqLength = length || Math.max(1, byteLength);
    assert(byteLength <= reqLength, 'byte array longer than desired length');
    assert(reqLength > 0, 'Requested array length <= 0');

    this.strip();
    var littleEndian = endian === 'le';
    var res = new ArrayType(reqLength);

    var b, i;
    var q = this.clone();
    if (!littleEndian) {
      // Assume big-endian
      for (i = 0; i < reqLength - byteLength; i++) {
        res[i] = 0;
      }

      for (i = 0; !q.isZero(); i++) {
        b = q.andln(0xff);
        q.iushrn(8);

        res[reqLength - i - 1] = b;
      }
    } else {
      for (i = 0; !q.isZero(); i++) {
        b = q.andln(0xff);
        q.iushrn(8);

        res[i] = b;
      }

      for (; i < reqLength; i++) {
        res[i] = 0;
      }
    }

    return res;
  };

  if (Math.clz32) {
    BN.prototype._countBits = function _countBits (w) {
      return 32 - Math.clz32(w);
    };
  } else {
    BN.prototype._countBits = function _countBits (w) {
      var t = w;
      var r = 0;
      if (t >= 0x1000) {
        r += 13;
        t >>>= 13;
      }
      if (t >= 0x40) {
        r += 7;
        t >>>= 7;
      }
      if (t >= 0x8) {
        r += 4;
        t >>>= 4;
      }
      if (t >= 0x02) {
        r += 2;
        t >>>= 2;
      }
      return r + t;
    };
  }

  BN.prototype._zeroBits = function _zeroBits (w) {
    // Short-cut
    if (w === 0) return 26;

    var t = w;
    var r = 0;
    if ((t & 0x1fff) === 0) {
      r += 13;
      t >>>= 13;
    }
    if ((t & 0x7f) === 0) {
      r += 7;
      t >>>= 7;
    }
    if ((t & 0xf) === 0) {
      r += 4;
      t >>>= 4;
    }
    if ((t & 0x3) === 0) {
      r += 2;
      t >>>= 2;
    }
    if ((t & 0x1) === 0) {
      r++;
    }
    return r;
  };

  // Return number of used bits in a BN
  BN.prototype.bitLength = function bitLength () {
    var w = this.words[this.length - 1];
    var hi = this._countBits(w);
    return (this.length - 1) * 26 + hi;
  };

  function toBitArray (num) {
    var w = new Array(num.bitLength());

    for (var bit = 0; bit < w.length; bit++) {
      var off = (bit / 26) | 0;
      var wbit = bit % 26;

      w[bit] = (num.words[off] & (1 << wbit)) >>> wbit;
    }

    return w;
  }

  // Number of trailing zero bits
  BN.prototype.zeroBits = function zeroBits () {
    if (this.isZero()) return 0;

    var r = 0;
    for (var i = 0; i < this.length; i++) {
      var b = this._zeroBits(this.words[i]);
      r += b;
      if (b !== 26) break;
    }
    return r;
  };

  BN.prototype.byteLength = function byteLength () {
    return Math.ceil(this.bitLength() / 8);
  };

  BN.prototype.toTwos = function toTwos (width) {
    if (this.negative !== 0) {
      return this.abs().inotn(width).iaddn(1);
    }
    return this.clone();
  };

  BN.prototype.fromTwos = function fromTwos (width) {
    if (this.testn(width - 1)) {
      return this.notn(width).iaddn(1).ineg();
    }
    return this.clone();
  };

  BN.prototype.isNeg = function isNeg () {
    return this.negative !== 0;
  };

  // Return negative clone of `this`
  BN.prototype.neg = function neg () {
    return this.clone().ineg();
  };

  BN.prototype.ineg = function ineg () {
    if (!this.isZero()) {
      this.negative ^= 1;
    }

    return this;
  };

  // Or `num` with `this` in-place
  BN.prototype.iuor = function iuor (num) {
    while (this.length < num.length) {
      this.words[this.length++] = 0;
    }

    for (var i = 0; i < num.length; i++) {
      this.words[i] = this.words[i] | num.words[i];
    }

    return this.strip();
  };

  BN.prototype.ior = function ior (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuor(num);
  };

  // Or `num` with `this`
  BN.prototype.or = function or (num) {
    if (this.length > num.length) return this.clone().ior(num);
    return num.clone().ior(this);
  };

  BN.prototype.uor = function uor (num) {
    if (this.length > num.length) return this.clone().iuor(num);
    return num.clone().iuor(this);
  };

  // And `num` with `this` in-place
  BN.prototype.iuand = function iuand (num) {
    // b = min-length(num, this)
    var b;
    if (this.length > num.length) {
      b = num;
    } else {
      b = this;
    }

    for (var i = 0; i < b.length; i++) {
      this.words[i] = this.words[i] & num.words[i];
    }

    this.length = b.length;

    return this.strip();
  };

  BN.prototype.iand = function iand (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuand(num);
  };

  // And `num` with `this`
  BN.prototype.and = function and (num) {
    if (this.length > num.length) return this.clone().iand(num);
    return num.clone().iand(this);
  };

  BN.prototype.uand = function uand (num) {
    if (this.length > num.length) return this.clone().iuand(num);
    return num.clone().iuand(this);
  };

  // Xor `num` with `this` in-place
  BN.prototype.iuxor = function iuxor (num) {
    // a.length > b.length
    var a;
    var b;
    if (this.length > num.length) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    for (var i = 0; i < b.length; i++) {
      this.words[i] = a.words[i] ^ b.words[i];
    }

    if (this !== a) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    this.length = a.length;

    return this.strip();
  };

  BN.prototype.ixor = function ixor (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuxor(num);
  };

  // Xor `num` with `this`
  BN.prototype.xor = function xor (num) {
    if (this.length > num.length) return this.clone().ixor(num);
    return num.clone().ixor(this);
  };

  BN.prototype.uxor = function uxor (num) {
    if (this.length > num.length) return this.clone().iuxor(num);
    return num.clone().iuxor(this);
  };

  // Not ``this`` with ``width`` bitwidth
  BN.prototype.inotn = function inotn (width) {
    assert(typeof width === 'number' && width >= 0);

    var bytesNeeded = Math.ceil(width / 26) | 0;
    var bitsLeft = width % 26;

    // Extend the buffer with leading zeroes
    this._expand(bytesNeeded);

    if (bitsLeft > 0) {
      bytesNeeded--;
    }

    // Handle complete words
    for (var i = 0; i < bytesNeeded; i++) {
      this.words[i] = ~this.words[i] & 0x3ffffff;
    }

    // Handle the residue
    if (bitsLeft > 0) {
      this.words[i] = ~this.words[i] & (0x3ffffff >> (26 - bitsLeft));
    }

    // And remove leading zeroes
    return this.strip();
  };

  BN.prototype.notn = function notn (width) {
    return this.clone().inotn(width);
  };

  // Set `bit` of `this`
  BN.prototype.setn = function setn (bit, val) {
    assert(typeof bit === 'number' && bit >= 0);

    var off = (bit / 26) | 0;
    var wbit = bit % 26;

    this._expand(off + 1);

    if (val) {
      this.words[off] = this.words[off] | (1 << wbit);
    } else {
      this.words[off] = this.words[off] & ~(1 << wbit);
    }

    return this.strip();
  };

  // Add `num` to `this` in-place
  BN.prototype.iadd = function iadd (num) {
    var r;

    // negative + positive
    if (this.negative !== 0 && num.negative === 0) {
      this.negative = 0;
      r = this.isub(num);
      this.negative ^= 1;
      return this._normSign();

    // positive + negative
    } else if (this.negative === 0 && num.negative !== 0) {
      num.negative = 0;
      r = this.isub(num);
      num.negative = 1;
      return r._normSign();
    }

    // a.length > b.length
    var a, b;
    if (this.length > num.length) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    var carry = 0;
    for (var i = 0; i < b.length; i++) {
      r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
      this.words[i] = r & 0x3ffffff;
      carry = r >>> 26;
    }
    for (; carry !== 0 && i < a.length; i++) {
      r = (a.words[i] | 0) + carry;
      this.words[i] = r & 0x3ffffff;
      carry = r >>> 26;
    }

    this.length = a.length;
    if (carry !== 0) {
      this.words[this.length] = carry;
      this.length++;
    // Copy the rest of the words
    } else if (a !== this) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    return this;
  };

  // Add `num` to `this`
  BN.prototype.add = function add (num) {
    var res;
    if (num.negative !== 0 && this.negative === 0) {
      num.negative = 0;
      res = this.sub(num);
      num.negative ^= 1;
      return res;
    } else if (num.negative === 0 && this.negative !== 0) {
      this.negative = 0;
      res = num.sub(this);
      this.negative = 1;
      return res;
    }

    if (this.length > num.length) return this.clone().iadd(num);

    return num.clone().iadd(this);
  };

  // Subtract `num` from `this` in-place
  BN.prototype.isub = function isub (num) {
    // this - (-num) = this + num
    if (num.negative !== 0) {
      num.negative = 0;
      var r = this.iadd(num);
      num.negative = 1;
      return r._normSign();

    // -this - num = -(this + num)
    } else if (this.negative !== 0) {
      this.negative = 0;
      this.iadd(num);
      this.negative = 1;
      return this._normSign();
    }

    // At this point both numbers are positive
    var cmp = this.cmp(num);

    // Optimization - zeroify
    if (cmp === 0) {
      this.negative = 0;
      this.length = 1;
      this.words[0] = 0;
      return this;
    }

    // a > b
    var a, b;
    if (cmp > 0) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    var carry = 0;
    for (var i = 0; i < b.length; i++) {
      r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
      carry = r >> 26;
      this.words[i] = r & 0x3ffffff;
    }
    for (; carry !== 0 && i < a.length; i++) {
      r = (a.words[i] | 0) + carry;
      carry = r >> 26;
      this.words[i] = r & 0x3ffffff;
    }

    // Copy rest of the words
    if (carry === 0 && i < a.length && a !== this) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    this.length = Math.max(this.length, i);

    if (a !== this) {
      this.negative = 1;
    }

    return this.strip();
  };

  // Subtract `num` from `this`
  BN.prototype.sub = function sub (num) {
    return this.clone().isub(num);
  };

  function smallMulTo (self, num, out) {
    out.negative = num.negative ^ self.negative;
    var len = (self.length + num.length) | 0;
    out.length = len;
    len = (len - 1) | 0;

    // Peel one iteration (compiler can't do it, because of code complexity)
    var a = self.words[0] | 0;
    var b = num.words[0] | 0;
    var r = a * b;

    var lo = r & 0x3ffffff;
    var carry = (r / 0x4000000) | 0;
    out.words[0] = lo;

    for (var k = 1; k < len; k++) {
      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
      // note that ncarry could be >= 0x3ffffff
      var ncarry = carry >>> 26;
      var rword = carry & 0x3ffffff;
      var maxJ = Math.min(k, num.length - 1);
      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
        var i = (k - j) | 0;
        a = self.words[i] | 0;
        b = num.words[j] | 0;
        r = a * b + rword;
        ncarry += (r / 0x4000000) | 0;
        rword = r & 0x3ffffff;
      }
      out.words[k] = rword | 0;
      carry = ncarry | 0;
    }
    if (carry !== 0) {
      out.words[k] = carry | 0;
    } else {
      out.length--;
    }

    return out.strip();
  }

  // TODO(indutny): it may be reasonable to omit it for users who don't need
  // to work with 256-bit numbers, otherwise it gives 20% improvement for 256-bit
  // multiplication (like elliptic secp256k1).
  var comb10MulTo = function comb10MulTo (self, num, out) {
    var a = self.words;
    var b = num.words;
    var o = out.words;
    var c = 0;
    var lo;
    var mid;
    var hi;
    var a0 = a[0] | 0;
    var al0 = a0 & 0x1fff;
    var ah0 = a0 >>> 13;
    var a1 = a[1] | 0;
    var al1 = a1 & 0x1fff;
    var ah1 = a1 >>> 13;
    var a2 = a[2] | 0;
    var al2 = a2 & 0x1fff;
    var ah2 = a2 >>> 13;
    var a3 = a[3] | 0;
    var al3 = a3 & 0x1fff;
    var ah3 = a3 >>> 13;
    var a4 = a[4] | 0;
    var al4 = a4 & 0x1fff;
    var ah4 = a4 >>> 13;
    var a5 = a[5] | 0;
    var al5 = a5 & 0x1fff;
    var ah5 = a5 >>> 13;
    var a6 = a[6] | 0;
    var al6 = a6 & 0x1fff;
    var ah6 = a6 >>> 13;
    var a7 = a[7] | 0;
    var al7 = a7 & 0x1fff;
    var ah7 = a7 >>> 13;
    var a8 = a[8] | 0;
    var al8 = a8 & 0x1fff;
    var ah8 = a8 >>> 13;
    var a9 = a[9] | 0;
    var al9 = a9 & 0x1fff;
    var ah9 = a9 >>> 13;
    var b0 = b[0] | 0;
    var bl0 = b0 & 0x1fff;
    var bh0 = b0 >>> 13;
    var b1 = b[1] | 0;
    var bl1 = b1 & 0x1fff;
    var bh1 = b1 >>> 13;
    var b2 = b[2] | 0;
    var bl2 = b2 & 0x1fff;
    var bh2 = b2 >>> 13;
    var b3 = b[3] | 0;
    var bl3 = b3 & 0x1fff;
    var bh3 = b3 >>> 13;
    var b4 = b[4] | 0;
    var bl4 = b4 & 0x1fff;
    var bh4 = b4 >>> 13;
    var b5 = b[5] | 0;
    var bl5 = b5 & 0x1fff;
    var bh5 = b5 >>> 13;
    var b6 = b[6] | 0;
    var bl6 = b6 & 0x1fff;
    var bh6 = b6 >>> 13;
    var b7 = b[7] | 0;
    var bl7 = b7 & 0x1fff;
    var bh7 = b7 >>> 13;
    var b8 = b[8] | 0;
    var bl8 = b8 & 0x1fff;
    var bh8 = b8 >>> 13;
    var b9 = b[9] | 0;
    var bl9 = b9 & 0x1fff;
    var bh9 = b9 >>> 13;

    out.negative = self.negative ^ num.negative;
    out.length = 19;
    /* k = 0 */
    lo = Math.imul(al0, bl0);
    mid = Math.imul(al0, bh0);
    mid = (mid + Math.imul(ah0, bl0)) | 0;
    hi = Math.imul(ah0, bh0);
    var w0 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w0 >>> 26)) | 0;
    w0 &= 0x3ffffff;
    /* k = 1 */
    lo = Math.imul(al1, bl0);
    mid = Math.imul(al1, bh0);
    mid = (mid + Math.imul(ah1, bl0)) | 0;
    hi = Math.imul(ah1, bh0);
    lo = (lo + Math.imul(al0, bl1)) | 0;
    mid = (mid + Math.imul(al0, bh1)) | 0;
    mid = (mid + Math.imul(ah0, bl1)) | 0;
    hi = (hi + Math.imul(ah0, bh1)) | 0;
    var w1 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w1 >>> 26)) | 0;
    w1 &= 0x3ffffff;
    /* k = 2 */
    lo = Math.imul(al2, bl0);
    mid = Math.imul(al2, bh0);
    mid = (mid + Math.imul(ah2, bl0)) | 0;
    hi = Math.imul(ah2, bh0);
    lo = (lo + Math.imul(al1, bl1)) | 0;
    mid = (mid + Math.imul(al1, bh1)) | 0;
    mid = (mid + Math.imul(ah1, bl1)) | 0;
    hi = (hi + Math.imul(ah1, bh1)) | 0;
    lo = (lo + Math.imul(al0, bl2)) | 0;
    mid = (mid + Math.imul(al0, bh2)) | 0;
    mid = (mid + Math.imul(ah0, bl2)) | 0;
    hi = (hi + Math.imul(ah0, bh2)) | 0;
    var w2 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w2 >>> 26)) | 0;
    w2 &= 0x3ffffff;
    /* k = 3 */
    lo = Math.imul(al3, bl0);
    mid = Math.imul(al3, bh0);
    mid = (mid + Math.imul(ah3, bl0)) | 0;
    hi = Math.imul(ah3, bh0);
    lo = (lo + Math.imul(al2, bl1)) | 0;
    mid = (mid + Math.imul(al2, bh1)) | 0;
    mid = (mid + Math.imul(ah2, bl1)) | 0;
    hi = (hi + Math.imul(ah2, bh1)) | 0;
    lo = (lo + Math.imul(al1, bl2)) | 0;
    mid = (mid + Math.imul(al1, bh2)) | 0;
    mid = (mid + Math.imul(ah1, bl2)) | 0;
    hi = (hi + Math.imul(ah1, bh2)) | 0;
    lo = (lo + Math.imul(al0, bl3)) | 0;
    mid = (mid + Math.imul(al0, bh3)) | 0;
    mid = (mid + Math.imul(ah0, bl3)) | 0;
    hi = (hi + Math.imul(ah0, bh3)) | 0;
    var w3 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w3 >>> 26)) | 0;
    w3 &= 0x3ffffff;
    /* k = 4 */
    lo = Math.imul(al4, bl0);
    mid = Math.imul(al4, bh0);
    mid = (mid + Math.imul(ah4, bl0)) | 0;
    hi = Math.imul(ah4, bh0);
    lo = (lo + Math.imul(al3, bl1)) | 0;
    mid = (mid + Math.imul(al3, bh1)) | 0;
    mid = (mid + Math.imul(ah3, bl1)) | 0;
    hi = (hi + Math.imul(ah3, bh1)) | 0;
    lo = (lo + Math.imul(al2, bl2)) | 0;
    mid = (mid + Math.imul(al2, bh2)) | 0;
    mid = (mid + Math.imul(ah2, bl2)) | 0;
    hi = (hi + Math.imul(ah2, bh2)) | 0;
    lo = (lo + Math.imul(al1, bl3)) | 0;
    mid = (mid + Math.imul(al1, bh3)) | 0;
    mid = (mid + Math.imul(ah1, bl3)) | 0;
    hi = (hi + Math.imul(ah1, bh3)) | 0;
    lo = (lo + Math.imul(al0, bl4)) | 0;
    mid = (mid + Math.imul(al0, bh4)) | 0;
    mid = (mid + Math.imul(ah0, bl4)) | 0;
    hi = (hi + Math.imul(ah0, bh4)) | 0;
    var w4 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w4 >>> 26)) | 0;
    w4 &= 0x3ffffff;
    /* k = 5 */
    lo = Math.imul(al5, bl0);
    mid = Math.imul(al5, bh0);
    mid = (mid + Math.imul(ah5, bl0)) | 0;
    hi = Math.imul(ah5, bh0);
    lo = (lo + Math.imul(al4, bl1)) | 0;
    mid = (mid + Math.imul(al4, bh1)) | 0;
    mid = (mid + Math.imul(ah4, bl1)) | 0;
    hi = (hi + Math.imul(ah4, bh1)) | 0;
    lo = (lo + Math.imul(al3, bl2)) | 0;
    mid = (mid + Math.imul(al3, bh2)) | 0;
    mid = (mid + Math.imul(ah3, bl2)) | 0;
    hi = (hi + Math.imul(ah3, bh2)) | 0;
    lo = (lo + Math.imul(al2, bl3)) | 0;
    mid = (mid + Math.imul(al2, bh3)) | 0;
    mid = (mid + Math.imul(ah2, bl3)) | 0;
    hi = (hi + Math.imul(ah2, bh3)) | 0;
    lo = (lo + Math.imul(al1, bl4)) | 0;
    mid = (mid + Math.imul(al1, bh4)) | 0;
    mid = (mid + Math.imul(ah1, bl4)) | 0;
    hi = (hi + Math.imul(ah1, bh4)) | 0;
    lo = (lo + Math.imul(al0, bl5)) | 0;
    mid = (mid + Math.imul(al0, bh5)) | 0;
    mid = (mid + Math.imul(ah0, bl5)) | 0;
    hi = (hi + Math.imul(ah0, bh5)) | 0;
    var w5 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w5 >>> 26)) | 0;
    w5 &= 0x3ffffff;
    /* k = 6 */
    lo = Math.imul(al6, bl0);
    mid = Math.imul(al6, bh0);
    mid = (mid + Math.imul(ah6, bl0)) | 0;
    hi = Math.imul(ah6, bh0);
    lo = (lo + Math.imul(al5, bl1)) | 0;
    mid = (mid + Math.imul(al5, bh1)) | 0;
    mid = (mid + Math.imul(ah5, bl1)) | 0;
    hi = (hi + Math.imul(ah5, bh1)) | 0;
    lo = (lo + Math.imul(al4, bl2)) | 0;
    mid = (mid + Math.imul(al4, bh2)) | 0;
    mid = (mid + Math.imul(ah4, bl2)) | 0;
    hi = (hi + Math.imul(ah4, bh2)) | 0;
    lo = (lo + Math.imul(al3, bl3)) | 0;
    mid = (mid + Math.imul(al3, bh3)) | 0;
    mid = (mid + Math.imul(ah3, bl3)) | 0;
    hi = (hi + Math.imul(ah3, bh3)) | 0;
    lo = (lo + Math.imul(al2, bl4)) | 0;
    mid = (mid + Math.imul(al2, bh4)) | 0;
    mid = (mid + Math.imul(ah2, bl4)) | 0;
    hi = (hi + Math.imul(ah2, bh4)) | 0;
    lo = (lo + Math.imul(al1, bl5)) | 0;
    mid = (mid + Math.imul(al1, bh5)) | 0;
    mid = (mid + Math.imul(ah1, bl5)) | 0;
    hi = (hi + Math.imul(ah1, bh5)) | 0;
    lo = (lo + Math.imul(al0, bl6)) | 0;
    mid = (mid + Math.imul(al0, bh6)) | 0;
    mid = (mid + Math.imul(ah0, bl6)) | 0;
    hi = (hi + Math.imul(ah0, bh6)) | 0;
    var w6 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w6 >>> 26)) | 0;
    w6 &= 0x3ffffff;
    /* k = 7 */
    lo = Math.imul(al7, bl0);
    mid = Math.imul(al7, bh0);
    mid = (mid + Math.imul(ah7, bl0)) | 0;
    hi = Math.imul(ah7, bh0);
    lo = (lo + Math.imul(al6, bl1)) | 0;
    mid = (mid + Math.imul(al6, bh1)) | 0;
    mid = (mid + Math.imul(ah6, bl1)) | 0;
    hi = (hi + Math.imul(ah6, bh1)) | 0;
    lo = (lo + Math.imul(al5, bl2)) | 0;
    mid = (mid + Math.imul(al5, bh2)) | 0;
    mid = (mid + Math.imul(ah5, bl2)) | 0;
    hi = (hi + Math.imul(ah5, bh2)) | 0;
    lo = (lo + Math.imul(al4, bl3)) | 0;
    mid = (mid + Math.imul(al4, bh3)) | 0;
    mid = (mid + Math.imul(ah4, bl3)) | 0;
    hi = (hi + Math.imul(ah4, bh3)) | 0;
    lo = (lo + Math.imul(al3, bl4)) | 0;
    mid = (mid + Math.imul(al3, bh4)) | 0;
    mid = (mid + Math.imul(ah3, bl4)) | 0;
    hi = (hi + Math.imul(ah3, bh4)) | 0;
    lo = (lo + Math.imul(al2, bl5)) | 0;
    mid = (mid + Math.imul(al2, bh5)) | 0;
    mid = (mid + Math.imul(ah2, bl5)) | 0;
    hi = (hi + Math.imul(ah2, bh5)) | 0;
    lo = (lo + Math.imul(al1, bl6)) | 0;
    mid = (mid + Math.imul(al1, bh6)) | 0;
    mid = (mid + Math.imul(ah1, bl6)) | 0;
    hi = (hi + Math.imul(ah1, bh6)) | 0;
    lo = (lo + Math.imul(al0, bl7)) | 0;
    mid = (mid + Math.imul(al0, bh7)) | 0;
    mid = (mid + Math.imul(ah0, bl7)) | 0;
    hi = (hi + Math.imul(ah0, bh7)) | 0;
    var w7 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w7 >>> 26)) | 0;
    w7 &= 0x3ffffff;
    /* k = 8 */
    lo = Math.imul(al8, bl0);
    mid = Math.imul(al8, bh0);
    mid = (mid + Math.imul(ah8, bl0)) | 0;
    hi = Math.imul(ah8, bh0);
    lo = (lo + Math.imul(al7, bl1)) | 0;
    mid = (mid + Math.imul(al7, bh1)) | 0;
    mid = (mid + Math.imul(ah7, bl1)) | 0;
    hi = (hi + Math.imul(ah7, bh1)) | 0;
    lo = (lo + Math.imul(al6, bl2)) | 0;
    mid = (mid + Math.imul(al6, bh2)) | 0;
    mid = (mid + Math.imul(ah6, bl2)) | 0;
    hi = (hi + Math.imul(ah6, bh2)) | 0;
    lo = (lo + Math.imul(al5, bl3)) | 0;
    mid = (mid + Math.imul(al5, bh3)) | 0;
    mid = (mid + Math.imul(ah5, bl3)) | 0;
    hi = (hi + Math.imul(ah5, bh3)) | 0;
    lo = (lo + Math.imul(al4, bl4)) | 0;
    mid = (mid + Math.imul(al4, bh4)) | 0;
    mid = (mid + Math.imul(ah4, bl4)) | 0;
    hi = (hi + Math.imul(ah4, bh4)) | 0;
    lo = (lo + Math.imul(al3, bl5)) | 0;
    mid = (mid + Math.imul(al3, bh5)) | 0;
    mid = (mid + Math.imul(ah3, bl5)) | 0;
    hi = (hi + Math.imul(ah3, bh5)) | 0;
    lo = (lo + Math.imul(al2, bl6)) | 0;
    mid = (mid + Math.imul(al2, bh6)) | 0;
    mid = (mid + Math.imul(ah2, bl6)) | 0;
    hi = (hi + Math.imul(ah2, bh6)) | 0;
    lo = (lo + Math.imul(al1, bl7)) | 0;
    mid = (mid + Math.imul(al1, bh7)) | 0;
    mid = (mid + Math.imul(ah1, bl7)) | 0;
    hi = (hi + Math.imul(ah1, bh7)) | 0;
    lo = (lo + Math.imul(al0, bl8)) | 0;
    mid = (mid + Math.imul(al0, bh8)) | 0;
    mid = (mid + Math.imul(ah0, bl8)) | 0;
    hi = (hi + Math.imul(ah0, bh8)) | 0;
    var w8 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w8 >>> 26)) | 0;
    w8 &= 0x3ffffff;
    /* k = 9 */
    lo = Math.imul(al9, bl0);
    mid = Math.imul(al9, bh0);
    mid = (mid + Math.imul(ah9, bl0)) | 0;
    hi = Math.imul(ah9, bh0);
    lo = (lo + Math.imul(al8, bl1)) | 0;
    mid = (mid + Math.imul(al8, bh1)) | 0;
    mid = (mid + Math.imul(ah8, bl1)) | 0;
    hi = (hi + Math.imul(ah8, bh1)) | 0;
    lo = (lo + Math.imul(al7, bl2)) | 0;
    mid = (mid + Math.imul(al7, bh2)) | 0;
    mid = (mid + Math.imul(ah7, bl2)) | 0;
    hi = (hi + Math.imul(ah7, bh2)) | 0;
    lo = (lo + Math.imul(al6, bl3)) | 0;
    mid = (mid + Math.imul(al6, bh3)) | 0;
    mid = (mid + Math.imul(ah6, bl3)) | 0;
    hi = (hi + Math.imul(ah6, bh3)) | 0;
    lo = (lo + Math.imul(al5, bl4)) | 0;
    mid = (mid + Math.imul(al5, bh4)) | 0;
    mid = (mid + Math.imul(ah5, bl4)) | 0;
    hi = (hi + Math.imul(ah5, bh4)) | 0;
    lo = (lo + Math.imul(al4, bl5)) | 0;
    mid = (mid + Math.imul(al4, bh5)) | 0;
    mid = (mid + Math.imul(ah4, bl5)) | 0;
    hi = (hi + Math.imul(ah4, bh5)) | 0;
    lo = (lo + Math.imul(al3, bl6)) | 0;
    mid = (mid + Math.imul(al3, bh6)) | 0;
    mid = (mid + Math.imul(ah3, bl6)) | 0;
    hi = (hi + Math.imul(ah3, bh6)) | 0;
    lo = (lo + Math.imul(al2, bl7)) | 0;
    mid = (mid + Math.imul(al2, bh7)) | 0;
    mid = (mid + Math.imul(ah2, bl7)) | 0;
    hi = (hi + Math.imul(ah2, bh7)) | 0;
    lo = (lo + Math.imul(al1, bl8)) | 0;
    mid = (mid + Math.imul(al1, bh8)) | 0;
    mid = (mid + Math.imul(ah1, bl8)) | 0;
    hi = (hi + Math.imul(ah1, bh8)) | 0;
    lo = (lo + Math.imul(al0, bl9)) | 0;
    mid = (mid + Math.imul(al0, bh9)) | 0;
    mid = (mid + Math.imul(ah0, bl9)) | 0;
    hi = (hi + Math.imul(ah0, bh9)) | 0;
    var w9 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w9 >>> 26)) | 0;
    w9 &= 0x3ffffff;
    /* k = 10 */
    lo = Math.imul(al9, bl1);
    mid = Math.imul(al9, bh1);
    mid = (mid + Math.imul(ah9, bl1)) | 0;
    hi = Math.imul(ah9, bh1);
    lo = (lo + Math.imul(al8, bl2)) | 0;
    mid = (mid + Math.imul(al8, bh2)) | 0;
    mid = (mid + Math.imul(ah8, bl2)) | 0;
    hi = (hi + Math.imul(ah8, bh2)) | 0;
    lo = (lo + Math.imul(al7, bl3)) | 0;
    mid = (mid + Math.imul(al7, bh3)) | 0;
    mid = (mid + Math.imul(ah7, bl3)) | 0;
    hi = (hi + Math.imul(ah7, bh3)) | 0;
    lo = (lo + Math.imul(al6, bl4)) | 0;
    mid = (mid + Math.imul(al6, bh4)) | 0;
    mid = (mid + Math.imul(ah6, bl4)) | 0;
    hi = (hi + Math.imul(ah6, bh4)) | 0;
    lo = (lo + Math.imul(al5, bl5)) | 0;
    mid = (mid + Math.imul(al5, bh5)) | 0;
    mid = (mid + Math.imul(ah5, bl5)) | 0;
    hi = (hi + Math.imul(ah5, bh5)) | 0;
    lo = (lo + Math.imul(al4, bl6)) | 0;
    mid = (mid + Math.imul(al4, bh6)) | 0;
    mid = (mid + Math.imul(ah4, bl6)) | 0;
    hi = (hi + Math.imul(ah4, bh6)) | 0;
    lo = (lo + Math.imul(al3, bl7)) | 0;
    mid = (mid + Math.imul(al3, bh7)) | 0;
    mid = (mid + Math.imul(ah3, bl7)) | 0;
    hi = (hi + Math.imul(ah3, bh7)) | 0;
    lo = (lo + Math.imul(al2, bl8)) | 0;
    mid = (mid + Math.imul(al2, bh8)) | 0;
    mid = (mid + Math.imul(ah2, bl8)) | 0;
    hi = (hi + Math.imul(ah2, bh8)) | 0;
    lo = (lo + Math.imul(al1, bl9)) | 0;
    mid = (mid + Math.imul(al1, bh9)) | 0;
    mid = (mid + Math.imul(ah1, bl9)) | 0;
    hi = (hi + Math.imul(ah1, bh9)) | 0;
    var w10 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w10 >>> 26)) | 0;
    w10 &= 0x3ffffff;
    /* k = 11 */
    lo = Math.imul(al9, bl2);
    mid = Math.imul(al9, bh2);
    mid = (mid + Math.imul(ah9, bl2)) | 0;
    hi = Math.imul(ah9, bh2);
    lo = (lo + Math.imul(al8, bl3)) | 0;
    mid = (mid + Math.imul(al8, bh3)) | 0;
    mid = (mid + Math.imul(ah8, bl3)) | 0;
    hi = (hi + Math.imul(ah8, bh3)) | 0;
    lo = (lo + Math.imul(al7, bl4)) | 0;
    mid = (mid + Math.imul(al7, bh4)) | 0;
    mid = (mid + Math.imul(ah7, bl4)) | 0;
    hi = (hi + Math.imul(ah7, bh4)) | 0;
    lo = (lo + Math.imul(al6, bl5)) | 0;
    mid = (mid + Math.imul(al6, bh5)) | 0;
    mid = (mid + Math.imul(ah6, bl5)) | 0;
    hi = (hi + Math.imul(ah6, bh5)) | 0;
    lo = (lo + Math.imul(al5, bl6)) | 0;
    mid = (mid + Math.imul(al5, bh6)) | 0;
    mid = (mid + Math.imul(ah5, bl6)) | 0;
    hi = (hi + Math.imul(ah5, bh6)) | 0;
    lo = (lo + Math.imul(al4, bl7)) | 0;
    mid = (mid + Math.imul(al4, bh7)) | 0;
    mid = (mid + Math.imul(ah4, bl7)) | 0;
    hi = (hi + Math.imul(ah4, bh7)) | 0;
    lo = (lo + Math.imul(al3, bl8)) | 0;
    mid = (mid + Math.imul(al3, bh8)) | 0;
    mid = (mid + Math.imul(ah3, bl8)) | 0;
    hi = (hi + Math.imul(ah3, bh8)) | 0;
    lo = (lo + Math.imul(al2, bl9)) | 0;
    mid = (mid + Math.imul(al2, bh9)) | 0;
    mid = (mid + Math.imul(ah2, bl9)) | 0;
    hi = (hi + Math.imul(ah2, bh9)) | 0;
    var w11 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w11 >>> 26)) | 0;
    w11 &= 0x3ffffff;
    /* k = 12 */
    lo = Math.imul(al9, bl3);
    mid = Math.imul(al9, bh3);
    mid = (mid + Math.imul(ah9, bl3)) | 0;
    hi = Math.imul(ah9, bh3);
    lo = (lo + Math.imul(al8, bl4)) | 0;
    mid = (mid + Math.imul(al8, bh4)) | 0;
    mid = (mid + Math.imul(ah8, bl4)) | 0;
    hi = (hi + Math.imul(ah8, bh4)) | 0;
    lo = (lo + Math.imul(al7, bl5)) | 0;
    mid = (mid + Math.imul(al7, bh5)) | 0;
    mid = (mid + Math.imul(ah7, bl5)) | 0;
    hi = (hi + Math.imul(ah7, bh5)) | 0;
    lo = (lo + Math.imul(al6, bl6)) | 0;
    mid = (mid + Math.imul(al6, bh6)) | 0;
    mid = (mid + Math.imul(ah6, bl6)) | 0;
    hi = (hi + Math.imul(ah6, bh6)) | 0;
    lo = (lo + Math.imul(al5, bl7)) | 0;
    mid = (mid + Math.imul(al5, bh7)) | 0;
    mid = (mid + Math.imul(ah5, bl7)) | 0;
    hi = (hi + Math.imul(ah5, bh7)) | 0;
    lo = (lo + Math.imul(al4, bl8)) | 0;
    mid = (mid + Math.imul(al4, bh8)) | 0;
    mid = (mid + Math.imul(ah4, bl8)) | 0;
    hi = (hi + Math.imul(ah4, bh8)) | 0;
    lo = (lo + Math.imul(al3, bl9)) | 0;
    mid = (mid + Math.imul(al3, bh9)) | 0;
    mid = (mid + Math.imul(ah3, bl9)) | 0;
    hi = (hi + Math.imul(ah3, bh9)) | 0;
    var w12 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w12 >>> 26)) | 0;
    w12 &= 0x3ffffff;
    /* k = 13 */
    lo = Math.imul(al9, bl4);
    mid = Math.imul(al9, bh4);
    mid = (mid + Math.imul(ah9, bl4)) | 0;
    hi = Math.imul(ah9, bh4);
    lo = (lo + Math.imul(al8, bl5)) | 0;
    mid = (mid + Math.imul(al8, bh5)) | 0;
    mid = (mid + Math.imul(ah8, bl5)) | 0;
    hi = (hi + Math.imul(ah8, bh5)) | 0;
    lo = (lo + Math.imul(al7, bl6)) | 0;
    mid = (mid + Math.imul(al7, bh6)) | 0;
    mid = (mid + Math.imul(ah7, bl6)) | 0;
    hi = (hi + Math.imul(ah7, bh6)) | 0;
    lo = (lo + Math.imul(al6, bl7)) | 0;
    mid = (mid + Math.imul(al6, bh7)) | 0;
    mid = (mid + Math.imul(ah6, bl7)) | 0;
    hi = (hi + Math.imul(ah6, bh7)) | 0;
    lo = (lo + Math.imul(al5, bl8)) | 0;
    mid = (mid + Math.imul(al5, bh8)) | 0;
    mid = (mid + Math.imul(ah5, bl8)) | 0;
    hi = (hi + Math.imul(ah5, bh8)) | 0;
    lo = (lo + Math.imul(al4, bl9)) | 0;
    mid = (mid + Math.imul(al4, bh9)) | 0;
    mid = (mid + Math.imul(ah4, bl9)) | 0;
    hi = (hi + Math.imul(ah4, bh9)) | 0;
    var w13 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w13 >>> 26)) | 0;
    w13 &= 0x3ffffff;
    /* k = 14 */
    lo = Math.imul(al9, bl5);
    mid = Math.imul(al9, bh5);
    mid = (mid + Math.imul(ah9, bl5)) | 0;
    hi = Math.imul(ah9, bh5);
    lo = (lo + Math.imul(al8, bl6)) | 0;
    mid = (mid + Math.imul(al8, bh6)) | 0;
    mid = (mid + Math.imul(ah8, bl6)) | 0;
    hi = (hi + Math.imul(ah8, bh6)) | 0;
    lo = (lo + Math.imul(al7, bl7)) | 0;
    mid = (mid + Math.imul(al7, bh7)) | 0;
    mid = (mid + Math.imul(ah7, bl7)) | 0;
    hi = (hi + Math.imul(ah7, bh7)) | 0;
    lo = (lo + Math.imul(al6, bl8)) | 0;
    mid = (mid + Math.imul(al6, bh8)) | 0;
    mid = (mid + Math.imul(ah6, bl8)) | 0;
    hi = (hi + Math.imul(ah6, bh8)) | 0;
    lo = (lo + Math.imul(al5, bl9)) | 0;
    mid = (mid + Math.imul(al5, bh9)) | 0;
    mid = (mid + Math.imul(ah5, bl9)) | 0;
    hi = (hi + Math.imul(ah5, bh9)) | 0;
    var w14 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w14 >>> 26)) | 0;
    w14 &= 0x3ffffff;
    /* k = 15 */
    lo = Math.imul(al9, bl6);
    mid = Math.imul(al9, bh6);
    mid = (mid + Math.imul(ah9, bl6)) | 0;
    hi = Math.imul(ah9, bh6);
    lo = (lo + Math.imul(al8, bl7)) | 0;
    mid = (mid + Math.imul(al8, bh7)) | 0;
    mid = (mid + Math.imul(ah8, bl7)) | 0;
    hi = (hi + Math.imul(ah8, bh7)) | 0;
    lo = (lo + Math.imul(al7, bl8)) | 0;
    mid = (mid + Math.imul(al7, bh8)) | 0;
    mid = (mid + Math.imul(ah7, bl8)) | 0;
    hi = (hi + Math.imul(ah7, bh8)) | 0;
    lo = (lo + Math.imul(al6, bl9)) | 0;
    mid = (mid + Math.imul(al6, bh9)) | 0;
    mid = (mid + Math.imul(ah6, bl9)) | 0;
    hi = (hi + Math.imul(ah6, bh9)) | 0;
    var w15 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w15 >>> 26)) | 0;
    w15 &= 0x3ffffff;
    /* k = 16 */
    lo = Math.imul(al9, bl7);
    mid = Math.imul(al9, bh7);
    mid = (mid + Math.imul(ah9, bl7)) | 0;
    hi = Math.imul(ah9, bh7);
    lo = (lo + Math.imul(al8, bl8)) | 0;
    mid = (mid + Math.imul(al8, bh8)) | 0;
    mid = (mid + Math.imul(ah8, bl8)) | 0;
    hi = (hi + Math.imul(ah8, bh8)) | 0;
    lo = (lo + Math.imul(al7, bl9)) | 0;
    mid = (mid + Math.imul(al7, bh9)) | 0;
    mid = (mid + Math.imul(ah7, bl9)) | 0;
    hi = (hi + Math.imul(ah7, bh9)) | 0;
    var w16 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w16 >>> 26)) | 0;
    w16 &= 0x3ffffff;
    /* k = 17 */
    lo = Math.imul(al9, bl8);
    mid = Math.imul(al9, bh8);
    mid = (mid + Math.imul(ah9, bl8)) | 0;
    hi = Math.imul(ah9, bh8);
    lo = (lo + Math.imul(al8, bl9)) | 0;
    mid = (mid + Math.imul(al8, bh9)) | 0;
    mid = (mid + Math.imul(ah8, bl9)) | 0;
    hi = (hi + Math.imul(ah8, bh9)) | 0;
    var w17 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w17 >>> 26)) | 0;
    w17 &= 0x3ffffff;
    /* k = 18 */
    lo = Math.imul(al9, bl9);
    mid = Math.imul(al9, bh9);
    mid = (mid + Math.imul(ah9, bl9)) | 0;
    hi = Math.imul(ah9, bh9);
    var w18 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w18 >>> 26)) | 0;
    w18 &= 0x3ffffff;
    o[0] = w0;
    o[1] = w1;
    o[2] = w2;
    o[3] = w3;
    o[4] = w4;
    o[5] = w5;
    o[6] = w6;
    o[7] = w7;
    o[8] = w8;
    o[9] = w9;
    o[10] = w10;
    o[11] = w11;
    o[12] = w12;
    o[13] = w13;
    o[14] = w14;
    o[15] = w15;
    o[16] = w16;
    o[17] = w17;
    o[18] = w18;
    if (c !== 0) {
      o[19] = c;
      out.length++;
    }
    return out;
  };

  // Polyfill comb
  if (!Math.imul) {
    comb10MulTo = smallMulTo;
  }

  function bigMulTo (self, num, out) {
    out.negative = num.negative ^ self.negative;
    out.length = self.length + num.length;

    var carry = 0;
    var hncarry = 0;
    for (var k = 0; k < out.length - 1; k++) {
      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
      // note that ncarry could be >= 0x3ffffff
      var ncarry = hncarry;
      hncarry = 0;
      var rword = carry & 0x3ffffff;
      var maxJ = Math.min(k, num.length - 1);
      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
        var i = k - j;
        var a = self.words[i] | 0;
        var b = num.words[j] | 0;
        var r = a * b;

        var lo = r & 0x3ffffff;
        ncarry = (ncarry + ((r / 0x4000000) | 0)) | 0;
        lo = (lo + rword) | 0;
        rword = lo & 0x3ffffff;
        ncarry = (ncarry + (lo >>> 26)) | 0;

        hncarry += ncarry >>> 26;
        ncarry &= 0x3ffffff;
      }
      out.words[k] = rword;
      carry = ncarry;
      ncarry = hncarry;
    }
    if (carry !== 0) {
      out.words[k] = carry;
    } else {
      out.length--;
    }

    return out.strip();
  }

  function jumboMulTo (self, num, out) {
    var fftm = new FFTM();
    return fftm.mulp(self, num, out);
  }

  BN.prototype.mulTo = function mulTo (num, out) {
    var res;
    var len = this.length + num.length;
    if (this.length === 10 && num.length === 10) {
      res = comb10MulTo(this, num, out);
    } else if (len < 63) {
      res = smallMulTo(this, num, out);
    } else if (len < 1024) {
      res = bigMulTo(this, num, out);
    } else {
      res = jumboMulTo(this, num, out);
    }

    return res;
  };

  // Cooley-Tukey algorithm for FFT
  // slightly revisited to rely on looping instead of recursion

  function FFTM (x, y) {
    this.x = x;
    this.y = y;
  }

  FFTM.prototype.makeRBT = function makeRBT (N) {
    var t = new Array(N);
    var l = BN.prototype._countBits(N) - 1;
    for (var i = 0; i < N; i++) {
      t[i] = this.revBin(i, l, N);
    }

    return t;
  };

  // Returns binary-reversed representation of `x`
  FFTM.prototype.revBin = function revBin (x, l, N) {
    if (x === 0 || x === N - 1) return x;

    var rb = 0;
    for (var i = 0; i < l; i++) {
      rb |= (x & 1) << (l - i - 1);
      x >>= 1;
    }

    return rb;
  };

  // Performs "tweedling" phase, therefore 'emulating'
  // behaviour of the recursive algorithm
  FFTM.prototype.permute = function permute (rbt, rws, iws, rtws, itws, N) {
    for (var i = 0; i < N; i++) {
      rtws[i] = rws[rbt[i]];
      itws[i] = iws[rbt[i]];
    }
  };

  FFTM.prototype.transform = function transform (rws, iws, rtws, itws, N, rbt) {
    this.permute(rbt, rws, iws, rtws, itws, N);

    for (var s = 1; s < N; s <<= 1) {
      var l = s << 1;

      var rtwdf = Math.cos(2 * Math.PI / l);
      var itwdf = Math.sin(2 * Math.PI / l);

      for (var p = 0; p < N; p += l) {
        var rtwdf_ = rtwdf;
        var itwdf_ = itwdf;

        for (var j = 0; j < s; j++) {
          var re = rtws[p + j];
          var ie = itws[p + j];

          var ro = rtws[p + j + s];
          var io = itws[p + j + s];

          var rx = rtwdf_ * ro - itwdf_ * io;

          io = rtwdf_ * io + itwdf_ * ro;
          ro = rx;

          rtws[p + j] = re + ro;
          itws[p + j] = ie + io;

          rtws[p + j + s] = re - ro;
          itws[p + j + s] = ie - io;

          /* jshint maxdepth : false */
          if (j !== l) {
            rx = rtwdf * rtwdf_ - itwdf * itwdf_;

            itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
            rtwdf_ = rx;
          }
        }
      }
    }
  };

  FFTM.prototype.guessLen13b = function guessLen13b (n, m) {
    var N = Math.max(m, n) | 1;
    var odd = N & 1;
    var i = 0;
    for (N = N / 2 | 0; N; N = N >>> 1) {
      i++;
    }

    return 1 << i + 1 + odd;
  };

  FFTM.prototype.conjugate = function conjugate (rws, iws, N) {
    if (N <= 1) return;

    for (var i = 0; i < N / 2; i++) {
      var t = rws[i];

      rws[i] = rws[N - i - 1];
      rws[N - i - 1] = t;

      t = iws[i];

      iws[i] = -iws[N - i - 1];
      iws[N - i - 1] = -t;
    }
  };

  FFTM.prototype.normalize13b = function normalize13b (ws, N) {
    var carry = 0;
    for (var i = 0; i < N / 2; i++) {
      var w = Math.round(ws[2 * i + 1] / N) * 0x2000 +
        Math.round(ws[2 * i] / N) +
        carry;

      ws[i] = w & 0x3ffffff;

      if (w < 0x4000000) {
        carry = 0;
      } else {
        carry = w / 0x4000000 | 0;
      }
    }

    return ws;
  };

  FFTM.prototype.convert13b = function convert13b (ws, len, rws, N) {
    var carry = 0;
    for (var i = 0; i < len; i++) {
      carry = carry + (ws[i] | 0);

      rws[2 * i] = carry & 0x1fff; carry = carry >>> 13;
      rws[2 * i + 1] = carry & 0x1fff; carry = carry >>> 13;
    }

    // Pad with zeroes
    for (i = 2 * len; i < N; ++i) {
      rws[i] = 0;
    }

    assert(carry === 0);
    assert((carry & ~0x1fff) === 0);
  };

  FFTM.prototype.stub = function stub (N) {
    var ph = new Array(N);
    for (var i = 0; i < N; i++) {
      ph[i] = 0;
    }

    return ph;
  };

  FFTM.prototype.mulp = function mulp (x, y, out) {
    var N = 2 * this.guessLen13b(x.length, y.length);

    var rbt = this.makeRBT(N);

    var _ = this.stub(N);

    var rws = new Array(N);
    var rwst = new Array(N);
    var iwst = new Array(N);

    var nrws = new Array(N);
    var nrwst = new Array(N);
    var niwst = new Array(N);

    var rmws = out.words;
    rmws.length = N;

    this.convert13b(x.words, x.length, rws, N);
    this.convert13b(y.words, y.length, nrws, N);

    this.transform(rws, _, rwst, iwst, N, rbt);
    this.transform(nrws, _, nrwst, niwst, N, rbt);

    for (var i = 0; i < N; i++) {
      var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
      iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
      rwst[i] = rx;
    }

    this.conjugate(rwst, iwst, N);
    this.transform(rwst, iwst, rmws, _, N, rbt);
    this.conjugate(rmws, _, N);
    this.normalize13b(rmws, N);

    out.negative = x.negative ^ y.negative;
    out.length = x.length + y.length;
    return out.strip();
  };

  // Multiply `this` by `num`
  BN.prototype.mul = function mul (num) {
    var out = new BN(null);
    out.words = new Array(this.length + num.length);
    return this.mulTo(num, out);
  };

  // Multiply employing FFT
  BN.prototype.mulf = function mulf (num) {
    var out = new BN(null);
    out.words = new Array(this.length + num.length);
    return jumboMulTo(this, num, out);
  };

  // In-place Multiplication
  BN.prototype.imul = function imul (num) {
    return this.clone().mulTo(num, this);
  };

  BN.prototype.imuln = function imuln (num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);

    // Carry
    var carry = 0;
    for (var i = 0; i < this.length; i++) {
      var w = (this.words[i] | 0) * num;
      var lo = (w & 0x3ffffff) + (carry & 0x3ffffff);
      carry >>= 26;
      carry += (w / 0x4000000) | 0;
      // NOTE: lo is 27bit maximum
      carry += lo >>> 26;
      this.words[i] = lo & 0x3ffffff;
    }

    if (carry !== 0) {
      this.words[i] = carry;
      this.length++;
    }

    return this;
  };

  BN.prototype.muln = function muln (num) {
    return this.clone().imuln(num);
  };

  // `this` * `this`
  BN.prototype.sqr = function sqr () {
    return this.mul(this);
  };

  // `this` * `this` in-place
  BN.prototype.isqr = function isqr () {
    return this.imul(this.clone());
  };

  // Math.pow(`this`, `num`)
  BN.prototype.pow = function pow (num) {
    var w = toBitArray(num);
    if (w.length === 0) return new BN(1);

    // Skip leading zeroes
    var res = this;
    for (var i = 0; i < w.length; i++, res = res.sqr()) {
      if (w[i] !== 0) break;
    }

    if (++i < w.length) {
      for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
        if (w[i] === 0) continue;

        res = res.mul(q);
      }
    }

    return res;
  };

  // Shift-left in-place
  BN.prototype.iushln = function iushln (bits) {
    assert(typeof bits === 'number' && bits >= 0);
    var r = bits % 26;
    var s = (bits - r) / 26;
    var carryMask = (0x3ffffff >>> (26 - r)) << (26 - r);
    var i;

    if (r !== 0) {
      var carry = 0;

      for (i = 0; i < this.length; i++) {
        var newCarry = this.words[i] & carryMask;
        var c = ((this.words[i] | 0) - newCarry) << r;
        this.words[i] = c | carry;
        carry = newCarry >>> (26 - r);
      }

      if (carry) {
        this.words[i] = carry;
        this.length++;
      }
    }

    if (s !== 0) {
      for (i = this.length - 1; i >= 0; i--) {
        this.words[i + s] = this.words[i];
      }

      for (i = 0; i < s; i++) {
        this.words[i] = 0;
      }

      this.length += s;
    }

    return this.strip();
  };

  BN.prototype.ishln = function ishln (bits) {
    // TODO(indutny): implement me
    assert(this.negative === 0);
    return this.iushln(bits);
  };

  // Shift-right in-place
  // NOTE: `hint` is a lowest bit before trailing zeroes
  // NOTE: if `extended` is present - it will be filled with destroyed bits
  BN.prototype.iushrn = function iushrn (bits, hint, extended) {
    assert(typeof bits === 'number' && bits >= 0);
    var h;
    if (hint) {
      h = (hint - (hint % 26)) / 26;
    } else {
      h = 0;
    }

    var r = bits % 26;
    var s = Math.min((bits - r) / 26, this.length);
    var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
    var maskedWords = extended;

    h -= s;
    h = Math.max(0, h);

    // Extended mode, copy masked part
    if (maskedWords) {
      for (var i = 0; i < s; i++) {
        maskedWords.words[i] = this.words[i];
      }
      maskedWords.length = s;
    }

    if (s === 0) {
      // No-op, we should not move anything at all
    } else if (this.length > s) {
      this.length -= s;
      for (i = 0; i < this.length; i++) {
        this.words[i] = this.words[i + s];
      }
    } else {
      this.words[0] = 0;
      this.length = 1;
    }

    var carry = 0;
    for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
      var word = this.words[i] | 0;
      this.words[i] = (carry << (26 - r)) | (word >>> r);
      carry = word & mask;
    }

    // Push carried bits as a mask
    if (maskedWords && carry !== 0) {
      maskedWords.words[maskedWords.length++] = carry;
    }

    if (this.length === 0) {
      this.words[0] = 0;
      this.length = 1;
    }

    return this.strip();
  };

  BN.prototype.ishrn = function ishrn (bits, hint, extended) {
    // TODO(indutny): implement me
    assert(this.negative === 0);
    return this.iushrn(bits, hint, extended);
  };

  // Shift-left
  BN.prototype.shln = function shln (bits) {
    return this.clone().ishln(bits);
  };

  BN.prototype.ushln = function ushln (bits) {
    return this.clone().iushln(bits);
  };

  // Shift-right
  BN.prototype.shrn = function shrn (bits) {
    return this.clone().ishrn(bits);
  };

  BN.prototype.ushrn = function ushrn (bits) {
    return this.clone().iushrn(bits);
  };

  // Test if n bit is set
  BN.prototype.testn = function testn (bit) {
    assert(typeof bit === 'number' && bit >= 0);
    var r = bit % 26;
    var s = (bit - r) / 26;
    var q = 1 << r;

    // Fast case: bit is much higher than all existing words
    if (this.length <= s) return false;

    // Check bit and return
    var w = this.words[s];

    return !!(w & q);
  };

  // Return only lowers bits of number (in-place)
  BN.prototype.imaskn = function imaskn (bits) {
    assert(typeof bits === 'number' && bits >= 0);
    var r = bits % 26;
    var s = (bits - r) / 26;

    assert(this.negative === 0, 'imaskn works only with positive numbers');

    if (this.length <= s) {
      return this;
    }

    if (r !== 0) {
      s++;
    }
    this.length = Math.min(s, this.length);

    if (r !== 0) {
      var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
      this.words[this.length - 1] &= mask;
    }

    return this.strip();
  };

  // Return only lowers bits of number
  BN.prototype.maskn = function maskn (bits) {
    return this.clone().imaskn(bits);
  };

  // Add plain number `num` to `this`
  BN.prototype.iaddn = function iaddn (num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);
    if (num < 0) return this.isubn(-num);

    // Possible sign change
    if (this.negative !== 0) {
      if (this.length === 1 && (this.words[0] | 0) < num) {
        this.words[0] = num - (this.words[0] | 0);
        this.negative = 0;
        return this;
      }

      this.negative = 0;
      this.isubn(num);
      this.negative = 1;
      return this;
    }

    // Add without checks
    return this._iaddn(num);
  };

  BN.prototype._iaddn = function _iaddn (num) {
    this.words[0] += num;

    // Carry
    for (var i = 0; i < this.length && this.words[i] >= 0x4000000; i++) {
      this.words[i] -= 0x4000000;
      if (i === this.length - 1) {
        this.words[i + 1] = 1;
      } else {
        this.words[i + 1]++;
      }
    }
    this.length = Math.max(this.length, i + 1);

    return this;
  };

  // Subtract plain number `num` from `this`
  BN.prototype.isubn = function isubn (num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);
    if (num < 0) return this.iaddn(-num);

    if (this.negative !== 0) {
      this.negative = 0;
      this.iaddn(num);
      this.negative = 1;
      return this;
    }

    this.words[0] -= num;

    if (this.length === 1 && this.words[0] < 0) {
      this.words[0] = -this.words[0];
      this.negative = 1;
    } else {
      // Carry
      for (var i = 0; i < this.length && this.words[i] < 0; i++) {
        this.words[i] += 0x4000000;
        this.words[i + 1] -= 1;
      }
    }

    return this.strip();
  };

  BN.prototype.addn = function addn (num) {
    return this.clone().iaddn(num);
  };

  BN.prototype.subn = function subn (num) {
    return this.clone().isubn(num);
  };

  BN.prototype.iabs = function iabs () {
    this.negative = 0;

    return this;
  };

  BN.prototype.abs = function abs () {
    return this.clone().iabs();
  };

  BN.prototype._ishlnsubmul = function _ishlnsubmul (num, mul, shift) {
    var len = num.length + shift;
    var i;

    this._expand(len);

    var w;
    var carry = 0;
    for (i = 0; i < num.length; i++) {
      w = (this.words[i + shift] | 0) + carry;
      var right = (num.words[i] | 0) * mul;
      w -= right & 0x3ffffff;
      carry = (w >> 26) - ((right / 0x4000000) | 0);
      this.words[i + shift] = w & 0x3ffffff;
    }
    for (; i < this.length - shift; i++) {
      w = (this.words[i + shift] | 0) + carry;
      carry = w >> 26;
      this.words[i + shift] = w & 0x3ffffff;
    }

    if (carry === 0) return this.strip();

    // Subtraction overflow
    assert(carry === -1);
    carry = 0;
    for (i = 0; i < this.length; i++) {
      w = -(this.words[i] | 0) + carry;
      carry = w >> 26;
      this.words[i] = w & 0x3ffffff;
    }
    this.negative = 1;

    return this.strip();
  };

  BN.prototype._wordDiv = function _wordDiv (num, mode) {
    var shift = this.length - num.length;

    var a = this.clone();
    var b = num;

    // Normalize
    var bhi = b.words[b.length - 1] | 0;
    var bhiBits = this._countBits(bhi);
    shift = 26 - bhiBits;
    if (shift !== 0) {
      b = b.ushln(shift);
      a.iushln(shift);
      bhi = b.words[b.length - 1] | 0;
    }

    // Initialize quotient
    var m = a.length - b.length;
    var q;

    if (mode !== 'mod') {
      q = new BN(null);
      q.length = m + 1;
      q.words = new Array(q.length);
      for (var i = 0; i < q.length; i++) {
        q.words[i] = 0;
      }
    }

    var diff = a.clone()._ishlnsubmul(b, 1, m);
    if (diff.negative === 0) {
      a = diff;
      if (q) {
        q.words[m] = 1;
      }
    }

    for (var j = m - 1; j >= 0; j--) {
      var qj = (a.words[b.length + j] | 0) * 0x4000000 +
        (a.words[b.length + j - 1] | 0);

      // NOTE: (qj / bhi) is (0x3ffffff * 0x4000000 + 0x3ffffff) / 0x2000000 max
      // (0x7ffffff)
      qj = Math.min((qj / bhi) | 0, 0x3ffffff);

      a._ishlnsubmul(b, qj, j);
      while (a.negative !== 0) {
        qj--;
        a.negative = 0;
        a._ishlnsubmul(b, 1, j);
        if (!a.isZero()) {
          a.negative ^= 1;
        }
      }
      if (q) {
        q.words[j] = qj;
      }
    }
    if (q) {
      q.strip();
    }
    a.strip();

    // Denormalize
    if (mode !== 'div' && shift !== 0) {
      a.iushrn(shift);
    }

    return {
      div: q || null,
      mod: a
    };
  };

  // NOTE: 1) `mode` can be set to `mod` to request mod only,
  //       to `div` to request div only, or be absent to
  //       request both div & mod
  //       2) `positive` is true if unsigned mod is requested
  BN.prototype.divmod = function divmod (num, mode, positive) {
    assert(!num.isZero());

    if (this.isZero()) {
      return {
        div: new BN(0),
        mod: new BN(0)
      };
    }

    var div, mod, res;
    if (this.negative !== 0 && num.negative === 0) {
      res = this.neg().divmod(num, mode);

      if (mode !== 'mod') {
        div = res.div.neg();
      }

      if (mode !== 'div') {
        mod = res.mod.neg();
        if (positive && mod.negative !== 0) {
          mod.iadd(num);
        }
      }

      return {
        div: div,
        mod: mod
      };
    }

    if (this.negative === 0 && num.negative !== 0) {
      res = this.divmod(num.neg(), mode);

      if (mode !== 'mod') {
        div = res.div.neg();
      }

      return {
        div: div,
        mod: res.mod
      };
    }

    if ((this.negative & num.negative) !== 0) {
      res = this.neg().divmod(num.neg(), mode);

      if (mode !== 'div') {
        mod = res.mod.neg();
        if (positive && mod.negative !== 0) {
          mod.isub(num);
        }
      }

      return {
        div: res.div,
        mod: mod
      };
    }

    // Both numbers are positive at this point

    // Strip both numbers to approximate shift value
    if (num.length > this.length || this.cmp(num) < 0) {
      return {
        div: new BN(0),
        mod: this
      };
    }

    // Very short reduction
    if (num.length === 1) {
      if (mode === 'div') {
        return {
          div: this.divn(num.words[0]),
          mod: null
        };
      }

      if (mode === 'mod') {
        return {
          div: null,
          mod: new BN(this.modn(num.words[0]))
        };
      }

      return {
        div: this.divn(num.words[0]),
        mod: new BN(this.modn(num.words[0]))
      };
    }

    return this._wordDiv(num, mode);
  };

  // Find `this` / `num`
  BN.prototype.div = function div (num) {
    return this.divmod(num, 'div', false).div;
  };

  // Find `this` % `num`
  BN.prototype.mod = function mod (num) {
    return this.divmod(num, 'mod', false).mod;
  };

  BN.prototype.umod = function umod (num) {
    return this.divmod(num, 'mod', true).mod;
  };

  // Find Round(`this` / `num`)
  BN.prototype.divRound = function divRound (num) {
    var dm = this.divmod(num);

    // Fast case - exact division
    if (dm.mod.isZero()) return dm.div;

    var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;

    var half = num.ushrn(1);
    var r2 = num.andln(1);
    var cmp = mod.cmp(half);

    // Round down
    if (cmp < 0 || r2 === 1 && cmp === 0) return dm.div;

    // Round up
    return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
  };

  BN.prototype.modn = function modn (num) {
    assert(num <= 0x3ffffff);
    var p = (1 << 26) % num;

    var acc = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      acc = (p * acc + (this.words[i] | 0)) % num;
    }

    return acc;
  };

  // In-place division by number
  BN.prototype.idivn = function idivn (num) {
    assert(num <= 0x3ffffff);

    var carry = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      var w = (this.words[i] | 0) + carry * 0x4000000;
      this.words[i] = (w / num) | 0;
      carry = w % num;
    }

    return this.strip();
  };

  BN.prototype.divn = function divn (num) {
    return this.clone().idivn(num);
  };

  BN.prototype.egcd = function egcd (p) {
    assert(p.negative === 0);
    assert(!p.isZero());

    var x = this;
    var y = p.clone();

    if (x.negative !== 0) {
      x = x.umod(p);
    } else {
      x = x.clone();
    }

    // A * x + B * y = x
    var A = new BN(1);
    var B = new BN(0);

    // C * x + D * y = y
    var C = new BN(0);
    var D = new BN(1);

    var g = 0;

    while (x.isEven() && y.isEven()) {
      x.iushrn(1);
      y.iushrn(1);
      ++g;
    }

    var yp = y.clone();
    var xp = x.clone();

    while (!x.isZero()) {
      for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
      if (i > 0) {
        x.iushrn(i);
        while (i-- > 0) {
          if (A.isOdd() || B.isOdd()) {
            A.iadd(yp);
            B.isub(xp);
          }

          A.iushrn(1);
          B.iushrn(1);
        }
      }

      for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
      if (j > 0) {
        y.iushrn(j);
        while (j-- > 0) {
          if (C.isOdd() || D.isOdd()) {
            C.iadd(yp);
            D.isub(xp);
          }

          C.iushrn(1);
          D.iushrn(1);
        }
      }

      if (x.cmp(y) >= 0) {
        x.isub(y);
        A.isub(C);
        B.isub(D);
      } else {
        y.isub(x);
        C.isub(A);
        D.isub(B);
      }
    }

    return {
      a: C,
      b: D,
      gcd: y.iushln(g)
    };
  };

  // This is reduced incarnation of the binary EEA
  // above, designated to invert members of the
  // _prime_ fields F(p) at a maximal speed
  BN.prototype._invmp = function _invmp (p) {
    assert(p.negative === 0);
    assert(!p.isZero());

    var a = this;
    var b = p.clone();

    if (a.negative !== 0) {
      a = a.umod(p);
    } else {
      a = a.clone();
    }

    var x1 = new BN(1);
    var x2 = new BN(0);

    var delta = b.clone();

    while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
      for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
      if (i > 0) {
        a.iushrn(i);
        while (i-- > 0) {
          if (x1.isOdd()) {
            x1.iadd(delta);
          }

          x1.iushrn(1);
        }
      }

      for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
      if (j > 0) {
        b.iushrn(j);
        while (j-- > 0) {
          if (x2.isOdd()) {
            x2.iadd(delta);
          }

          x2.iushrn(1);
        }
      }

      if (a.cmp(b) >= 0) {
        a.isub(b);
        x1.isub(x2);
      } else {
        b.isub(a);
        x2.isub(x1);
      }
    }

    var res;
    if (a.cmpn(1) === 0) {
      res = x1;
    } else {
      res = x2;
    }

    if (res.cmpn(0) < 0) {
      res.iadd(p);
    }

    return res;
  };

  BN.prototype.gcd = function gcd (num) {
    if (this.isZero()) return num.abs();
    if (num.isZero()) return this.abs();

    var a = this.clone();
    var b = num.clone();
    a.negative = 0;
    b.negative = 0;

    // Remove common factor of two
    for (var shift = 0; a.isEven() && b.isEven(); shift++) {
      a.iushrn(1);
      b.iushrn(1);
    }

    do {
      while (a.isEven()) {
        a.iushrn(1);
      }
      while (b.isEven()) {
        b.iushrn(1);
      }

      var r = a.cmp(b);
      if (r < 0) {
        // Swap `a` and `b` to make `a` always bigger than `b`
        var t = a;
        a = b;
        b = t;
      } else if (r === 0 || b.cmpn(1) === 0) {
        break;
      }

      a.isub(b);
    } while (true);

    return b.iushln(shift);
  };

  // Invert number in the field F(num)
  BN.prototype.invm = function invm (num) {
    return this.egcd(num).a.umod(num);
  };

  BN.prototype.isEven = function isEven () {
    return (this.words[0] & 1) === 0;
  };

  BN.prototype.isOdd = function isOdd () {
    return (this.words[0] & 1) === 1;
  };

  // And first word and num
  BN.prototype.andln = function andln (num) {
    return this.words[0] & num;
  };

  // Increment at the bit position in-line
  BN.prototype.bincn = function bincn (bit) {
    assert(typeof bit === 'number');
    var r = bit % 26;
    var s = (bit - r) / 26;
    var q = 1 << r;

    // Fast case: bit is much higher than all existing words
    if (this.length <= s) {
      this._expand(s + 1);
      this.words[s] |= q;
      return this;
    }

    // Add bit and propagate, if needed
    var carry = q;
    for (var i = s; carry !== 0 && i < this.length; i++) {
      var w = this.words[i] | 0;
      w += carry;
      carry = w >>> 26;
      w &= 0x3ffffff;
      this.words[i] = w;
    }
    if (carry !== 0) {
      this.words[i] = carry;
      this.length++;
    }
    return this;
  };

  BN.prototype.isZero = function isZero () {
    return this.length === 1 && this.words[0] === 0;
  };

  BN.prototype.cmpn = function cmpn (num) {
    var negative = num < 0;

    if (this.negative !== 0 && !negative) return -1;
    if (this.negative === 0 && negative) return 1;

    this.strip();

    var res;
    if (this.length > 1) {
      res = 1;
    } else {
      if (negative) {
        num = -num;
      }

      assert(num <= 0x3ffffff, 'Number is too big');

      var w = this.words[0] | 0;
      res = w === num ? 0 : w < num ? -1 : 1;
    }
    if (this.negative !== 0) return -res | 0;
    return res;
  };

  // Compare two numbers and return:
  // 1 - if `this` > `num`
  // 0 - if `this` == `num`
  // -1 - if `this` < `num`
  BN.prototype.cmp = function cmp (num) {
    if (this.negative !== 0 && num.negative === 0) return -1;
    if (this.negative === 0 && num.negative !== 0) return 1;

    var res = this.ucmp(num);
    if (this.negative !== 0) return -res | 0;
    return res;
  };

  // Unsigned comparison
  BN.prototype.ucmp = function ucmp (num) {
    // At this point both numbers have the same sign
    if (this.length > num.length) return 1;
    if (this.length < num.length) return -1;

    var res = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      var a = this.words[i] | 0;
      var b = num.words[i] | 0;

      if (a === b) continue;
      if (a < b) {
        res = -1;
      } else if (a > b) {
        res = 1;
      }
      break;
    }
    return res;
  };

  BN.prototype.gtn = function gtn (num) {
    return this.cmpn(num) === 1;
  };

  BN.prototype.gt = function gt (num) {
    return this.cmp(num) === 1;
  };

  BN.prototype.gten = function gten (num) {
    return this.cmpn(num) >= 0;
  };

  BN.prototype.gte = function gte (num) {
    return this.cmp(num) >= 0;
  };

  BN.prototype.ltn = function ltn (num) {
    return this.cmpn(num) === -1;
  };

  BN.prototype.lt = function lt (num) {
    return this.cmp(num) === -1;
  };

  BN.prototype.lten = function lten (num) {
    return this.cmpn(num) <= 0;
  };

  BN.prototype.lte = function lte (num) {
    return this.cmp(num) <= 0;
  };

  BN.prototype.eqn = function eqn (num) {
    return this.cmpn(num) === 0;
  };

  BN.prototype.eq = function eq (num) {
    return this.cmp(num) === 0;
  };

  //
  // A reduce context, could be using montgomery or something better, depending
  // on the `m` itself.
  //
  BN.red = function red (num) {
    return new Red(num);
  };

  BN.prototype.toRed = function toRed (ctx) {
    assert(!this.red, 'Already a number in reduction context');
    assert(this.negative === 0, 'red works only with positives');
    return ctx.convertTo(this)._forceRed(ctx);
  };

  BN.prototype.fromRed = function fromRed () {
    assert(this.red, 'fromRed works only with numbers in reduction context');
    return this.red.convertFrom(this);
  };

  BN.prototype._forceRed = function _forceRed (ctx) {
    this.red = ctx;
    return this;
  };

  BN.prototype.forceRed = function forceRed (ctx) {
    assert(!this.red, 'Already a number in reduction context');
    return this._forceRed(ctx);
  };

  BN.prototype.redAdd = function redAdd (num) {
    assert(this.red, 'redAdd works only with red numbers');
    return this.red.add(this, num);
  };

  BN.prototype.redIAdd = function redIAdd (num) {
    assert(this.red, 'redIAdd works only with red numbers');
    return this.red.iadd(this, num);
  };

  BN.prototype.redSub = function redSub (num) {
    assert(this.red, 'redSub works only with red numbers');
    return this.red.sub(this, num);
  };

  BN.prototype.redISub = function redISub (num) {
    assert(this.red, 'redISub works only with red numbers');
    return this.red.isub(this, num);
  };

  BN.prototype.redShl = function redShl (num) {
    assert(this.red, 'redShl works only with red numbers');
    return this.red.shl(this, num);
  };

  BN.prototype.redMul = function redMul (num) {
    assert(this.red, 'redMul works only with red numbers');
    this.red._verify2(this, num);
    return this.red.mul(this, num);
  };

  BN.prototype.redIMul = function redIMul (num) {
    assert(this.red, 'redMul works only with red numbers');
    this.red._verify2(this, num);
    return this.red.imul(this, num);
  };

  BN.prototype.redSqr = function redSqr () {
    assert(this.red, 'redSqr works only with red numbers');
    this.red._verify1(this);
    return this.red.sqr(this);
  };

  BN.prototype.redISqr = function redISqr () {
    assert(this.red, 'redISqr works only with red numbers');
    this.red._verify1(this);
    return this.red.isqr(this);
  };

  // Square root over p
  BN.prototype.redSqrt = function redSqrt () {
    assert(this.red, 'redSqrt works only with red numbers');
    this.red._verify1(this);
    return this.red.sqrt(this);
  };

  BN.prototype.redInvm = function redInvm () {
    assert(this.red, 'redInvm works only with red numbers');
    this.red._verify1(this);
    return this.red.invm(this);
  };

  // Return negative clone of `this` % `red modulo`
  BN.prototype.redNeg = function redNeg () {
    assert(this.red, 'redNeg works only with red numbers');
    this.red._verify1(this);
    return this.red.neg(this);
  };

  BN.prototype.redPow = function redPow (num) {
    assert(this.red && !num.red, 'redPow(normalNum)');
    this.red._verify1(this);
    return this.red.pow(this, num);
  };

  // Prime numbers with efficient reduction
  var primes = {
    k256: null,
    p224: null,
    p192: null,
    p25519: null
  };

  // Pseudo-Mersenne prime
  function MPrime (name, p) {
    // P = 2 ^ N - K
    this.name = name;
    this.p = new BN(p, 16);
    this.n = this.p.bitLength();
    this.k = new BN(1).iushln(this.n).isub(this.p);

    this.tmp = this._tmp();
  }

  MPrime.prototype._tmp = function _tmp () {
    var tmp = new BN(null);
    tmp.words = new Array(Math.ceil(this.n / 13));
    return tmp;
  };

  MPrime.prototype.ireduce = function ireduce (num) {
    // Assumes that `num` is less than `P^2`
    // num = HI * (2 ^ N - K) + HI * K + LO = HI * K + LO (mod P)
    var r = num;
    var rlen;

    do {
      this.split(r, this.tmp);
      r = this.imulK(r);
      r = r.iadd(this.tmp);
      rlen = r.bitLength();
    } while (rlen > this.n);

    var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
    if (cmp === 0) {
      r.words[0] = 0;
      r.length = 1;
    } else if (cmp > 0) {
      r.isub(this.p);
    } else {
      if (r.strip !== undefined) {
        // r is BN v4 instance
        r.strip();
      } else {
        // r is BN v5 instance
        r._strip();
      }
    }

    return r;
  };

  MPrime.prototype.split = function split (input, out) {
    input.iushrn(this.n, 0, out);
  };

  MPrime.prototype.imulK = function imulK (num) {
    return num.imul(this.k);
  };

  function K256 () {
    MPrime.call(
      this,
      'k256',
      'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f');
  }
  inherits(K256, MPrime);

  K256.prototype.split = function split (input, output) {
    // 256 = 9 * 26 + 22
    var mask = 0x3fffff;

    var outLen = Math.min(input.length, 9);
    for (var i = 0; i < outLen; i++) {
      output.words[i] = input.words[i];
    }
    output.length = outLen;

    if (input.length <= 9) {
      input.words[0] = 0;
      input.length = 1;
      return;
    }

    // Shift by 9 limbs
    var prev = input.words[9];
    output.words[output.length++] = prev & mask;

    for (i = 10; i < input.length; i++) {
      var next = input.words[i] | 0;
      input.words[i - 10] = ((next & mask) << 4) | (prev >>> 22);
      prev = next;
    }
    prev >>>= 22;
    input.words[i - 10] = prev;
    if (prev === 0 && input.length > 10) {
      input.length -= 10;
    } else {
      input.length -= 9;
    }
  };

  K256.prototype.imulK = function imulK (num) {
    // K = 0x1000003d1 = [ 0x40, 0x3d1 ]
    num.words[num.length] = 0;
    num.words[num.length + 1] = 0;
    num.length += 2;

    // bounded at: 0x40 * 0x3ffffff + 0x3d0 = 0x100000390
    var lo = 0;
    for (var i = 0; i < num.length; i++) {
      var w = num.words[i] | 0;
      lo += w * 0x3d1;
      num.words[i] = lo & 0x3ffffff;
      lo = w * 0x40 + ((lo / 0x4000000) | 0);
    }

    // Fast length reduction
    if (num.words[num.length - 1] === 0) {
      num.length--;
      if (num.words[num.length - 1] === 0) {
        num.length--;
      }
    }
    return num;
  };

  function P224 () {
    MPrime.call(
      this,
      'p224',
      'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001');
  }
  inherits(P224, MPrime);

  function P192 () {
    MPrime.call(
      this,
      'p192',
      'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff');
  }
  inherits(P192, MPrime);

  function P25519 () {
    // 2 ^ 255 - 19
    MPrime.call(
      this,
      '25519',
      '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed');
  }
  inherits(P25519, MPrime);

  P25519.prototype.imulK = function imulK (num) {
    // K = 0x13
    var carry = 0;
    for (var i = 0; i < num.length; i++) {
      var hi = (num.words[i] | 0) * 0x13 + carry;
      var lo = hi & 0x3ffffff;
      hi >>>= 26;

      num.words[i] = lo;
      carry = hi;
    }
    if (carry !== 0) {
      num.words[num.length++] = carry;
    }
    return num;
  };

  // Exported mostly for testing purposes, use plain name instead
  BN._prime = function prime (name) {
    // Cached version of prime
    if (primes[name]) return primes[name];

    var prime;
    if (name === 'k256') {
      prime = new K256();
    } else if (name === 'p224') {
      prime = new P224();
    } else if (name === 'p192') {
      prime = new P192();
    } else if (name === 'p25519') {
      prime = new P25519();
    } else {
      throw new Error('Unknown prime ' + name);
    }
    primes[name] = prime;

    return prime;
  };

  //
  // Base reduction engine
  //
  function Red (m) {
    if (typeof m === 'string') {
      var prime = BN._prime(m);
      this.m = prime.p;
      this.prime = prime;
    } else {
      assert(m.gtn(1), 'modulus must be greater than 1');
      this.m = m;
      this.prime = null;
    }
  }

  Red.prototype._verify1 = function _verify1 (a) {
    assert(a.negative === 0, 'red works only with positives');
    assert(a.red, 'red works only with red numbers');
  };

  Red.prototype._verify2 = function _verify2 (a, b) {
    assert((a.negative | b.negative) === 0, 'red works only with positives');
    assert(a.red && a.red === b.red,
      'red works only with red numbers');
  };

  Red.prototype.imod = function imod (a) {
    if (this.prime) return this.prime.ireduce(a)._forceRed(this);
    return a.umod(this.m)._forceRed(this);
  };

  Red.prototype.neg = function neg (a) {
    if (a.isZero()) {
      return a.clone();
    }

    return this.m.sub(a)._forceRed(this);
  };

  Red.prototype.add = function add (a, b) {
    this._verify2(a, b);

    var res = a.add(b);
    if (res.cmp(this.m) >= 0) {
      res.isub(this.m);
    }
    return res._forceRed(this);
  };

  Red.prototype.iadd = function iadd (a, b) {
    this._verify2(a, b);

    var res = a.iadd(b);
    if (res.cmp(this.m) >= 0) {
      res.isub(this.m);
    }
    return res;
  };

  Red.prototype.sub = function sub (a, b) {
    this._verify2(a, b);

    var res = a.sub(b);
    if (res.cmpn(0) < 0) {
      res.iadd(this.m);
    }
    return res._forceRed(this);
  };

  Red.prototype.isub = function isub (a, b) {
    this._verify2(a, b);

    var res = a.isub(b);
    if (res.cmpn(0) < 0) {
      res.iadd(this.m);
    }
    return res;
  };

  Red.prototype.shl = function shl (a, num) {
    this._verify1(a);
    return this.imod(a.ushln(num));
  };

  Red.prototype.imul = function imul (a, b) {
    this._verify2(a, b);
    return this.imod(a.imul(b));
  };

  Red.prototype.mul = function mul (a, b) {
    this._verify2(a, b);
    return this.imod(a.mul(b));
  };

  Red.prototype.isqr = function isqr (a) {
    return this.imul(a, a.clone());
  };

  Red.prototype.sqr = function sqr (a) {
    return this.mul(a, a);
  };

  Red.prototype.sqrt = function sqrt (a) {
    if (a.isZero()) return a.clone();

    var mod3 = this.m.andln(3);
    assert(mod3 % 2 === 1);

    // Fast case
    if (mod3 === 3) {
      var pow = this.m.add(new BN(1)).iushrn(2);
      return this.pow(a, pow);
    }

    // Tonelli-Shanks algorithm (Totally unoptimized and slow)
    //
    // Find Q and S, that Q * 2 ^ S = (P - 1)
    var q = this.m.subn(1);
    var s = 0;
    while (!q.isZero() && q.andln(1) === 0) {
      s++;
      q.iushrn(1);
    }
    assert(!q.isZero());

    var one = new BN(1).toRed(this);
    var nOne = one.redNeg();

    // Find quadratic non-residue
    // NOTE: Max is such because of generalized Riemann hypothesis.
    var lpow = this.m.subn(1).iushrn(1);
    var z = this.m.bitLength();
    z = new BN(2 * z * z).toRed(this);

    while (this.pow(z, lpow).cmp(nOne) !== 0) {
      z.redIAdd(nOne);
    }

    var c = this.pow(z, q);
    var r = this.pow(a, q.addn(1).iushrn(1));
    var t = this.pow(a, q);
    var m = s;
    while (t.cmp(one) !== 0) {
      var tmp = t;
      for (var i = 0; tmp.cmp(one) !== 0; i++) {
        tmp = tmp.redSqr();
      }
      assert(i < m);
      var b = this.pow(c, new BN(1).iushln(m - i - 1));

      r = r.redMul(b);
      c = b.redSqr();
      t = t.redMul(c);
      m = i;
    }

    return r;
  };

  Red.prototype.invm = function invm (a) {
    var inv = a._invmp(this.m);
    if (inv.negative !== 0) {
      inv.negative = 0;
      return this.imod(inv).redNeg();
    } else {
      return this.imod(inv);
    }
  };

  Red.prototype.pow = function pow (a, num) {
    if (num.isZero()) return new BN(1).toRed(this);
    if (num.cmpn(1) === 0) return a.clone();

    var windowSize = 4;
    var wnd = new Array(1 << windowSize);
    wnd[0] = new BN(1).toRed(this);
    wnd[1] = a;
    for (var i = 2; i < wnd.length; i++) {
      wnd[i] = this.mul(wnd[i - 1], a);
    }

    var res = wnd[0];
    var current = 0;
    var currentLen = 0;
    var start = num.bitLength() % 26;
    if (start === 0) {
      start = 26;
    }

    for (i = num.length - 1; i >= 0; i--) {
      var word = num.words[i];
      for (var j = start - 1; j >= 0; j--) {
        var bit = (word >> j) & 1;
        if (res !== wnd[0]) {
          res = this.sqr(res);
        }

        if (bit === 0 && current === 0) {
          currentLen = 0;
          continue;
        }

        current <<= 1;
        current |= bit;
        currentLen++;
        if (currentLen !== windowSize && (i !== 0 || j !== 0)) continue;

        res = this.mul(res, wnd[current]);
        currentLen = 0;
        current = 0;
      }
      start = 26;
    }

    return res;
  };

  Red.prototype.convertTo = function convertTo (num) {
    var r = num.umod(this.m);

    return r === num ? r.clone() : r;
  };

  Red.prototype.convertFrom = function convertFrom (num) {
    var res = num.clone();
    res.red = null;
    return res;
  };

  //
  // Montgomery method engine
  //

  BN.mont = function mont (num) {
    return new Mont(num);
  };

  function Mont (m) {
    Red.call(this, m);

    this.shift = this.m.bitLength();
    if (this.shift % 26 !== 0) {
      this.shift += 26 - (this.shift % 26);
    }

    this.r = new BN(1).iushln(this.shift);
    this.r2 = this.imod(this.r.sqr());
    this.rinv = this.r._invmp(this.m);

    this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
    this.minv = this.minv.umod(this.r);
    this.minv = this.r.sub(this.minv);
  }
  inherits(Mont, Red);

  Mont.prototype.convertTo = function convertTo (num) {
    return this.imod(num.ushln(this.shift));
  };

  Mont.prototype.convertFrom = function convertFrom (num) {
    var r = this.imod(num.mul(this.rinv));
    r.red = null;
    return r;
  };

  Mont.prototype.imul = function imul (a, b) {
    if (a.isZero() || b.isZero()) {
      a.words[0] = 0;
      a.length = 1;
      return a;
    }

    var t = a.imul(b);
    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
    var u = t.isub(c).iushrn(this.shift);
    var res = u;

    if (u.cmp(this.m) >= 0) {
      res = u.isub(this.m);
    } else if (u.cmpn(0) < 0) {
      res = u.iadd(this.m);
    }

    return res._forceRed(this);
  };

  Mont.prototype.mul = function mul (a, b) {
    if (a.isZero() || b.isZero()) return new BN(0)._forceRed(this);

    var t = a.mul(b);
    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
    var u = t.isub(c).iushrn(this.shift);
    var res = u;
    if (u.cmp(this.m) >= 0) {
      res = u.isub(this.m);
    } else if (u.cmpn(0) < 0) {
      res = u.iadd(this.m);
    }

    return res._forceRed(this);
  };

  Mont.prototype.invm = function invm (a) {
    // (AR)^-1 * R^2 = (A^-1 * R^-1) * R^2 = A^-1 * R
    var res = this.imod(a._invmp(this.m).mul(this.r2));
    return res._forceRed(this);
  };
})(typeof module === 'undefined' || module, this);

},{"buffer":27}],24:[function(require,module,exports){
'use strict'

exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  var i
  for (i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}

},{}],25:[function(require,module,exports){
(function (module, exports) {
  'use strict';

  // Utils
  function assert (val, msg) {
    if (!val) throw new Error(msg || 'Assertion failed');
  }

  // Could use `inherits` module, but don't want to move from single file
  // architecture yet.
  function inherits (ctor, superCtor) {
    ctor.super_ = superCtor;
    var TempCtor = function () {};
    TempCtor.prototype = superCtor.prototype;
    ctor.prototype = new TempCtor();
    ctor.prototype.constructor = ctor;
  }

  // BN

  function BN (number, base, endian) {
    if (BN.isBN(number)) {
      return number;
    }

    this.negative = 0;
    this.words = null;
    this.length = 0;

    // Reduction context
    this.red = null;

    if (number !== null) {
      if (base === 'le' || base === 'be') {
        endian = base;
        base = 10;
      }

      this._init(number || 0, base || 10, endian || 'be');
    }
  }
  if (typeof module === 'object') {
    module.exports = BN;
  } else {
    exports.BN = BN;
  }

  BN.BN = BN;
  BN.wordSize = 26;

  var Buffer;
  try {
    if (typeof window !== 'undefined' && typeof window.Buffer !== 'undefined') {
      Buffer = window.Buffer;
    } else {
      Buffer = require('buffer').Buffer;
    }
  } catch (e) {
  }

  BN.isBN = function isBN (num) {
    if (num instanceof BN) {
      return true;
    }

    return num !== null && typeof num === 'object' &&
      num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
  };

  BN.max = function max (left, right) {
    if (left.cmp(right) > 0) return left;
    return right;
  };

  BN.min = function min (left, right) {
    if (left.cmp(right) < 0) return left;
    return right;
  };

  BN.prototype._init = function init (number, base, endian) {
    if (typeof number === 'number') {
      return this._initNumber(number, base, endian);
    }

    if (typeof number === 'object') {
      return this._initArray(number, base, endian);
    }

    if (base === 'hex') {
      base = 16;
    }
    assert(base === (base | 0) && base >= 2 && base <= 36);

    number = number.toString().replace(/\s+/g, '');
    var start = 0;
    if (number[0] === '-') {
      start++;
      this.negative = 1;
    }

    if (start < number.length) {
      if (base === 16) {
        this._parseHex(number, start, endian);
      } else {
        this._parseBase(number, base, start);
        if (endian === 'le') {
          this._initArray(this.toArray(), base, endian);
        }
      }
    }
  };

  BN.prototype._initNumber = function _initNumber (number, base, endian) {
    if (number < 0) {
      this.negative = 1;
      number = -number;
    }
    if (number < 0x4000000) {
      this.words = [number & 0x3ffffff];
      this.length = 1;
    } else if (number < 0x10000000000000) {
      this.words = [
        number & 0x3ffffff,
        (number / 0x4000000) & 0x3ffffff
      ];
      this.length = 2;
    } else {
      assert(number < 0x20000000000000); // 2 ^ 53 (unsafe)
      this.words = [
        number & 0x3ffffff,
        (number / 0x4000000) & 0x3ffffff,
        1
      ];
      this.length = 3;
    }

    if (endian !== 'le') return;

    // Reverse the bytes
    this._initArray(this.toArray(), base, endian);
  };

  BN.prototype._initArray = function _initArray (number, base, endian) {
    // Perhaps a Uint8Array
    assert(typeof number.length === 'number');
    if (number.length <= 0) {
      this.words = [0];
      this.length = 1;
      return this;
    }

    this.length = Math.ceil(number.length / 3);
    this.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      this.words[i] = 0;
    }

    var j, w;
    var off = 0;
    if (endian === 'be') {
      for (i = number.length - 1, j = 0; i >= 0; i -= 3) {
        w = number[i] | (number[i - 1] << 8) | (number[i - 2] << 16);
        this.words[j] |= (w << off) & 0x3ffffff;
        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
        off += 24;
        if (off >= 26) {
          off -= 26;
          j++;
        }
      }
    } else if (endian === 'le') {
      for (i = 0, j = 0; i < number.length; i += 3) {
        w = number[i] | (number[i + 1] << 8) | (number[i + 2] << 16);
        this.words[j] |= (w << off) & 0x3ffffff;
        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
        off += 24;
        if (off >= 26) {
          off -= 26;
          j++;
        }
      }
    }
    return this._strip();
  };

  function parseHex4Bits (string, index) {
    var c = string.charCodeAt(index);
    // '0' - '9'
    if (c >= 48 && c <= 57) {
      return c - 48;
    // 'A' - 'F'
    } else if (c >= 65 && c <= 70) {
      return c - 55;
    // 'a' - 'f'
    } else if (c >= 97 && c <= 102) {
      return c - 87;
    } else {
      assert(false, 'Invalid character in ' + string);
    }
  }

  function parseHexByte (string, lowerBound, index) {
    var r = parseHex4Bits(string, index);
    if (index - 1 >= lowerBound) {
      r |= parseHex4Bits(string, index - 1) << 4;
    }
    return r;
  }

  BN.prototype._parseHex = function _parseHex (number, start, endian) {
    // Create possibly bigger array to ensure that it fits the number
    this.length = Math.ceil((number.length - start) / 6);
    this.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      this.words[i] = 0;
    }

    // 24-bits chunks
    var off = 0;
    var j = 0;

    var w;
    if (endian === 'be') {
      for (i = number.length - 1; i >= start; i -= 2) {
        w = parseHexByte(number, start, i) << off;
        this.words[j] |= w & 0x3ffffff;
        if (off >= 18) {
          off -= 18;
          j += 1;
          this.words[j] |= w >>> 26;
        } else {
          off += 8;
        }
      }
    } else {
      var parseLength = number.length - start;
      for (i = parseLength % 2 === 0 ? start + 1 : start; i < number.length; i += 2) {
        w = parseHexByte(number, start, i) << off;
        this.words[j] |= w & 0x3ffffff;
        if (off >= 18) {
          off -= 18;
          j += 1;
          this.words[j] |= w >>> 26;
        } else {
          off += 8;
        }
      }
    }

    this._strip();
  };

  function parseBase (str, start, end, mul) {
    var r = 0;
    var b = 0;
    var len = Math.min(str.length, end);
    for (var i = start; i < len; i++) {
      var c = str.charCodeAt(i) - 48;

      r *= mul;

      // 'a'
      if (c >= 49) {
        b = c - 49 + 0xa;

      // 'A'
      } else if (c >= 17) {
        b = c - 17 + 0xa;

      // '0' - '9'
      } else {
        b = c;
      }
      assert(c >= 0 && b < mul, 'Invalid character');
      r += b;
    }
    return r;
  }

  BN.prototype._parseBase = function _parseBase (number, base, start) {
    // Initialize as zero
    this.words = [0];
    this.length = 1;

    // Find length of limb in base
    for (var limbLen = 0, limbPow = 1; limbPow <= 0x3ffffff; limbPow *= base) {
      limbLen++;
    }
    limbLen--;
    limbPow = (limbPow / base) | 0;

    var total = number.length - start;
    var mod = total % limbLen;
    var end = Math.min(total, total - mod) + start;

    var word = 0;
    for (var i = start; i < end; i += limbLen) {
      word = parseBase(number, i, i + limbLen, base);

      this.imuln(limbPow);
      if (this.words[0] + word < 0x4000000) {
        this.words[0] += word;
      } else {
        this._iaddn(word);
      }
    }

    if (mod !== 0) {
      var pow = 1;
      word = parseBase(number, i, number.length, base);

      for (i = 0; i < mod; i++) {
        pow *= base;
      }

      this.imuln(pow);
      if (this.words[0] + word < 0x4000000) {
        this.words[0] += word;
      } else {
        this._iaddn(word);
      }
    }

    this._strip();
  };

  BN.prototype.copy = function copy (dest) {
    dest.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      dest.words[i] = this.words[i];
    }
    dest.length = this.length;
    dest.negative = this.negative;
    dest.red = this.red;
  };

  function move (dest, src) {
    dest.words = src.words;
    dest.length = src.length;
    dest.negative = src.negative;
    dest.red = src.red;
  }

  BN.prototype._move = function _move (dest) {
    move(dest, this);
  };

  BN.prototype.clone = function clone () {
    var r = new BN(null);
    this.copy(r);
    return r;
  };

  BN.prototype._expand = function _expand (size) {
    while (this.length < size) {
      this.words[this.length++] = 0;
    }
    return this;
  };

  // Remove leading `0` from `this`
  BN.prototype._strip = function strip () {
    while (this.length > 1 && this.words[this.length - 1] === 0) {
      this.length--;
    }
    return this._normSign();
  };

  BN.prototype._normSign = function _normSign () {
    // -0 = 0
    if (this.length === 1 && this.words[0] === 0) {
      this.negative = 0;
    }
    return this;
  };

  // Check Symbol.for because not everywhere where Symbol defined
  // See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol#Browser_compatibility
  if (typeof Symbol !== 'undefined' && typeof Symbol.for === 'function') {
    try {
      BN.prototype[Symbol.for('nodejs.util.inspect.custom')] = inspect;
    } catch (e) {
      BN.prototype.inspect = inspect;
    }
  } else {
    BN.prototype.inspect = inspect;
  }

  function inspect () {
    return (this.red ? '<BN-R: ' : '<BN: ') + this.toString(16) + '>';
  }

  /*

  var zeros = [];
  var groupSizes = [];
  var groupBases = [];

  var s = '';
  var i = -1;
  while (++i < BN.wordSize) {
    zeros[i] = s;
    s += '0';
  }
  groupSizes[0] = 0;
  groupSizes[1] = 0;
  groupBases[0] = 0;
  groupBases[1] = 0;
  var base = 2 - 1;
  while (++base < 36 + 1) {
    var groupSize = 0;
    var groupBase = 1;
    while (groupBase < (1 << BN.wordSize) / base) {
      groupBase *= base;
      groupSize += 1;
    }
    groupSizes[base] = groupSize;
    groupBases[base] = groupBase;
  }

  */

  var zeros = [
    '',
    '0',
    '00',
    '000',
    '0000',
    '00000',
    '000000',
    '0000000',
    '00000000',
    '000000000',
    '0000000000',
    '00000000000',
    '000000000000',
    '0000000000000',
    '00000000000000',
    '000000000000000',
    '0000000000000000',
    '00000000000000000',
    '000000000000000000',
    '0000000000000000000',
    '00000000000000000000',
    '000000000000000000000',
    '0000000000000000000000',
    '00000000000000000000000',
    '000000000000000000000000',
    '0000000000000000000000000'
  ];

  var groupSizes = [
    0, 0,
    25, 16, 12, 11, 10, 9, 8,
    8, 7, 7, 7, 7, 6, 6,
    6, 6, 6, 6, 6, 5, 5,
    5, 5, 5, 5, 5, 5, 5,
    5, 5, 5, 5, 5, 5, 5
  ];

  var groupBases = [
    0, 0,
    33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216,
    43046721, 10000000, 19487171, 35831808, 62748517, 7529536, 11390625,
    16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632,
    6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149,
    24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176
  ];

  BN.prototype.toString = function toString (base, padding) {
    base = base || 10;
    padding = padding | 0 || 1;

    var out;
    if (base === 16 || base === 'hex') {
      out = '';
      var off = 0;
      var carry = 0;
      for (var i = 0; i < this.length; i++) {
        var w = this.words[i];
        var word = (((w << off) | carry) & 0xffffff).toString(16);
        carry = (w >>> (24 - off)) & 0xffffff;
        if (carry !== 0 || i !== this.length - 1) {
          out = zeros[6 - word.length] + word + out;
        } else {
          out = word + out;
        }
        off += 2;
        if (off >= 26) {
          off -= 26;
          i--;
        }
      }
      if (carry !== 0) {
        out = carry.toString(16) + out;
      }
      while (out.length % padding !== 0) {
        out = '0' + out;
      }
      if (this.negative !== 0) {
        out = '-' + out;
      }
      return out;
    }

    if (base === (base | 0) && base >= 2 && base <= 36) {
      // var groupSize = Math.floor(BN.wordSize * Math.LN2 / Math.log(base));
      var groupSize = groupSizes[base];
      // var groupBase = Math.pow(base, groupSize);
      var groupBase = groupBases[base];
      out = '';
      var c = this.clone();
      c.negative = 0;
      while (!c.isZero()) {
        var r = c.modrn(groupBase).toString(base);
        c = c.idivn(groupBase);

        if (!c.isZero()) {
          out = zeros[groupSize - r.length] + r + out;
        } else {
          out = r + out;
        }
      }
      if (this.isZero()) {
        out = '0' + out;
      }
      while (out.length % padding !== 0) {
        out = '0' + out;
      }
      if (this.negative !== 0) {
        out = '-' + out;
      }
      return out;
    }

    assert(false, 'Base should be between 2 and 36');
  };

  BN.prototype.toNumber = function toNumber () {
    var ret = this.words[0];
    if (this.length === 2) {
      ret += this.words[1] * 0x4000000;
    } else if (this.length === 3 && this.words[2] === 0x01) {
      // NOTE: at this stage it is known that the top bit is set
      ret += 0x10000000000000 + (this.words[1] * 0x4000000);
    } else if (this.length > 2) {
      assert(false, 'Number can only safely store up to 53 bits');
    }
    return (this.negative !== 0) ? -ret : ret;
  };

  BN.prototype.toJSON = function toJSON () {
    return this.toString(16, 2);
  };

  if (Buffer) {
    BN.prototype.toBuffer = function toBuffer (endian, length) {
      return this.toArrayLike(Buffer, endian, length);
    };
  }

  BN.prototype.toArray = function toArray (endian, length) {
    return this.toArrayLike(Array, endian, length);
  };

  var allocate = function allocate (ArrayType, size) {
    if (ArrayType.allocUnsafe) {
      return ArrayType.allocUnsafe(size);
    }
    return new ArrayType(size);
  };

  BN.prototype.toArrayLike = function toArrayLike (ArrayType, endian, length) {
    this._strip();

    var byteLength = this.byteLength();
    var reqLength = length || Math.max(1, byteLength);
    assert(byteLength <= reqLength, 'byte array longer than desired length');
    assert(reqLength > 0, 'Requested array length <= 0');

    var res = allocate(ArrayType, reqLength);
    var postfix = endian === 'le' ? 'LE' : 'BE';
    this['_toArrayLike' + postfix](res, byteLength);
    return res;
  };

  BN.prototype._toArrayLikeLE = function _toArrayLikeLE (res, byteLength) {
    var position = 0;
    var carry = 0;

    for (var i = 0, shift = 0; i < this.length; i++) {
      var word = (this.words[i] << shift) | carry;

      res[position++] = word & 0xff;
      if (position < res.length) {
        res[position++] = (word >> 8) & 0xff;
      }
      if (position < res.length) {
        res[position++] = (word >> 16) & 0xff;
      }

      if (shift === 6) {
        if (position < res.length) {
          res[position++] = (word >> 24) & 0xff;
        }
        carry = 0;
        shift = 0;
      } else {
        carry = word >>> 24;
        shift += 2;
      }
    }

    if (position < res.length) {
      res[position++] = carry;

      while (position < res.length) {
        res[position++] = 0;
      }
    }
  };

  BN.prototype._toArrayLikeBE = function _toArrayLikeBE (res, byteLength) {
    var position = res.length - 1;
    var carry = 0;

    for (var i = 0, shift = 0; i < this.length; i++) {
      var word = (this.words[i] << shift) | carry;

      res[position--] = word & 0xff;
      if (position >= 0) {
        res[position--] = (word >> 8) & 0xff;
      }
      if (position >= 0) {
        res[position--] = (word >> 16) & 0xff;
      }

      if (shift === 6) {
        if (position >= 0) {
          res[position--] = (word >> 24) & 0xff;
        }
        carry = 0;
        shift = 0;
      } else {
        carry = word >>> 24;
        shift += 2;
      }
    }

    if (position >= 0) {
      res[position--] = carry;

      while (position >= 0) {
        res[position--] = 0;
      }
    }
  };

  if (Math.clz32) {
    BN.prototype._countBits = function _countBits (w) {
      return 32 - Math.clz32(w);
    };
  } else {
    BN.prototype._countBits = function _countBits (w) {
      var t = w;
      var r = 0;
      if (t >= 0x1000) {
        r += 13;
        t >>>= 13;
      }
      if (t >= 0x40) {
        r += 7;
        t >>>= 7;
      }
      if (t >= 0x8) {
        r += 4;
        t >>>= 4;
      }
      if (t >= 0x02) {
        r += 2;
        t >>>= 2;
      }
      return r + t;
    };
  }

  BN.prototype._zeroBits = function _zeroBits (w) {
    // Short-cut
    if (w === 0) return 26;

    var t = w;
    var r = 0;
    if ((t & 0x1fff) === 0) {
      r += 13;
      t >>>= 13;
    }
    if ((t & 0x7f) === 0) {
      r += 7;
      t >>>= 7;
    }
    if ((t & 0xf) === 0) {
      r += 4;
      t >>>= 4;
    }
    if ((t & 0x3) === 0) {
      r += 2;
      t >>>= 2;
    }
    if ((t & 0x1) === 0) {
      r++;
    }
    return r;
  };

  // Return number of used bits in a BN
  BN.prototype.bitLength = function bitLength () {
    var w = this.words[this.length - 1];
    var hi = this._countBits(w);
    return (this.length - 1) * 26 + hi;
  };

  function toBitArray (num) {
    var w = new Array(num.bitLength());

    for (var bit = 0; bit < w.length; bit++) {
      var off = (bit / 26) | 0;
      var wbit = bit % 26;

      w[bit] = (num.words[off] >>> wbit) & 0x01;
    }

    return w;
  }

  // Number of trailing zero bits
  BN.prototype.zeroBits = function zeroBits () {
    if (this.isZero()) return 0;

    var r = 0;
    for (var i = 0; i < this.length; i++) {
      var b = this._zeroBits(this.words[i]);
      r += b;
      if (b !== 26) break;
    }
    return r;
  };

  BN.prototype.byteLength = function byteLength () {
    return Math.ceil(this.bitLength() / 8);
  };

  BN.prototype.toTwos = function toTwos (width) {
    if (this.negative !== 0) {
      return this.abs().inotn(width).iaddn(1);
    }
    return this.clone();
  };

  BN.prototype.fromTwos = function fromTwos (width) {
    if (this.testn(width - 1)) {
      return this.notn(width).iaddn(1).ineg();
    }
    return this.clone();
  };

  BN.prototype.isNeg = function isNeg () {
    return this.negative !== 0;
  };

  // Return negative clone of `this`
  BN.prototype.neg = function neg () {
    return this.clone().ineg();
  };

  BN.prototype.ineg = function ineg () {
    if (!this.isZero()) {
      this.negative ^= 1;
    }

    return this;
  };

  // Or `num` with `this` in-place
  BN.prototype.iuor = function iuor (num) {
    while (this.length < num.length) {
      this.words[this.length++] = 0;
    }

    for (var i = 0; i < num.length; i++) {
      this.words[i] = this.words[i] | num.words[i];
    }

    return this._strip();
  };

  BN.prototype.ior = function ior (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuor(num);
  };

  // Or `num` with `this`
  BN.prototype.or = function or (num) {
    if (this.length > num.length) return this.clone().ior(num);
    return num.clone().ior(this);
  };

  BN.prototype.uor = function uor (num) {
    if (this.length > num.length) return this.clone().iuor(num);
    return num.clone().iuor(this);
  };

  // And `num` with `this` in-place
  BN.prototype.iuand = function iuand (num) {
    // b = min-length(num, this)
    var b;
    if (this.length > num.length) {
      b = num;
    } else {
      b = this;
    }

    for (var i = 0; i < b.length; i++) {
      this.words[i] = this.words[i] & num.words[i];
    }

    this.length = b.length;

    return this._strip();
  };

  BN.prototype.iand = function iand (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuand(num);
  };

  // And `num` with `this`
  BN.prototype.and = function and (num) {
    if (this.length > num.length) return this.clone().iand(num);
    return num.clone().iand(this);
  };

  BN.prototype.uand = function uand (num) {
    if (this.length > num.length) return this.clone().iuand(num);
    return num.clone().iuand(this);
  };

  // Xor `num` with `this` in-place
  BN.prototype.iuxor = function iuxor (num) {
    // a.length > b.length
    var a;
    var b;
    if (this.length > num.length) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    for (var i = 0; i < b.length; i++) {
      this.words[i] = a.words[i] ^ b.words[i];
    }

    if (this !== a) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    this.length = a.length;

    return this._strip();
  };

  BN.prototype.ixor = function ixor (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuxor(num);
  };

  // Xor `num` with `this`
  BN.prototype.xor = function xor (num) {
    if (this.length > num.length) return this.clone().ixor(num);
    return num.clone().ixor(this);
  };

  BN.prototype.uxor = function uxor (num) {
    if (this.length > num.length) return this.clone().iuxor(num);
    return num.clone().iuxor(this);
  };

  // Not ``this`` with ``width`` bitwidth
  BN.prototype.inotn = function inotn (width) {
    assert(typeof width === 'number' && width >= 0);

    var bytesNeeded = Math.ceil(width / 26) | 0;
    var bitsLeft = width % 26;

    // Extend the buffer with leading zeroes
    this._expand(bytesNeeded);

    if (bitsLeft > 0) {
      bytesNeeded--;
    }

    // Handle complete words
    for (var i = 0; i < bytesNeeded; i++) {
      this.words[i] = ~this.words[i] & 0x3ffffff;
    }

    // Handle the residue
    if (bitsLeft > 0) {
      this.words[i] = ~this.words[i] & (0x3ffffff >> (26 - bitsLeft));
    }

    // And remove leading zeroes
    return this._strip();
  };

  BN.prototype.notn = function notn (width) {
    return this.clone().inotn(width);
  };

  // Set `bit` of `this`
  BN.prototype.setn = function setn (bit, val) {
    assert(typeof bit === 'number' && bit >= 0);

    var off = (bit / 26) | 0;
    var wbit = bit % 26;

    this._expand(off + 1);

    if (val) {
      this.words[off] = this.words[off] | (1 << wbit);
    } else {
      this.words[off] = this.words[off] & ~(1 << wbit);
    }

    return this._strip();
  };

  // Add `num` to `this` in-place
  BN.prototype.iadd = function iadd (num) {
    var r;

    // negative + positive
    if (this.negative !== 0 && num.negative === 0) {
      this.negative = 0;
      r = this.isub(num);
      this.negative ^= 1;
      return this._normSign();

    // positive + negative
    } else if (this.negative === 0 && num.negative !== 0) {
      num.negative = 0;
      r = this.isub(num);
      num.negative = 1;
      return r._normSign();
    }

    // a.length > b.length
    var a, b;
    if (this.length > num.length) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    var carry = 0;
    for (var i = 0; i < b.length; i++) {
      r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
      this.words[i] = r & 0x3ffffff;
      carry = r >>> 26;
    }
    for (; carry !== 0 && i < a.length; i++) {
      r = (a.words[i] | 0) + carry;
      this.words[i] = r & 0x3ffffff;
      carry = r >>> 26;
    }

    this.length = a.length;
    if (carry !== 0) {
      this.words[this.length] = carry;
      this.length++;
    // Copy the rest of the words
    } else if (a !== this) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    return this;
  };

  // Add `num` to `this`
  BN.prototype.add = function add (num) {
    var res;
    if (num.negative !== 0 && this.negative === 0) {
      num.negative = 0;
      res = this.sub(num);
      num.negative ^= 1;
      return res;
    } else if (num.negative === 0 && this.negative !== 0) {
      this.negative = 0;
      res = num.sub(this);
      this.negative = 1;
      return res;
    }

    if (this.length > num.length) return this.clone().iadd(num);

    return num.clone().iadd(this);
  };

  // Subtract `num` from `this` in-place
  BN.prototype.isub = function isub (num) {
    // this - (-num) = this + num
    if (num.negative !== 0) {
      num.negative = 0;
      var r = this.iadd(num);
      num.negative = 1;
      return r._normSign();

    // -this - num = -(this + num)
    } else if (this.negative !== 0) {
      this.negative = 0;
      this.iadd(num);
      this.negative = 1;
      return this._normSign();
    }

    // At this point both numbers are positive
    var cmp = this.cmp(num);

    // Optimization - zeroify
    if (cmp === 0) {
      this.negative = 0;
      this.length = 1;
      this.words[0] = 0;
      return this;
    }

    // a > b
    var a, b;
    if (cmp > 0) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    var carry = 0;
    for (var i = 0; i < b.length; i++) {
      r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
      carry = r >> 26;
      this.words[i] = r & 0x3ffffff;
    }
    for (; carry !== 0 && i < a.length; i++) {
      r = (a.words[i] | 0) + carry;
      carry = r >> 26;
      this.words[i] = r & 0x3ffffff;
    }

    // Copy rest of the words
    if (carry === 0 && i < a.length && a !== this) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    this.length = Math.max(this.length, i);

    if (a !== this) {
      this.negative = 1;
    }

    return this._strip();
  };

  // Subtract `num` from `this`
  BN.prototype.sub = function sub (num) {
    return this.clone().isub(num);
  };

  function smallMulTo (self, num, out) {
    out.negative = num.negative ^ self.negative;
    var len = (self.length + num.length) | 0;
    out.length = len;
    len = (len - 1) | 0;

    // Peel one iteration (compiler can't do it, because of code complexity)
    var a = self.words[0] | 0;
    var b = num.words[0] | 0;
    var r = a * b;

    var lo = r & 0x3ffffff;
    var carry = (r / 0x4000000) | 0;
    out.words[0] = lo;

    for (var k = 1; k < len; k++) {
      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
      // note that ncarry could be >= 0x3ffffff
      var ncarry = carry >>> 26;
      var rword = carry & 0x3ffffff;
      var maxJ = Math.min(k, num.length - 1);
      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
        var i = (k - j) | 0;
        a = self.words[i] | 0;
        b = num.words[j] | 0;
        r = a * b + rword;
        ncarry += (r / 0x4000000) | 0;
        rword = r & 0x3ffffff;
      }
      out.words[k] = rword | 0;
      carry = ncarry | 0;
    }
    if (carry !== 0) {
      out.words[k] = carry | 0;
    } else {
      out.length--;
    }

    return out._strip();
  }

  // TODO(indutny): it may be reasonable to omit it for users who don't need
  // to work with 256-bit numbers, otherwise it gives 20% improvement for 256-bit
  // multiplication (like elliptic secp256k1).
  var comb10MulTo = function comb10MulTo (self, num, out) {
    var a = self.words;
    var b = num.words;
    var o = out.words;
    var c = 0;
    var lo;
    var mid;
    var hi;
    var a0 = a[0] | 0;
    var al0 = a0 & 0x1fff;
    var ah0 = a0 >>> 13;
    var a1 = a[1] | 0;
    var al1 = a1 & 0x1fff;
    var ah1 = a1 >>> 13;
    var a2 = a[2] | 0;
    var al2 = a2 & 0x1fff;
    var ah2 = a2 >>> 13;
    var a3 = a[3] | 0;
    var al3 = a3 & 0x1fff;
    var ah3 = a3 >>> 13;
    var a4 = a[4] | 0;
    var al4 = a4 & 0x1fff;
    var ah4 = a4 >>> 13;
    var a5 = a[5] | 0;
    var al5 = a5 & 0x1fff;
    var ah5 = a5 >>> 13;
    var a6 = a[6] | 0;
    var al6 = a6 & 0x1fff;
    var ah6 = a6 >>> 13;
    var a7 = a[7] | 0;
    var al7 = a7 & 0x1fff;
    var ah7 = a7 >>> 13;
    var a8 = a[8] | 0;
    var al8 = a8 & 0x1fff;
    var ah8 = a8 >>> 13;
    var a9 = a[9] | 0;
    var al9 = a9 & 0x1fff;
    var ah9 = a9 >>> 13;
    var b0 = b[0] | 0;
    var bl0 = b0 & 0x1fff;
    var bh0 = b0 >>> 13;
    var b1 = b[1] | 0;
    var bl1 = b1 & 0x1fff;
    var bh1 = b1 >>> 13;
    var b2 = b[2] | 0;
    var bl2 = b2 & 0x1fff;
    var bh2 = b2 >>> 13;
    var b3 = b[3] | 0;
    var bl3 = b3 & 0x1fff;
    var bh3 = b3 >>> 13;
    var b4 = b[4] | 0;
    var bl4 = b4 & 0x1fff;
    var bh4 = b4 >>> 13;
    var b5 = b[5] | 0;
    var bl5 = b5 & 0x1fff;
    var bh5 = b5 >>> 13;
    var b6 = b[6] | 0;
    var bl6 = b6 & 0x1fff;
    var bh6 = b6 >>> 13;
    var b7 = b[7] | 0;
    var bl7 = b7 & 0x1fff;
    var bh7 = b7 >>> 13;
    var b8 = b[8] | 0;
    var bl8 = b8 & 0x1fff;
    var bh8 = b8 >>> 13;
    var b9 = b[9] | 0;
    var bl9 = b9 & 0x1fff;
    var bh9 = b9 >>> 13;

    out.negative = self.negative ^ num.negative;
    out.length = 19;
    /* k = 0 */
    lo = Math.imul(al0, bl0);
    mid = Math.imul(al0, bh0);
    mid = (mid + Math.imul(ah0, bl0)) | 0;
    hi = Math.imul(ah0, bh0);
    var w0 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w0 >>> 26)) | 0;
    w0 &= 0x3ffffff;
    /* k = 1 */
    lo = Math.imul(al1, bl0);
    mid = Math.imul(al1, bh0);
    mid = (mid + Math.imul(ah1, bl0)) | 0;
    hi = Math.imul(ah1, bh0);
    lo = (lo + Math.imul(al0, bl1)) | 0;
    mid = (mid + Math.imul(al0, bh1)) | 0;
    mid = (mid + Math.imul(ah0, bl1)) | 0;
    hi = (hi + Math.imul(ah0, bh1)) | 0;
    var w1 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w1 >>> 26)) | 0;
    w1 &= 0x3ffffff;
    /* k = 2 */
    lo = Math.imul(al2, bl0);
    mid = Math.imul(al2, bh0);
    mid = (mid + Math.imul(ah2, bl0)) | 0;
    hi = Math.imul(ah2, bh0);
    lo = (lo + Math.imul(al1, bl1)) | 0;
    mid = (mid + Math.imul(al1, bh1)) | 0;
    mid = (mid + Math.imul(ah1, bl1)) | 0;
    hi = (hi + Math.imul(ah1, bh1)) | 0;
    lo = (lo + Math.imul(al0, bl2)) | 0;
    mid = (mid + Math.imul(al0, bh2)) | 0;
    mid = (mid + Math.imul(ah0, bl2)) | 0;
    hi = (hi + Math.imul(ah0, bh2)) | 0;
    var w2 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w2 >>> 26)) | 0;
    w2 &= 0x3ffffff;
    /* k = 3 */
    lo = Math.imul(al3, bl0);
    mid = Math.imul(al3, bh0);
    mid = (mid + Math.imul(ah3, bl0)) | 0;
    hi = Math.imul(ah3, bh0);
    lo = (lo + Math.imul(al2, bl1)) | 0;
    mid = (mid + Math.imul(al2, bh1)) | 0;
    mid = (mid + Math.imul(ah2, bl1)) | 0;
    hi = (hi + Math.imul(ah2, bh1)) | 0;
    lo = (lo + Math.imul(al1, bl2)) | 0;
    mid = (mid + Math.imul(al1, bh2)) | 0;
    mid = (mid + Math.imul(ah1, bl2)) | 0;
    hi = (hi + Math.imul(ah1, bh2)) | 0;
    lo = (lo + Math.imul(al0, bl3)) | 0;
    mid = (mid + Math.imul(al0, bh3)) | 0;
    mid = (mid + Math.imul(ah0, bl3)) | 0;
    hi = (hi + Math.imul(ah0, bh3)) | 0;
    var w3 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w3 >>> 26)) | 0;
    w3 &= 0x3ffffff;
    /* k = 4 */
    lo = Math.imul(al4, bl0);
    mid = Math.imul(al4, bh0);
    mid = (mid + Math.imul(ah4, bl0)) | 0;
    hi = Math.imul(ah4, bh0);
    lo = (lo + Math.imul(al3, bl1)) | 0;
    mid = (mid + Math.imul(al3, bh1)) | 0;
    mid = (mid + Math.imul(ah3, bl1)) | 0;
    hi = (hi + Math.imul(ah3, bh1)) | 0;
    lo = (lo + Math.imul(al2, bl2)) | 0;
    mid = (mid + Math.imul(al2, bh2)) | 0;
    mid = (mid + Math.imul(ah2, bl2)) | 0;
    hi = (hi + Math.imul(ah2, bh2)) | 0;
    lo = (lo + Math.imul(al1, bl3)) | 0;
    mid = (mid + Math.imul(al1, bh3)) | 0;
    mid = (mid + Math.imul(ah1, bl3)) | 0;
    hi = (hi + Math.imul(ah1, bh3)) | 0;
    lo = (lo + Math.imul(al0, bl4)) | 0;
    mid = (mid + Math.imul(al0, bh4)) | 0;
    mid = (mid + Math.imul(ah0, bl4)) | 0;
    hi = (hi + Math.imul(ah0, bh4)) | 0;
    var w4 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w4 >>> 26)) | 0;
    w4 &= 0x3ffffff;
    /* k = 5 */
    lo = Math.imul(al5, bl0);
    mid = Math.imul(al5, bh0);
    mid = (mid + Math.imul(ah5, bl0)) | 0;
    hi = Math.imul(ah5, bh0);
    lo = (lo + Math.imul(al4, bl1)) | 0;
    mid = (mid + Math.imul(al4, bh1)) | 0;
    mid = (mid + Math.imul(ah4, bl1)) | 0;
    hi = (hi + Math.imul(ah4, bh1)) | 0;
    lo = (lo + Math.imul(al3, bl2)) | 0;
    mid = (mid + Math.imul(al3, bh2)) | 0;
    mid = (mid + Math.imul(ah3, bl2)) | 0;
    hi = (hi + Math.imul(ah3, bh2)) | 0;
    lo = (lo + Math.imul(al2, bl3)) | 0;
    mid = (mid + Math.imul(al2, bh3)) | 0;
    mid = (mid + Math.imul(ah2, bl3)) | 0;
    hi = (hi + Math.imul(ah2, bh3)) | 0;
    lo = (lo + Math.imul(al1, bl4)) | 0;
    mid = (mid + Math.imul(al1, bh4)) | 0;
    mid = (mid + Math.imul(ah1, bl4)) | 0;
    hi = (hi + Math.imul(ah1, bh4)) | 0;
    lo = (lo + Math.imul(al0, bl5)) | 0;
    mid = (mid + Math.imul(al0, bh5)) | 0;
    mid = (mid + Math.imul(ah0, bl5)) | 0;
    hi = (hi + Math.imul(ah0, bh5)) | 0;
    var w5 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w5 >>> 26)) | 0;
    w5 &= 0x3ffffff;
    /* k = 6 */
    lo = Math.imul(al6, bl0);
    mid = Math.imul(al6, bh0);
    mid = (mid + Math.imul(ah6, bl0)) | 0;
    hi = Math.imul(ah6, bh0);
    lo = (lo + Math.imul(al5, bl1)) | 0;
    mid = (mid + Math.imul(al5, bh1)) | 0;
    mid = (mid + Math.imul(ah5, bl1)) | 0;
    hi = (hi + Math.imul(ah5, bh1)) | 0;
    lo = (lo + Math.imul(al4, bl2)) | 0;
    mid = (mid + Math.imul(al4, bh2)) | 0;
    mid = (mid + Math.imul(ah4, bl2)) | 0;
    hi = (hi + Math.imul(ah4, bh2)) | 0;
    lo = (lo + Math.imul(al3, bl3)) | 0;
    mid = (mid + Math.imul(al3, bh3)) | 0;
    mid = (mid + Math.imul(ah3, bl3)) | 0;
    hi = (hi + Math.imul(ah3, bh3)) | 0;
    lo = (lo + Math.imul(al2, bl4)) | 0;
    mid = (mid + Math.imul(al2, bh4)) | 0;
    mid = (mid + Math.imul(ah2, bl4)) | 0;
    hi = (hi + Math.imul(ah2, bh4)) | 0;
    lo = (lo + Math.imul(al1, bl5)) | 0;
    mid = (mid + Math.imul(al1, bh5)) | 0;
    mid = (mid + Math.imul(ah1, bl5)) | 0;
    hi = (hi + Math.imul(ah1, bh5)) | 0;
    lo = (lo + Math.imul(al0, bl6)) | 0;
    mid = (mid + Math.imul(al0, bh6)) | 0;
    mid = (mid + Math.imul(ah0, bl6)) | 0;
    hi = (hi + Math.imul(ah0, bh6)) | 0;
    var w6 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w6 >>> 26)) | 0;
    w6 &= 0x3ffffff;
    /* k = 7 */
    lo = Math.imul(al7, bl0);
    mid = Math.imul(al7, bh0);
    mid = (mid + Math.imul(ah7, bl0)) | 0;
    hi = Math.imul(ah7, bh0);
    lo = (lo + Math.imul(al6, bl1)) | 0;
    mid = (mid + Math.imul(al6, bh1)) | 0;
    mid = (mid + Math.imul(ah6, bl1)) | 0;
    hi = (hi + Math.imul(ah6, bh1)) | 0;
    lo = (lo + Math.imul(al5, bl2)) | 0;
    mid = (mid + Math.imul(al5, bh2)) | 0;
    mid = (mid + Math.imul(ah5, bl2)) | 0;
    hi = (hi + Math.imul(ah5, bh2)) | 0;
    lo = (lo + Math.imul(al4, bl3)) | 0;
    mid = (mid + Math.imul(al4, bh3)) | 0;
    mid = (mid + Math.imul(ah4, bl3)) | 0;
    hi = (hi + Math.imul(ah4, bh3)) | 0;
    lo = (lo + Math.imul(al3, bl4)) | 0;
    mid = (mid + Math.imul(al3, bh4)) | 0;
    mid = (mid + Math.imul(ah3, bl4)) | 0;
    hi = (hi + Math.imul(ah3, bh4)) | 0;
    lo = (lo + Math.imul(al2, bl5)) | 0;
    mid = (mid + Math.imul(al2, bh5)) | 0;
    mid = (mid + Math.imul(ah2, bl5)) | 0;
    hi = (hi + Math.imul(ah2, bh5)) | 0;
    lo = (lo + Math.imul(al1, bl6)) | 0;
    mid = (mid + Math.imul(al1, bh6)) | 0;
    mid = (mid + Math.imul(ah1, bl6)) | 0;
    hi = (hi + Math.imul(ah1, bh6)) | 0;
    lo = (lo + Math.imul(al0, bl7)) | 0;
    mid = (mid + Math.imul(al0, bh7)) | 0;
    mid = (mid + Math.imul(ah0, bl7)) | 0;
    hi = (hi + Math.imul(ah0, bh7)) | 0;
    var w7 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w7 >>> 26)) | 0;
    w7 &= 0x3ffffff;
    /* k = 8 */
    lo = Math.imul(al8, bl0);
    mid = Math.imul(al8, bh0);
    mid = (mid + Math.imul(ah8, bl0)) | 0;
    hi = Math.imul(ah8, bh0);
    lo = (lo + Math.imul(al7, bl1)) | 0;
    mid = (mid + Math.imul(al7, bh1)) | 0;
    mid = (mid + Math.imul(ah7, bl1)) | 0;
    hi = (hi + Math.imul(ah7, bh1)) | 0;
    lo = (lo + Math.imul(al6, bl2)) | 0;
    mid = (mid + Math.imul(al6, bh2)) | 0;
    mid = (mid + Math.imul(ah6, bl2)) | 0;
    hi = (hi + Math.imul(ah6, bh2)) | 0;
    lo = (lo + Math.imul(al5, bl3)) | 0;
    mid = (mid + Math.imul(al5, bh3)) | 0;
    mid = (mid + Math.imul(ah5, bl3)) | 0;
    hi = (hi + Math.imul(ah5, bh3)) | 0;
    lo = (lo + Math.imul(al4, bl4)) | 0;
    mid = (mid + Math.imul(al4, bh4)) | 0;
    mid = (mid + Math.imul(ah4, bl4)) | 0;
    hi = (hi + Math.imul(ah4, bh4)) | 0;
    lo = (lo + Math.imul(al3, bl5)) | 0;
    mid = (mid + Math.imul(al3, bh5)) | 0;
    mid = (mid + Math.imul(ah3, bl5)) | 0;
    hi = (hi + Math.imul(ah3, bh5)) | 0;
    lo = (lo + Math.imul(al2, bl6)) | 0;
    mid = (mid + Math.imul(al2, bh6)) | 0;
    mid = (mid + Math.imul(ah2, bl6)) | 0;
    hi = (hi + Math.imul(ah2, bh6)) | 0;
    lo = (lo + Math.imul(al1, bl7)) | 0;
    mid = (mid + Math.imul(al1, bh7)) | 0;
    mid = (mid + Math.imul(ah1, bl7)) | 0;
    hi = (hi + Math.imul(ah1, bh7)) | 0;
    lo = (lo + Math.imul(al0, bl8)) | 0;
    mid = (mid + Math.imul(al0, bh8)) | 0;
    mid = (mid + Math.imul(ah0, bl8)) | 0;
    hi = (hi + Math.imul(ah0, bh8)) | 0;
    var w8 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w8 >>> 26)) | 0;
    w8 &= 0x3ffffff;
    /* k = 9 */
    lo = Math.imul(al9, bl0);
    mid = Math.imul(al9, bh0);
    mid = (mid + Math.imul(ah9, bl0)) | 0;
    hi = Math.imul(ah9, bh0);
    lo = (lo + Math.imul(al8, bl1)) | 0;
    mid = (mid + Math.imul(al8, bh1)) | 0;
    mid = (mid + Math.imul(ah8, bl1)) | 0;
    hi = (hi + Math.imul(ah8, bh1)) | 0;
    lo = (lo + Math.imul(al7, bl2)) | 0;
    mid = (mid + Math.imul(al7, bh2)) | 0;
    mid = (mid + Math.imul(ah7, bl2)) | 0;
    hi = (hi + Math.imul(ah7, bh2)) | 0;
    lo = (lo + Math.imul(al6, bl3)) | 0;
    mid = (mid + Math.imul(al6, bh3)) | 0;
    mid = (mid + Math.imul(ah6, bl3)) | 0;
    hi = (hi + Math.imul(ah6, bh3)) | 0;
    lo = (lo + Math.imul(al5, bl4)) | 0;
    mid = (mid + Math.imul(al5, bh4)) | 0;
    mid = (mid + Math.imul(ah5, bl4)) | 0;
    hi = (hi + Math.imul(ah5, bh4)) | 0;
    lo = (lo + Math.imul(al4, bl5)) | 0;
    mid = (mid + Math.imul(al4, bh5)) | 0;
    mid = (mid + Math.imul(ah4, bl5)) | 0;
    hi = (hi + Math.imul(ah4, bh5)) | 0;
    lo = (lo + Math.imul(al3, bl6)) | 0;
    mid = (mid + Math.imul(al3, bh6)) | 0;
    mid = (mid + Math.imul(ah3, bl6)) | 0;
    hi = (hi + Math.imul(ah3, bh6)) | 0;
    lo = (lo + Math.imul(al2, bl7)) | 0;
    mid = (mid + Math.imul(al2, bh7)) | 0;
    mid = (mid + Math.imul(ah2, bl7)) | 0;
    hi = (hi + Math.imul(ah2, bh7)) | 0;
    lo = (lo + Math.imul(al1, bl8)) | 0;
    mid = (mid + Math.imul(al1, bh8)) | 0;
    mid = (mid + Math.imul(ah1, bl8)) | 0;
    hi = (hi + Math.imul(ah1, bh8)) | 0;
    lo = (lo + Math.imul(al0, bl9)) | 0;
    mid = (mid + Math.imul(al0, bh9)) | 0;
    mid = (mid + Math.imul(ah0, bl9)) | 0;
    hi = (hi + Math.imul(ah0, bh9)) | 0;
    var w9 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w9 >>> 26)) | 0;
    w9 &= 0x3ffffff;
    /* k = 10 */
    lo = Math.imul(al9, bl1);
    mid = Math.imul(al9, bh1);
    mid = (mid + Math.imul(ah9, bl1)) | 0;
    hi = Math.imul(ah9, bh1);
    lo = (lo + Math.imul(al8, bl2)) | 0;
    mid = (mid + Math.imul(al8, bh2)) | 0;
    mid = (mid + Math.imul(ah8, bl2)) | 0;
    hi = (hi + Math.imul(ah8, bh2)) | 0;
    lo = (lo + Math.imul(al7, bl3)) | 0;
    mid = (mid + Math.imul(al7, bh3)) | 0;
    mid = (mid + Math.imul(ah7, bl3)) | 0;
    hi = (hi + Math.imul(ah7, bh3)) | 0;
    lo = (lo + Math.imul(al6, bl4)) | 0;
    mid = (mid + Math.imul(al6, bh4)) | 0;
    mid = (mid + Math.imul(ah6, bl4)) | 0;
    hi = (hi + Math.imul(ah6, bh4)) | 0;
    lo = (lo + Math.imul(al5, bl5)) | 0;
    mid = (mid + Math.imul(al5, bh5)) | 0;
    mid = (mid + Math.imul(ah5, bl5)) | 0;
    hi = (hi + Math.imul(ah5, bh5)) | 0;
    lo = (lo + Math.imul(al4, bl6)) | 0;
    mid = (mid + Math.imul(al4, bh6)) | 0;
    mid = (mid + Math.imul(ah4, bl6)) | 0;
    hi = (hi + Math.imul(ah4, bh6)) | 0;
    lo = (lo + Math.imul(al3, bl7)) | 0;
    mid = (mid + Math.imul(al3, bh7)) | 0;
    mid = (mid + Math.imul(ah3, bl7)) | 0;
    hi = (hi + Math.imul(ah3, bh7)) | 0;
    lo = (lo + Math.imul(al2, bl8)) | 0;
    mid = (mid + Math.imul(al2, bh8)) | 0;
    mid = (mid + Math.imul(ah2, bl8)) | 0;
    hi = (hi + Math.imul(ah2, bh8)) | 0;
    lo = (lo + Math.imul(al1, bl9)) | 0;
    mid = (mid + Math.imul(al1, bh9)) | 0;
    mid = (mid + Math.imul(ah1, bl9)) | 0;
    hi = (hi + Math.imul(ah1, bh9)) | 0;
    var w10 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w10 >>> 26)) | 0;
    w10 &= 0x3ffffff;
    /* k = 11 */
    lo = Math.imul(al9, bl2);
    mid = Math.imul(al9, bh2);
    mid = (mid + Math.imul(ah9, bl2)) | 0;
    hi = Math.imul(ah9, bh2);
    lo = (lo + Math.imul(al8, bl3)) | 0;
    mid = (mid + Math.imul(al8, bh3)) | 0;
    mid = (mid + Math.imul(ah8, bl3)) | 0;
    hi = (hi + Math.imul(ah8, bh3)) | 0;
    lo = (lo + Math.imul(al7, bl4)) | 0;
    mid = (mid + Math.imul(al7, bh4)) | 0;
    mid = (mid + Math.imul(ah7, bl4)) | 0;
    hi = (hi + Math.imul(ah7, bh4)) | 0;
    lo = (lo + Math.imul(al6, bl5)) | 0;
    mid = (mid + Math.imul(al6, bh5)) | 0;
    mid = (mid + Math.imul(ah6, bl5)) | 0;
    hi = (hi + Math.imul(ah6, bh5)) | 0;
    lo = (lo + Math.imul(al5, bl6)) | 0;
    mid = (mid + Math.imul(al5, bh6)) | 0;
    mid = (mid + Math.imul(ah5, bl6)) | 0;
    hi = (hi + Math.imul(ah5, bh6)) | 0;
    lo = (lo + Math.imul(al4, bl7)) | 0;
    mid = (mid + Math.imul(al4, bh7)) | 0;
    mid = (mid + Math.imul(ah4, bl7)) | 0;
    hi = (hi + Math.imul(ah4, bh7)) | 0;
    lo = (lo + Math.imul(al3, bl8)) | 0;
    mid = (mid + Math.imul(al3, bh8)) | 0;
    mid = (mid + Math.imul(ah3, bl8)) | 0;
    hi = (hi + Math.imul(ah3, bh8)) | 0;
    lo = (lo + Math.imul(al2, bl9)) | 0;
    mid = (mid + Math.imul(al2, bh9)) | 0;
    mid = (mid + Math.imul(ah2, bl9)) | 0;
    hi = (hi + Math.imul(ah2, bh9)) | 0;
    var w11 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w11 >>> 26)) | 0;
    w11 &= 0x3ffffff;
    /* k = 12 */
    lo = Math.imul(al9, bl3);
    mid = Math.imul(al9, bh3);
    mid = (mid + Math.imul(ah9, bl3)) | 0;
    hi = Math.imul(ah9, bh3);
    lo = (lo + Math.imul(al8, bl4)) | 0;
    mid = (mid + Math.imul(al8, bh4)) | 0;
    mid = (mid + Math.imul(ah8, bl4)) | 0;
    hi = (hi + Math.imul(ah8, bh4)) | 0;
    lo = (lo + Math.imul(al7, bl5)) | 0;
    mid = (mid + Math.imul(al7, bh5)) | 0;
    mid = (mid + Math.imul(ah7, bl5)) | 0;
    hi = (hi + Math.imul(ah7, bh5)) | 0;
    lo = (lo + Math.imul(al6, bl6)) | 0;
    mid = (mid + Math.imul(al6, bh6)) | 0;
    mid = (mid + Math.imul(ah6, bl6)) | 0;
    hi = (hi + Math.imul(ah6, bh6)) | 0;
    lo = (lo + Math.imul(al5, bl7)) | 0;
    mid = (mid + Math.imul(al5, bh7)) | 0;
    mid = (mid + Math.imul(ah5, bl7)) | 0;
    hi = (hi + Math.imul(ah5, bh7)) | 0;
    lo = (lo + Math.imul(al4, bl8)) | 0;
    mid = (mid + Math.imul(al4, bh8)) | 0;
    mid = (mid + Math.imul(ah4, bl8)) | 0;
    hi = (hi + Math.imul(ah4, bh8)) | 0;
    lo = (lo + Math.imul(al3, bl9)) | 0;
    mid = (mid + Math.imul(al3, bh9)) | 0;
    mid = (mid + Math.imul(ah3, bl9)) | 0;
    hi = (hi + Math.imul(ah3, bh9)) | 0;
    var w12 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w12 >>> 26)) | 0;
    w12 &= 0x3ffffff;
    /* k = 13 */
    lo = Math.imul(al9, bl4);
    mid = Math.imul(al9, bh4);
    mid = (mid + Math.imul(ah9, bl4)) | 0;
    hi = Math.imul(ah9, bh4);
    lo = (lo + Math.imul(al8, bl5)) | 0;
    mid = (mid + Math.imul(al8, bh5)) | 0;
    mid = (mid + Math.imul(ah8, bl5)) | 0;
    hi = (hi + Math.imul(ah8, bh5)) | 0;
    lo = (lo + Math.imul(al7, bl6)) | 0;
    mid = (mid + Math.imul(al7, bh6)) | 0;
    mid = (mid + Math.imul(ah7, bl6)) | 0;
    hi = (hi + Math.imul(ah7, bh6)) | 0;
    lo = (lo + Math.imul(al6, bl7)) | 0;
    mid = (mid + Math.imul(al6, bh7)) | 0;
    mid = (mid + Math.imul(ah6, bl7)) | 0;
    hi = (hi + Math.imul(ah6, bh7)) | 0;
    lo = (lo + Math.imul(al5, bl8)) | 0;
    mid = (mid + Math.imul(al5, bh8)) | 0;
    mid = (mid + Math.imul(ah5, bl8)) | 0;
    hi = (hi + Math.imul(ah5, bh8)) | 0;
    lo = (lo + Math.imul(al4, bl9)) | 0;
    mid = (mid + Math.imul(al4, bh9)) | 0;
    mid = (mid + Math.imul(ah4, bl9)) | 0;
    hi = (hi + Math.imul(ah4, bh9)) | 0;
    var w13 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w13 >>> 26)) | 0;
    w13 &= 0x3ffffff;
    /* k = 14 */
    lo = Math.imul(al9, bl5);
    mid = Math.imul(al9, bh5);
    mid = (mid + Math.imul(ah9, bl5)) | 0;
    hi = Math.imul(ah9, bh5);
    lo = (lo + Math.imul(al8, bl6)) | 0;
    mid = (mid + Math.imul(al8, bh6)) | 0;
    mid = (mid + Math.imul(ah8, bl6)) | 0;
    hi = (hi + Math.imul(ah8, bh6)) | 0;
    lo = (lo + Math.imul(al7, bl7)) | 0;
    mid = (mid + Math.imul(al7, bh7)) | 0;
    mid = (mid + Math.imul(ah7, bl7)) | 0;
    hi = (hi + Math.imul(ah7, bh7)) | 0;
    lo = (lo + Math.imul(al6, bl8)) | 0;
    mid = (mid + Math.imul(al6, bh8)) | 0;
    mid = (mid + Math.imul(ah6, bl8)) | 0;
    hi = (hi + Math.imul(ah6, bh8)) | 0;
    lo = (lo + Math.imul(al5, bl9)) | 0;
    mid = (mid + Math.imul(al5, bh9)) | 0;
    mid = (mid + Math.imul(ah5, bl9)) | 0;
    hi = (hi + Math.imul(ah5, bh9)) | 0;
    var w14 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w14 >>> 26)) | 0;
    w14 &= 0x3ffffff;
    /* k = 15 */
    lo = Math.imul(al9, bl6);
    mid = Math.imul(al9, bh6);
    mid = (mid + Math.imul(ah9, bl6)) | 0;
    hi = Math.imul(ah9, bh6);
    lo = (lo + Math.imul(al8, bl7)) | 0;
    mid = (mid + Math.imul(al8, bh7)) | 0;
    mid = (mid + Math.imul(ah8, bl7)) | 0;
    hi = (hi + Math.imul(ah8, bh7)) | 0;
    lo = (lo + Math.imul(al7, bl8)) | 0;
    mid = (mid + Math.imul(al7, bh8)) | 0;
    mid = (mid + Math.imul(ah7, bl8)) | 0;
    hi = (hi + Math.imul(ah7, bh8)) | 0;
    lo = (lo + Math.imul(al6, bl9)) | 0;
    mid = (mid + Math.imul(al6, bh9)) | 0;
    mid = (mid + Math.imul(ah6, bl9)) | 0;
    hi = (hi + Math.imul(ah6, bh9)) | 0;
    var w15 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w15 >>> 26)) | 0;
    w15 &= 0x3ffffff;
    /* k = 16 */
    lo = Math.imul(al9, bl7);
    mid = Math.imul(al9, bh7);
    mid = (mid + Math.imul(ah9, bl7)) | 0;
    hi = Math.imul(ah9, bh7);
    lo = (lo + Math.imul(al8, bl8)) | 0;
    mid = (mid + Math.imul(al8, bh8)) | 0;
    mid = (mid + Math.imul(ah8, bl8)) | 0;
    hi = (hi + Math.imul(ah8, bh8)) | 0;
    lo = (lo + Math.imul(al7, bl9)) | 0;
    mid = (mid + Math.imul(al7, bh9)) | 0;
    mid = (mid + Math.imul(ah7, bl9)) | 0;
    hi = (hi + Math.imul(ah7, bh9)) | 0;
    var w16 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w16 >>> 26)) | 0;
    w16 &= 0x3ffffff;
    /* k = 17 */
    lo = Math.imul(al9, bl8);
    mid = Math.imul(al9, bh8);
    mid = (mid + Math.imul(ah9, bl8)) | 0;
    hi = Math.imul(ah9, bh8);
    lo = (lo + Math.imul(al8, bl9)) | 0;
    mid = (mid + Math.imul(al8, bh9)) | 0;
    mid = (mid + Math.imul(ah8, bl9)) | 0;
    hi = (hi + Math.imul(ah8, bh9)) | 0;
    var w17 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w17 >>> 26)) | 0;
    w17 &= 0x3ffffff;
    /* k = 18 */
    lo = Math.imul(al9, bl9);
    mid = Math.imul(al9, bh9);
    mid = (mid + Math.imul(ah9, bl9)) | 0;
    hi = Math.imul(ah9, bh9);
    var w18 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w18 >>> 26)) | 0;
    w18 &= 0x3ffffff;
    o[0] = w0;
    o[1] = w1;
    o[2] = w2;
    o[3] = w3;
    o[4] = w4;
    o[5] = w5;
    o[6] = w6;
    o[7] = w7;
    o[8] = w8;
    o[9] = w9;
    o[10] = w10;
    o[11] = w11;
    o[12] = w12;
    o[13] = w13;
    o[14] = w14;
    o[15] = w15;
    o[16] = w16;
    o[17] = w17;
    o[18] = w18;
    if (c !== 0) {
      o[19] = c;
      out.length++;
    }
    return out;
  };

  // Polyfill comb
  if (!Math.imul) {
    comb10MulTo = smallMulTo;
  }

  function bigMulTo (self, num, out) {
    out.negative = num.negative ^ self.negative;
    out.length = self.length + num.length;

    var carry = 0;
    var hncarry = 0;
    for (var k = 0; k < out.length - 1; k++) {
      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
      // note that ncarry could be >= 0x3ffffff
      var ncarry = hncarry;
      hncarry = 0;
      var rword = carry & 0x3ffffff;
      var maxJ = Math.min(k, num.length - 1);
      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
        var i = k - j;
        var a = self.words[i] | 0;
        var b = num.words[j] | 0;
        var r = a * b;

        var lo = r & 0x3ffffff;
        ncarry = (ncarry + ((r / 0x4000000) | 0)) | 0;
        lo = (lo + rword) | 0;
        rword = lo & 0x3ffffff;
        ncarry = (ncarry + (lo >>> 26)) | 0;

        hncarry += ncarry >>> 26;
        ncarry &= 0x3ffffff;
      }
      out.words[k] = rword;
      carry = ncarry;
      ncarry = hncarry;
    }
    if (carry !== 0) {
      out.words[k] = carry;
    } else {
      out.length--;
    }

    return out._strip();
  }

  function jumboMulTo (self, num, out) {
    // Temporary disable, see https://github.com/indutny/bn.js/issues/211
    // var fftm = new FFTM();
    // return fftm.mulp(self, num, out);
    return bigMulTo(self, num, out);
  }

  BN.prototype.mulTo = function mulTo (num, out) {
    var res;
    var len = this.length + num.length;
    if (this.length === 10 && num.length === 10) {
      res = comb10MulTo(this, num, out);
    } else if (len < 63) {
      res = smallMulTo(this, num, out);
    } else if (len < 1024) {
      res = bigMulTo(this, num, out);
    } else {
      res = jumboMulTo(this, num, out);
    }

    return res;
  };

  // Cooley-Tukey algorithm for FFT
  // slightly revisited to rely on looping instead of recursion

  function FFTM (x, y) {
    this.x = x;
    this.y = y;
  }

  FFTM.prototype.makeRBT = function makeRBT (N) {
    var t = new Array(N);
    var l = BN.prototype._countBits(N) - 1;
    for (var i = 0; i < N; i++) {
      t[i] = this.revBin(i, l, N);
    }

    return t;
  };

  // Returns binary-reversed representation of `x`
  FFTM.prototype.revBin = function revBin (x, l, N) {
    if (x === 0 || x === N - 1) return x;

    var rb = 0;
    for (var i = 0; i < l; i++) {
      rb |= (x & 1) << (l - i - 1);
      x >>= 1;
    }

    return rb;
  };

  // Performs "tweedling" phase, therefore 'emulating'
  // behaviour of the recursive algorithm
  FFTM.prototype.permute = function permute (rbt, rws, iws, rtws, itws, N) {
    for (var i = 0; i < N; i++) {
      rtws[i] = rws[rbt[i]];
      itws[i] = iws[rbt[i]];
    }
  };

  FFTM.prototype.transform = function transform (rws, iws, rtws, itws, N, rbt) {
    this.permute(rbt, rws, iws, rtws, itws, N);

    for (var s = 1; s < N; s <<= 1) {
      var l = s << 1;

      var rtwdf = Math.cos(2 * Math.PI / l);
      var itwdf = Math.sin(2 * Math.PI / l);

      for (var p = 0; p < N; p += l) {
        var rtwdf_ = rtwdf;
        var itwdf_ = itwdf;

        for (var j = 0; j < s; j++) {
          var re = rtws[p + j];
          var ie = itws[p + j];

          var ro = rtws[p + j + s];
          var io = itws[p + j + s];

          var rx = rtwdf_ * ro - itwdf_ * io;

          io = rtwdf_ * io + itwdf_ * ro;
          ro = rx;

          rtws[p + j] = re + ro;
          itws[p + j] = ie + io;

          rtws[p + j + s] = re - ro;
          itws[p + j + s] = ie - io;

          /* jshint maxdepth : false */
          if (j !== l) {
            rx = rtwdf * rtwdf_ - itwdf * itwdf_;

            itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
            rtwdf_ = rx;
          }
        }
      }
    }
  };

  FFTM.prototype.guessLen13b = function guessLen13b (n, m) {
    var N = Math.max(m, n) | 1;
    var odd = N & 1;
    var i = 0;
    for (N = N / 2 | 0; N; N = N >>> 1) {
      i++;
    }

    return 1 << i + 1 + odd;
  };

  FFTM.prototype.conjugate = function conjugate (rws, iws, N) {
    if (N <= 1) return;

    for (var i = 0; i < N / 2; i++) {
      var t = rws[i];

      rws[i] = rws[N - i - 1];
      rws[N - i - 1] = t;

      t = iws[i];

      iws[i] = -iws[N - i - 1];
      iws[N - i - 1] = -t;
    }
  };

  FFTM.prototype.normalize13b = function normalize13b (ws, N) {
    var carry = 0;
    for (var i = 0; i < N / 2; i++) {
      var w = Math.round(ws[2 * i + 1] / N) * 0x2000 +
        Math.round(ws[2 * i] / N) +
        carry;

      ws[i] = w & 0x3ffffff;

      if (w < 0x4000000) {
        carry = 0;
      } else {
        carry = w / 0x4000000 | 0;
      }
    }

    return ws;
  };

  FFTM.prototype.convert13b = function convert13b (ws, len, rws, N) {
    var carry = 0;
    for (var i = 0; i < len; i++) {
      carry = carry + (ws[i] | 0);

      rws[2 * i] = carry & 0x1fff; carry = carry >>> 13;
      rws[2 * i + 1] = carry & 0x1fff; carry = carry >>> 13;
    }

    // Pad with zeroes
    for (i = 2 * len; i < N; ++i) {
      rws[i] = 0;
    }

    assert(carry === 0);
    assert((carry & ~0x1fff) === 0);
  };

  FFTM.prototype.stub = function stub (N) {
    var ph = new Array(N);
    for (var i = 0; i < N; i++) {
      ph[i] = 0;
    }

    return ph;
  };

  FFTM.prototype.mulp = function mulp (x, y, out) {
    var N = 2 * this.guessLen13b(x.length, y.length);

    var rbt = this.makeRBT(N);

    var _ = this.stub(N);

    var rws = new Array(N);
    var rwst = new Array(N);
    var iwst = new Array(N);

    var nrws = new Array(N);
    var nrwst = new Array(N);
    var niwst = new Array(N);

    var rmws = out.words;
    rmws.length = N;

    this.convert13b(x.words, x.length, rws, N);
    this.convert13b(y.words, y.length, nrws, N);

    this.transform(rws, _, rwst, iwst, N, rbt);
    this.transform(nrws, _, nrwst, niwst, N, rbt);

    for (var i = 0; i < N; i++) {
      var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
      iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
      rwst[i] = rx;
    }

    this.conjugate(rwst, iwst, N);
    this.transform(rwst, iwst, rmws, _, N, rbt);
    this.conjugate(rmws, _, N);
    this.normalize13b(rmws, N);

    out.negative = x.negative ^ y.negative;
    out.length = x.length + y.length;
    return out._strip();
  };

  // Multiply `this` by `num`
  BN.prototype.mul = function mul (num) {
    var out = new BN(null);
    out.words = new Array(this.length + num.length);
    return this.mulTo(num, out);
  };

  // Multiply employing FFT
  BN.prototype.mulf = function mulf (num) {
    var out = new BN(null);
    out.words = new Array(this.length + num.length);
    return jumboMulTo(this, num, out);
  };

  // In-place Multiplication
  BN.prototype.imul = function imul (num) {
    return this.clone().mulTo(num, this);
  };

  BN.prototype.imuln = function imuln (num) {
    var isNegNum = num < 0;
    if (isNegNum) num = -num;

    assert(typeof num === 'number');
    assert(num < 0x4000000);

    // Carry
    var carry = 0;
    for (var i = 0; i < this.length; i++) {
      var w = (this.words[i] | 0) * num;
      var lo = (w & 0x3ffffff) + (carry & 0x3ffffff);
      carry >>= 26;
      carry += (w / 0x4000000) | 0;
      // NOTE: lo is 27bit maximum
      carry += lo >>> 26;
      this.words[i] = lo & 0x3ffffff;
    }

    if (carry !== 0) {
      this.words[i] = carry;
      this.length++;
    }

    return isNegNum ? this.ineg() : this;
  };

  BN.prototype.muln = function muln (num) {
    return this.clone().imuln(num);
  };

  // `this` * `this`
  BN.prototype.sqr = function sqr () {
    return this.mul(this);
  };

  // `this` * `this` in-place
  BN.prototype.isqr = function isqr () {
    return this.imul(this.clone());
  };

  // Math.pow(`this`, `num`)
  BN.prototype.pow = function pow (num) {
    var w = toBitArray(num);
    if (w.length === 0) return new BN(1);

    // Skip leading zeroes
    var res = this;
    for (var i = 0; i < w.length; i++, res = res.sqr()) {
      if (w[i] !== 0) break;
    }

    if (++i < w.length) {
      for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
        if (w[i] === 0) continue;

        res = res.mul(q);
      }
    }

    return res;
  };

  // Shift-left in-place
  BN.prototype.iushln = function iushln (bits) {
    assert(typeof bits === 'number' && bits >= 0);
    var r = bits % 26;
    var s = (bits - r) / 26;
    var carryMask = (0x3ffffff >>> (26 - r)) << (26 - r);
    var i;

    if (r !== 0) {
      var carry = 0;

      for (i = 0; i < this.length; i++) {
        var newCarry = this.words[i] & carryMask;
        var c = ((this.words[i] | 0) - newCarry) << r;
        this.words[i] = c | carry;
        carry = newCarry >>> (26 - r);
      }

      if (carry) {
        this.words[i] = carry;
        this.length++;
      }
    }

    if (s !== 0) {
      for (i = this.length - 1; i >= 0; i--) {
        this.words[i + s] = this.words[i];
      }

      for (i = 0; i < s; i++) {
        this.words[i] = 0;
      }

      this.length += s;
    }

    return this._strip();
  };

  BN.prototype.ishln = function ishln (bits) {
    // TODO(indutny): implement me
    assert(this.negative === 0);
    return this.iushln(bits);
  };

  // Shift-right in-place
  // NOTE: `hint` is a lowest bit before trailing zeroes
  // NOTE: if `extended` is present - it will be filled with destroyed bits
  BN.prototype.iushrn = function iushrn (bits, hint, extended) {
    assert(typeof bits === 'number' && bits >= 0);
    var h;
    if (hint) {
      h = (hint - (hint % 26)) / 26;
    } else {
      h = 0;
    }

    var r = bits % 26;
    var s = Math.min((bits - r) / 26, this.length);
    var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
    var maskedWords = extended;

    h -= s;
    h = Math.max(0, h);

    // Extended mode, copy masked part
    if (maskedWords) {
      for (var i = 0; i < s; i++) {
        maskedWords.words[i] = this.words[i];
      }
      maskedWords.length = s;
    }

    if (s === 0) {
      // No-op, we should not move anything at all
    } else if (this.length > s) {
      this.length -= s;
      for (i = 0; i < this.length; i++) {
        this.words[i] = this.words[i + s];
      }
    } else {
      this.words[0] = 0;
      this.length = 1;
    }

    var carry = 0;
    for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
      var word = this.words[i] | 0;
      this.words[i] = (carry << (26 - r)) | (word >>> r);
      carry = word & mask;
    }

    // Push carried bits as a mask
    if (maskedWords && carry !== 0) {
      maskedWords.words[maskedWords.length++] = carry;
    }

    if (this.length === 0) {
      this.words[0] = 0;
      this.length = 1;
    }

    return this._strip();
  };

  BN.prototype.ishrn = function ishrn (bits, hint, extended) {
    // TODO(indutny): implement me
    assert(this.negative === 0);
    return this.iushrn(bits, hint, extended);
  };

  // Shift-left
  BN.prototype.shln = function shln (bits) {
    return this.clone().ishln(bits);
  };

  BN.prototype.ushln = function ushln (bits) {
    return this.clone().iushln(bits);
  };

  // Shift-right
  BN.prototype.shrn = function shrn (bits) {
    return this.clone().ishrn(bits);
  };

  BN.prototype.ushrn = function ushrn (bits) {
    return this.clone().iushrn(bits);
  };

  // Test if n bit is set
  BN.prototype.testn = function testn (bit) {
    assert(typeof bit === 'number' && bit >= 0);
    var r = bit % 26;
    var s = (bit - r) / 26;
    var q = 1 << r;

    // Fast case: bit is much higher than all existing words
    if (this.length <= s) return false;

    // Check bit and return
    var w = this.words[s];

    return !!(w & q);
  };

  // Return only lowers bits of number (in-place)
  BN.prototype.imaskn = function imaskn (bits) {
    assert(typeof bits === 'number' && bits >= 0);
    var r = bits % 26;
    var s = (bits - r) / 26;

    assert(this.negative === 0, 'imaskn works only with positive numbers');

    if (this.length <= s) {
      return this;
    }

    if (r !== 0) {
      s++;
    }
    this.length = Math.min(s, this.length);

    if (r !== 0) {
      var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
      this.words[this.length - 1] &= mask;
    }

    return this._strip();
  };

  // Return only lowers bits of number
  BN.prototype.maskn = function maskn (bits) {
    return this.clone().imaskn(bits);
  };

  // Add plain number `num` to `this`
  BN.prototype.iaddn = function iaddn (num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);
    if (num < 0) return this.isubn(-num);

    // Possible sign change
    if (this.negative !== 0) {
      if (this.length === 1 && (this.words[0] | 0) <= num) {
        this.words[0] = num - (this.words[0] | 0);
        this.negative = 0;
        return this;
      }

      this.negative = 0;
      this.isubn(num);
      this.negative = 1;
      return this;
    }

    // Add without checks
    return this._iaddn(num);
  };

  BN.prototype._iaddn = function _iaddn (num) {
    this.words[0] += num;

    // Carry
    for (var i = 0; i < this.length && this.words[i] >= 0x4000000; i++) {
      this.words[i] -= 0x4000000;
      if (i === this.length - 1) {
        this.words[i + 1] = 1;
      } else {
        this.words[i + 1]++;
      }
    }
    this.length = Math.max(this.length, i + 1);

    return this;
  };

  // Subtract plain number `num` from `this`
  BN.prototype.isubn = function isubn (num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);
    if (num < 0) return this.iaddn(-num);

    if (this.negative !== 0) {
      this.negative = 0;
      this.iaddn(num);
      this.negative = 1;
      return this;
    }

    this.words[0] -= num;

    if (this.length === 1 && this.words[0] < 0) {
      this.words[0] = -this.words[0];
      this.negative = 1;
    } else {
      // Carry
      for (var i = 0; i < this.length && this.words[i] < 0; i++) {
        this.words[i] += 0x4000000;
        this.words[i + 1] -= 1;
      }
    }

    return this._strip();
  };

  BN.prototype.addn = function addn (num) {
    return this.clone().iaddn(num);
  };

  BN.prototype.subn = function subn (num) {
    return this.clone().isubn(num);
  };

  BN.prototype.iabs = function iabs () {
    this.negative = 0;

    return this;
  };

  BN.prototype.abs = function abs () {
    return this.clone().iabs();
  };

  BN.prototype._ishlnsubmul = function _ishlnsubmul (num, mul, shift) {
    var len = num.length + shift;
    var i;

    this._expand(len);

    var w;
    var carry = 0;
    for (i = 0; i < num.length; i++) {
      w = (this.words[i + shift] | 0) + carry;
      var right = (num.words[i] | 0) * mul;
      w -= right & 0x3ffffff;
      carry = (w >> 26) - ((right / 0x4000000) | 0);
      this.words[i + shift] = w & 0x3ffffff;
    }
    for (; i < this.length - shift; i++) {
      w = (this.words[i + shift] | 0) + carry;
      carry = w >> 26;
      this.words[i + shift] = w & 0x3ffffff;
    }

    if (carry === 0) return this._strip();

    // Subtraction overflow
    assert(carry === -1);
    carry = 0;
    for (i = 0; i < this.length; i++) {
      w = -(this.words[i] | 0) + carry;
      carry = w >> 26;
      this.words[i] = w & 0x3ffffff;
    }
    this.negative = 1;

    return this._strip();
  };

  BN.prototype._wordDiv = function _wordDiv (num, mode) {
    var shift = this.length - num.length;

    var a = this.clone();
    var b = num;

    // Normalize
    var bhi = b.words[b.length - 1] | 0;
    var bhiBits = this._countBits(bhi);
    shift = 26 - bhiBits;
    if (shift !== 0) {
      b = b.ushln(shift);
      a.iushln(shift);
      bhi = b.words[b.length - 1] | 0;
    }

    // Initialize quotient
    var m = a.length - b.length;
    var q;

    if (mode !== 'mod') {
      q = new BN(null);
      q.length = m + 1;
      q.words = new Array(q.length);
      for (var i = 0; i < q.length; i++) {
        q.words[i] = 0;
      }
    }

    var diff = a.clone()._ishlnsubmul(b, 1, m);
    if (diff.negative === 0) {
      a = diff;
      if (q) {
        q.words[m] = 1;
      }
    }

    for (var j = m - 1; j >= 0; j--) {
      var qj = (a.words[b.length + j] | 0) * 0x4000000 +
        (a.words[b.length + j - 1] | 0);

      // NOTE: (qj / bhi) is (0x3ffffff * 0x4000000 + 0x3ffffff) / 0x2000000 max
      // (0x7ffffff)
      qj = Math.min((qj / bhi) | 0, 0x3ffffff);

      a._ishlnsubmul(b, qj, j);
      while (a.negative !== 0) {
        qj--;
        a.negative = 0;
        a._ishlnsubmul(b, 1, j);
        if (!a.isZero()) {
          a.negative ^= 1;
        }
      }
      if (q) {
        q.words[j] = qj;
      }
    }
    if (q) {
      q._strip();
    }
    a._strip();

    // Denormalize
    if (mode !== 'div' && shift !== 0) {
      a.iushrn(shift);
    }

    return {
      div: q || null,
      mod: a
    };
  };

  // NOTE: 1) `mode` can be set to `mod` to request mod only,
  //       to `div` to request div only, or be absent to
  //       request both div & mod
  //       2) `positive` is true if unsigned mod is requested
  BN.prototype.divmod = function divmod (num, mode, positive) {
    assert(!num.isZero());

    if (this.isZero()) {
      return {
        div: new BN(0),
        mod: new BN(0)
      };
    }

    var div, mod, res;
    if (this.negative !== 0 && num.negative === 0) {
      res = this.neg().divmod(num, mode);

      if (mode !== 'mod') {
        div = res.div.neg();
      }

      if (mode !== 'div') {
        mod = res.mod.neg();
        if (positive && mod.negative !== 0) {
          mod.iadd(num);
        }
      }

      return {
        div: div,
        mod: mod
      };
    }

    if (this.negative === 0 && num.negative !== 0) {
      res = this.divmod(num.neg(), mode);

      if (mode !== 'mod') {
        div = res.div.neg();
      }

      return {
        div: div,
        mod: res.mod
      };
    }

    if ((this.negative & num.negative) !== 0) {
      res = this.neg().divmod(num.neg(), mode);

      if (mode !== 'div') {
        mod = res.mod.neg();
        if (positive && mod.negative !== 0) {
          mod.isub(num);
        }
      }

      return {
        div: res.div,
        mod: mod
      };
    }

    // Both numbers are positive at this point

    // Strip both numbers to approximate shift value
    if (num.length > this.length || this.cmp(num) < 0) {
      return {
        div: new BN(0),
        mod: this
      };
    }

    // Very short reduction
    if (num.length === 1) {
      if (mode === 'div') {
        return {
          div: this.divn(num.words[0]),
          mod: null
        };
      }

      if (mode === 'mod') {
        return {
          div: null,
          mod: new BN(this.modrn(num.words[0]))
        };
      }

      return {
        div: this.divn(num.words[0]),
        mod: new BN(this.modrn(num.words[0]))
      };
    }

    return this._wordDiv(num, mode);
  };

  // Find `this` / `num`
  BN.prototype.div = function div (num) {
    return this.divmod(num, 'div', false).div;
  };

  // Find `this` % `num`
  BN.prototype.mod = function mod (num) {
    return this.divmod(num, 'mod', false).mod;
  };

  BN.prototype.umod = function umod (num) {
    return this.divmod(num, 'mod', true).mod;
  };

  // Find Round(`this` / `num`)
  BN.prototype.divRound = function divRound (num) {
    var dm = this.divmod(num);

    // Fast case - exact division
    if (dm.mod.isZero()) return dm.div;

    var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;

    var half = num.ushrn(1);
    var r2 = num.andln(1);
    var cmp = mod.cmp(half);

    // Round down
    if (cmp < 0 || (r2 === 1 && cmp === 0)) return dm.div;

    // Round up
    return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
  };

  BN.prototype.modrn = function modrn (num) {
    var isNegNum = num < 0;
    if (isNegNum) num = -num;

    assert(num <= 0x3ffffff);
    var p = (1 << 26) % num;

    var acc = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      acc = (p * acc + (this.words[i] | 0)) % num;
    }

    return isNegNum ? -acc : acc;
  };

  // WARNING: DEPRECATED
  BN.prototype.modn = function modn (num) {
    return this.modrn(num);
  };

  // In-place division by number
  BN.prototype.idivn = function idivn (num) {
    var isNegNum = num < 0;
    if (isNegNum) num = -num;

    assert(num <= 0x3ffffff);

    var carry = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      var w = (this.words[i] | 0) + carry * 0x4000000;
      this.words[i] = (w / num) | 0;
      carry = w % num;
    }

    this._strip();
    return isNegNum ? this.ineg() : this;
  };

  BN.prototype.divn = function divn (num) {
    return this.clone().idivn(num);
  };

  BN.prototype.egcd = function egcd (p) {
    assert(p.negative === 0);
    assert(!p.isZero());

    var x = this;
    var y = p.clone();

    if (x.negative !== 0) {
      x = x.umod(p);
    } else {
      x = x.clone();
    }

    // A * x + B * y = x
    var A = new BN(1);
    var B = new BN(0);

    // C * x + D * y = y
    var C = new BN(0);
    var D = new BN(1);

    var g = 0;

    while (x.isEven() && y.isEven()) {
      x.iushrn(1);
      y.iushrn(1);
      ++g;
    }

    var yp = y.clone();
    var xp = x.clone();

    while (!x.isZero()) {
      for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
      if (i > 0) {
        x.iushrn(i);
        while (i-- > 0) {
          if (A.isOdd() || B.isOdd()) {
            A.iadd(yp);
            B.isub(xp);
          }

          A.iushrn(1);
          B.iushrn(1);
        }
      }

      for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
      if (j > 0) {
        y.iushrn(j);
        while (j-- > 0) {
          if (C.isOdd() || D.isOdd()) {
            C.iadd(yp);
            D.isub(xp);
          }

          C.iushrn(1);
          D.iushrn(1);
        }
      }

      if (x.cmp(y) >= 0) {
        x.isub(y);
        A.isub(C);
        B.isub(D);
      } else {
        y.isub(x);
        C.isub(A);
        D.isub(B);
      }
    }

    return {
      a: C,
      b: D,
      gcd: y.iushln(g)
    };
  };

  // This is reduced incarnation of the binary EEA
  // above, designated to invert members of the
  // _prime_ fields F(p) at a maximal speed
  BN.prototype._invmp = function _invmp (p) {
    assert(p.negative === 0);
    assert(!p.isZero());

    var a = this;
    var b = p.clone();

    if (a.negative !== 0) {
      a = a.umod(p);
    } else {
      a = a.clone();
    }

    var x1 = new BN(1);
    var x2 = new BN(0);

    var delta = b.clone();

    while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
      for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
      if (i > 0) {
        a.iushrn(i);
        while (i-- > 0) {
          if (x1.isOdd()) {
            x1.iadd(delta);
          }

          x1.iushrn(1);
        }
      }

      for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
      if (j > 0) {
        b.iushrn(j);
        while (j-- > 0) {
          if (x2.isOdd()) {
            x2.iadd(delta);
          }

          x2.iushrn(1);
        }
      }

      if (a.cmp(b) >= 0) {
        a.isub(b);
        x1.isub(x2);
      } else {
        b.isub(a);
        x2.isub(x1);
      }
    }

    var res;
    if (a.cmpn(1) === 0) {
      res = x1;
    } else {
      res = x2;
    }

    if (res.cmpn(0) < 0) {
      res.iadd(p);
    }

    return res;
  };

  BN.prototype.gcd = function gcd (num) {
    if (this.isZero()) return num.abs();
    if (num.isZero()) return this.abs();

    var a = this.clone();
    var b = num.clone();
    a.negative = 0;
    b.negative = 0;

    // Remove common factor of two
    for (var shift = 0; a.isEven() && b.isEven(); shift++) {
      a.iushrn(1);
      b.iushrn(1);
    }

    do {
      while (a.isEven()) {
        a.iushrn(1);
      }
      while (b.isEven()) {
        b.iushrn(1);
      }

      var r = a.cmp(b);
      if (r < 0) {
        // Swap `a` and `b` to make `a` always bigger than `b`
        var t = a;
        a = b;
        b = t;
      } else if (r === 0 || b.cmpn(1) === 0) {
        break;
      }

      a.isub(b);
    } while (true);

    return b.iushln(shift);
  };

  // Invert number in the field F(num)
  BN.prototype.invm = function invm (num) {
    return this.egcd(num).a.umod(num);
  };

  BN.prototype.isEven = function isEven () {
    return (this.words[0] & 1) === 0;
  };

  BN.prototype.isOdd = function isOdd () {
    return (this.words[0] & 1) === 1;
  };

  // And first word and num
  BN.prototype.andln = function andln (num) {
    return this.words[0] & num;
  };

  // Increment at the bit position in-line
  BN.prototype.bincn = function bincn (bit) {
    assert(typeof bit === 'number');
    var r = bit % 26;
    var s = (bit - r) / 26;
    var q = 1 << r;

    // Fast case: bit is much higher than all existing words
    if (this.length <= s) {
      this._expand(s + 1);
      this.words[s] |= q;
      return this;
    }

    // Add bit and propagate, if needed
    var carry = q;
    for (var i = s; carry !== 0 && i < this.length; i++) {
      var w = this.words[i] | 0;
      w += carry;
      carry = w >>> 26;
      w &= 0x3ffffff;
      this.words[i] = w;
    }
    if (carry !== 0) {
      this.words[i] = carry;
      this.length++;
    }
    return this;
  };

  BN.prototype.isZero = function isZero () {
    return this.length === 1 && this.words[0] === 0;
  };

  BN.prototype.cmpn = function cmpn (num) {
    var negative = num < 0;

    if (this.negative !== 0 && !negative) return -1;
    if (this.negative === 0 && negative) return 1;

    this._strip();

    var res;
    if (this.length > 1) {
      res = 1;
    } else {
      if (negative) {
        num = -num;
      }

      assert(num <= 0x3ffffff, 'Number is too big');

      var w = this.words[0] | 0;
      res = w === num ? 0 : w < num ? -1 : 1;
    }
    if (this.negative !== 0) return -res | 0;
    return res;
  };

  // Compare two numbers and return:
  // 1 - if `this` > `num`
  // 0 - if `this` == `num`
  // -1 - if `this` < `num`
  BN.prototype.cmp = function cmp (num) {
    if (this.negative !== 0 && num.negative === 0) return -1;
    if (this.negative === 0 && num.negative !== 0) return 1;

    var res = this.ucmp(num);
    if (this.negative !== 0) return -res | 0;
    return res;
  };

  // Unsigned comparison
  BN.prototype.ucmp = function ucmp (num) {
    // At this point both numbers have the same sign
    if (this.length > num.length) return 1;
    if (this.length < num.length) return -1;

    var res = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      var a = this.words[i] | 0;
      var b = num.words[i] | 0;

      if (a === b) continue;
      if (a < b) {
        res = -1;
      } else if (a > b) {
        res = 1;
      }
      break;
    }
    return res;
  };

  BN.prototype.gtn = function gtn (num) {
    return this.cmpn(num) === 1;
  };

  BN.prototype.gt = function gt (num) {
    return this.cmp(num) === 1;
  };

  BN.prototype.gten = function gten (num) {
    return this.cmpn(num) >= 0;
  };

  BN.prototype.gte = function gte (num) {
    return this.cmp(num) >= 0;
  };

  BN.prototype.ltn = function ltn (num) {
    return this.cmpn(num) === -1;
  };

  BN.prototype.lt = function lt (num) {
    return this.cmp(num) === -1;
  };

  BN.prototype.lten = function lten (num) {
    return this.cmpn(num) <= 0;
  };

  BN.prototype.lte = function lte (num) {
    return this.cmp(num) <= 0;
  };

  BN.prototype.eqn = function eqn (num) {
    return this.cmpn(num) === 0;
  };

  BN.prototype.eq = function eq (num) {
    return this.cmp(num) === 0;
  };

  //
  // A reduce context, could be using montgomery or something better, depending
  // on the `m` itself.
  //
  BN.red = function red (num) {
    return new Red(num);
  };

  BN.prototype.toRed = function toRed (ctx) {
    assert(!this.red, 'Already a number in reduction context');
    assert(this.negative === 0, 'red works only with positives');
    return ctx.convertTo(this)._forceRed(ctx);
  };

  BN.prototype.fromRed = function fromRed () {
    assert(this.red, 'fromRed works only with numbers in reduction context');
    return this.red.convertFrom(this);
  };

  BN.prototype._forceRed = function _forceRed (ctx) {
    this.red = ctx;
    return this;
  };

  BN.prototype.forceRed = function forceRed (ctx) {
    assert(!this.red, 'Already a number in reduction context');
    return this._forceRed(ctx);
  };

  BN.prototype.redAdd = function redAdd (num) {
    assert(this.red, 'redAdd works only with red numbers');
    return this.red.add(this, num);
  };

  BN.prototype.redIAdd = function redIAdd (num) {
    assert(this.red, 'redIAdd works only with red numbers');
    return this.red.iadd(this, num);
  };

  BN.prototype.redSub = function redSub (num) {
    assert(this.red, 'redSub works only with red numbers');
    return this.red.sub(this, num);
  };

  BN.prototype.redISub = function redISub (num) {
    assert(this.red, 'redISub works only with red numbers');
    return this.red.isub(this, num);
  };

  BN.prototype.redShl = function redShl (num) {
    assert(this.red, 'redShl works only with red numbers');
    return this.red.shl(this, num);
  };

  BN.prototype.redMul = function redMul (num) {
    assert(this.red, 'redMul works only with red numbers');
    this.red._verify2(this, num);
    return this.red.mul(this, num);
  };

  BN.prototype.redIMul = function redIMul (num) {
    assert(this.red, 'redMul works only with red numbers');
    this.red._verify2(this, num);
    return this.red.imul(this, num);
  };

  BN.prototype.redSqr = function redSqr () {
    assert(this.red, 'redSqr works only with red numbers');
    this.red._verify1(this);
    return this.red.sqr(this);
  };

  BN.prototype.redISqr = function redISqr () {
    assert(this.red, 'redISqr works only with red numbers');
    this.red._verify1(this);
    return this.red.isqr(this);
  };

  // Square root over p
  BN.prototype.redSqrt = function redSqrt () {
    assert(this.red, 'redSqrt works only with red numbers');
    this.red._verify1(this);
    return this.red.sqrt(this);
  };

  BN.prototype.redInvm = function redInvm () {
    assert(this.red, 'redInvm works only with red numbers');
    this.red._verify1(this);
    return this.red.invm(this);
  };

  // Return negative clone of `this` % `red modulo`
  BN.prototype.redNeg = function redNeg () {
    assert(this.red, 'redNeg works only with red numbers');
    this.red._verify1(this);
    return this.red.neg(this);
  };

  BN.prototype.redPow = function redPow (num) {
    assert(this.red && !num.red, 'redPow(normalNum)');
    this.red._verify1(this);
    return this.red.pow(this, num);
  };

  // Prime numbers with efficient reduction
  var primes = {
    k256: null,
    p224: null,
    p192: null,
    p25519: null
  };

  // Pseudo-Mersenne prime
  function MPrime (name, p) {
    // P = 2 ^ N - K
    this.name = name;
    this.p = new BN(p, 16);
    this.n = this.p.bitLength();
    this.k = new BN(1).iushln(this.n).isub(this.p);

    this.tmp = this._tmp();
  }

  MPrime.prototype._tmp = function _tmp () {
    var tmp = new BN(null);
    tmp.words = new Array(Math.ceil(this.n / 13));
    return tmp;
  };

  MPrime.prototype.ireduce = function ireduce (num) {
    // Assumes that `num` is less than `P^2`
    // num = HI * (2 ^ N - K) + HI * K + LO = HI * K + LO (mod P)
    var r = num;
    var rlen;

    do {
      this.split(r, this.tmp);
      r = this.imulK(r);
      r = r.iadd(this.tmp);
      rlen = r.bitLength();
    } while (rlen > this.n);

    var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
    if (cmp === 0) {
      r.words[0] = 0;
      r.length = 1;
    } else if (cmp > 0) {
      r.isub(this.p);
    } else {
      if (r.strip !== undefined) {
        // r is a BN v4 instance
        r.strip();
      } else {
        // r is a BN v5 instance
        r._strip();
      }
    }

    return r;
  };

  MPrime.prototype.split = function split (input, out) {
    input.iushrn(this.n, 0, out);
  };

  MPrime.prototype.imulK = function imulK (num) {
    return num.imul(this.k);
  };

  function K256 () {
    MPrime.call(
      this,
      'k256',
      'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f');
  }
  inherits(K256, MPrime);

  K256.prototype.split = function split (input, output) {
    // 256 = 9 * 26 + 22
    var mask = 0x3fffff;

    var outLen = Math.min(input.length, 9);
    for (var i = 0; i < outLen; i++) {
      output.words[i] = input.words[i];
    }
    output.length = outLen;

    if (input.length <= 9) {
      input.words[0] = 0;
      input.length = 1;
      return;
    }

    // Shift by 9 limbs
    var prev = input.words[9];
    output.words[output.length++] = prev & mask;

    for (i = 10; i < input.length; i++) {
      var next = input.words[i] | 0;
      input.words[i - 10] = ((next & mask) << 4) | (prev >>> 22);
      prev = next;
    }
    prev >>>= 22;
    input.words[i - 10] = prev;
    if (prev === 0 && input.length > 10) {
      input.length -= 10;
    } else {
      input.length -= 9;
    }
  };

  K256.prototype.imulK = function imulK (num) {
    // K = 0x1000003d1 = [ 0x40, 0x3d1 ]
    num.words[num.length] = 0;
    num.words[num.length + 1] = 0;
    num.length += 2;

    // bounded at: 0x40 * 0x3ffffff + 0x3d0 = 0x100000390
    var lo = 0;
    for (var i = 0; i < num.length; i++) {
      var w = num.words[i] | 0;
      lo += w * 0x3d1;
      num.words[i] = lo & 0x3ffffff;
      lo = w * 0x40 + ((lo / 0x4000000) | 0);
    }

    // Fast length reduction
    if (num.words[num.length - 1] === 0) {
      num.length--;
      if (num.words[num.length - 1] === 0) {
        num.length--;
      }
    }
    return num;
  };

  function P224 () {
    MPrime.call(
      this,
      'p224',
      'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001');
  }
  inherits(P224, MPrime);

  function P192 () {
    MPrime.call(
      this,
      'p192',
      'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff');
  }
  inherits(P192, MPrime);

  function P25519 () {
    // 2 ^ 255 - 19
    MPrime.call(
      this,
      '25519',
      '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed');
  }
  inherits(P25519, MPrime);

  P25519.prototype.imulK = function imulK (num) {
    // K = 0x13
    var carry = 0;
    for (var i = 0; i < num.length; i++) {
      var hi = (num.words[i] | 0) * 0x13 + carry;
      var lo = hi & 0x3ffffff;
      hi >>>= 26;

      num.words[i] = lo;
      carry = hi;
    }
    if (carry !== 0) {
      num.words[num.length++] = carry;
    }
    return num;
  };

  // Exported mostly for testing purposes, use plain name instead
  BN._prime = function prime (name) {
    // Cached version of prime
    if (primes[name]) return primes[name];

    var prime;
    if (name === 'k256') {
      prime = new K256();
    } else if (name === 'p224') {
      prime = new P224();
    } else if (name === 'p192') {
      prime = new P192();
    } else if (name === 'p25519') {
      prime = new P25519();
    } else {
      throw new Error('Unknown prime ' + name);
    }
    primes[name] = prime;

    return prime;
  };

  //
  // Base reduction engine
  //
  function Red (m) {
    if (typeof m === 'string') {
      var prime = BN._prime(m);
      this.m = prime.p;
      this.prime = prime;
    } else {
      assert(m.gtn(1), 'modulus must be greater than 1');
      this.m = m;
      this.prime = null;
    }
  }

  Red.prototype._verify1 = function _verify1 (a) {
    assert(a.negative === 0, 'red works only with positives');
    assert(a.red, 'red works only with red numbers');
  };

  Red.prototype._verify2 = function _verify2 (a, b) {
    assert((a.negative | b.negative) === 0, 'red works only with positives');
    assert(a.red && a.red === b.red,
      'red works only with red numbers');
  };

  Red.prototype.imod = function imod (a) {
    if (this.prime) return this.prime.ireduce(a)._forceRed(this);

    move(a, a.umod(this.m)._forceRed(this));
    return a;
  };

  Red.prototype.neg = function neg (a) {
    if (a.isZero()) {
      return a.clone();
    }

    return this.m.sub(a)._forceRed(this);
  };

  Red.prototype.add = function add (a, b) {
    this._verify2(a, b);

    var res = a.add(b);
    if (res.cmp(this.m) >= 0) {
      res.isub(this.m);
    }
    return res._forceRed(this);
  };

  Red.prototype.iadd = function iadd (a, b) {
    this._verify2(a, b);

    var res = a.iadd(b);
    if (res.cmp(this.m) >= 0) {
      res.isub(this.m);
    }
    return res;
  };

  Red.prototype.sub = function sub (a, b) {
    this._verify2(a, b);

    var res = a.sub(b);
    if (res.cmpn(0) < 0) {
      res.iadd(this.m);
    }
    return res._forceRed(this);
  };

  Red.prototype.isub = function isub (a, b) {
    this._verify2(a, b);

    var res = a.isub(b);
    if (res.cmpn(0) < 0) {
      res.iadd(this.m);
    }
    return res;
  };

  Red.prototype.shl = function shl (a, num) {
    this._verify1(a);
    return this.imod(a.ushln(num));
  };

  Red.prototype.imul = function imul (a, b) {
    this._verify2(a, b);
    return this.imod(a.imul(b));
  };

  Red.prototype.mul = function mul (a, b) {
    this._verify2(a, b);
    return this.imod(a.mul(b));
  };

  Red.prototype.isqr = function isqr (a) {
    return this.imul(a, a.clone());
  };

  Red.prototype.sqr = function sqr (a) {
    return this.mul(a, a);
  };

  Red.prototype.sqrt = function sqrt (a) {
    if (a.isZero()) return a.clone();

    var mod3 = this.m.andln(3);
    assert(mod3 % 2 === 1);

    // Fast case
    if (mod3 === 3) {
      var pow = this.m.add(new BN(1)).iushrn(2);
      return this.pow(a, pow);
    }

    // Tonelli-Shanks algorithm (Totally unoptimized and slow)
    //
    // Find Q and S, that Q * 2 ^ S = (P - 1)
    var q = this.m.subn(1);
    var s = 0;
    while (!q.isZero() && q.andln(1) === 0) {
      s++;
      q.iushrn(1);
    }
    assert(!q.isZero());

    var one = new BN(1).toRed(this);
    var nOne = one.redNeg();

    // Find quadratic non-residue
    // NOTE: Max is such because of generalized Riemann hypothesis.
    var lpow = this.m.subn(1).iushrn(1);
    var z = this.m.bitLength();
    z = new BN(2 * z * z).toRed(this);

    while (this.pow(z, lpow).cmp(nOne) !== 0) {
      z.redIAdd(nOne);
    }

    var c = this.pow(z, q);
    var r = this.pow(a, q.addn(1).iushrn(1));
    var t = this.pow(a, q);
    var m = s;
    while (t.cmp(one) !== 0) {
      var tmp = t;
      for (var i = 0; tmp.cmp(one) !== 0; i++) {
        tmp = tmp.redSqr();
      }
      assert(i < m);
      var b = this.pow(c, new BN(1).iushln(m - i - 1));

      r = r.redMul(b);
      c = b.redSqr();
      t = t.redMul(c);
      m = i;
    }

    return r;
  };

  Red.prototype.invm = function invm (a) {
    var inv = a._invmp(this.m);
    if (inv.negative !== 0) {
      inv.negative = 0;
      return this.imod(inv).redNeg();
    } else {
      return this.imod(inv);
    }
  };

  Red.prototype.pow = function pow (a, num) {
    if (num.isZero()) return new BN(1).toRed(this);
    if (num.cmpn(1) === 0) return a.clone();

    var windowSize = 4;
    var wnd = new Array(1 << windowSize);
    wnd[0] = new BN(1).toRed(this);
    wnd[1] = a;
    for (var i = 2; i < wnd.length; i++) {
      wnd[i] = this.mul(wnd[i - 1], a);
    }

    var res = wnd[0];
    var current = 0;
    var currentLen = 0;
    var start = num.bitLength() % 26;
    if (start === 0) {
      start = 26;
    }

    for (i = num.length - 1; i >= 0; i--) {
      var word = num.words[i];
      for (var j = start - 1; j >= 0; j--) {
        var bit = (word >> j) & 1;
        if (res !== wnd[0]) {
          res = this.sqr(res);
        }

        if (bit === 0 && current === 0) {
          currentLen = 0;
          continue;
        }

        current <<= 1;
        current |= bit;
        currentLen++;
        if (currentLen !== windowSize && (i !== 0 || j !== 0)) continue;

        res = this.mul(res, wnd[current]);
        currentLen = 0;
        current = 0;
      }
      start = 26;
    }

    return res;
  };

  Red.prototype.convertTo = function convertTo (num) {
    var r = num.umod(this.m);

    return r === num ? r.clone() : r;
  };

  Red.prototype.convertFrom = function convertFrom (num) {
    var res = num.clone();
    res.red = null;
    return res;
  };

  //
  // Montgomery method engine
  //

  BN.mont = function mont (num) {
    return new Mont(num);
  };

  function Mont (m) {
    Red.call(this, m);

    this.shift = this.m.bitLength();
    if (this.shift % 26 !== 0) {
      this.shift += 26 - (this.shift % 26);
    }

    this.r = new BN(1).iushln(this.shift);
    this.r2 = this.imod(this.r.sqr());
    this.rinv = this.r._invmp(this.m);

    this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
    this.minv = this.minv.umod(this.r);
    this.minv = this.r.sub(this.minv);
  }
  inherits(Mont, Red);

  Mont.prototype.convertTo = function convertTo (num) {
    return this.imod(num.ushln(this.shift));
  };

  Mont.prototype.convertFrom = function convertFrom (num) {
    var r = this.imod(num.mul(this.rinv));
    r.red = null;
    return r;
  };

  Mont.prototype.imul = function imul (a, b) {
    if (a.isZero() || b.isZero()) {
      a.words[0] = 0;
      a.length = 1;
      return a;
    }

    var t = a.imul(b);
    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
    var u = t.isub(c).iushrn(this.shift);
    var res = u;

    if (u.cmp(this.m) >= 0) {
      res = u.isub(this.m);
    } else if (u.cmpn(0) < 0) {
      res = u.iadd(this.m);
    }

    return res._forceRed(this);
  };

  Mont.prototype.mul = function mul (a, b) {
    if (a.isZero() || b.isZero()) return new BN(0)._forceRed(this);

    var t = a.mul(b);
    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
    var u = t.isub(c).iushrn(this.shift);
    var res = u;
    if (u.cmp(this.m) >= 0) {
      res = u.isub(this.m);
    } else if (u.cmpn(0) < 0) {
      res = u.iadd(this.m);
    }

    return res._forceRed(this);
  };

  Mont.prototype.invm = function invm (a) {
    // (AR)^-1 * R^2 = (A^-1 * R^-1) * R^2 = A^-1 * R
    var res = this.imod(a._invmp(this.m).mul(this.r2));
    return res._forceRed(this);
  };
})(typeof module === 'undefined' || module, this);

},{"buffer":27}],26:[function(require,module,exports){
var r;

module.exports = function rand(len) {
  if (!r)
    r = new Rand(null);

  return r.generate(len);
};

function Rand(rand) {
  this.rand = rand;
}
module.exports.Rand = Rand;

Rand.prototype.generate = function generate(len) {
  return this._rand(len);
};

// Emulate crypto API using randy
Rand.prototype._rand = function _rand(n) {
  if (this.rand.getBytes)
    return this.rand.getBytes(n);

  var res = new Uint8Array(n);
  for (var i = 0; i < res.length; i++)
    res[i] = this.rand.getByte();
  return res;
};

if (typeof self === 'object') {
  if (self.crypto && self.crypto.getRandomValues) {
    // Modern browsers
    Rand.prototype._rand = function _rand(n) {
      var arr = new Uint8Array(n);
      self.crypto.getRandomValues(arr);
      return arr;
    };
  } else if (self.msCrypto && self.msCrypto.getRandomValues) {
    // IE
    Rand.prototype._rand = function _rand(n) {
      var arr = new Uint8Array(n);
      self.msCrypto.getRandomValues(arr);
      return arr;
    };

  // Safari's WebWorkers do not have `crypto`
  } else if (typeof window === 'object') {
    // Old junk
    Rand.prototype._rand = function() {
      throw new Error('Not implemented yet');
    };
  }
} else {
  // Node.js or Web worker with no crypto support
  try {
    var crypto = require('crypto');
    if (typeof crypto.randomBytes !== 'function')
      throw new Error('Not supported');

    Rand.prototype._rand = function _rand(n) {
      return crypto.randomBytes(n);
    };
  } catch (e) {
  }
}

},{"crypto":27}],27:[function(require,module,exports){

},{}],28:[function(require,module,exports){
// based on the aes implimentation in triple sec
// https://github.com/keybase/triplesec
// which is in turn based on the one from crypto-js
// https://code.google.com/p/crypto-js/

var Buffer = require('safe-buffer').Buffer

function asUInt32Array (buf) {
  if (!Buffer.isBuffer(buf)) buf = Buffer.from(buf)

  var len = (buf.length / 4) | 0
  var out = new Array(len)

  for (var i = 0; i < len; i++) {
    out[i] = buf.readUInt32BE(i * 4)
  }

  return out
}

function scrubVec (v) {
  for (var i = 0; i < v.length; v++) {
    v[i] = 0
  }
}

function cryptBlock (M, keySchedule, SUB_MIX, SBOX, nRounds) {
  var SUB_MIX0 = SUB_MIX[0]
  var SUB_MIX1 = SUB_MIX[1]
  var SUB_MIX2 = SUB_MIX[2]
  var SUB_MIX3 = SUB_MIX[3]

  var s0 = M[0] ^ keySchedule[0]
  var s1 = M[1] ^ keySchedule[1]
  var s2 = M[2] ^ keySchedule[2]
  var s3 = M[3] ^ keySchedule[3]
  var t0, t1, t2, t3
  var ksRow = 4

  for (var round = 1; round < nRounds; round++) {
    t0 = SUB_MIX0[s0 >>> 24] ^ SUB_MIX1[(s1 >>> 16) & 0xff] ^ SUB_MIX2[(s2 >>> 8) & 0xff] ^ SUB_MIX3[s3 & 0xff] ^ keySchedule[ksRow++]
    t1 = SUB_MIX0[s1 >>> 24] ^ SUB_MIX1[(s2 >>> 16) & 0xff] ^ SUB_MIX2[(s3 >>> 8) & 0xff] ^ SUB_MIX3[s0 & 0xff] ^ keySchedule[ksRow++]
    t2 = SUB_MIX0[s2 >>> 24] ^ SUB_MIX1[(s3 >>> 16) & 0xff] ^ SUB_MIX2[(s0 >>> 8) & 0xff] ^ SUB_MIX3[s1 & 0xff] ^ keySchedule[ksRow++]
    t3 = SUB_MIX0[s3 >>> 24] ^ SUB_MIX1[(s0 >>> 16) & 0xff] ^ SUB_MIX2[(s1 >>> 8) & 0xff] ^ SUB_MIX3[s2 & 0xff] ^ keySchedule[ksRow++]
    s0 = t0
    s1 = t1
    s2 = t2
    s3 = t3
  }

  t0 = ((SBOX[s0 >>> 24] << 24) | (SBOX[(s1 >>> 16) & 0xff] << 16) | (SBOX[(s2 >>> 8) & 0xff] << 8) | SBOX[s3 & 0xff]) ^ keySchedule[ksRow++]
  t1 = ((SBOX[s1 >>> 24] << 24) | (SBOX[(s2 >>> 16) & 0xff] << 16) | (SBOX[(s3 >>> 8) & 0xff] << 8) | SBOX[s0 & 0xff]) ^ keySchedule[ksRow++]
  t2 = ((SBOX[s2 >>> 24] << 24) | (SBOX[(s3 >>> 16) & 0xff] << 16) | (SBOX[(s0 >>> 8) & 0xff] << 8) | SBOX[s1 & 0xff]) ^ keySchedule[ksRow++]
  t3 = ((SBOX[s3 >>> 24] << 24) | (SBOX[(s0 >>> 16) & 0xff] << 16) | (SBOX[(s1 >>> 8) & 0xff] << 8) | SBOX[s2 & 0xff]) ^ keySchedule[ksRow++]
  t0 = t0 >>> 0
  t1 = t1 >>> 0
  t2 = t2 >>> 0
  t3 = t3 >>> 0

  return [t0, t1, t2, t3]
}

// AES constants
var RCON = [0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36]
var G = (function () {
  // Compute double table
  var d = new Array(256)
  for (var j = 0; j < 256; j++) {
    if (j < 128) {
      d[j] = j << 1
    } else {
      d[j] = (j << 1) ^ 0x11b
    }
  }

  var SBOX = []
  var INV_SBOX = []
  var SUB_MIX = [[], [], [], []]
  var INV_SUB_MIX = [[], [], [], []]

  // Walk GF(2^8)
  var x = 0
  var xi = 0
  for (var i = 0; i < 256; ++i) {
    // Compute sbox
    var sx = xi ^ (xi << 1) ^ (xi << 2) ^ (xi << 3) ^ (xi << 4)
    sx = (sx >>> 8) ^ (sx & 0xff) ^ 0x63
    SBOX[x] = sx
    INV_SBOX[sx] = x

    // Compute multiplication
    var x2 = d[x]
    var x4 = d[x2]
    var x8 = d[x4]

    // Compute sub bytes, mix columns tables
    var t = (d[sx] * 0x101) ^ (sx * 0x1010100)
    SUB_MIX[0][x] = (t << 24) | (t >>> 8)
    SUB_MIX[1][x] = (t << 16) | (t >>> 16)
    SUB_MIX[2][x] = (t << 8) | (t >>> 24)
    SUB_MIX[3][x] = t

    // Compute inv sub bytes, inv mix columns tables
    t = (x8 * 0x1010101) ^ (x4 * 0x10001) ^ (x2 * 0x101) ^ (x * 0x1010100)
    INV_SUB_MIX[0][sx] = (t << 24) | (t >>> 8)
    INV_SUB_MIX[1][sx] = (t << 16) | (t >>> 16)
    INV_SUB_MIX[2][sx] = (t << 8) | (t >>> 24)
    INV_SUB_MIX[3][sx] = t

    if (x === 0) {
      x = xi = 1
    } else {
      x = x2 ^ d[d[d[x8 ^ x2]]]
      xi ^= d[d[xi]]
    }
  }

  return {
    SBOX: SBOX,
    INV_SBOX: INV_SBOX,
    SUB_MIX: SUB_MIX,
    INV_SUB_MIX: INV_SUB_MIX
  }
})()

function AES (key) {
  this._key = asUInt32Array(key)
  this._reset()
}

AES.blockSize = 4 * 4
AES.keySize = 256 / 8
AES.prototype.blockSize = AES.blockSize
AES.prototype.keySize = AES.keySize
AES.prototype._reset = function () {
  var keyWords = this._key
  var keySize = keyWords.length
  var nRounds = keySize + 6
  var ksRows = (nRounds + 1) * 4

  var keySchedule = []
  for (var k = 0; k < keySize; k++) {
    keySchedule[k] = keyWords[k]
  }

  for (k = keySize; k < ksRows; k++) {
    var t = keySchedule[k - 1]

    if (k % keySize === 0) {
      t = (t << 8) | (t >>> 24)
      t =
        (G.SBOX[t >>> 24] << 24) |
        (G.SBOX[(t >>> 16) & 0xff] << 16) |
        (G.SBOX[(t >>> 8) & 0xff] << 8) |
        (G.SBOX[t & 0xff])

      t ^= RCON[(k / keySize) | 0] << 24
    } else if (keySize > 6 && k % keySize === 4) {
      t =
        (G.SBOX[t >>> 24] << 24) |
        (G.SBOX[(t >>> 16) & 0xff] << 16) |
        (G.SBOX[(t >>> 8) & 0xff] << 8) |
        (G.SBOX[t & 0xff])
    }

    keySchedule[k] = keySchedule[k - keySize] ^ t
  }

  var invKeySchedule = []
  for (var ik = 0; ik < ksRows; ik++) {
    var ksR = ksRows - ik
    var tt = keySchedule[ksR - (ik % 4 ? 0 : 4)]

    if (ik < 4 || ksR <= 4) {
      invKeySchedule[ik] = tt
    } else {
      invKeySchedule[ik] =
        G.INV_SUB_MIX[0][G.SBOX[tt >>> 24]] ^
        G.INV_SUB_MIX[1][G.SBOX[(tt >>> 16) & 0xff]] ^
        G.INV_SUB_MIX[2][G.SBOX[(tt >>> 8) & 0xff]] ^
        G.INV_SUB_MIX[3][G.SBOX[tt & 0xff]]
    }
  }

  this._nRounds = nRounds
  this._keySchedule = keySchedule
  this._invKeySchedule = invKeySchedule
}

AES.prototype.encryptBlockRaw = function (M) {
  M = asUInt32Array(M)
  return cryptBlock(M, this._keySchedule, G.SUB_MIX, G.SBOX, this._nRounds)
}

AES.prototype.encryptBlock = function (M) {
  var out = this.encryptBlockRaw(M)
  var buf = Buffer.allocUnsafe(16)
  buf.writeUInt32BE(out[0], 0)
  buf.writeUInt32BE(out[1], 4)
  buf.writeUInt32BE(out[2], 8)
  buf.writeUInt32BE(out[3], 12)
  return buf
}

AES.prototype.decryptBlock = function (M) {
  M = asUInt32Array(M)

  // swap
  var m1 = M[1]
  M[1] = M[3]
  M[3] = m1

  var out = cryptBlock(M, this._invKeySchedule, G.INV_SUB_MIX, G.INV_SBOX, this._nRounds)
  var buf = Buffer.allocUnsafe(16)
  buf.writeUInt32BE(out[0], 0)
  buf.writeUInt32BE(out[3], 4)
  buf.writeUInt32BE(out[2], 8)
  buf.writeUInt32BE(out[1], 12)
  return buf
}

AES.prototype.scrub = function () {
  scrubVec(this._keySchedule)
  scrubVec(this._invKeySchedule)
  scrubVec(this._key)
}

module.exports.AES = AES

},{"safe-buffer":170}],29:[function(require,module,exports){
var aes = require('./aes')
var Buffer = require('safe-buffer').Buffer
var Transform = require('cipher-base')
var inherits = require('inherits')
var GHASH = require('./ghash')
var xor = require('buffer-xor')
var incr32 = require('./incr32')

function xorTest (a, b) {
  var out = 0
  if (a.length !== b.length) out++

  var len = Math.min(a.length, b.length)
  for (var i = 0; i < len; ++i) {
    out += (a[i] ^ b[i])
  }

  return out
}

function calcIv (self, iv, ck) {
  if (iv.length === 12) {
    self._finID = Buffer.concat([iv, Buffer.from([0, 0, 0, 1])])
    return Buffer.concat([iv, Buffer.from([0, 0, 0, 2])])
  }
  var ghash = new GHASH(ck)
  var len = iv.length
  var toPad = len % 16
  ghash.update(iv)
  if (toPad) {
    toPad = 16 - toPad
    ghash.update(Buffer.alloc(toPad, 0))
  }
  ghash.update(Buffer.alloc(8, 0))
  var ivBits = len * 8
  var tail = Buffer.alloc(8)
  tail.writeUIntBE(ivBits, 0, 8)
  ghash.update(tail)
  self._finID = ghash.state
  var out = Buffer.from(self._finID)
  incr32(out)
  return out
}
function StreamCipher (mode, key, iv, decrypt) {
  Transform.call(this)

  var h = Buffer.alloc(4, 0)

  this._cipher = new aes.AES(key)
  var ck = this._cipher.encryptBlock(h)
  this._ghash = new GHASH(ck)
  iv = calcIv(this, iv, ck)

  this._prev = Buffer.from(iv)
  this._cache = Buffer.allocUnsafe(0)
  this._secCache = Buffer.allocUnsafe(0)
  this._decrypt = decrypt
  this._alen = 0
  this._len = 0
  this._mode = mode

  this._authTag = null
  this._called = false
}

inherits(StreamCipher, Transform)

StreamCipher.prototype._update = function (chunk) {
  if (!this._called && this._alen) {
    var rump = 16 - (this._alen % 16)
    if (rump < 16) {
      rump = Buffer.alloc(rump, 0)
      this._ghash.update(rump)
    }
  }

  this._called = true
  var out = this._mode.encrypt(this, chunk)
  if (this._decrypt) {
    this._ghash.update(chunk)
  } else {
    this._ghash.update(out)
  }
  this._len += chunk.length
  return out
}

StreamCipher.prototype._final = function () {
  if (this._decrypt && !this._authTag) throw new Error('Unsupported state or unable to authenticate data')

  var tag = xor(this._ghash.final(this._alen * 8, this._len * 8), this._cipher.encryptBlock(this._finID))
  if (this._decrypt && xorTest(tag, this._authTag)) throw new Error('Unsupported state or unable to authenticate data')

  this._authTag = tag
  this._cipher.scrub()
}

StreamCipher.prototype.getAuthTag = function getAuthTag () {
  if (this._decrypt || !Buffer.isBuffer(this._authTag)) throw new Error('Attempting to get auth tag in unsupported state')

  return this._authTag
}

StreamCipher.prototype.setAuthTag = function setAuthTag (tag) {
  if (!this._decrypt) throw new Error('Attempting to set auth tag in unsupported state')

  this._authTag = tag
}

StreamCipher.prototype.setAAD = function setAAD (buf) {
  if (this._called) throw new Error('Attempting to set AAD in unsupported state')

  this._ghash.update(buf)
  this._alen += buf.length
}

module.exports = StreamCipher

},{"./aes":28,"./ghash":33,"./incr32":34,"buffer-xor":71,"cipher-base":73,"inherits":141,"safe-buffer":170}],30:[function(require,module,exports){
var ciphers = require('./encrypter')
var deciphers = require('./decrypter')
var modes = require('./modes/list.json')

function getCiphers () {
  return Object.keys(modes)
}

exports.createCipher = exports.Cipher = ciphers.createCipher
exports.createCipheriv = exports.Cipheriv = ciphers.createCipheriv
exports.createDecipher = exports.Decipher = deciphers.createDecipher
exports.createDecipheriv = exports.Decipheriv = deciphers.createDecipheriv
exports.listCiphers = exports.getCiphers = getCiphers

},{"./decrypter":31,"./encrypter":32,"./modes/list.json":42}],31:[function(require,module,exports){
var AuthCipher = require('./authCipher')
var Buffer = require('safe-buffer').Buffer
var MODES = require('./modes')
var StreamCipher = require('./streamCipher')
var Transform = require('cipher-base')
var aes = require('./aes')
var ebtk = require('evp_bytestokey')
var inherits = require('inherits')

function Decipher (mode, key, iv) {
  Transform.call(this)

  this._cache = new Splitter()
  this._last = void 0
  this._cipher = new aes.AES(key)
  this._prev = Buffer.from(iv)
  this._mode = mode
  this._autopadding = true
}

inherits(Decipher, Transform)

Decipher.prototype._update = function (data) {
  this._cache.add(data)
  var chunk
  var thing
  var out = []
  while ((chunk = this._cache.get(this._autopadding))) {
    thing = this._mode.decrypt(this, chunk)
    out.push(thing)
  }
  return Buffer.concat(out)
}

Decipher.prototype._final = function () {
  var chunk = this._cache.flush()
  if (this._autopadding) {
    return unpad(this._mode.decrypt(this, chunk))
  } else if (chunk) {
    throw new Error('data not multiple of block length')
  }
}

Decipher.prototype.setAutoPadding = function (setTo) {
  this._autopadding = !!setTo
  return this
}

function Splitter () {
  this.cache = Buffer.allocUnsafe(0)
}

Splitter.prototype.add = function (data) {
  this.cache = Buffer.concat([this.cache, data])
}

Splitter.prototype.get = function (autoPadding) {
  var out
  if (autoPadding) {
    if (this.cache.length > 16) {
      out = this.cache.slice(0, 16)
      this.cache = this.cache.slice(16)
      return out
    }
  } else {
    if (this.cache.length >= 16) {
      out = this.cache.slice(0, 16)
      this.cache = this.cache.slice(16)
      return out
    }
  }

  return null
}

Splitter.prototype.flush = function () {
  if (this.cache.length) return this.cache
}

function unpad (last) {
  var padded = last[15]
  if (padded < 1 || padded > 16) {
    throw new Error('unable to decrypt data')
  }
  var i = -1
  while (++i < padded) {
    if (last[(i + (16 - padded))] !== padded) {
      throw new Error('unable to decrypt data')
    }
  }
  if (padded === 16) return

  return last.slice(0, 16 - padded)
}

function createDecipheriv (suite, password, iv) {
  var config = MODES[suite.toLowerCase()]
  if (!config) throw new TypeError('invalid suite type')

  if (typeof iv === 'string') iv = Buffer.from(iv)
  if (config.mode !== 'GCM' && iv.length !== config.iv) throw new TypeError('invalid iv length ' + iv.length)

  if (typeof password === 'string') password = Buffer.from(password)
  if (password.length !== config.key / 8) throw new TypeError('invalid key length ' + password.length)

  if (config.type === 'stream') {
    return new StreamCipher(config.module, password, iv, true)
  } else if (config.type === 'auth') {
    return new AuthCipher(config.module, password, iv, true)
  }

  return new Decipher(config.module, password, iv)
}

function createDecipher (suite, password) {
  var config = MODES[suite.toLowerCase()]
  if (!config) throw new TypeError('invalid suite type')

  var keys = ebtk(password, false, config.key, config.iv)
  return createDecipheriv(suite, keys.key, keys.iv)
}

exports.createDecipher = createDecipher
exports.createDecipheriv = createDecipheriv

},{"./aes":28,"./authCipher":29,"./modes":41,"./streamCipher":44,"cipher-base":73,"evp_bytestokey":110,"inherits":141,"safe-buffer":170}],32:[function(require,module,exports){
var MODES = require('./modes')
var AuthCipher = require('./authCipher')
var Buffer = require('safe-buffer').Buffer
var StreamCipher = require('./streamCipher')
var Transform = require('cipher-base')
var aes = require('./aes')
var ebtk = require('evp_bytestokey')
var inherits = require('inherits')

function Cipher (mode, key, iv) {
  Transform.call(this)

  this._cache = new Splitter()
  this._cipher = new aes.AES(key)
  this._prev = Buffer.from(iv)
  this._mode = mode
  this._autopadding = true
}

inherits(Cipher, Transform)

Cipher.prototype._update = function (data) {
  this._cache.add(data)
  var chunk
  var thing
  var out = []

  while ((chunk = this._cache.get())) {
    thing = this._mode.encrypt(this, chunk)
    out.push(thing)
  }

  return Buffer.concat(out)
}

var PADDING = Buffer.alloc(16, 0x10)

Cipher.prototype._final = function () {
  var chunk = this._cache.flush()
  if (this._autopadding) {
    chunk = this._mode.encrypt(this, chunk)
    this._cipher.scrub()
    return chunk
  }

  if (!chunk.equals(PADDING)) {
    this._cipher.scrub()
    throw new Error('data not multiple of block length')
  }
}

Cipher.prototype.setAutoPadding = function (setTo) {
  this._autopadding = !!setTo
  return this
}

function Splitter () {
  this.cache = Buffer.allocUnsafe(0)
}

Splitter.prototype.add = function (data) {
  this.cache = Buffer.concat([this.cache, data])
}

Splitter.prototype.get = function () {
  if (this.cache.length > 15) {
    var out = this.cache.slice(0, 16)
    this.cache = this.cache.slice(16)
    return out
  }
  return null
}

Splitter.prototype.flush = function () {
  var len = 16 - this.cache.length
  var padBuff = Buffer.allocUnsafe(len)

  var i = -1
  while (++i < len) {
    padBuff.writeUInt8(len, i)
  }

  return Buffer.concat([this.cache, padBuff])
}

function createCipheriv (suite, password, iv) {
  var config = MODES[suite.toLowerCase()]
  if (!config) throw new TypeError('invalid suite type')

  if (typeof password === 'string') password = Buffer.from(password)
  if (password.length !== config.key / 8) throw new TypeError('invalid key length ' + password.length)

  if (typeof iv === 'string') iv = Buffer.from(iv)
  if (config.mode !== 'GCM' && iv.length !== config.iv) throw new TypeError('invalid iv length ' + iv.length)

  if (config.type === 'stream') {
    return new StreamCipher(config.module, password, iv)
  } else if (config.type === 'auth') {
    return new AuthCipher(config.module, password, iv)
  }

  return new Cipher(config.module, password, iv)
}

function createCipher (suite, password) {
  var config = MODES[suite.toLowerCase()]
  if (!config) throw new TypeError('invalid suite type')

  var keys = ebtk(password, false, config.key, config.iv)
  return createCipheriv(suite, keys.key, keys.iv)
}

exports.createCipheriv = createCipheriv
exports.createCipher = createCipher

},{"./aes":28,"./authCipher":29,"./modes":41,"./streamCipher":44,"cipher-base":73,"evp_bytestokey":110,"inherits":141,"safe-buffer":170}],33:[function(require,module,exports){
var Buffer = require('safe-buffer').Buffer
var ZEROES = Buffer.alloc(16, 0)

function toArray (buf) {
  return [
    buf.readUInt32BE(0),
    buf.readUInt32BE(4),
    buf.readUInt32BE(8),
    buf.readUInt32BE(12)
  ]
}

function fromArray (out) {
  var buf = Buffer.allocUnsafe(16)
  buf.writeUInt32BE(out[0] >>> 0, 0)
  buf.writeUInt32BE(out[1] >>> 0, 4)
  buf.writeUInt32BE(out[2] >>> 0, 8)
  buf.writeUInt32BE(out[3] >>> 0, 12)
  return buf
}

function GHASH (key) {
  this.h = key
  this.state = Buffer.alloc(16, 0)
  this.cache = Buffer.allocUnsafe(0)
}

// from http://bitwiseshiftleft.github.io/sjcl/doc/symbols/src/core_gcm.js.html
// by Juho Vähä-Herttua
GHASH.prototype.ghash = function (block) {
  var i = -1
  while (++i < block.length) {
    this.state[i] ^= block[i]
  }
  this._multiply()
}

GHASH.prototype._multiply = function () {
  var Vi = toArray(this.h)
  var Zi = [0, 0, 0, 0]
  var j, xi, lsbVi
  var i = -1
  while (++i < 128) {
    xi = (this.state[~~(i / 8)] & (1 << (7 - (i % 8)))) !== 0
    if (xi) {
      // Z_i+1 = Z_i ^ V_i
      Zi[0] ^= Vi[0]
      Zi[1] ^= Vi[1]
      Zi[2] ^= Vi[2]
      Zi[3] ^= Vi[3]
    }

    // Store the value of LSB(V_i)
    lsbVi = (Vi[3] & 1) !== 0

    // V_i+1 = V_i >> 1
    for (j = 3; j > 0; j--) {
      Vi[j] = (Vi[j] >>> 1) | ((Vi[j - 1] & 1) << 31)
    }
    Vi[0] = Vi[0] >>> 1

    // If LSB(V_i) is 1, V_i+1 = (V_i >> 1) ^ R
    if (lsbVi) {
      Vi[0] = Vi[0] ^ (0xe1 << 24)
    }
  }
  this.state = fromArray(Zi)
}

GHASH.prototype.update = function (buf) {
  this.cache = Buffer.concat([this.cache, buf])
  var chunk
  while (this.cache.length >= 16) {
    chunk = this.cache.slice(0, 16)
    this.cache = this.cache.slice(16)
    this.ghash(chunk)
  }
}

GHASH.prototype.final = function (abl, bl) {
  if (this.cache.length) {
    this.ghash(Buffer.concat([this.cache, ZEROES], 16))
  }

  this.ghash(fromArray([0, abl, 0, bl]))
  return this.state
}

module.exports = GHASH

},{"safe-buffer":170}],34:[function(require,module,exports){
function incr32 (iv) {
  var len = iv.length
  var item
  while (len--) {
    item = iv.readUInt8(len)
    if (item === 255) {
      iv.writeUInt8(0, len)
    } else {
      item++
      iv.writeUInt8(item, len)
      break
    }
  }
}
module.exports = incr32

},{}],35:[function(require,module,exports){
var xor = require('buffer-xor')

exports.encrypt = function (self, block) {
  var data = xor(block, self._prev)

  self._prev = self._cipher.encryptBlock(data)
  return self._prev
}

exports.decrypt = function (self, block) {
  var pad = self._prev

  self._prev = block
  var out = self._cipher.decryptBlock(block)

  return xor(out, pad)
}

},{"buffer-xor":71}],36:[function(require,module,exports){
var Buffer = require('safe-buffer').Buffer
var xor = require('buffer-xor')

function encryptStart (self, data, decrypt) {
  var len = data.length
  var out = xor(data, self._cache)
  self._cache = self._cache.slice(len)
  self._prev = Buffer.concat([self._prev, decrypt ? data : out])
  return out
}

exports.encrypt = function (self, data, decrypt) {
  var out = Buffer.allocUnsafe(0)
  var len

  while (data.length) {
    if (self._cache.length === 0) {
      self._cache = self._cipher.encryptBlock(self._prev)
      self._prev = Buffer.allocUnsafe(0)
    }

    if (self._cache.length <= data.length) {
      len = self._cache.length
      out = Buffer.concat([out, encryptStart(self, data.slice(0, len), decrypt)])
      data = data.slice(len)
    } else {
      out = Buffer.concat([out, encryptStart(self, data, decrypt)])
      break
    }
  }

  return out
}

},{"buffer-xor":71,"safe-buffer":170}],37:[function(require,module,exports){
var Buffer = require('safe-buffer').Buffer

function encryptByte (self, byteParam, decrypt) {
  var pad
  var i = -1
  var len = 8
  var out = 0
  var bit, value
  while (++i < len) {
    pad = self._cipher.encryptBlock(self._prev)
    bit = (byteParam & (1 << (7 - i))) ? 0x80 : 0
    value = pad[0] ^ bit
    out += ((value & 0x80) >> (i % 8))
    self._prev = shiftIn(self._prev, decrypt ? bit : value)
  }
  return out
}

function shiftIn (buffer, value) {
  var len = buffer.length
  var i = -1
  var out = Buffer.allocUnsafe(buffer.length)
  buffer = Buffer.concat([buffer, Buffer.from([value])])

  while (++i < len) {
    out[i] = buffer[i] << 1 | buffer[i + 1] >> (7)
  }

  return out
}

exports.encrypt = function (self, chunk, decrypt) {
  var len = chunk.length
  var out = Buffer.allocUnsafe(len)
  var i = -1

  while (++i < len) {
    out[i] = encryptByte(self, chunk[i], decrypt)
  }

  return out
}

},{"safe-buffer":170}],38:[function(require,module,exports){
var Buffer = require('safe-buffer').Buffer

function encryptByte (self, byteParam, decrypt) {
  var pad = self._cipher.encryptBlock(self._prev)
  var out = pad[0] ^ byteParam

  self._prev = Buffer.concat([
    self._prev.slice(1),
    Buffer.from([decrypt ? byteParam : out])
  ])

  return out
}

exports.encrypt = function (self, chunk, decrypt) {
  var len = chunk.length
  var out = Buffer.allocUnsafe(len)
  var i = -1

  while (++i < len) {
    out[i] = encryptByte(self, chunk[i], decrypt)
  }

  return out
}

},{"safe-buffer":170}],39:[function(require,module,exports){
var xor = require('buffer-xor')
var Buffer = require('safe-buffer').Buffer
var incr32 = require('../incr32')

function getBlock (self) {
  var out = self._cipher.encryptBlockRaw(self._prev)
  incr32(self._prev)
  return out
}

var blockSize = 16
exports.encrypt = function (self, chunk) {
  var chunkNum = Math.ceil(chunk.length / blockSize)
  var start = self._cache.length
  self._cache = Buffer.concat([
    self._cache,
    Buffer.allocUnsafe(chunkNum * blockSize)
  ])
  for (var i = 0; i < chunkNum; i++) {
    var out = getBlock(self)
    var offset = start + i * blockSize
    self._cache.writeUInt32BE(out[0], offset + 0)
    self._cache.writeUInt32BE(out[1], offset + 4)
    self._cache.writeUInt32BE(out[2], offset + 8)
    self._cache.writeUInt32BE(out[3], offset + 12)
  }
  var pad = self._cache.slice(0, chunk.length)
  self._cache = self._cache.slice(chunk.length)
  return xor(chunk, pad)
}

},{"../incr32":34,"buffer-xor":71,"safe-buffer":170}],40:[function(require,module,exports){
exports.encrypt = function (self, block) {
  return self._cipher.encryptBlock(block)
}

exports.decrypt = function (self, block) {
  return self._cipher.decryptBlock(block)
}

},{}],41:[function(require,module,exports){
var modeModules = {
  ECB: require('./ecb'),
  CBC: require('./cbc'),
  CFB: require('./cfb'),
  CFB8: require('./cfb8'),
  CFB1: require('./cfb1'),
  OFB: require('./ofb'),
  CTR: require('./ctr'),
  GCM: require('./ctr')
}

var modes = require('./list.json')

for (var key in modes) {
  modes[key].module = modeModules[modes[key].mode]
}

module.exports = modes

},{"./cbc":35,"./cfb":36,"./cfb1":37,"./cfb8":38,"./ctr":39,"./ecb":40,"./list.json":42,"./ofb":43}],42:[function(require,module,exports){
module.exports={
  "aes-128-ecb": {
    "cipher": "AES",
    "key": 128,
    "iv": 0,
    "mode": "ECB",
    "type": "block"
  },
  "aes-192-ecb": {
    "cipher": "AES",
    "key": 192,
    "iv": 0,
    "mode": "ECB",
    "type": "block"
  },
  "aes-256-ecb": {
    "cipher": "AES",
    "key": 256,
    "iv": 0,
    "mode": "ECB",
    "type": "block"
  },
  "aes-128-cbc": {
    "cipher": "AES",
    "key": 128,
    "iv": 16,
    "mode": "CBC",
    "type": "block"
  },
  "aes-192-cbc": {
    "cipher": "AES",
    "key": 192,
    "iv": 16,
    "mode": "CBC",
    "type": "block"
  },
  "aes-256-cbc": {
    "cipher": "AES",
    "key": 256,
    "iv": 16,
    "mode": "CBC",
    "type": "block"
  },
  "aes128": {
    "cipher": "AES",
    "key": 128,
    "iv": 16,
    "mode": "CBC",
    "type": "block"
  },
  "aes192": {
    "cipher": "AES",
    "key": 192,
    "iv": 16,
    "mode": "CBC",
    "type": "block"
  },
  "aes256": {
    "cipher": "AES",
    "key": 256,
    "iv": 16,
    "mode": "CBC",
    "type": "block"
  },
  "aes-128-cfb": {
    "cipher": "AES",
    "key": 128,
    "iv": 16,
    "mode": "CFB",
    "type": "stream"
  },
  "aes-192-cfb": {
    "cipher": "AES",
    "key": 192,
    "iv": 16,
    "mode": "CFB",
    "type": "stream"
  },
  "aes-256-cfb": {
    "cipher": "AES",
    "key": 256,
    "iv": 16,
    "mode": "CFB",
    "type": "stream"
  },
  "aes-128-cfb8": {
    "cipher": "AES",
    "key": 128,
    "iv": 16,
    "mode": "CFB8",
    "type": "stream"
  },
  "aes-192-cfb8": {
    "cipher": "AES",
    "key": 192,
    "iv": 16,
    "mode": "CFB8",
    "type": "stream"
  },
  "aes-256-cfb8": {
    "cipher": "AES",
    "key": 256,
    "iv": 16,
    "mode": "CFB8",
    "type": "stream"
  },
  "aes-128-cfb1": {
    "cipher": "AES",
    "key": 128,
    "iv": 16,
    "mode": "CFB1",
    "type": "stream"
  },
  "aes-192-cfb1": {
    "cipher": "AES",
    "key": 192,
    "iv": 16,
    "mode": "CFB1",
    "type": "stream"
  },
  "aes-256-cfb1": {
    "cipher": "AES",
    "key": 256,
    "iv": 16,
    "mode": "CFB1",
    "type": "stream"
  },
  "aes-128-ofb": {
    "cipher": "AES",
    "key": 128,
    "iv": 16,
    "mode": "OFB",
    "type": "stream"
  },
  "aes-192-ofb": {
    "cipher": "AES",
    "key": 192,
    "iv": 16,
    "mode": "OFB",
    "type": "stream"
  },
  "aes-256-ofb": {
    "cipher": "AES",
    "key": 256,
    "iv": 16,
    "mode": "OFB",
    "type": "stream"
  },
  "aes-128-ctr": {
    "cipher": "AES",
    "key": 128,
    "iv": 16,
    "mode": "CTR",
    "type": "stream"
  },
  "aes-192-ctr": {
    "cipher": "AES",
    "key": 192,
    "iv": 16,
    "mode": "CTR",
    "type": "stream"
  },
  "aes-256-ctr": {
    "cipher": "AES",
    "key": 256,
    "iv": 16,
    "mode": "CTR",
    "type": "stream"
  },
  "aes-128-gcm": {
    "cipher": "AES",
    "key": 128,
    "iv": 12,
    "mode": "GCM",
    "type": "auth"
  },
  "aes-192-gcm": {
    "cipher": "AES",
    "key": 192,
    "iv": 12,
    "mode": "GCM",
    "type": "auth"
  },
  "aes-256-gcm": {
    "cipher": "AES",
    "key": 256,
    "iv": 12,
    "mode": "GCM",
    "type": "auth"
  }
}

},{}],43:[function(require,module,exports){
(function (Buffer){(function (){
var xor = require('buffer-xor')

function getBlock (self) {
  self._prev = self._cipher.encryptBlock(self._prev)
  return self._prev
}

exports.encrypt = function (self, chunk) {
  while (self._cache.length < chunk.length) {
    self._cache = Buffer.concat([self._cache, getBlock(self)])
  }

  var pad = self._cache.slice(0, chunk.length)
  self._cache = self._cache.slice(chunk.length)
  return xor(chunk, pad)
}

}).call(this)}).call(this,require("buffer").Buffer)
},{"buffer":72,"buffer-xor":71}],44:[function(require,module,exports){
var aes = require('./aes')
var Buffer = require('safe-buffer').Buffer
var Transform = require('cipher-base')
var inherits = require('inherits')

function StreamCipher (mode, key, iv, decrypt) {
  Transform.call(this)

  this._cipher = new aes.AES(key)
  this._prev = Buffer.from(iv)
  this._cache = Buffer.allocUnsafe(0)
  this._secCache = Buffer.allocUnsafe(0)
  this._decrypt = decrypt
  this._mode = mode
}

inherits(StreamCipher, Transform)

StreamCipher.prototype._update = function (chunk) {
  return this._mode.encrypt(this, chunk, this._decrypt)
}

StreamCipher.prototype._final = function () {
  this._cipher.scrub()
}

module.exports = StreamCipher

},{"./aes":28,"cipher-base":73,"inherits":141,"safe-buffer":170}],45:[function(require,module,exports){
var DES = require('browserify-des')
var aes = require('browserify-aes/browser')
var aesModes = require('browserify-aes/modes')
var desModes = require('browserify-des/modes')
var ebtk = require('evp_bytestokey')

function createCipher (suite, password) {
  suite = suite.toLowerCase()

  var keyLen, ivLen
  if (aesModes[suite]) {
    keyLen = aesModes[suite].key
    ivLen = aesModes[suite].iv
  } else if (desModes[suite]) {
    keyLen = desModes[suite].key * 8
    ivLen = desModes[suite].iv
  } else {
    throw new TypeError('invalid suite type')
  }

  var keys = ebtk(password, false, keyLen, ivLen)
  return createCipheriv(suite, keys.key, keys.iv)
}

function createDecipher (suite, password) {
  suite = suite.toLowerCase()

  var keyLen, ivLen
  if (aesModes[suite]) {
    keyLen = aesModes[suite].key
    ivLen = aesModes[suite].iv
  } else if (desModes[suite]) {
    keyLen = desModes[suite].key * 8
    ivLen = desModes[suite].iv
  } else {
    throw new TypeError('invalid suite type')
  }

  var keys = ebtk(password, false, keyLen, ivLen)
  return createDecipheriv(suite, keys.key, keys.iv)
}

function createCipheriv (suite, key, iv) {
  suite = suite.toLowerCase()
  if (aesModes[suite]) return aes.createCipheriv(suite, key, iv)
  if (desModes[suite]) return new DES({ key: key, iv: iv, mode: suite })

  throw new TypeError('invalid suite type')
}

function createDecipheriv (suite, key, iv) {
  suite = suite.toLowerCase()
  if (aesModes[suite]) return aes.createDecipheriv(suite, key, iv)
  if (desModes[suite]) return new DES({ key: key, iv: iv, mode: suite, decrypt: true })

  throw new TypeError('invalid suite type')
}

function getCiphers () {
  return Object.keys(desModes).concat(aes.getCiphers())
}

exports.createCipher = exports.Cipher = createCipher
exports.createCipheriv = exports.Cipheriv = createCipheriv
exports.createDecipher = exports.Decipher = createDecipher
exports.createDecipheriv = exports.Decipheriv = createDecipheriv
exports.listCiphers = exports.getCiphers = getCiphers

},{"browserify-aes/browser":30,"browserify-aes/modes":41,"browserify-des":46,"browserify-des/modes":47,"evp_bytestokey":110}],46:[function(require,module,exports){
var CipherBase = require('cipher-base')
var des = require('des.js')
var inherits = require('inherits')
var Buffer = require('safe-buffer').Buffer

var modes = {
  'des-ede3-cbc': des.CBC.instantiate(des.EDE),
  'des-ede3': des.EDE,
  'des-ede-cbc': des.CBC.instantiate(des.EDE),
  'des-ede': des.EDE,
  'des-cbc': des.CBC.instantiate(des.DES),
  'des-ecb': des.DES
}
modes.des = modes['des-cbc']
modes.des3 = modes['des-ede3-cbc']
module.exports = DES
inherits(DES, CipherBase)
function DES (opts) {
  CipherBase.call(this)
  var modeName = opts.mode.toLowerCase()
  var mode = modes[modeName]
  var type
  if (opts.decrypt) {
    type = 'decrypt'
  } else {
    type = 'encrypt'
  }
  var key = opts.key
  if (!Buffer.isBuffer(key)) {
    key = Buffer.from(key)
  }
  if (modeName === 'des-ede' || modeName === 'des-ede-cbc') {
    key = Buffer.concat([key, key.slice(0, 8)])
  }
  var iv = opts.iv
  if (!Buffer.isBuffer(iv)) {
    iv = Buffer.from(iv)
  }
  this._des = mode.create({
    key: key,
    iv: iv,
    type: type
  })
}
DES.prototype._update = function (data) {
  return Buffer.from(this._des.update(data))
}
DES.prototype._final = function () {
  return Buffer.from(this._des.final())
}

},{"cipher-base":73,"des.js":81,"inherits":141,"safe-buffer":170}],47:[function(require,module,exports){
exports['des-ecb'] = {
  key: 8,
  iv: 0
}
exports['des-cbc'] = exports.des = {
  key: 8,
  iv: 8
}
exports['des-ede3-cbc'] = exports.des3 = {
  key: 24,
  iv: 8
}
exports['des-ede3'] = {
  key: 24,
  iv: 0
}
exports['des-ede-cbc'] = {
  key: 16,
  iv: 8
}
exports['des-ede'] = {
  key: 16,
  iv: 0
}

},{}],48:[function(require,module,exports){
(function (Buffer){(function (){
var BN = require('bn.js')
var randomBytes = require('randombytes')

function blind (priv) {
  var r = getr(priv)
  var blinder = r.toRed(BN.mont(priv.modulus)).redPow(new BN(priv.publicExponent)).fromRed()
  return { blinder: blinder, unblinder: r.invm(priv.modulus) }
}

function getr (priv) {
  var len = priv.modulus.byteLength()
  var r
  do {
    r = new BN(randomBytes(len))
  } while (r.cmp(priv.modulus) >= 0 || !r.umod(priv.prime1) || !r.umod(priv.prime2))
  return r
}

function crt (msg, priv) {
  var blinds = blind(priv)
  var len = priv.modulus.byteLength()
  var blinded = new BN(msg).mul(blinds.blinder).umod(priv.modulus)
  var c1 = blinded.toRed(BN.mont(priv.prime1))
  var c2 = blinded.toRed(BN.mont(priv.prime2))
  var qinv = priv.coefficient
  var p = priv.prime1
  var q = priv.prime2
  var m1 = c1.redPow(priv.exponent1).fromRed()
  var m2 = c2.redPow(priv.exponent2).fromRed()
  var h = m1.isub(m2).imul(qinv).umod(p).imul(q)
  return m2.iadd(h).imul(blinds.unblinder).umod(priv.modulus).toArrayLike(Buffer, 'be', len)
}
crt.getr = getr

module.exports = crt

}).call(this)}).call(this,require("buffer").Buffer)
},{"bn.js":25,"buffer":72,"randombytes":167}],49:[function(require,module,exports){
module.exports = require('./browser/algorithms.json')

},{"./browser/algorithms.json":50}],50:[function(require,module,exports){
module.exports={
  "sha224WithRSAEncryption": {
    "sign": "rsa",
    "hash": "sha224",
    "id": "302d300d06096086480165030402040500041c"
  },
  "RSA-SHA224": {
    "sign": "ecdsa/rsa",
    "hash": "sha224",
    "id": "302d300d06096086480165030402040500041c"
  },
  "sha256WithRSAEncryption": {
    "sign": "rsa",
    "hash": "sha256",
    "id": "3031300d060960864801650304020105000420"
  },
  "RSA-SHA256": {
    "sign": "ecdsa/rsa",
    "hash": "sha256",
    "id": "3031300d060960864801650304020105000420"
  },
  "sha384WithRSAEncryption": {
    "sign": "rsa",
    "hash": "sha384",
    "id": "3041300d060960864801650304020205000430"
  },
  "RSA-SHA384": {
    "sign": "ecdsa/rsa",
    "hash": "sha384",
    "id": "3041300d060960864801650304020205000430"
  },
  "sha512WithRSAEncryption": {
    "sign": "rsa",
    "hash": "sha512",
    "id": "3051300d060960864801650304020305000440"
  },
  "RSA-SHA512": {
    "sign": "ecdsa/rsa",
    "hash": "sha512",
    "id": "3051300d060960864801650304020305000440"
  },
  "RSA-SHA1": {
    "sign": "rsa",
    "hash": "sha1",
    "id": "3021300906052b0e03021a05000414"
  },
  "ecdsa-with-SHA1": {
    "sign": "ecdsa",
    "hash": "sha1",
    "id": ""
  },
  "sha256": {
    "sign": "ecdsa",
    "hash": "sha256",
    "id": ""
  },
  "sha224": {
    "sign": "ecdsa",
    "hash": "sha224",
    "id": ""
  },
  "sha384": {
    "sign": "ecdsa",
    "hash": "sha384",
    "id": ""
  },
  "sha512": {
    "sign": "ecdsa",
    "hash": "sha512",
    "id": ""
  },
  "DSA-SHA": {
    "sign": "dsa",
    "hash": "sha1",
    "id": ""
  },
  "DSA-SHA1": {
    "sign": "dsa",
    "hash": "sha1",
    "id": ""
  },
  "DSA": {
    "sign": "dsa",
    "hash": "sha1",
    "id": ""
  },
  "DSA-WITH-SHA224": {
    "sign": "dsa",
    "hash": "sha224",
    "id": ""
  },
  "DSA-SHA224": {
    "sign": "dsa",
    "hash": "sha224",
    "id": ""
  },
  "DSA-WITH-SHA256": {
    "sign": "dsa",
    "hash": "sha256",
    "id": ""
  },
  "DSA-SHA256": {
    "sign": "dsa",
    "hash": "sha256",
    "id": ""
  },
  "DSA-WITH-SHA384": {
    "sign": "dsa",
    "hash": "sha384",
    "id": ""
  },
  "DSA-SHA384": {
    "sign": "dsa",
    "hash": "sha384",
    "id": ""
  },
  "DSA-WITH-SHA512": {
    "sign": "dsa",
    "hash": "sha512",
    "id": ""
  },
  "DSA-SHA512": {
    "sign": "dsa",
    "hash": "sha512",
    "id": ""
  },
  "DSA-RIPEMD160": {
    "sign": "dsa",
    "hash": "rmd160",
    "id": ""
  },
  "ripemd160WithRSA": {
    "sign": "rsa",
    "hash": "rmd160",
    "id": "3021300906052b2403020105000414"
  },
  "RSA-RIPEMD160": {
    "sign": "rsa",
    "hash": "rmd160",
    "id": "3021300906052b2403020105000414"
  },
  "md5WithRSAEncryption": {
    "sign": "rsa",
    "hash": "md5",
    "id": "3020300c06082a864886f70d020505000410"
  },
  "RSA-MD5": {
    "sign": "rsa",
    "hash": "md5",
    "id": "3020300c06082a864886f70d020505000410"
  }
}

},{}],51:[function(require,module,exports){
module.exports={
  "1.3.132.0.10": "secp256k1",
  "1.3.132.0.33": "p224",
  "1.2.840.10045.3.1.1": "p192",
  "1.2.840.10045.3.1.7": "p256",
  "1.3.132.0.34": "p384",
  "1.3.132.0.35": "p521"
}

},{}],52:[function(require,module,exports){
var Buffer = require('safe-buffer').Buffer
var createHash = require('create-hash')
var stream = require('readable-stream')
var inherits = require('inherits')
var sign = require('./sign')
var verify = require('./verify')

var algorithms = require('./algorithms.json')
Object.keys(algorithms).forEach(function (key) {
  algorithms[key].id = Buffer.from(algorithms[key].id, 'hex')
  algorithms[key.toLowerCase()] = algorithms[key]
})

function Sign (algorithm) {
  stream.Writable.call(this)

  var data = algorithms[algorithm]
  if (!data) throw new Error('Unknown message digest')

  this._hashType = data.hash
  this._hash = createHash(data.hash)
  this._tag = data.id
  this._signType = data.sign
}
inherits(Sign, stream.Writable)

Sign.prototype._write = function _write (data, _, done) {
  this._hash.update(data)
  done()
}

Sign.prototype.update = function update (data, enc) {
  if (typeof data === 'string') data = Buffer.from(data, enc)

  this._hash.update(data)
  return this
}

Sign.prototype.sign = function signMethod (key, enc) {
  this.end()
  var hash = this._hash.digest()
  var sig = sign(hash, key, this._hashType, this._signType, this._tag)

  return enc ? sig.toString(enc) : sig
}

function Verify (algorithm) {
  stream.Writable.call(this)

  var data = algorithms[algorithm]
  if (!data) throw new Error('Unknown message digest')

  this._hash = createHash(data.hash)
  this._tag = data.id
  this._signType = data.sign
}
inherits(Verify, stream.Writable)

Verify.prototype._write = function _write (data, _, done) {
  this._hash.update(data)
  done()
}

Verify.prototype.update = function update (data, enc) {
  if (typeof data === 'string') data = Buffer.from(data, enc)

  this._hash.update(data)
  return this
}

Verify.prototype.verify = function verifyMethod (key, sig, enc) {
  if (typeof sig === 'string') sig = Buffer.from(sig, enc)

  this.end()
  var hash = this._hash.digest()
  return verify(sig, hash, key, this._signType, this._tag)
}

function createSign (algorithm) {
  return new Sign(algorithm)
}

function createVerify (algorithm) {
  return new Verify(algorithm)
}

module.exports = {
  Sign: createSign,
  Verify: createVerify,
  createSign: createSign,
  createVerify: createVerify
}

},{"./algorithms.json":50,"./sign":53,"./verify":54,"create-hash":76,"inherits":141,"readable-stream":69,"safe-buffer":170}],53:[function(require,module,exports){
// much of this based on https://github.com/indutny/self-signed/blob/gh-pages/lib/rsa.js
var Buffer = require('safe-buffer').Buffer
var createHmac = require('create-hmac')
var crt = require('browserify-rsa')
var EC = require('elliptic').ec
var BN = require('bn.js')
var parseKeys = require('parse-asn1')
var curves = require('./curves.json')

function sign (hash, key, hashType, signType, tag) {
  var priv = parseKeys(key)
  if (priv.curve) {
    // rsa keys can be interpreted as ecdsa ones in openssl
    if (signType !== 'ecdsa' && signType !== 'ecdsa/rsa') throw new Error('wrong private key type')
    return ecSign(hash, priv)
  } else if (priv.type === 'dsa') {
    if (signType !== 'dsa') throw new Error('wrong private key type')
    return dsaSign(hash, priv, hashType)
  } else {
    if (signType !== 'rsa' && signType !== 'ecdsa/rsa') throw new Error('wrong private key type')
  }
  hash = Buffer.concat([tag, hash])
  var len = priv.modulus.byteLength()
  var pad = [0, 1]
  while (hash.length + pad.length + 1 < len) pad.push(0xff)
  pad.push(0x00)
  var i = -1
  while (++i < hash.length) pad.push(hash[i])

  var out = crt(pad, priv)
  return out
}

function ecSign (hash, priv) {
  var curveId = curves[priv.curve.join('.')]
  if (!curveId) throw new Error('unknown curve ' + priv.curve.join('.'))

  var curve = new EC(curveId)
  var key = curve.keyFromPrivate(priv.privateKey)
  var out = key.sign(hash)

  return Buffer.from(out.toDER())
}

function dsaSign (hash, priv, algo) {
  var x = priv.params.priv_key
  var p = priv.params.p
  var q = priv.params.q
  var g = priv.params.g
  var r = new BN(0)
  var k
  var H = bits2int(hash, q).mod(q)
  var s = false
  var kv = getKey(x, q, hash, algo)
  while (s === false) {
    k = makeKey(q, kv, algo)
    r = makeR(g, k, p, q)
    s = k.invm(q).imul(H.add(x.mul(r))).mod(q)
    if (s.cmpn(0) === 0) {
      s = false
      r = new BN(0)
    }
  }
  return toDER(r, s)
}

function toDER (r, s) {
  r = r.toArray()
  s = s.toArray()

  // Pad values
  if (r[0] & 0x80) r = [0].concat(r)
  if (s[0] & 0x80) s = [0].concat(s)

  var total = r.length + s.length + 4
  var res = [0x30, total, 0x02, r.length]
  res = res.concat(r, [0x02, s.length], s)
  return Buffer.from(res)
}

function getKey (x, q, hash, algo) {
  x = Buffer.from(x.toArray())
  if (x.length < q.byteLength()) {
    var zeros = Buffer.alloc(q.byteLength() - x.length)
    x = Buffer.concat([zeros, x])
  }
  var hlen = hash.length
  var hbits = bits2octets(hash, q)
  var v = Buffer.alloc(hlen)
  v.fill(1)
  var k = Buffer.alloc(hlen)
  k = createHmac(algo, k).update(v).update(Buffer.from([0])).update(x).update(hbits).digest()
  v = createHmac(algo, k).update(v).digest()
  k = createHmac(algo, k).update(v).update(Buffer.from([1])).update(x).update(hbits).digest()
  v = createHmac(algo, k).update(v).digest()
  return { k: k, v: v }
}

function bits2int (obits, q) {
  var bits = new BN(obits)
  var shift = (obits.length << 3) - q.bitLength()
  if (shift > 0) bits.ishrn(shift)
  return bits
}

function bits2octets (bits, q) {
  bits = bits2int(bits, q)
  bits = bits.mod(q)
  var out = Buffer.from(bits.toArray())
  if (out.length < q.byteLength()) {
    var zeros = Buffer.alloc(q.byteLength() - out.length)
    out = Buffer.concat([zeros, out])
  }
  return out
}

function makeKey (q, kv, algo) {
  var t
  var k

  do {
    t = Buffer.alloc(0)

    while (t.length * 8 < q.bitLength()) {
      kv.v = createHmac(algo, kv.k).update(kv.v).digest()
      t = Buffer.concat([t, kv.v])
    }

    k = bits2int(t, q)
    kv.k = createHmac(algo, kv.k).update(kv.v).update(Buffer.from([0])).digest()
    kv.v = createHmac(algo, kv.k).update(kv.v).digest()
  } while (k.cmp(q) !== -1)

  return k
}

function makeR (g, k, p, q) {
  return g.toRed(BN.mont(p)).redPow(k).fromRed().mod(q)
}

module.exports = sign
module.exports.getKey = getKey
module.exports.makeKey = makeKey

},{"./curves.json":51,"bn.js":25,"browserify-rsa":48,"create-hmac":78,"elliptic":92,"parse-asn1":151,"safe-buffer":170}],54:[function(require,module,exports){
// much of this based on https://github.com/indutny/self-signed/blob/gh-pages/lib/rsa.js
var Buffer = require('safe-buffer').Buffer
var BN = require('bn.js')
var EC = require('elliptic').ec
var parseKeys = require('parse-asn1')
var curves = require('./curves.json')

function verify (sig, hash, key, signType, tag) {
  var pub = parseKeys(key)
  if (pub.type === 'ec') {
    // rsa keys can be interpreted as ecdsa ones in openssl
    if (signType !== 'ecdsa' && signType !== 'ecdsa/rsa') throw new Error('wrong public key type')
    return ecVerify(sig, hash, pub)
  } else if (pub.type === 'dsa') {
    if (signType !== 'dsa') throw new Error('wrong public key type')
    return dsaVerify(sig, hash, pub)
  } else {
    if (signType !== 'rsa' && signType !== 'ecdsa/rsa') throw new Error('wrong public key type')
  }
  hash = Buffer.concat([tag, hash])
  var len = pub.modulus.byteLength()
  var pad = [1]
  var padNum = 0
  while (hash.length + pad.length + 2 < len) {
    pad.push(0xff)
    padNum++
  }
  pad.push(0x00)
  var i = -1
  while (++i < hash.length) {
    pad.push(hash[i])
  }
  pad = Buffer.from(pad)
  var red = BN.mont(pub.modulus)
  sig = new BN(sig).toRed(red)

  sig = sig.redPow(new BN(pub.publicExponent))
  sig = Buffer.from(sig.fromRed().toArray())
  var out = padNum < 8 ? 1 : 0
  len = Math.min(sig.length, pad.length)
  if (sig.length !== pad.length) out = 1

  i = -1
  while (++i < len) out |= sig[i] ^ pad[i]
  return out === 0
}

function ecVerify (sig, hash, pub) {
  var curveId = curves[pub.data.algorithm.curve.join('.')]
  if (!curveId) throw new Error('unknown curve ' + pub.data.algorithm.curve.join('.'))

  var curve = new EC(curveId)
  var pubkey = pub.data.subjectPrivateKey.data

  return curve.verify(hash, sig, pubkey)
}

function dsaVerify (sig, hash, pub) {
  var p = pub.data.p
  var q = pub.data.q
  var g = pub.data.g
  var y = pub.data.pub_key
  var unpacked = parseKeys.signature.decode(sig, 'der')
  var s = unpacked.s
  var r = unpacked.r
  checkValue(s, q)
  checkValue(r, q)
  var montp = BN.mont(p)
  var w = s.invm(q)
  var v = g.toRed(montp)
    .redPow(new BN(hash).mul(w).mod(q))
    .fromRed()
    .mul(y.toRed(montp).redPow(r.mul(w).mod(q)).fromRed())
    .mod(p)
    .mod(q)
  return v.cmp(r) === 0
}

function checkValue (b, q) {
  if (b.cmpn(0) <= 0) throw new Error('invalid sig')
  if (b.cmp(q) >= q) throw new Error('invalid sig')
}

module.exports = verify

},{"./curves.json":51,"bn.js":25,"elliptic":92,"parse-asn1":151,"safe-buffer":170}],55:[function(require,module,exports){
'use strict';

function _inheritsLoose(subClass, superClass) { subClass.prototype = Object.create(superClass.prototype); subClass.prototype.constructor = subClass; subClass.__proto__ = superClass; }

var codes = {};

function createErrorType(code, message, Base) {
  if (!Base) {
    Base = Error;
  }

  function getMessage(arg1, arg2, arg3) {
    if (typeof message === 'string') {
      return message;
    } else {
      return message(arg1, arg2, arg3);
    }
  }

  var NodeError =
  /*#__PURE__*/
  function (_Base) {
    _inheritsLoose(NodeError, _Base);

    function NodeError(arg1, arg2, arg3) {
      return _Base.call(this, getMessage(arg1, arg2, arg3)) || this;
    }

    return NodeError;
  }(Base);

  NodeError.prototype.name = Base.name;
  NodeError.prototype.code = code;
  codes[code] = NodeError;
} // https://github.com/nodejs/node/blob/v10.8.0/lib/internal/errors.js


function oneOf(expected, thing) {
  if (Array.isArray(expected)) {
    var len = expected.length;
    expected = expected.map(function (i) {
      return String(i);
    });

    if (len > 2) {
      return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(', '), ", or ") + expected[len - 1];
    } else if (len === 2) {
      return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
    } else {
      return "of ".concat(thing, " ").concat(expected[0]);
    }
  } else {
    return "of ".concat(thing, " ").concat(String(expected));
  }
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith


function startsWith(str, search, pos) {
  return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith


function endsWith(str, search, this_len) {
  if (this_len === undefined || this_len > str.length) {
    this_len = str.length;
  }

  return str.substring(this_len - search.length, this_len) === search;
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes


function includes(str, search, start) {
  if (typeof start !== 'number') {
    start = 0;
  }

  if (start + search.length > str.length) {
    return false;
  } else {
    return str.indexOf(search, start) !== -1;
  }
}

createErrorType('ERR_INVALID_OPT_VALUE', function (name, value) {
  return 'The value "' + value + '" is invalid for option "' + name + '"';
}, TypeError);
createErrorType('ERR_INVALID_ARG_TYPE', function (name, expected, actual) {
  // determiner: 'must be' or 'must not be'
  var determiner;

  if (typeof expected === 'string' && startsWith(expected, 'not ')) {
    determiner = 'must not be';
    expected = expected.replace(/^not /, '');
  } else {
    determiner = 'must be';
  }

  var msg;

  if (endsWith(name, ' argument')) {
    // For cases like 'first argument'
    msg = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf(expected, 'type'));
  } else {
    var type = includes(name, '.') ? 'property' : 'argument';
    msg = "The \"".concat(name, "\" ").concat(type, " ").concat(determiner, " ").concat(oneOf(expected, 'type'));
  }

  msg += ". Received type ".concat(typeof actual);
  return msg;
}, TypeError);
createErrorType('ERR_STREAM_PUSH_AFTER_EOF', 'stream.push() after EOF');
createErrorType('ERR_METHOD_NOT_IMPLEMENTED', function (name) {
  return 'The ' + name + ' method is not implemented';
});
createErrorType('ERR_STREAM_PREMATURE_CLOSE', 'Premature close');
createErrorType('ERR_STREAM_DESTROYED', function (name) {
  return 'Cannot call ' + name + ' after a stream was destroyed';
});
createErrorType('ERR_MULTIPLE_CALLBACK', 'Callback called multiple times');
createErrorType('ERR_STREAM_CANNOT_PIPE', 'Cannot pipe, not readable');
createErrorType('ERR_STREAM_WRITE_AFTER_END', 'write after end');
createErrorType('ERR_STREAM_NULL_VALUES', 'May not write null values to stream', TypeError);
createErrorType('ERR_UNKNOWN_ENCODING', function (arg) {
  return 'Unknown encoding: ' + arg;
}, TypeError);
createErrorType('ERR_STREAM_UNSHIFT_AFTER_END_EVENT', 'stream.unshift() after end event');
module.exports.codes = codes;

},{}],56:[function(require,module,exports){
(function (process){(function (){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.
'use strict';
/*<replacement>*/

var objectKeys = Object.keys || function (obj) {
  var keys = [];

  for (var key in obj) {
    keys.push(key);
  }

  return keys;
};
/*</replacement>*/


module.exports = Duplex;

var Readable = require('./_stream_readable');

var Writable = require('./_stream_writable');

require('inherits')(Duplex, Readable);

{
  // Allow the keys array to be GC'ed.
  var keys = objectKeys(Writable.prototype);

  for (var v = 0; v < keys.length; v++) {
    var method = keys[v];
    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
  }
}

function Duplex(options) {
  if (!(this instanceof Duplex)) return new Duplex(options);
  Readable.call(this, options);
  Writable.call(this, options);
  this.allowHalfOpen = true;

  if (options) {
    if (options.readable === false) this.readable = false;
    if (options.writable === false) this.writable = false;

    if (options.allowHalfOpen === false) {
      this.allowHalfOpen = false;
      this.once('end', onend);
    }
  }
}

Object.defineProperty(Duplex.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.highWaterMark;
  }
});
Object.defineProperty(Duplex.prototype, 'writableBuffer', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState && this._writableState.getBuffer();
  }
});
Object.defineProperty(Duplex.prototype, 'writableLength', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.length;
  }
}); // the no-half-open enforcer

function onend() {
  // If the writable side ended, then we're ok.
  if (this._writableState.ended) return; // no more data can be written.
  // But allow more writes to happen in this tick.

  process.nextTick(onEndNT, this);
}

function onEndNT(self) {
  self.end();
}

Object.defineProperty(Duplex.prototype, 'destroyed', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    if (this._readableState === undefined || this._writableState === undefined) {
      return false;
    }

    return this._readableState.destroyed && this._writableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (this._readableState === undefined || this._writableState === undefined) {
      return;
    } // backward compatibility, the user is explicitly
    // managing destroyed


    this._readableState.destroyed = value;
    this._writableState.destroyed = value;
  }
});
}).call(this)}).call(this,require('_process'))
},{"./_stream_readable":58,"./_stream_writable":60,"_process":159,"inherits":141}],57:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.
'use strict';

module.exports = PassThrough;

var Transform = require('./_stream_transform');

require('inherits')(PassThrough, Transform);

function PassThrough(options) {
  if (!(this instanceof PassThrough)) return new PassThrough(options);
  Transform.call(this, options);
}

PassThrough.prototype._transform = function (chunk, encoding, cb) {
  cb(null, chunk);
};
},{"./_stream_transform":59,"inherits":141}],58:[function(require,module,exports){
(function (process,global){(function (){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
'use strict';

module.exports = Readable;
/*<replacement>*/

var Duplex;
/*</replacement>*/

Readable.ReadableState = ReadableState;
/*<replacement>*/

var EE = require('events').EventEmitter;

var EElistenerCount = function EElistenerCount(emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/

/*<replacement>*/


var Stream = require('./internal/streams/stream');
/*</replacement>*/


var Buffer = require('buffer').Buffer;

var OurUint8Array = global.Uint8Array || function () {};

function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}

function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}
/*<replacement>*/


var debugUtil = require('util');

var debug;

if (debugUtil && debugUtil.debuglog) {
  debug = debugUtil.debuglog('stream');
} else {
  debug = function debug() {};
}
/*</replacement>*/


var BufferList = require('./internal/streams/buffer_list');

var destroyImpl = require('./internal/streams/destroy');

var _require = require('./internal/streams/state'),
    getHighWaterMark = _require.getHighWaterMark;

var _require$codes = require('../errors').codes,
    ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,
    ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF,
    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
    ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT; // Lazy loaded to improve the startup performance.


var StringDecoder;
var createReadableStreamAsyncIterator;
var from;

require('inherits')(Readable, Stream);

var errorOrDestroy = destroyImpl.errorOrDestroy;
var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];

function prependListener(emitter, event, fn) {
  // Sadly this is not cacheable as some libraries bundle their own
  // event emitter implementation with them.
  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn); // This is a hack to make sure that our error handler is attached before any
  // userland ones.  NEVER DO THIS. This is here only because this code needs
  // to continue to work with older versions of Node.js that do not include
  // the prependListener() method. The goal is to eventually remove this hack.

  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (Array.isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
}

function ReadableState(options, stream, isDuplex) {
  Duplex = Duplex || require('./_stream_duplex');
  options = options || {}; // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.

  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex; // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away

  this.objectMode = !!options.objectMode;
  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode; // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"

  this.highWaterMark = getHighWaterMark(this, options, 'readableHighWaterMark', isDuplex); // A linked list is used to store data chunks instead of an array because the
  // linked list can remove elements from the beginning faster than
  // array.shift()

  this.buffer = new BufferList();
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false; // a flag to be able to tell if the event 'readable'/'data' is emitted
  // immediately, or on a later tick.  We set this to true at first, because
  // any actions that shouldn't happen until "later" should generally also
  // not happen before the first read call.

  this.sync = true; // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.

  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;
  this.paused = true; // Should close be emitted on destroy. Defaults to true.

  this.emitClose = options.emitClose !== false; // Should .destroy() be called after 'end' (and potentially 'finish')

  this.autoDestroy = !!options.autoDestroy; // has it been destroyed

  this.destroyed = false; // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.

  this.defaultEncoding = options.defaultEncoding || 'utf8'; // the number of writers that are awaiting a drain event in .pipe()s

  this.awaitDrain = 0; // if true, a maybeReadMore has been scheduled

  this.readingMore = false;
  this.decoder = null;
  this.encoding = null;

  if (options.encoding) {
    if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

function Readable(options) {
  Duplex = Duplex || require('./_stream_duplex');
  if (!(this instanceof Readable)) return new Readable(options); // Checking for a Stream.Duplex instance is faster here instead of inside
  // the ReadableState constructor, at least with V8 6.5

  var isDuplex = this instanceof Duplex;
  this._readableState = new ReadableState(options, this, isDuplex); // legacy

  this.readable = true;

  if (options) {
    if (typeof options.read === 'function') this._read = options.read;
    if (typeof options.destroy === 'function') this._destroy = options.destroy;
  }

  Stream.call(this);
}

Object.defineProperty(Readable.prototype, 'destroyed', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    if (this._readableState === undefined) {
      return false;
    }

    return this._readableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._readableState) {
      return;
    } // backward compatibility, the user is explicitly
    // managing destroyed


    this._readableState.destroyed = value;
  }
});
Readable.prototype.destroy = destroyImpl.destroy;
Readable.prototype._undestroy = destroyImpl.undestroy;

Readable.prototype._destroy = function (err, cb) {
  cb(err);
}; // Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.


Readable.prototype.push = function (chunk, encoding) {
  var state = this._readableState;
  var skipChunkCheck;

  if (!state.objectMode) {
    if (typeof chunk === 'string') {
      encoding = encoding || state.defaultEncoding;

      if (encoding !== state.encoding) {
        chunk = Buffer.from(chunk, encoding);
        encoding = '';
      }

      skipChunkCheck = true;
    }
  } else {
    skipChunkCheck = true;
  }

  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
}; // Unshift should *always* be something directly out of read()


Readable.prototype.unshift = function (chunk) {
  return readableAddChunk(this, chunk, null, true, false);
};

function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
  debug('readableAddChunk', chunk);
  var state = stream._readableState;

  if (chunk === null) {
    state.reading = false;
    onEofChunk(stream, state);
  } else {
    var er;
    if (!skipChunkCheck) er = chunkInvalid(state, chunk);

    if (er) {
      errorOrDestroy(stream, er);
    } else if (state.objectMode || chunk && chunk.length > 0) {
      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
        chunk = _uint8ArrayToBuffer(chunk);
      }

      if (addToFront) {
        if (state.endEmitted) errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());else addChunk(stream, state, chunk, true);
      } else if (state.ended) {
        errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
      } else if (state.destroyed) {
        return false;
      } else {
        state.reading = false;

        if (state.decoder && !encoding) {
          chunk = state.decoder.write(chunk);
          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);
        } else {
          addChunk(stream, state, chunk, false);
        }
      }
    } else if (!addToFront) {
      state.reading = false;
      maybeReadMore(stream, state);
    }
  } // We can push more data if we are below the highWaterMark.
  // Also, if we have no data yet, we can stand some more bytes.
  // This is to work around cases where hwm=0, such as the repl.


  return !state.ended && (state.length < state.highWaterMark || state.length === 0);
}

function addChunk(stream, state, chunk, addToFront) {
  if (state.flowing && state.length === 0 && !state.sync) {
    state.awaitDrain = 0;
    stream.emit('data', chunk);
  } else {
    // update the buffer info.
    state.length += state.objectMode ? 1 : chunk.length;
    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);
    if (state.needReadable) emitReadable(stream);
  }

  maybeReadMore(stream, state);
}

function chunkInvalid(state, chunk) {
  var er;

  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer', 'Uint8Array'], chunk);
  }

  return er;
}

Readable.prototype.isPaused = function () {
  return this._readableState.flowing === false;
}; // backwards compatibility.


Readable.prototype.setEncoding = function (enc) {
  if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
  var decoder = new StringDecoder(enc);
  this._readableState.decoder = decoder; // If setEncoding(null), decoder.encoding equals utf8

  this._readableState.encoding = this._readableState.decoder.encoding; // Iterate over current buffer to convert already stored Buffers:

  var p = this._readableState.buffer.head;
  var content = '';

  while (p !== null) {
    content += decoder.write(p.data);
    p = p.next;
  }

  this._readableState.buffer.clear();

  if (content !== '') this._readableState.buffer.push(content);
  this._readableState.length = content.length;
  return this;
}; // Don't raise the hwm > 1GB


var MAX_HWM = 0x40000000;

function computeNewHighWaterMark(n) {
  if (n >= MAX_HWM) {
    // TODO(ronag): Throw ERR_VALUE_OUT_OF_RANGE.
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2 to prevent increasing hwm excessively in
    // tiny amounts
    n--;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    n++;
  }

  return n;
} // This function is designed to be inlinable, so please take care when making
// changes to the function body.


function howMuchToRead(n, state) {
  if (n <= 0 || state.length === 0 && state.ended) return 0;
  if (state.objectMode) return 1;

  if (n !== n) {
    // Only flow one buffer at a time
    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
  } // If we're asking for more than the current hwm, then raise the hwm.


  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
  if (n <= state.length) return n; // Don't have enough

  if (!state.ended) {
    state.needReadable = true;
    return 0;
  }

  return state.length;
} // you can override either this method, or the async _read(n) below.


Readable.prototype.read = function (n) {
  debug('read', n);
  n = parseInt(n, 10);
  var state = this._readableState;
  var nOrig = n;
  if (n !== 0) state.emittedReadable = false; // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.

  if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state); // if we've ended, and we're now clear, then finish it up.

  if (n === 0 && state.ended) {
    if (state.length === 0) endReadable(this);
    return null;
  } // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.
  // if we need a readable event, then we need to do some reading.


  var doRead = state.needReadable;
  debug('need readable', doRead); // if we currently have less than the highWaterMark, then also read some

  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  } // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.


  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  } else if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true; // if the length is currently zero, then we *need* a readable event.

    if (state.length === 0) state.needReadable = true; // call internal read method

    this._read(state.highWaterMark);

    state.sync = false; // If _read pushed data synchronously, then `reading` will be false,
    // and we need to re-evaluate how much data we can return to the user.

    if (!state.reading) n = howMuchToRead(nOrig, state);
  }

  var ret;
  if (n > 0) ret = fromList(n, state);else ret = null;

  if (ret === null) {
    state.needReadable = state.length <= state.highWaterMark;
    n = 0;
  } else {
    state.length -= n;
    state.awaitDrain = 0;
  }

  if (state.length === 0) {
    // If we have nothing in the buffer, then we want to know
    // as soon as we *do* get something into the buffer.
    if (!state.ended) state.needReadable = true; // If we tried to read() past the EOF, then emit end on the next tick.

    if (nOrig !== n && state.ended) endReadable(this);
  }

  if (ret !== null) this.emit('data', ret);
  return ret;
};

function onEofChunk(stream, state) {
  debug('onEofChunk');
  if (state.ended) return;

  if (state.decoder) {
    var chunk = state.decoder.end();

    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }

  state.ended = true;

  if (state.sync) {
    // if we are sync, wait until next tick to emit the data.
    // Otherwise we risk emitting data in the flow()
    // the readable code triggers during a read() call
    emitReadable(stream);
  } else {
    // emit 'readable' now to make sure it gets picked up.
    state.needReadable = false;

    if (!state.emittedReadable) {
      state.emittedReadable = true;
      emitReadable_(stream);
    }
  }
} // Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.


function emitReadable(stream) {
  var state = stream._readableState;
  debug('emitReadable', state.needReadable, state.emittedReadable);
  state.needReadable = false;

  if (!state.emittedReadable) {
    debug('emitReadable', state.flowing);
    state.emittedReadable = true;
    process.nextTick(emitReadable_, stream);
  }
}

function emitReadable_(stream) {
  var state = stream._readableState;
  debug('emitReadable_', state.destroyed, state.length, state.ended);

  if (!state.destroyed && (state.length || state.ended)) {
    stream.emit('readable');
    state.emittedReadable = false;
  } // The stream needs another readable event if
  // 1. It is not flowing, as the flow mechanism will take
  //    care of it.
  // 2. It is not ended.
  // 3. It is below the highWaterMark, so we can schedule
  //    another readable later.


  state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
  flow(stream);
} // at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.


function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    process.nextTick(maybeReadMore_, stream, state);
  }
}

function maybeReadMore_(stream, state) {
  // Attempt to read more data if we should.
  //
  // The conditions for reading more data are (one of):
  // - Not enough data buffered (state.length < state.highWaterMark). The loop
  //   is responsible for filling the buffer with enough data if such data
  //   is available. If highWaterMark is 0 and we are not in the flowing mode
  //   we should _not_ attempt to buffer any extra data. We'll get more data
  //   when the stream consumer calls read() instead.
  // - No data in the buffer, and the stream is in flowing mode. In this mode
  //   the loop below is responsible for ensuring read() is called. Failing to
  //   call read here would abort the flow and there's no other mechanism for
  //   continuing the flow if the stream consumer has just subscribed to the
  //   'data' event.
  //
  // In addition to the above conditions to keep reading data, the following
  // conditions prevent the data from being read:
  // - The stream has ended (state.ended).
  // - There is already a pending 'read' operation (state.reading). This is a
  //   case where the the stream has called the implementation defined _read()
  //   method, but they are processing the call asynchronously and have _not_
  //   called push() with new data. In this case we skip performing more
  //   read()s. The execution ends in this method again after the _read() ends
  //   up calling push() with more data.
  while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
    var len = state.length;
    debug('maybeReadMore read 0');
    stream.read(0);
    if (len === state.length) // didn't get any data, stop spinning.
      break;
  }

  state.readingMore = false;
} // abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.


Readable.prototype._read = function (n) {
  errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED('_read()'));
};

Readable.prototype.pipe = function (dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;

    case 1:
      state.pipes = [state.pipes, dest];
      break;

    default:
      state.pipes.push(dest);
      break;
  }

  state.pipesCount += 1;
  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);
  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
  var endFn = doEnd ? onend : unpipe;
  if (state.endEmitted) process.nextTick(endFn);else src.once('end', endFn);
  dest.on('unpipe', onunpipe);

  function onunpipe(readable, unpipeInfo) {
    debug('onunpipe');

    if (readable === src) {
      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
        unpipeInfo.hasUnpiped = true;
        cleanup();
      }
    }
  }

  function onend() {
    debug('onend');
    dest.end();
  } // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.


  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);
  var cleanedUp = false;

  function cleanup() {
    debug('cleanup'); // cleanup event handlers once the pipe is broken

    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', unpipe);
    src.removeListener('data', ondata);
    cleanedUp = true; // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.

    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
  }

  src.on('data', ondata);

  function ondata(chunk) {
    debug('ondata');
    var ret = dest.write(chunk);
    debug('dest.write', ret);

    if (ret === false) {
      // If the user unpiped during `dest.write()`, it is possible
      // to get stuck in a permanently paused state if that write
      // also returned false.
      // => Check whether `dest` is still a piping destination.
      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
        debug('false write response, pause', state.awaitDrain);
        state.awaitDrain++;
      }

      src.pause();
    }
  } // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.


  function onerror(er) {
    debug('onerror', er);
    unpipe();
    dest.removeListener('error', onerror);
    if (EElistenerCount(dest, 'error') === 0) errorOrDestroy(dest, er);
  } // Make sure our error handler is attached before userland ones.


  prependListener(dest, 'error', onerror); // Both close and finish should trigger unpipe, but only once.

  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }

  dest.once('close', onclose);

  function onfinish() {
    debug('onfinish');
    dest.removeListener('close', onclose);
    unpipe();
  }

  dest.once('finish', onfinish);

  function unpipe() {
    debug('unpipe');
    src.unpipe(dest);
  } // tell the dest that it's being piped to


  dest.emit('pipe', src); // start the flow if it hasn't been started already.

  if (!state.flowing) {
    debug('pipe resume');
    src.resume();
  }

  return dest;
};

function pipeOnDrain(src) {
  return function pipeOnDrainFunctionResult() {
    var state = src._readableState;
    debug('pipeOnDrain', state.awaitDrain);
    if (state.awaitDrain) state.awaitDrain--;

    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
      state.flowing = true;
      flow(src);
    }
  };
}

Readable.prototype.unpipe = function (dest) {
  var state = this._readableState;
  var unpipeInfo = {
    hasUnpiped: false
  }; // if we're not piping anywhere, then do nothing.

  if (state.pipesCount === 0) return this; // just one destination.  most common case.

  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes) return this;
    if (!dest) dest = state.pipes; // got a match.

    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    if (dest) dest.emit('unpipe', this, unpipeInfo);
    return this;
  } // slow case. multiple pipe destinations.


  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;

    for (var i = 0; i < len; i++) {
      dests[i].emit('unpipe', this, {
        hasUnpiped: false
      });
    }

    return this;
  } // try to find the right one.


  var index = indexOf(state.pipes, dest);
  if (index === -1) return this;
  state.pipes.splice(index, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1) state.pipes = state.pipes[0];
  dest.emit('unpipe', this, unpipeInfo);
  return this;
}; // set up data events if they are asked for
// Ensure readable listeners eventually get something


Readable.prototype.on = function (ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);
  var state = this._readableState;

  if (ev === 'data') {
    // update readableListening so that resume() may be a no-op
    // a few lines down. This is needed to support once('readable').
    state.readableListening = this.listenerCount('readable') > 0; // Try start flowing on next tick if stream isn't explicitly paused

    if (state.flowing !== false) this.resume();
  } else if (ev === 'readable') {
    if (!state.endEmitted && !state.readableListening) {
      state.readableListening = state.needReadable = true;
      state.flowing = false;
      state.emittedReadable = false;
      debug('on readable', state.length, state.reading);

      if (state.length) {
        emitReadable(this);
      } else if (!state.reading) {
        process.nextTick(nReadingNextTick, this);
      }
    }
  }

  return res;
};

Readable.prototype.addListener = Readable.prototype.on;

Readable.prototype.removeListener = function (ev, fn) {
  var res = Stream.prototype.removeListener.call(this, ev, fn);

  if (ev === 'readable') {
    // We need to check if there is someone still listening to
    // readable and reset the state. However this needs to happen
    // after readable has been emitted but before I/O (nextTick) to
    // support once('readable', fn) cycles. This means that calling
    // resume within the same tick will have no
    // effect.
    process.nextTick(updateReadableListening, this);
  }

  return res;
};

Readable.prototype.removeAllListeners = function (ev) {
  var res = Stream.prototype.removeAllListeners.apply(this, arguments);

  if (ev === 'readable' || ev === undefined) {
    // We need to check if there is someone still listening to
    // readable and reset the state. However this needs to happen
    // after readable has been emitted but before I/O (nextTick) to
    // support once('readable', fn) cycles. This means that calling
    // resume within the same tick will have no
    // effect.
    process.nextTick(updateReadableListening, this);
  }

  return res;
};

function updateReadableListening(self) {
  var state = self._readableState;
  state.readableListening = self.listenerCount('readable') > 0;

  if (state.resumeScheduled && !state.paused) {
    // flowing needs to be set to true now, otherwise
    // the upcoming resume will not flow.
    state.flowing = true; // crude way to check if we should resume
  } else if (self.listenerCount('data') > 0) {
    self.resume();
  }
}

function nReadingNextTick(self) {
  debug('readable nexttick read 0');
  self.read(0);
} // pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.


Readable.prototype.resume = function () {
  var state = this._readableState;

  if (!state.flowing) {
    debug('resume'); // we flow only if there is no one listening
    // for readable, but we still have to call
    // resume()

    state.flowing = !state.readableListening;
    resume(this, state);
  }

  state.paused = false;
  return this;
};

function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    process.nextTick(resume_, stream, state);
  }
}

function resume_(stream, state) {
  debug('resume', state.reading);

  if (!state.reading) {
    stream.read(0);
  }

  state.resumeScheduled = false;
  stream.emit('resume');
  flow(stream);
  if (state.flowing && !state.reading) stream.read(0);
}

Readable.prototype.pause = function () {
  debug('call pause flowing=%j', this._readableState.flowing);

  if (this._readableState.flowing !== false) {
    debug('pause');
    this._readableState.flowing = false;
    this.emit('pause');
  }

  this._readableState.paused = true;
  return this;
};

function flow(stream) {
  var state = stream._readableState;
  debug('flow', state.flowing);

  while (state.flowing && stream.read() !== null) {
    ;
  }
} // wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.


Readable.prototype.wrap = function (stream) {
  var _this = this;

  var state = this._readableState;
  var paused = false;
  stream.on('end', function () {
    debug('wrapped end');

    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) _this.push(chunk);
    }

    _this.push(null);
  });
  stream.on('data', function (chunk) {
    debug('wrapped data');
    if (state.decoder) chunk = state.decoder.write(chunk); // don't skip over falsy values in objectMode

    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;

    var ret = _this.push(chunk);

    if (!ret) {
      paused = true;
      stream.pause();
    }
  }); // proxy all the other methods.
  // important when wrapping filters and duplexes.

  for (var i in stream) {
    if (this[i] === undefined && typeof stream[i] === 'function') {
      this[i] = function methodWrap(method) {
        return function methodWrapReturnFunction() {
          return stream[method].apply(stream, arguments);
        };
      }(i);
    }
  } // proxy certain important events.


  for (var n = 0; n < kProxyEvents.length; n++) {
    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
  } // when we try to consume some more bytes, simply unpause the
  // underlying stream.


  this._read = function (n) {
    debug('wrapped _read', n);

    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return this;
};

if (typeof Symbol === 'function') {
  Readable.prototype[Symbol.asyncIterator] = function () {
    if (createReadableStreamAsyncIterator === undefined) {
      createReadableStreamAsyncIterator = require('./internal/streams/async_iterator');
    }

    return createReadableStreamAsyncIterator(this);
  };
}

Object.defineProperty(Readable.prototype, 'readableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState.highWaterMark;
  }
});
Object.defineProperty(Readable.prototype, 'readableBuffer', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState && this._readableState.buffer;
  }
});
Object.defineProperty(Readable.prototype, 'readableFlowing', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState.flowing;
  },
  set: function set(state) {
    if (this._readableState) {
      this._readableState.flowing = state;
    }
  }
}); // exposed for testing purposes only.

Readable._fromList = fromList;
Object.defineProperty(Readable.prototype, 'readableLength', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState.length;
  }
}); // Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.

function fromList(n, state) {
  // nothing buffered
  if (state.length === 0) return null;
  var ret;
  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
    // read it all, truncate the list
    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.first();else ret = state.buffer.concat(state.length);
    state.buffer.clear();
  } else {
    // read part of list
    ret = state.buffer.consume(n, state.decoder);
  }
  return ret;
}

function endReadable(stream) {
  var state = stream._readableState;
  debug('endReadable', state.endEmitted);

  if (!state.endEmitted) {
    state.ended = true;
    process.nextTick(endReadableNT, state, stream);
  }
}

function endReadableNT(state, stream) {
  debug('endReadableNT', state.endEmitted, state.length); // Check that we didn't get one last unshift.

  if (!state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.readable = false;
    stream.emit('end');

    if (state.autoDestroy) {
      // In case of duplex streams we need a way to detect
      // if the writable side is ready for autoDestroy as well
      var wState = stream._writableState;

      if (!wState || wState.autoDestroy && wState.finished) {
        stream.destroy();
      }
    }
  }
}

if (typeof Symbol === 'function') {
  Readable.from = function (iterable, opts) {
    if (from === undefined) {
      from = require('./internal/streams/from');
    }

    return from(Readable, iterable, opts);
  };
}

function indexOf(xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }

  return -1;
}
}).call(this)}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../errors":55,"./_stream_duplex":56,"./internal/streams/async_iterator":61,"./internal/streams/buffer_list":62,"./internal/streams/destroy":63,"./internal/streams/from":65,"./internal/streams/state":67,"./internal/streams/stream":68,"_process":159,"buffer":72,"events":109,"inherits":141,"string_decoder/":195,"util":27}],59:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.
'use strict';

module.exports = Transform;

var _require$codes = require('../errors').codes,
    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
    ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,
    ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING,
    ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;

var Duplex = require('./_stream_duplex');

require('inherits')(Transform, Duplex);

function afterTransform(er, data) {
  var ts = this._transformState;
  ts.transforming = false;
  var cb = ts.writecb;

  if (cb === null) {
    return this.emit('error', new ERR_MULTIPLE_CALLBACK());
  }

  ts.writechunk = null;
  ts.writecb = null;
  if (data != null) // single equals check for both `null` and `undefined`
    this.push(data);
  cb(er);
  var rs = this._readableState;
  rs.reading = false;

  if (rs.needReadable || rs.length < rs.highWaterMark) {
    this._read(rs.highWaterMark);
  }
}

function Transform(options) {
  if (!(this instanceof Transform)) return new Transform(options);
  Duplex.call(this, options);
  this._transformState = {
    afterTransform: afterTransform.bind(this),
    needTransform: false,
    transforming: false,
    writecb: null,
    writechunk: null,
    writeencoding: null
  }; // start out asking for a readable event once data is transformed.

  this._readableState.needReadable = true; // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.

  this._readableState.sync = false;

  if (options) {
    if (typeof options.transform === 'function') this._transform = options.transform;
    if (typeof options.flush === 'function') this._flush = options.flush;
  } // When the writable side finishes, then flush out anything remaining.


  this.on('prefinish', prefinish);
}

function prefinish() {
  var _this = this;

  if (typeof this._flush === 'function' && !this._readableState.destroyed) {
    this._flush(function (er, data) {
      done(_this, er, data);
    });
  } else {
    done(this, null, null);
  }
}

Transform.prototype.push = function (chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
}; // This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.


Transform.prototype._transform = function (chunk, encoding, cb) {
  cb(new ERR_METHOD_NOT_IMPLEMENTED('_transform()'));
};

Transform.prototype._write = function (chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;

  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
  }
}; // Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.


Transform.prototype._read = function (n) {
  var ts = this._transformState;

  if (ts.writechunk !== null && !ts.transforming) {
    ts.transforming = true;

    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};

Transform.prototype._destroy = function (err, cb) {
  Duplex.prototype._destroy.call(this, err, function (err2) {
    cb(err2);
  });
};

function done(stream, er, data) {
  if (er) return stream.emit('error', er);
  if (data != null) // single equals check for both `null` and `undefined`
    stream.push(data); // TODO(BridgeAR): Write a test for these two error cases
  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided

  if (stream._writableState.length) throw new ERR_TRANSFORM_WITH_LENGTH_0();
  if (stream._transformState.transforming) throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
  return stream.push(null);
}
},{"../errors":55,"./_stream_duplex":56,"inherits":141}],60:[function(require,module,exports){
(function (process,global){(function (){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// A bit simpler than readable streams.
// Implement an async ._write(chunk, encoding, cb), and it'll handle all
// the drain event emission and buffering.
'use strict';

module.exports = Writable;
/* <replacement> */

function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
  this.next = null;
} // It seems a linked list but it is not
// there will be only 2 of these for each stream


function CorkedRequest(state) {
  var _this = this;

  this.next = null;
  this.entry = null;

  this.finish = function () {
    onCorkedFinish(_this, state);
  };
}
/* </replacement> */

/*<replacement>*/


var Duplex;
/*</replacement>*/

Writable.WritableState = WritableState;
/*<replacement>*/

var internalUtil = {
  deprecate: require('util-deprecate')
};
/*</replacement>*/

/*<replacement>*/

var Stream = require('./internal/streams/stream');
/*</replacement>*/


var Buffer = require('buffer').Buffer;

var OurUint8Array = global.Uint8Array || function () {};

function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}

function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}

var destroyImpl = require('./internal/streams/destroy');

var _require = require('./internal/streams/state'),
    getHighWaterMark = _require.getHighWaterMark;

var _require$codes = require('../errors').codes,
    ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,
    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
    ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,
    ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE,
    ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED,
    ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES,
    ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END,
    ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;

var errorOrDestroy = destroyImpl.errorOrDestroy;

require('inherits')(Writable, Stream);

function nop() {}

function WritableState(options, stream, isDuplex) {
  Duplex = Duplex || require('./_stream_duplex');
  options = options || {}; // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream,
  // e.g. options.readableObjectMode vs. options.writableObjectMode, etc.

  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex; // object stream flag to indicate whether or not this stream
  // contains buffers or objects.

  this.objectMode = !!options.objectMode;
  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode; // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()

  this.highWaterMark = getHighWaterMark(this, options, 'writableHighWaterMark', isDuplex); // if _final has been called

  this.finalCalled = false; // drain event flag.

  this.needDrain = false; // at the start of calling end()

  this.ending = false; // when end() has been called, and returned

  this.ended = false; // when 'finish' is emitted

  this.finished = false; // has it been destroyed

  this.destroyed = false; // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.

  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode; // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.

  this.defaultEncoding = options.defaultEncoding || 'utf8'; // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.

  this.length = 0; // a flag to see when we're in the middle of a write.

  this.writing = false; // when true all writes will be buffered until .uncork() call

  this.corked = 0; // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.

  this.sync = true; // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.

  this.bufferProcessing = false; // the callback that's passed to _write(chunk,cb)

  this.onwrite = function (er) {
    onwrite(stream, er);
  }; // the callback that the user supplies to write(chunk,encoding,cb)


  this.writecb = null; // the amount that is being written when _write is called.

  this.writelen = 0;
  this.bufferedRequest = null;
  this.lastBufferedRequest = null; // number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted

  this.pendingcb = 0; // emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams

  this.prefinished = false; // True if the error was already emitted and should not be thrown again

  this.errorEmitted = false; // Should close be emitted on destroy. Defaults to true.

  this.emitClose = options.emitClose !== false; // Should .destroy() be called after 'finish' (and potentially 'end')

  this.autoDestroy = !!options.autoDestroy; // count buffered requests

  this.bufferedRequestCount = 0; // allocate the first CorkedRequest, there is always
  // one allocated and free to use, and we maintain at most two

  this.corkedRequestsFree = new CorkedRequest(this);
}

WritableState.prototype.getBuffer = function getBuffer() {
  var current = this.bufferedRequest;
  var out = [];

  while (current) {
    out.push(current);
    current = current.next;
  }

  return out;
};

(function () {
  try {
    Object.defineProperty(WritableState.prototype, 'buffer', {
      get: internalUtil.deprecate(function writableStateBufferGetter() {
        return this.getBuffer();
      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')
    });
  } catch (_) {}
})(); // Test _writableState for inheritance to account for Duplex streams,
// whose prototype chain only points to Readable.


var realHasInstance;

if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
  realHasInstance = Function.prototype[Symbol.hasInstance];
  Object.defineProperty(Writable, Symbol.hasInstance, {
    value: function value(object) {
      if (realHasInstance.call(this, object)) return true;
      if (this !== Writable) return false;
      return object && object._writableState instanceof WritableState;
    }
  });
} else {
  realHasInstance = function realHasInstance(object) {
    return object instanceof this;
  };
}

function Writable(options) {
  Duplex = Duplex || require('./_stream_duplex'); // Writable ctor is applied to Duplexes, too.
  // `realHasInstance` is necessary because using plain `instanceof`
  // would return false, as no `_writableState` property is attached.
  // Trying to use the custom `instanceof` for Writable here will also break the
  // Node.js LazyTransform implementation, which has a non-trivial getter for
  // `_writableState` that would lead to infinite recursion.
  // Checking for a Stream.Duplex instance is faster here instead of inside
  // the WritableState constructor, at least with V8 6.5

  var isDuplex = this instanceof Duplex;
  if (!isDuplex && !realHasInstance.call(Writable, this)) return new Writable(options);
  this._writableState = new WritableState(options, this, isDuplex); // legacy.

  this.writable = true;

  if (options) {
    if (typeof options.write === 'function') this._write = options.write;
    if (typeof options.writev === 'function') this._writev = options.writev;
    if (typeof options.destroy === 'function') this._destroy = options.destroy;
    if (typeof options.final === 'function') this._final = options.final;
  }

  Stream.call(this);
} // Otherwise people can pipe Writable streams, which is just wrong.


Writable.prototype.pipe = function () {
  errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
};

function writeAfterEnd(stream, cb) {
  var er = new ERR_STREAM_WRITE_AFTER_END(); // TODO: defer error events consistently everywhere, not just the cb

  errorOrDestroy(stream, er);
  process.nextTick(cb, er);
} // Checks that a user-supplied chunk is valid, especially for the particular
// mode the stream is in. Currently this means that `null` is never accepted
// and undefined/non-string values are only allowed in object mode.


function validChunk(stream, state, chunk, cb) {
  var er;

  if (chunk === null) {
    er = new ERR_STREAM_NULL_VALUES();
  } else if (typeof chunk !== 'string' && !state.objectMode) {
    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer'], chunk);
  }

  if (er) {
    errorOrDestroy(stream, er);
    process.nextTick(cb, er);
    return false;
  }

  return true;
}

Writable.prototype.write = function (chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;

  var isBuf = !state.objectMode && _isUint8Array(chunk);

  if (isBuf && !Buffer.isBuffer(chunk)) {
    chunk = _uint8ArrayToBuffer(chunk);
  }

  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;
  if (typeof cb !== 'function') cb = nop;
  if (state.ending) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
  }
  return ret;
};

Writable.prototype.cork = function () {
  this._writableState.corked++;
};

Writable.prototype.uncork = function () {
  var state = this._writableState;

  if (state.corked) {
    state.corked--;
    if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
  }
};

Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
  // node::ParseEncoding() requires lower case.
  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new ERR_UNKNOWN_ENCODING(encoding);
  this._writableState.defaultEncoding = encoding;
  return this;
};

Object.defineProperty(Writable.prototype, 'writableBuffer', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState && this._writableState.getBuffer();
  }
});

function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
    chunk = Buffer.from(chunk, encoding);
  }

  return chunk;
}

Object.defineProperty(Writable.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.highWaterMark;
  }
}); // if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.

function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
  if (!isBuf) {
    var newChunk = decodeChunk(state, chunk, encoding);

    if (chunk !== newChunk) {
      isBuf = true;
      encoding = 'buffer';
      chunk = newChunk;
    }
  }

  var len = state.objectMode ? 1 : chunk.length;
  state.length += len;
  var ret = state.length < state.highWaterMark; // we must ensure that previous needDrain will not be reset to false.

  if (!ret) state.needDrain = true;

  if (state.writing || state.corked) {
    var last = state.lastBufferedRequest;
    state.lastBufferedRequest = {
      chunk: chunk,
      encoding: encoding,
      isBuf: isBuf,
      callback: cb,
      next: null
    };

    if (last) {
      last.next = state.lastBufferedRequest;
    } else {
      state.bufferedRequest = state.lastBufferedRequest;
    }

    state.bufferedRequestCount += 1;
  } else {
    doWrite(stream, state, false, len, chunk, encoding, cb);
  }

  return ret;
}

function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (state.destroyed) state.onwrite(new ERR_STREAM_DESTROYED('write'));else if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  --state.pendingcb;

  if (sync) {
    // defer the callback if we are being called synchronously
    // to avoid piling up things on the stack
    process.nextTick(cb, er); // this can emit finish, and it will always happen
    // after error

    process.nextTick(finishMaybe, stream, state);
    stream._writableState.errorEmitted = true;
    errorOrDestroy(stream, er);
  } else {
    // the caller expect this to happen before if
    // it is async
    cb(er);
    stream._writableState.errorEmitted = true;
    errorOrDestroy(stream, er); // this can emit finish, but finish must
    // always follow error

    finishMaybe(stream, state);
  }
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;
  if (typeof cb !== 'function') throw new ERR_MULTIPLE_CALLBACK();
  onwriteStateUpdate(state);
  if (er) onwriteError(stream, state, sync, er, cb);else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(state) || stream.destroyed;

    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
      clearBuffer(stream, state);
    }

    if (sync) {
      process.nextTick(afterWrite, stream, state, finished, cb);
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}

function afterWrite(stream, state, finished, cb) {
  if (!finished) onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
} // Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.


function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
} // if there's something in the buffer waiting, then process it


function clearBuffer(stream, state) {
  state.bufferProcessing = true;
  var entry = state.bufferedRequest;

  if (stream._writev && entry && entry.next) {
    // Fast case, write everything using _writev()
    var l = state.bufferedRequestCount;
    var buffer = new Array(l);
    var holder = state.corkedRequestsFree;
    holder.entry = entry;
    var count = 0;
    var allBuffers = true;

    while (entry) {
      buffer[count] = entry;
      if (!entry.isBuf) allBuffers = false;
      entry = entry.next;
      count += 1;
    }

    buffer.allBuffers = allBuffers;
    doWrite(stream, state, true, state.length, buffer, '', holder.finish); // doWrite is almost always async, defer these to save a bit of time
    // as the hot path ends with doWrite

    state.pendingcb++;
    state.lastBufferedRequest = null;

    if (holder.next) {
      state.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state.corkedRequestsFree = new CorkedRequest(state);
    }

    state.bufferedRequestCount = 0;
  } else {
    // Slow case, write chunks one-by-one
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;
      doWrite(stream, state, false, len, chunk, encoding, cb);
      entry = entry.next;
      state.bufferedRequestCount--; // if we didn't call the onwrite immediately, then
      // it means that we need to wait until it does.
      // also, that means that the chunk and cb are currently
      // being processed, so move the buffer counter past them.

      if (state.writing) {
        break;
      }
    }

    if (entry === null) state.lastBufferedRequest = null;
  }

  state.bufferedRequest = entry;
  state.bufferProcessing = false;
}

Writable.prototype._write = function (chunk, encoding, cb) {
  cb(new ERR_METHOD_NOT_IMPLEMENTED('_write()'));
};

Writable.prototype._writev = null;

Writable.prototype.end = function (chunk, encoding, cb) {
  var state = this._writableState;

  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding); // .end() fully uncorks

  if (state.corked) {
    state.corked = 1;
    this.uncork();
  } // ignore unnecessary end() calls.


  if (!state.ending) endWritable(this, state, cb);
  return this;
};

Object.defineProperty(Writable.prototype, 'writableLength', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.length;
  }
});

function needFinish(state) {
  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}

function callFinal(stream, state) {
  stream._final(function (err) {
    state.pendingcb--;

    if (err) {
      errorOrDestroy(stream, err);
    }

    state.prefinished = true;
    stream.emit('prefinish');
    finishMaybe(stream, state);
  });
}

function prefinish(stream, state) {
  if (!state.prefinished && !state.finalCalled) {
    if (typeof stream._final === 'function' && !state.destroyed) {
      state.pendingcb++;
      state.finalCalled = true;
      process.nextTick(callFinal, stream, state);
    } else {
      state.prefinished = true;
      stream.emit('prefinish');
    }
  }
}

function finishMaybe(stream, state) {
  var need = needFinish(state);

  if (need) {
    prefinish(stream, state);

    if (state.pendingcb === 0) {
      state.finished = true;
      stream.emit('finish');

      if (state.autoDestroy) {
        // In case of duplex streams we need a way to detect
        // if the readable side is ready for autoDestroy as well
        var rState = stream._readableState;

        if (!rState || rState.autoDestroy && rState.endEmitted) {
          stream.destroy();
        }
      }
    }
  }

  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);

  if (cb) {
    if (state.finished) process.nextTick(cb);else stream.once('finish', cb);
  }

  state.ended = true;
  stream.writable = false;
}

function onCorkedFinish(corkReq, state, err) {
  var entry = corkReq.entry;
  corkReq.entry = null;

  while (entry) {
    var cb = entry.callback;
    state.pendingcb--;
    cb(err);
    entry = entry.next;
  } // reuse the free corkReq.


  state.corkedRequestsFree.next = corkReq;
}

Object.defineProperty(Writable.prototype, 'destroyed', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    if (this._writableState === undefined) {
      return false;
    }

    return this._writableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._writableState) {
      return;
    } // backward compatibility, the user is explicitly
    // managing destroyed


    this._writableState.destroyed = value;
  }
});
Writable.prototype.destroy = destroyImpl.destroy;
Writable.prototype._undestroy = destroyImpl.undestroy;

Writable.prototype._destroy = function (err, cb) {
  cb(err);
};
}).call(this)}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../errors":55,"./_stream_duplex":56,"./internal/streams/destroy":63,"./internal/streams/state":67,"./internal/streams/stream":68,"_process":159,"buffer":72,"inherits":141,"util-deprecate":196}],61:[function(require,module,exports){
(function (process){(function (){
'use strict';

var _Object$setPrototypeO;

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var finished = require('./end-of-stream');

var kLastResolve = Symbol('lastResolve');
var kLastReject = Symbol('lastReject');
var kError = Symbol('error');
var kEnded = Symbol('ended');
var kLastPromise = Symbol('lastPromise');
var kHandlePromise = Symbol('handlePromise');
var kStream = Symbol('stream');

function createIterResult(value, done) {
  return {
    value: value,
    done: done
  };
}

function readAndResolve(iter) {
  var resolve = iter[kLastResolve];

  if (resolve !== null) {
    var data = iter[kStream].read(); // we defer if data is null
    // we can be expecting either 'end' or
    // 'error'

    if (data !== null) {
      iter[kLastPromise] = null;
      iter[kLastResolve] = null;
      iter[kLastReject] = null;
      resolve(createIterResult(data, false));
    }
  }
}

function onReadable(iter) {
  // we wait for the next tick, because it might
  // emit an error with process.nextTick
  process.nextTick(readAndResolve, iter);
}

function wrapForNext(lastPromise, iter) {
  return function (resolve, reject) {
    lastPromise.then(function () {
      if (iter[kEnded]) {
        resolve(createIterResult(undefined, true));
        return;
      }

      iter[kHandlePromise](resolve, reject);
    }, reject);
  };
}

var AsyncIteratorPrototype = Object.getPrototypeOf(function () {});
var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
  get stream() {
    return this[kStream];
  },

  next: function next() {
    var _this = this;

    // if we have detected an error in the meanwhile
    // reject straight away
    var error = this[kError];

    if (error !== null) {
      return Promise.reject(error);
    }

    if (this[kEnded]) {
      return Promise.resolve(createIterResult(undefined, true));
    }

    if (this[kStream].destroyed) {
      // We need to defer via nextTick because if .destroy(err) is
      // called, the error will be emitted via nextTick, and
      // we cannot guarantee that there is no error lingering around
      // waiting to be emitted.
      return new Promise(function (resolve, reject) {
        process.nextTick(function () {
          if (_this[kError]) {
            reject(_this[kError]);
          } else {
            resolve(createIterResult(undefined, true));
          }
        });
      });
    } // if we have multiple next() calls
    // we will wait for the previous Promise to finish
    // this logic is optimized to support for await loops,
    // where next() is only called once at a time


    var lastPromise = this[kLastPromise];
    var promise;

    if (lastPromise) {
      promise = new Promise(wrapForNext(lastPromise, this));
    } else {
      // fast path needed to support multiple this.push()
      // without triggering the next() queue
      var data = this[kStream].read();

      if (data !== null) {
        return Promise.resolve(createIterResult(data, false));
      }

      promise = new Promise(this[kHandlePromise]);
    }

    this[kLastPromise] = promise;
    return promise;
  }
}, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function () {
  return this;
}), _defineProperty(_Object$setPrototypeO, "return", function _return() {
  var _this2 = this;

  // destroy(err, cb) is a private API
  // we can guarantee we have that here, because we control the
  // Readable class this is attached to
  return new Promise(function (resolve, reject) {
    _this2[kStream].destroy(null, function (err) {
      if (err) {
        reject(err);
        return;
      }

      resolve(createIterResult(undefined, true));
    });
  });
}), _Object$setPrototypeO), AsyncIteratorPrototype);

var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator(stream) {
  var _Object$create;

  var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
    value: stream,
    writable: true
  }), _defineProperty(_Object$create, kLastResolve, {
    value: null,
    writable: true
  }), _defineProperty(_Object$create, kLastReject, {
    value: null,
    writable: true
  }), _defineProperty(_Object$create, kError, {
    value: null,
    writable: true
  }), _defineProperty(_Object$create, kEnded, {
    value: stream._readableState.endEmitted,
    writable: true
  }), _defineProperty(_Object$create, kHandlePromise, {
    value: function value(resolve, reject) {
      var data = iterator[kStream].read();

      if (data) {
        iterator[kLastPromise] = null;
        iterator[kLastResolve] = null;
        iterator[kLastReject] = null;
        resolve(createIterResult(data, false));
      } else {
        iterator[kLastResolve] = resolve;
        iterator[kLastReject] = reject;
      }
    },
    writable: true
  }), _Object$create));
  iterator[kLastPromise] = null;
  finished(stream, function (err) {
    if (err && err.code !== 'ERR_STREAM_PREMATURE_CLOSE') {
      var reject = iterator[kLastReject]; // reject if we are waiting for data in the Promise
      // returned by next() and store the error

      if (reject !== null) {
        iterator[kLastPromise] = null;
        iterator[kLastResolve] = null;
        iterator[kLastReject] = null;
        reject(err);
      }

      iterator[kError] = err;
      return;
    }

    var resolve = iterator[kLastResolve];

    if (resolve !== null) {
      iterator[kLastPromise] = null;
      iterator[kLastResolve] = null;
      iterator[kLastReject] = null;
      resolve(createIterResult(undefined, true));
    }

    iterator[kEnded] = true;
  });
  stream.on('readable', onReadable.bind(null, iterator));
  return iterator;
};

module.exports = createReadableStreamAsyncIterator;
}).call(this)}).call(this,require('_process'))
},{"./end-of-stream":64,"_process":159}],62:[function(require,module,exports){
'use strict';

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var _require = require('buffer'),
    Buffer = _require.Buffer;

var _require2 = require('util'),
    inspect = _require2.inspect;

var custom = inspect && inspect.custom || 'inspect';

function copyBuffer(src, target, offset) {
  Buffer.prototype.copy.call(src, target, offset);
}

module.exports =
/*#__PURE__*/
function () {
  function BufferList() {
    _classCallCheck(this, BufferList);

    this.head = null;
    this.tail = null;
    this.length = 0;
  }

  _createClass(BufferList, [{
    key: "push",
    value: function push(v) {
      var entry = {
        data: v,
        next: null
      };
      if (this.length > 0) this.tail.next = entry;else this.head = entry;
      this.tail = entry;
      ++this.length;
    }
  }, {
    key: "unshift",
    value: function unshift(v) {
      var entry = {
        data: v,
        next: this.head
      };
      if (this.length === 0) this.tail = entry;
      this.head = entry;
      ++this.length;
    }
  }, {
    key: "shift",
    value: function shift() {
      if (this.length === 0) return;
      var ret = this.head.data;
      if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
      --this.length;
      return ret;
    }
  }, {
    key: "clear",
    value: function clear() {
      this.head = this.tail = null;
      this.length = 0;
    }
  }, {
    key: "join",
    value: function join(s) {
      if (this.length === 0) return '';
      var p = this.head;
      var ret = '' + p.data;

      while (p = p.next) {
        ret += s + p.data;
      }

      return ret;
    }
  }, {
    key: "concat",
    value: function concat(n) {
      if (this.length === 0) return Buffer.alloc(0);
      var ret = Buffer.allocUnsafe(n >>> 0);
      var p = this.head;
      var i = 0;

      while (p) {
        copyBuffer(p.data, ret, i);
        i += p.data.length;
        p = p.next;
      }

      return ret;
    } // Consumes a specified amount of bytes or characters from the buffered data.

  }, {
    key: "consume",
    value: function consume(n, hasStrings) {
      var ret;

      if (n < this.head.data.length) {
        // `slice` is the same for buffers and strings.
        ret = this.head.data.slice(0, n);
        this.head.data = this.head.data.slice(n);
      } else if (n === this.head.data.length) {
        // First chunk is a perfect match.
        ret = this.shift();
      } else {
        // Result spans more than one buffer.
        ret = hasStrings ? this._getString(n) : this._getBuffer(n);
      }

      return ret;
    }
  }, {
    key: "first",
    value: function first() {
      return this.head.data;
    } // Consumes a specified amount of characters from the buffered data.

  }, {
    key: "_getString",
    value: function _getString(n) {
      var p = this.head;
      var c = 1;
      var ret = p.data;
      n -= ret.length;

      while (p = p.next) {
        var str = p.data;
        var nb = n > str.length ? str.length : n;
        if (nb === str.length) ret += str;else ret += str.slice(0, n);
        n -= nb;

        if (n === 0) {
          if (nb === str.length) {
            ++c;
            if (p.next) this.head = p.next;else this.head = this.tail = null;
          } else {
            this.head = p;
            p.data = str.slice(nb);
          }

          break;
        }

        ++c;
      }

      this.length -= c;
      return ret;
    } // Consumes a specified amount of bytes from the buffered data.

  }, {
    key: "_getBuffer",
    value: function _getBuffer(n) {
      var ret = Buffer.allocUnsafe(n);
      var p = this.head;
      var c = 1;
      p.data.copy(ret);
      n -= p.data.length;

      while (p = p.next) {
        var buf = p.data;
        var nb = n > buf.length ? buf.length : n;
        buf.copy(ret, ret.length - n, 0, nb);
        n -= nb;

        if (n === 0) {
          if (nb === buf.length) {
            ++c;
            if (p.next) this.head = p.next;else this.head = this.tail = null;
          } else {
            this.head = p;
            p.data = buf.slice(nb);
          }

          break;
        }

        ++c;
      }

      this.length -= c;
      return ret;
    } // Make sure the linked list only shows the minimal necessary information.

  }, {
    key: custom,
    value: function value(_, options) {
      return inspect(this, _objectSpread({}, options, {
        // Only inspect one level.
        depth: 0,
        // It should not recurse.
        customInspect: false
      }));
    }
  }]);

  return BufferList;
}();
},{"buffer":72,"util":27}],63:[function(require,module,exports){
(function (process){(function (){
'use strict'; // undocumented cb() API, needed for core, not for public API

function destroy(err, cb) {
  var _this = this;

  var readableDestroyed = this._readableState && this._readableState.destroyed;
  var writableDestroyed = this._writableState && this._writableState.destroyed;

  if (readableDestroyed || writableDestroyed) {
    if (cb) {
      cb(err);
    } else if (err) {
      if (!this._writableState) {
        process.nextTick(emitErrorNT, this, err);
      } else if (!this._writableState.errorEmitted) {
        this._writableState.errorEmitted = true;
        process.nextTick(emitErrorNT, this, err);
      }
    }

    return this;
  } // we set destroyed to true before firing error callbacks in order
  // to make it re-entrance safe in case destroy() is called within callbacks


  if (this._readableState) {
    this._readableState.destroyed = true;
  } // if this is a duplex stream mark the writable part as destroyed as well


  if (this._writableState) {
    this._writableState.destroyed = true;
  }

  this._destroy(err || null, function (err) {
    if (!cb && err) {
      if (!_this._writableState) {
        process.nextTick(emitErrorAndCloseNT, _this, err);
      } else if (!_this._writableState.errorEmitted) {
        _this._writableState.errorEmitted = true;
        process.nextTick(emitErrorAndCloseNT, _this, err);
      } else {
        process.nextTick(emitCloseNT, _this);
      }
    } else if (cb) {
      process.nextTick(emitCloseNT, _this);
      cb(err);
    } else {
      process.nextTick(emitCloseNT, _this);
    }
  });

  return this;
}

function emitErrorAndCloseNT(self, err) {
  emitErrorNT(self, err);
  emitCloseNT(self);
}

function emitCloseNT(self) {
  if (self._writableState && !self._writableState.emitClose) return;
  if (self._readableState && !self._readableState.emitClose) return;
  self.emit('close');
}

function undestroy() {
  if (this._readableState) {
    this._readableState.destroyed = false;
    this._readableState.reading = false;
    this._readableState.ended = false;
    this._readableState.endEmitted = false;
  }

  if (this._writableState) {
    this._writableState.destroyed = false;
    this._writableState.ended = false;
    this._writableState.ending = false;
    this._writableState.finalCalled = false;
    this._writableState.prefinished = false;
    this._writableState.finished = false;
    this._writableState.errorEmitted = false;
  }
}

function emitErrorNT(self, err) {
  self.emit('error', err);
}

function errorOrDestroy(stream, err) {
  // We have tests that rely on errors being emitted
  // in the same tick, so changing this is semver major.
  // For now when you opt-in to autoDestroy we allow
  // the error to be emitted nextTick. In a future
  // semver major update we should change the default to this.
  var rState = stream._readableState;
  var wState = stream._writableState;
  if (rState && rState.autoDestroy || wState && wState.autoDestroy) stream.destroy(err);else stream.emit('error', err);
}

module.exports = {
  destroy: destroy,
  undestroy: undestroy,
  errorOrDestroy: errorOrDestroy
};
}).call(this)}).call(this,require('_process'))
},{"_process":159}],64:[function(require,module,exports){
// Ported from https://github.com/mafintosh/end-of-stream with
// permission from the author, Mathias Buus (@mafintosh).
'use strict';

var ERR_STREAM_PREMATURE_CLOSE = require('../../../errors').codes.ERR_STREAM_PREMATURE_CLOSE;

function once(callback) {
  var called = false;
  return function () {
    if (called) return;
    called = true;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    callback.apply(this, args);
  };
}

function noop() {}

function isRequest(stream) {
  return stream.setHeader && typeof stream.abort === 'function';
}

function eos(stream, opts, callback) {
  if (typeof opts === 'function') return eos(stream, null, opts);
  if (!opts) opts = {};
  callback = once(callback || noop);
  var readable = opts.readable || opts.readable !== false && stream.readable;
  var writable = opts.writable || opts.writable !== false && stream.writable;

  var onlegacyfinish = function onlegacyfinish() {
    if (!stream.writable) onfinish();
  };

  var writableEnded = stream._writableState && stream._writableState.finished;

  var onfinish = function onfinish() {
    writable = false;
    writableEnded = true;
    if (!readable) callback.call(stream);
  };

  var readableEnded = stream._readableState && stream._readableState.endEmitted;

  var onend = function onend() {
    readable = false;
    readableEnded = true;
    if (!writable) callback.call(stream);
  };

  var onerror = function onerror(err) {
    callback.call(stream, err);
  };

  var onclose = function onclose() {
    var err;

    if (readable && !readableEnded) {
      if (!stream._readableState || !stream._readableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
      return callback.call(stream, err);
    }

    if (writable && !writableEnded) {
      if (!stream._writableState || !stream._writableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
      return callback.call(stream, err);
    }
  };

  var onrequest = function onrequest() {
    stream.req.on('finish', onfinish);
  };

  if (isRequest(stream)) {
    stream.on('complete', onfinish);
    stream.on('abort', onclose);
    if (stream.req) onrequest();else stream.on('request', onrequest);
  } else if (writable && !stream._writableState) {
    // legacy streams
    stream.on('end', onlegacyfinish);
    stream.on('close', onlegacyfinish);
  }

  stream.on('end', onend);
  stream.on('finish', onfinish);
  if (opts.error !== false) stream.on('error', onerror);
  stream.on('close', onclose);
  return function () {
    stream.removeListener('complete', onfinish);
    stream.removeListener('abort', onclose);
    stream.removeListener('request', onrequest);
    if (stream.req) stream.req.removeListener('finish', onfinish);
    stream.removeListener('end', onlegacyfinish);
    stream.removeListener('close', onlegacyfinish);
    stream.removeListener('finish', onfinish);
    stream.removeListener('end', onend);
    stream.removeListener('error', onerror);
    stream.removeListener('close', onclose);
  };
}

module.exports = eos;
},{"../../../errors":55}],65:[function(require,module,exports){
module.exports = function () {
  throw new Error('Readable.from is not available in the browser')
};

},{}],66:[function(require,module,exports){
// Ported from https://github.com/mafintosh/pump with
// permission from the author, Mathias Buus (@mafintosh).
'use strict';

var eos;

function once(callback) {
  var called = false;
  return function () {
    if (called) return;
    called = true;
    callback.apply(void 0, arguments);
  };
}

var _require$codes = require('../../../errors').codes,
    ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS,
    ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;

function noop(err) {
  // Rethrow the error if it exists to avoid swallowing it
  if (err) throw err;
}

function isRequest(stream) {
  return stream.setHeader && typeof stream.abort === 'function';
}

function destroyer(stream, reading, writing, callback) {
  callback = once(callback);
  var closed = false;
  stream.on('close', function () {
    closed = true;
  });
  if (eos === undefined) eos = require('./end-of-stream');
  eos(stream, {
    readable: reading,
    writable: writing
  }, function (err) {
    if (err) return callback(err);
    closed = true;
    callback();
  });
  var destroyed = false;
  return function (err) {
    if (closed) return;
    if (destroyed) return;
    destroyed = true; // request.destroy just do .end - .abort is what we want

    if (isRequest(stream)) return stream.abort();
    if (typeof stream.destroy === 'function') return stream.destroy();
    callback(err || new ERR_STREAM_DESTROYED('pipe'));
  };
}

function call(fn) {
  fn();
}

function pipe(from, to) {
  return from.pipe(to);
}

function popCallback(streams) {
  if (!streams.length) return noop;
  if (typeof streams[streams.length - 1] !== 'function') return noop;
  return streams.pop();
}

function pipeline() {
  for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
    streams[_key] = arguments[_key];
  }

  var callback = popCallback(streams);
  if (Array.isArray(streams[0])) streams = streams[0];

  if (streams.length < 2) {
    throw new ERR_MISSING_ARGS('streams');
  }

  var error;
  var destroys = streams.map(function (stream, i) {
    var reading = i < streams.length - 1;
    var writing = i > 0;
    return destroyer(stream, reading, writing, function (err) {
      if (!error) error = err;
      if (err) destroys.forEach(call);
      if (reading) return;
      destroys.forEach(call);
      callback(error);
    });
  });
  return streams.reduce(pipe);
}

module.exports = pipeline;
},{"../../../errors":55,"./end-of-stream":64}],67:[function(require,module,exports){
'use strict';

var ERR_INVALID_OPT_VALUE = require('../../../errors').codes.ERR_INVALID_OPT_VALUE;

function highWaterMarkFrom(options, isDuplex, duplexKey) {
  return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
}

function getHighWaterMark(state, options, duplexKey, isDuplex) {
  var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);

  if (hwm != null) {
    if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
      var name = isDuplex ? duplexKey : 'highWaterMark';
      throw new ERR_INVALID_OPT_VALUE(name, hwm);
    }

    return Math.floor(hwm);
  } // Default value


  return state.objectMode ? 16 : 16 * 1024;
}

module.exports = {
  getHighWaterMark: getHighWaterMark
};
},{"../../../errors":55}],68:[function(require,module,exports){
module.exports = require('events').EventEmitter;

},{"events":109}],69:[function(require,module,exports){
exports = module.exports = require('./lib/_stream_readable.js');
exports.Stream = exports;
exports.Readable = exports;
exports.Writable = require('./lib/_stream_writable.js');
exports.Duplex = require('./lib/_stream_duplex.js');
exports.Transform = require('./lib/_stream_transform.js');
exports.PassThrough = require('./lib/_stream_passthrough.js');
exports.finished = require('./lib/internal/streams/end-of-stream.js');
exports.pipeline = require('./lib/internal/streams/pipeline.js');

},{"./lib/_stream_duplex.js":56,"./lib/_stream_passthrough.js":57,"./lib/_stream_readable.js":58,"./lib/_stream_transform.js":59,"./lib/_stream_writable.js":60,"./lib/internal/streams/end-of-stream.js":64,"./lib/internal/streams/pipeline.js":66}],70:[function(require,module,exports){
arguments[4][27][0].apply(exports,arguments)
},{"dup":27}],71:[function(require,module,exports){
(function (Buffer){(function (){
module.exports = function xor (a, b) {
  var length = Math.min(a.length, b.length)
  var buffer = new Buffer(length)

  for (var i = 0; i < length; ++i) {
    buffer[i] = a[i] ^ b[i]
  }

  return buffer
}

}).call(this)}).call(this,require("buffer").Buffer)
},{"buffer":72}],72:[function(require,module,exports){
(function (Buffer){(function (){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

'use strict'

var base64 = require('base64-js')
var ieee754 = require('ieee754')

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

var K_MAX_LENGTH = 0x7fffffff
exports.kMaxLength = K_MAX_LENGTH

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */
Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport()

if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&
    typeof console.error === 'function') {
  console.error(
    'This browser lacks typed array (Uint8Array) support which is required by ' +
    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
  )
}

function typedArraySupport () {
  // Can typed array instances can be augmented?
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = { __proto__: Uint8Array.prototype, foo: function () { return 42 } }
    return arr.foo() === 42
  } catch (e) {
    return false
  }
}

Object.defineProperty(Buffer.prototype, 'parent', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.buffer
  }
})

Object.defineProperty(Buffer.prototype, 'offset', {
  enumerable: true,
  get: function () {
    if (!Buffer.isBuffer(this)) return undefined
    return this.byteOffset
  }
})

function createBuffer (length) {
  if (length > K_MAX_LENGTH) {
    throw new RangeError('The value "' + length + '" is invalid for option "size"')
  }
  // Return an augmented `Uint8Array` instance
  var buf = new Uint8Array(length)
  buf.__proto__ = Buffer.prototype
  return buf
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new TypeError(
        'The "string" argument must be of type string. Received type number'
      )
    }
    return allocUnsafe(arg)
  }
  return from(arg, encodingOrOffset, length)
}

// Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
if (typeof Symbol !== 'undefined' && Symbol.species != null &&
    Buffer[Symbol.species] === Buffer) {
  Object.defineProperty(Buffer, Symbol.species, {
    value: null,
    configurable: true,
    enumerable: false,
    writable: false
  })
}

Buffer.poolSize = 8192 // not used by this implementation

function from (value, encodingOrOffset, length) {
  if (typeof value === 'string') {
    return fromString(value, encodingOrOffset)
  }

  if (ArrayBuffer.isView(value)) {
    return fromArrayLike(value)
  }

  if (value == null) {
    throw TypeError(
      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
      'or Array-like Object. Received type ' + (typeof value)
    )
  }

  if (isInstance(value, ArrayBuffer) ||
      (value && isInstance(value.buffer, ArrayBuffer))) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof value === 'number') {
    throw new TypeError(
      'The "value" argument must not be of type number. Received type number'
    )
  }

  var valueOf = value.valueOf && value.valueOf()
  if (valueOf != null && valueOf !== value) {
    return Buffer.from(valueOf, encodingOrOffset, length)
  }

  var b = fromObject(value)
  if (b) return b

  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&
      typeof value[Symbol.toPrimitive] === 'function') {
    return Buffer.from(
      value[Symbol.toPrimitive]('string'), encodingOrOffset, length
    )
  }

  throw new TypeError(
    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +
    'or Array-like Object. Received type ' + (typeof value)
  )
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(value, encodingOrOffset, length)
}

// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Buffer.prototype.__proto__ = Uint8Array.prototype
Buffer.__proto__ = Uint8Array

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be of type number')
  } else if (size < 0) {
    throw new RangeError('The value "' + size + '" is invalid for option "size"')
  }
}

function alloc (size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(size).fill(fill, encoding)
      : createBuffer(size).fill(fill)
  }
  return createBuffer(size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(size, fill, encoding)
}

function allocUnsafe (size) {
  assertSize(size)
  return createBuffer(size < 0 ? 0 : checked(size) | 0)
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(size)
}

function fromString (string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('Unknown encoding: ' + encoding)
  }

  var length = byteLength(string, encoding) | 0
  var buf = createBuffer(length)

  var actual = buf.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual)
  }

  return buf
}

function fromArrayLike (array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  var buf = createBuffer(length)
  for (var i = 0; i < length; i += 1) {
    buf[i] = array[i] & 255
  }
  return buf
}

function fromArrayBuffer (array, byteOffset, length) {
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('"offset" is outside of buffer bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('"length" is outside of buffer bounds')
  }

  var buf
  if (byteOffset === undefined && length === undefined) {
    buf = new Uint8Array(array)
  } else if (length === undefined) {
    buf = new Uint8Array(array, byteOffset)
  } else {
    buf = new Uint8Array(array, byteOffset, length)
  }

  // Return an augmented `Uint8Array` instance
  buf.__proto__ = Buffer.prototype
  return buf
}

function fromObject (obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    var buf = createBuffer(len)

    if (buf.length === 0) {
      return buf
    }

    obj.copy(buf, 0, 0, len)
    return buf
  }

  if (obj.length !== undefined) {
    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
      return createBuffer(0)
    }
    return fromArrayLike(obj)
  }

  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
    return fromArrayLike(obj.data)
  }
}

function checked (length) {
  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= K_MAX_LENGTH) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return b != null && b._isBuffer === true &&
    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false
}

Buffer.compare = function compare (a, b) {
  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)
  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError(
      'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
    )
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!Array.isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (isInstance(buf, Uint8Array)) {
      buf = Buffer.from(buf)
    }
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    throw new TypeError(
      'The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' +
      'Received type ' + typeof string
    )
  }

  var len = string.length
  var mustMatch = (arguments.length > 2 && arguments[2] === true)
  if (!mustMatch && len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) {
          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8
        }
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.toLocaleString = Buffer.prototype.toString

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()
  if (this.length > max) str += ' ... '
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (isInstance(target, Uint8Array)) {
    target = Buffer.from(target, target.offset, target.byteLength)
  }
  if (!Buffer.isBuffer(target)) {
    throw new TypeError(
      'The "target" argument must be one of type Buffer or Uint8Array. ' +
      'Received type ' + (typeof target)
    )
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset // Coerce to Number.
  if (numberIsNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  var strLen = string.length

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (numberIsNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset >>> 0
    if (isFinite(length)) {
      length = length >>> 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
        : (firstByte > 0xBF) ? 2
          : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf = this.subarray(start, end)
  // Return an augmented `Uint8Array` instance
  newBuf.__proto__ = Buffer.prototype
  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset + 3] = (value >>> 24)
  this[offset + 2] = (value >>> 16)
  this[offset + 1] = (value >>> 8)
  this[offset] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  this[offset + 2] = (value >>> 16)
  this[offset + 3] = (value >>> 24)
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start

  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
    // Use built-in when available, missing from IE11
    this.copyWithin(targetStart, start, end)
  } else if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (var i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, end),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if ((encoding === 'utf8' && code < 128) ||
          encoding === 'latin1') {
        // Fast path: If `val` fits into a single byte, use that numeric value.
        val = code
      }
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : Buffer.from(val, encoding)
    var len = bytes.length
    if (len === 0) {
      throw new TypeError('The value "' + val +
        '" is invalid for argument "value"')
    }
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node takes equal signs as end of the Base64 encoding
  str = str.split('=')[0]
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = str.trim().replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
// the `instanceof` check but they should be treated as of that type.
// See: https://github.com/feross/buffer/issues/166
function isInstance (obj, type) {
  return obj instanceof type ||
    (obj != null && obj.constructor != null && obj.constructor.name != null &&
      obj.constructor.name === type.name)
}
function numberIsNaN (obj) {
  // For IE11 support
  return obj !== obj // eslint-disable-line no-self-compare
}

}).call(this)}).call(this,require("buffer").Buffer)
},{"base64-js":24,"buffer":72,"ieee754":140}],73:[function(require,module,exports){
var Buffer = require('safe-buffer').Buffer
var Transform = require('stream').Transform
var StringDecoder = require('string_decoder').StringDecoder
var inherits = require('inherits')

function CipherBase (hashMode) {
  Transform.call(this)
  this.hashMode = typeof hashMode === 'string'
  if (this.hashMode) {
    this[hashMode] = this._finalOrDigest
  } else {
    this.final = this._finalOrDigest
  }
  if (this._final) {
    this.__final = this._final
    this._final = null
  }
  this._decoder = null
  this._encoding = null
}
inherits(CipherBase, Transform)

CipherBase.prototype.update = function (data, inputEnc, outputEnc) {
  if (typeof data === 'string') {
    data = Buffer.from(data, inputEnc)
  }

  var outData = this._update(data)
  if (this.hashMode) return this

  if (outputEnc) {
    outData = this._toString(outData, outputEnc)
  }

  return outData
}

CipherBase.prototype.setAutoPadding = function () {}
CipherBase.prototype.getAuthTag = function () {
  throw new Error('trying to get auth tag in unsupported state')
}

CipherBase.prototype.setAuthTag = function () {
  throw new Error('trying to set auth tag in unsupported state')
}

CipherBase.prototype.setAAD = function () {
  throw new Error('trying to set aad in unsupported state')
}

CipherBase.prototype._transform = function (data, _, next) {
  var err
  try {
    if (this.hashMode) {
      this._update(data)
    } else {
      this.push(this._update(data))
    }
  } catch (e) {
    err = e
  } finally {
    next(err)
  }
}
CipherBase.prototype._flush = function (done) {
  var err
  try {
    this.push(this.__final())
  } catch (e) {
    err = e
  }

  done(err)
}
CipherBase.prototype._finalOrDigest = function (outputEnc) {
  var outData = this.__final() || Buffer.alloc(0)
  if (outputEnc) {
    outData = this._toString(outData, outputEnc, true)
  }
  return outData
}

CipherBase.prototype._toString = function (value, enc, fin) {
  if (!this._decoder) {
    this._decoder = new StringDecoder(enc)
    this._encoding = enc
  }

  if (this._encoding !== enc) throw new Error('can\'t switch encodings')

  var out = this._decoder.write(value)
  if (fin) {
    out += this._decoder.end()
  }

  return out
}

module.exports = CipherBase

},{"inherits":141,"safe-buffer":170,"stream":180,"string_decoder":195}],74:[function(require,module,exports){
(function (Buffer){(function (){
var elliptic = require('elliptic')
var BN = require('bn.js')

module.exports = function createECDH (curve) {
  return new ECDH(curve)
}

var aliases = {
  secp256k1: {
    name: 'secp256k1',
    byteLength: 32
  },
  secp224r1: {
    name: 'p224',
    byteLength: 28
  },
  prime256v1: {
    name: 'p256',
    byteLength: 32
  },
  prime192v1: {
    name: 'p192',
    byteLength: 24
  },
  ed25519: {
    name: 'ed25519',
    byteLength: 32
  },
  secp384r1: {
    name: 'p384',
    byteLength: 48
  },
  secp521r1: {
    name: 'p521',
    byteLength: 66
  }
}

aliases.p224 = aliases.secp224r1
aliases.p256 = aliases.secp256r1 = aliases.prime256v1
aliases.p192 = aliases.secp192r1 = aliases.prime192v1
aliases.p384 = aliases.secp384r1
aliases.p521 = aliases.secp521r1

function ECDH (curve) {
  this.curveType = aliases[curve]
  if (!this.curveType) {
    this.curveType = {
      name: curve
    }
  }
  this.curve = new elliptic.ec(this.curveType.name) // eslint-disable-line new-cap
  this.keys = void 0
}

ECDH.prototype.generateKeys = function (enc, format) {
  this.keys = this.curve.genKeyPair()
  return this.getPublicKey(enc, format)
}

ECDH.prototype.computeSecret = function (other, inenc, enc) {
  inenc = inenc || 'utf8'
  if (!Buffer.isBuffer(other)) {
    other = new Buffer(other, inenc)
  }
  var otherPub = this.curve.keyFromPublic(other).getPublic()
  var out = otherPub.mul(this.keys.getPrivate()).getX()
  return formatReturnValue(out, enc, this.curveType.byteLength)
}

ECDH.prototype.getPublicKey = function (enc, format) {
  var key = this.keys.getPublic(format === 'compressed', true)
  if (format === 'hybrid') {
    if (key[key.length - 1] % 2) {
      key[0] = 7
    } else {
      key[0] = 6
    }
  }
  return formatReturnValue(key, enc)
}

ECDH.prototype.getPrivateKey = function (enc) {
  return formatReturnValue(this.keys.getPrivate(), enc)
}

ECDH.prototype.setPublicKey = function (pub, enc) {
  enc = enc || 'utf8'
  if (!Buffer.isBuffer(pub)) {
    pub = new Buffer(pub, enc)
  }
  this.keys._importPublic(pub)
  return this
}

ECDH.prototype.setPrivateKey = function (priv, enc) {
  enc = enc || 'utf8'
  if (!Buffer.isBuffer(priv)) {
    priv = new Buffer(priv, enc)
  }

  var _priv = new BN(priv)
  _priv = _priv.toString(16)
  this.keys = this.curve.genKeyPair()
  this.keys._importPrivate(_priv)
  return this
}

function formatReturnValue (bn, enc, len) {
  if (!Array.isArray(bn)) {
    bn = bn.toArray()
  }
  var buf = new Buffer(bn)
  if (len && buf.length < len) {
    var zeros = new Buffer(len - buf.length)
    zeros.fill(0)
    buf = Buffer.concat([zeros, buf])
  }
  if (!enc) {
    return buf
  } else {
    return buf.toString(enc)
  }
}

}).call(this)}).call(this,require("buffer").Buffer)
},{"bn.js":75,"buffer":72,"elliptic":92}],75:[function(require,module,exports){
arguments[4][23][0].apply(exports,arguments)
},{"buffer":27,"dup":23}],76:[function(require,module,exports){
'use strict'
var inherits = require('inherits')
var MD5 = require('md5.js')
var RIPEMD160 = require('ripemd160')
var sha = require('sha.js')
var Base = require('cipher-base')

function Hash (hash) {
  Base.call(this, 'digest')

  this._hash = hash
}

inherits(Hash, Base)

Hash.prototype._update = function (data) {
  this._hash.update(data)
}

Hash.prototype._final = function () {
  return this._hash.digest()
}

module.exports = function createHash (alg) {
  alg = alg.toLowerCase()
  if (alg === 'md5') return new MD5()
  if (alg === 'rmd160' || alg === 'ripemd160') return new RIPEMD160()

  return new Hash(sha(alg))
}

},{"cipher-base":73,"inherits":141,"md5.js":142,"ripemd160":169,"sha.js":173}],77:[function(require,module,exports){
var MD5 = require('md5.js')

module.exports = function (buffer) {
  return new MD5().update(buffer).digest()
}

},{"md5.js":142}],78:[function(require,module,exports){
'use strict'
var inherits = require('inherits')
var Legacy = require('./legacy')
var Base = require('cipher-base')
var Buffer = require('safe-buffer').Buffer
var md5 = require('create-hash/md5')
var RIPEMD160 = require('ripemd160')

var sha = require('sha.js')

var ZEROS = Buffer.alloc(128)

function Hmac (alg, key) {
  Base.call(this, 'digest')
  if (typeof key === 'string') {
    key = Buffer.from(key)
  }

  var blocksize = (alg === 'sha512' || alg === 'sha384') ? 128 : 64

  this._alg = alg
  this._key = key
  if (key.length > blocksize) {
    var hash = alg === 'rmd160' ? new RIPEMD160() : sha(alg)
    key = hash.update(key).digest()
  } else if (key.length < blocksize) {
    key = Buffer.concat([key, ZEROS], blocksize)
  }

  var ipad = this._ipad = Buffer.allocUnsafe(blocksize)
  var opad = this._opad = Buffer.allocUnsafe(blocksize)

  for (var i = 0; i < blocksize; i++) {
    ipad[i] = key[i] ^ 0x36
    opad[i] = key[i] ^ 0x5C
  }
  this._hash = alg === 'rmd160' ? new RIPEMD160() : sha(alg)
  this._hash.update(ipad)
}

inherits(Hmac, Base)

Hmac.prototype._update = function (data) {
  this._hash.update(data)
}

Hmac.prototype._final = function () {
  var h = this._hash.digest()
  var hash = this._alg === 'rmd160' ? new RIPEMD160() : sha(this._alg)
  return hash.update(this._opad).update(h).digest()
}

module.exports = function createHmac (alg, key) {
  alg = alg.toLowerCase()
  if (alg === 'rmd160' || alg === 'ripemd160') {
    return new Hmac('rmd160', key)
  }
  if (alg === 'md5') {
    return new Legacy(md5, key)
  }
  return new Hmac(alg, key)
}

},{"./legacy":79,"cipher-base":73,"create-hash/md5":77,"inherits":141,"ripemd160":169,"safe-buffer":170,"sha.js":173}],79:[function(require,module,exports){
'use strict'
var inherits = require('inherits')
var Buffer = require('safe-buffer').Buffer

var Base = require('cipher-base')

var ZEROS = Buffer.alloc(128)
var blocksize = 64

function Hmac (alg, key) {
  Base.call(this, 'digest')
  if (typeof key === 'string') {
    key = Buffer.from(key)
  }

  this._alg = alg
  this._key = key

  if (key.length > blocksize) {
    key = alg(key)
  } else if (key.length < blocksize) {
    key = Buffer.concat([key, ZEROS], blocksize)
  }

  var ipad = this._ipad = Buffer.allocUnsafe(blocksize)
  var opad = this._opad = Buffer.allocUnsafe(blocksize)

  for (var i = 0; i < blocksize; i++) {
    ipad[i] = key[i] ^ 0x36
    opad[i] = key[i] ^ 0x5C
  }

  this._hash = [ipad]
}

inherits(Hmac, Base)

Hmac.prototype._update = function (data) {
  this._hash.push(data)
}

Hmac.prototype._final = function () {
  var h = this._alg(Buffer.concat(this._hash))
  return this._alg(Buffer.concat([this._opad, h]))
}
module.exports = Hmac

},{"cipher-base":73,"inherits":141,"safe-buffer":170}],80:[function(require,module,exports){
'use strict'

exports.randomBytes = exports.rng = exports.pseudoRandomBytes = exports.prng = require('randombytes')
exports.createHash = exports.Hash = require('create-hash')
exports.createHmac = exports.Hmac = require('create-hmac')

var algos = require('browserify-sign/algos')
var algoKeys = Object.keys(algos)
var hashes = ['sha1', 'sha224', 'sha256', 'sha384', 'sha512', 'md5', 'rmd160'].concat(algoKeys)
exports.getHashes = function () {
  return hashes
}

var p = require('pbkdf2')
exports.pbkdf2 = p.pbkdf2
exports.pbkdf2Sync = p.pbkdf2Sync

var aes = require('browserify-cipher')

exports.Cipher = aes.Cipher
exports.createCipher = aes.createCipher
exports.Cipheriv = aes.Cipheriv
exports.createCipheriv = aes.createCipheriv
exports.Decipher = aes.Decipher
exports.createDecipher = aes.createDecipher
exports.Decipheriv = aes.Decipheriv
exports.createDecipheriv = aes.createDecipheriv
exports.getCiphers = aes.getCiphers
exports.listCiphers = aes.listCiphers

var dh = require('diffie-hellman')

exports.DiffieHellmanGroup = dh.DiffieHellmanGroup
exports.createDiffieHellmanGroup = dh.createDiffieHellmanGroup
exports.getDiffieHellman = dh.getDiffieHellman
exports.createDiffieHellman = dh.createDiffieHellman
exports.DiffieHellman = dh.DiffieHellman

var sign = require('browserify-sign')

exports.createSign = sign.createSign
exports.Sign = sign.Sign
exports.createVerify = sign.createVerify
exports.Verify = sign.Verify

exports.createECDH = require('create-ecdh')

var publicEncrypt = require('public-encrypt')

exports.publicEncrypt = publicEncrypt.publicEncrypt
exports.privateEncrypt = publicEncrypt.privateEncrypt
exports.publicDecrypt = publicEncrypt.publicDecrypt
exports.privateDecrypt = publicEncrypt.privateDecrypt

// the least I can do is make error messages for the rest of the node.js/crypto api.
// ;[
//   'createCredentials'
// ].forEach(function (name) {
//   exports[name] = function () {
//     throw new Error([
//       'sorry, ' + name + ' is not implemented yet',
//       'we accept pull requests',
//       'https://github.com/crypto-browserify/crypto-browserify'
//     ].join('\n'))
//   }
// })

var rf = require('randomfill')

exports.randomFill = rf.randomFill
exports.randomFillSync = rf.randomFillSync

exports.createCredentials = function () {
  throw new Error([
    'sorry, createCredentials is not implemented yet',
    'we accept pull requests',
    'https://github.com/crypto-browserify/crypto-browserify'
  ].join('\n'))
}

exports.constants = {
  'DH_CHECK_P_NOT_SAFE_PRIME': 2,
  'DH_CHECK_P_NOT_PRIME': 1,
  'DH_UNABLE_TO_CHECK_GENERATOR': 4,
  'DH_NOT_SUITABLE_GENERATOR': 8,
  'NPN_ENABLED': 1,
  'ALPN_ENABLED': 1,
  'RSA_PKCS1_PADDING': 1,
  'RSA_SSLV23_PADDING': 2,
  'RSA_NO_PADDING': 3,
  'RSA_PKCS1_OAEP_PADDING': 4,
  'RSA_X931_PADDING': 5,
  'RSA_PKCS1_PSS_PADDING': 6,
  'POINT_CONVERSION_COMPRESSED': 2,
  'POINT_CONVERSION_UNCOMPRESSED': 4,
  'POINT_CONVERSION_HYBRID': 6
}

},{"browserify-cipher":45,"browserify-sign":52,"browserify-sign/algos":49,"create-ecdh":74,"create-hash":76,"create-hmac":78,"diffie-hellman":87,"pbkdf2":153,"public-encrypt":160,"randombytes":167,"randomfill":168}],81:[function(require,module,exports){
'use strict';

exports.utils = require('./des/utils');
exports.Cipher = require('./des/cipher');
exports.DES = require('./des/des');
exports.CBC = require('./des/cbc');
exports.EDE = require('./des/ede');

},{"./des/cbc":82,"./des/cipher":83,"./des/des":84,"./des/ede":85,"./des/utils":86}],82:[function(require,module,exports){
'use strict';

var assert = require('minimalistic-assert');
var inherits = require('inherits');

var proto = {};

function CBCState(iv) {
  assert.equal(iv.length, 8, 'Invalid IV length');

  this.iv = new Array(8);
  for (var i = 0; i < this.iv.length; i++)
    this.iv[i] = iv[i];
}

function instantiate(Base) {
  function CBC(options) {
    Base.call(this, options);
    this._cbcInit();
  }
  inherits(CBC, Base);

  var keys = Object.keys(proto);
  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    CBC.prototype[key] = proto[key];
  }

  CBC.create = function create(options) {
    return new CBC(options);
  };

  return CBC;
}

exports.instantiate = instantiate;

proto._cbcInit = function _cbcInit() {
  var state = new CBCState(this.options.iv);
  this._cbcState = state;
};

proto._update = function _update(inp, inOff, out, outOff) {
  var state = this._cbcState;
  var superProto = this.constructor.super_.prototype;

  var iv = state.iv;
  if (this.type === 'encrypt') {
    for (var i = 0; i < this.blockSize; i++)
      iv[i] ^= inp[inOff + i];

    superProto._update.call(this, iv, 0, out, outOff);

    for (var i = 0; i < this.blockSize; i++)
      iv[i] = out[outOff + i];
  } else {
    superProto._update.call(this, inp, inOff, out, outOff);

    for (var i = 0; i < this.blockSize; i++)
      out[outOff + i] ^= iv[i];

    for (var i = 0; i < this.blockSize; i++)
      iv[i] = inp[inOff + i];
  }
};

},{"inherits":141,"minimalistic-assert":145}],83:[function(require,module,exports){
'use strict';

var assert = require('minimalistic-assert');

function Cipher(options) {
  this.options = options;

  this.type = this.options.type;
  this.blockSize = 8;
  this._init();

  this.buffer = new Array(this.blockSize);
  this.bufferOff = 0;
}
module.exports = Cipher;

Cipher.prototype._init = function _init() {
  // Might be overrided
};

Cipher.prototype.update = function update(data) {
  if (data.length === 0)
    return [];

  if (this.type === 'decrypt')
    return this._updateDecrypt(data);
  else
    return this._updateEncrypt(data);
};

Cipher.prototype._buffer = function _buffer(data, off) {
  // Append data to buffer
  var min = Math.min(this.buffer.length - this.bufferOff, data.length - off);
  for (var i = 0; i < min; i++)
    this.buffer[this.bufferOff + i] = data[off + i];
  this.bufferOff += min;

  // Shift next
  return min;
};

Cipher.prototype._flushBuffer = function _flushBuffer(out, off) {
  this._update(this.buffer, 0, out, off);
  this.bufferOff = 0;
  return this.blockSize;
};

Cipher.prototype._updateEncrypt = function _updateEncrypt(data) {
  var inputOff = 0;
  var outputOff = 0;

  var count = ((this.bufferOff + data.length) / this.blockSize) | 0;
  var out = new Array(count * this.blockSize);

  if (this.bufferOff !== 0) {
    inputOff += this._buffer(data, inputOff);

    if (this.bufferOff === this.buffer.length)
      outputOff += this._flushBuffer(out, outputOff);
  }

  // Write blocks
  var max = data.length - ((data.length - inputOff) % this.blockSize);
  for (; inputOff < max; inputOff += this.blockSize) {
    this._update(data, inputOff, out, outputOff);
    outputOff += this.blockSize;
  }

  // Queue rest
  for (; inputOff < data.length; inputOff++, this.bufferOff++)
    this.buffer[this.bufferOff] = data[inputOff];

  return out;
};

Cipher.prototype._updateDecrypt = function _updateDecrypt(data) {
  var inputOff = 0;
  var outputOff = 0;

  var count = Math.ceil((this.bufferOff + data.length) / this.blockSize) - 1;
  var out = new Array(count * this.blockSize);

  // TODO(indutny): optimize it, this is far from optimal
  for (; count > 0; count--) {
    inputOff += this._buffer(data, inputOff);
    outputOff += this._flushBuffer(out, outputOff);
  }

  // Buffer rest of the input
  inputOff += this._buffer(data, inputOff);

  return out;
};

Cipher.prototype.final = function final(buffer) {
  var first;
  if (buffer)
    first = this.update(buffer);

  var last;
  if (this.type === 'encrypt')
    last = this._finalEncrypt();
  else
    last = this._finalDecrypt();

  if (first)
    return first.concat(last);
  else
    return last;
};

Cipher.prototype._pad = function _pad(buffer, off) {
  if (off === 0)
    return false;

  while (off < buffer.length)
    buffer[off++] = 0;

  return true;
};

Cipher.prototype._finalEncrypt = function _finalEncrypt() {
  if (!this._pad(this.buffer, this.bufferOff))
    return [];

  var out = new Array(this.blockSize);
  this._update(this.buffer, 0, out, 0);
  return out;
};

Cipher.prototype._unpad = function _unpad(buffer) {
  return buffer;
};

Cipher.prototype._finalDecrypt = function _finalDecrypt() {
  assert.equal(this.bufferOff, this.blockSize, 'Not enough data to decrypt');
  var out = new Array(this.blockSize);
  this._flushBuffer(out, 0);

  return this._unpad(out);
};

},{"minimalistic-assert":145}],84:[function(require,module,exports){
'use strict';

var assert = require('minimalistic-assert');
var inherits = require('inherits');

var utils = require('./utils');
var Cipher = require('./cipher');

function DESState() {
  this.tmp = new Array(2);
  this.keys = null;
}

function DES(options) {
  Cipher.call(this, options);

  var state = new DESState();
  this._desState = state;

  this.deriveKeys(state, options.key);
}
inherits(DES, Cipher);
module.exports = DES;

DES.create = function create(options) {
  return new DES(options);
};

var shiftTable = [
  1, 1, 2, 2, 2, 2, 2, 2,
  1, 2, 2, 2, 2, 2, 2, 1
];

DES.prototype.deriveKeys = function deriveKeys(state, key) {
  state.keys = new Array(16 * 2);

  assert.equal(key.length, this.blockSize, 'Invalid key length');

  var kL = utils.readUInt32BE(key, 0);
  var kR = utils.readUInt32BE(key, 4);

  utils.pc1(kL, kR, state.tmp, 0);
  kL = state.tmp[0];
  kR = state.tmp[1];
  for (var i = 0; i < state.keys.length; i += 2) {
    var shift = shiftTable[i >>> 1];
    kL = utils.r28shl(kL, shift);
    kR = utils.r28shl(kR, shift);
    utils.pc2(kL, kR, state.keys, i);
  }
};

DES.prototype._update = function _update(inp, inOff, out, outOff) {
  var state = this._desState;

  var l = utils.readUInt32BE(inp, inOff);
  var r = utils.readUInt32BE(inp, inOff + 4);

  // Initial Permutation
  utils.ip(l, r, state.tmp, 0);
  l = state.tmp[0];
  r = state.tmp[1];

  if (this.type === 'encrypt')
    this._encrypt(state, l, r, state.tmp, 0);
  else
    this._decrypt(state, l, r, state.tmp, 0);

  l = state.tmp[0];
  r = state.tmp[1];

  utils.writeUInt32BE(out, l, outOff);
  utils.writeUInt32BE(out, r, outOff + 4);
};

DES.prototype._pad = function _pad(buffer, off) {
  var value = buffer.length - off;
  for (var i = off; i < buffer.length; i++)
    buffer[i] = value;

  return true;
};

DES.prototype._unpad = function _unpad(buffer) {
  var pad = buffer[buffer.length - 1];
  for (var i = buffer.length - pad; i < buffer.length; i++)
    assert.equal(buffer[i], pad);

  return buffer.slice(0, buffer.length - pad);
};

DES.prototype._encrypt = function _encrypt(state, lStart, rStart, out, off) {
  var l = lStart;
  var r = rStart;

  // Apply f() x16 times
  for (var i = 0; i < state.keys.length; i += 2) {
    var keyL = state.keys[i];
    var keyR = state.keys[i + 1];

    // f(r, k)
    utils.expand(r, state.tmp, 0);

    keyL ^= state.tmp[0];
    keyR ^= state.tmp[1];
    var s = utils.substitute(keyL, keyR);
    var f = utils.permute(s);

    var t = r;
    r = (l ^ f) >>> 0;
    l = t;
  }

  // Reverse Initial Permutation
  utils.rip(r, l, out, off);
};

DES.prototype._decrypt = function _decrypt(state, lStart, rStart, out, off) {
  var l = rStart;
  var r = lStart;

  // Apply f() x16 times
  for (var i = state.keys.length - 2; i >= 0; i -= 2) {
    var keyL = state.keys[i];
    var keyR = state.keys[i + 1];

    // f(r, k)
    utils.expand(l, state.tmp, 0);

    keyL ^= state.tmp[0];
    keyR ^= state.tmp[1];
    var s = utils.substitute(keyL, keyR);
    var f = utils.permute(s);

    var t = l;
    l = (r ^ f) >>> 0;
    r = t;
  }

  // Reverse Initial Permutation
  utils.rip(l, r, out, off);
};

},{"./cipher":83,"./utils":86,"inherits":141,"minimalistic-assert":145}],85:[function(require,module,exports){
'use strict';

var assert = require('minimalistic-assert');
var inherits = require('inherits');

var Cipher = require('./cipher');
var DES = require('./des');

function EDEState(type, key) {
  assert.equal(key.length, 24, 'Invalid key length');

  var k1 = key.slice(0, 8);
  var k2 = key.slice(8, 16);
  var k3 = key.slice(16, 24);

  if (type === 'encrypt') {
    this.ciphers = [
      DES.create({ type: 'encrypt', key: k1 }),
      DES.create({ type: 'decrypt', key: k2 }),
      DES.create({ type: 'encrypt', key: k3 })
    ];
  } else {
    this.ciphers = [
      DES.create({ type: 'decrypt', key: k3 }),
      DES.create({ type: 'encrypt', key: k2 }),
      DES.create({ type: 'decrypt', key: k1 })
    ];
  }
}

function EDE(options) {
  Cipher.call(this, options);

  var state = new EDEState(this.type, this.options.key);
  this._edeState = state;
}
inherits(EDE, Cipher);

module.exports = EDE;

EDE.create = function create(options) {
  return new EDE(options);
};

EDE.prototype._update = function _update(inp, inOff, out, outOff) {
  var state = this._edeState;

  state.ciphers[0]._update(inp, inOff, out, outOff);
  state.ciphers[1]._update(out, outOff, out, outOff);
  state.ciphers[2]._update(out, outOff, out, outOff);
};

EDE.prototype._pad = DES.prototype._pad;
EDE.prototype._unpad = DES.prototype._unpad;

},{"./cipher":83,"./des":84,"inherits":141,"minimalistic-assert":145}],86:[function(require,module,exports){
'use strict';

exports.readUInt32BE = function readUInt32BE(bytes, off) {
  var res =  (bytes[0 + off] << 24) |
             (bytes[1 + off] << 16) |
             (bytes[2 + off] << 8) |
             bytes[3 + off];
  return res >>> 0;
};

exports.writeUInt32BE = function writeUInt32BE(bytes, value, off) {
  bytes[0 + off] = value >>> 24;
  bytes[1 + off] = (value >>> 16) & 0xff;
  bytes[2 + off] = (value >>> 8) & 0xff;
  bytes[3 + off] = value & 0xff;
};

exports.ip = function ip(inL, inR, out, off) {
  var outL = 0;
  var outR = 0;

  for (var i = 6; i >= 0; i -= 2) {
    for (var j = 0; j <= 24; j += 8) {
      outL <<= 1;
      outL |= (inR >>> (j + i)) & 1;
    }
    for (var j = 0; j <= 24; j += 8) {
      outL <<= 1;
      outL |= (inL >>> (j + i)) & 1;
    }
  }

  for (var i = 6; i >= 0; i -= 2) {
    for (var j = 1; j <= 25; j += 8) {
      outR <<= 1;
      outR |= (inR >>> (j + i)) & 1;
    }
    for (var j = 1; j <= 25; j += 8) {
      outR <<= 1;
      outR |= (inL >>> (j + i)) & 1;
    }
  }

  out[off + 0] = outL >>> 0;
  out[off + 1] = outR >>> 0;
};

exports.rip = function rip(inL, inR, out, off) {
  var outL = 0;
  var outR = 0;

  for (var i = 0; i < 4; i++) {
    for (var j = 24; j >= 0; j -= 8) {
      outL <<= 1;
      outL |= (inR >>> (j + i)) & 1;
      outL <<= 1;
      outL |= (inL >>> (j + i)) & 1;
    }
  }
  for (var i = 4; i < 8; i++) {
    for (var j = 24; j >= 0; j -= 8) {
      outR <<= 1;
      outR |= (inR >>> (j + i)) & 1;
      outR <<= 1;
      outR |= (inL >>> (j + i)) & 1;
    }
  }

  out[off + 0] = outL >>> 0;
  out[off + 1] = outR >>> 0;
};

exports.pc1 = function pc1(inL, inR, out, off) {
  var outL = 0;
  var outR = 0;

  // 7, 15, 23, 31, 39, 47, 55, 63
  // 6, 14, 22, 30, 39, 47, 55, 63
  // 5, 13, 21, 29, 39, 47, 55, 63
  // 4, 12, 20, 28
  for (var i = 7; i >= 5; i--) {
    for (var j = 0; j <= 24; j += 8) {
      outL <<= 1;
      outL |= (inR >> (j + i)) & 1;
    }
    for (var j = 0; j <= 24; j += 8) {
      outL <<= 1;
      outL |= (inL >> (j + i)) & 1;
    }
  }
  for (var j = 0; j <= 24; j += 8) {
    outL <<= 1;
    outL |= (inR >> (j + i)) & 1;
  }

  // 1, 9, 17, 25, 33, 41, 49, 57
  // 2, 10, 18, 26, 34, 42, 50, 58
  // 3, 11, 19, 27, 35, 43, 51, 59
  // 36, 44, 52, 60
  for (var i = 1; i <= 3; i++) {
    for (var j = 0; j <= 24; j += 8) {
      outR <<= 1;
      outR |= (inR >> (j + i)) & 1;
    }
    for (var j = 0; j <= 24; j += 8) {
      outR <<= 1;
      outR |= (inL >> (j + i)) & 1;
    }
  }
  for (var j = 0; j <= 24; j += 8) {
    outR <<= 1;
    outR |= (inL >> (j + i)) & 1;
  }

  out[off + 0] = outL >>> 0;
  out[off + 1] = outR >>> 0;
};

exports.r28shl = function r28shl(num, shift) {
  return ((num << shift) & 0xfffffff) | (num >>> (28 - shift));
};

var pc2table = [
  // inL => outL
  14, 11, 17, 4, 27, 23, 25, 0,
  13, 22, 7, 18, 5, 9, 16, 24,
  2, 20, 12, 21, 1, 8, 15, 26,

  // inR => outR
  15, 4, 25, 19, 9, 1, 26, 16,
  5, 11, 23, 8, 12, 7, 17, 0,
  22, 3, 10, 14, 6, 20, 27, 24
];

exports.pc2 = function pc2(inL, inR, out, off) {
  var outL = 0;
  var outR = 0;

  var len = pc2table.length >>> 1;
  for (var i = 0; i < len; i++) {
    outL <<= 1;
    outL |= (inL >>> pc2table[i]) & 0x1;
  }
  for (var i = len; i < pc2table.length; i++) {
    outR <<= 1;
    outR |= (inR >>> pc2table[i]) & 0x1;
  }

  out[off + 0] = outL >>> 0;
  out[off + 1] = outR >>> 0;
};

exports.expand = function expand(r, out, off) {
  var outL = 0;
  var outR = 0;

  outL = ((r & 1) << 5) | (r >>> 27);
  for (var i = 23; i >= 15; i -= 4) {
    outL <<= 6;
    outL |= (r >>> i) & 0x3f;
  }
  for (var i = 11; i >= 3; i -= 4) {
    outR |= (r >>> i) & 0x3f;
    outR <<= 6;
  }
  outR |= ((r & 0x1f) << 1) | (r >>> 31);

  out[off + 0] = outL >>> 0;
  out[off + 1] = outR >>> 0;
};

var sTable = [
  14, 0, 4, 15, 13, 7, 1, 4, 2, 14, 15, 2, 11, 13, 8, 1,
  3, 10, 10, 6, 6, 12, 12, 11, 5, 9, 9, 5, 0, 3, 7, 8,
  4, 15, 1, 12, 14, 8, 8, 2, 13, 4, 6, 9, 2, 1, 11, 7,
  15, 5, 12, 11, 9, 3, 7, 14, 3, 10, 10, 0, 5, 6, 0, 13,

  15, 3, 1, 13, 8, 4, 14, 7, 6, 15, 11, 2, 3, 8, 4, 14,
  9, 12, 7, 0, 2, 1, 13, 10, 12, 6, 0, 9, 5, 11, 10, 5,
  0, 13, 14, 8, 7, 10, 11, 1, 10, 3, 4, 15, 13, 4, 1, 2,
  5, 11, 8, 6, 12, 7, 6, 12, 9, 0, 3, 5, 2, 14, 15, 9,

  10, 13, 0, 7, 9, 0, 14, 9, 6, 3, 3, 4, 15, 6, 5, 10,
  1, 2, 13, 8, 12, 5, 7, 14, 11, 12, 4, 11, 2, 15, 8, 1,
  13, 1, 6, 10, 4, 13, 9, 0, 8, 6, 15, 9, 3, 8, 0, 7,
  11, 4, 1, 15, 2, 14, 12, 3, 5, 11, 10, 5, 14, 2, 7, 12,

  7, 13, 13, 8, 14, 11, 3, 5, 0, 6, 6, 15, 9, 0, 10, 3,
  1, 4, 2, 7, 8, 2, 5, 12, 11, 1, 12, 10, 4, 14, 15, 9,
  10, 3, 6, 15, 9, 0, 0, 6, 12, 10, 11, 1, 7, 13, 13, 8,
  15, 9, 1, 4, 3, 5, 14, 11, 5, 12, 2, 7, 8, 2, 4, 14,

  2, 14, 12, 11, 4, 2, 1, 12, 7, 4, 10, 7, 11, 13, 6, 1,
  8, 5, 5, 0, 3, 15, 15, 10, 13, 3, 0, 9, 14, 8, 9, 6,
  4, 11, 2, 8, 1, 12, 11, 7, 10, 1, 13, 14, 7, 2, 8, 13,
  15, 6, 9, 15, 12, 0, 5, 9, 6, 10, 3, 4, 0, 5, 14, 3,

  12, 10, 1, 15, 10, 4, 15, 2, 9, 7, 2, 12, 6, 9, 8, 5,
  0, 6, 13, 1, 3, 13, 4, 14, 14, 0, 7, 11, 5, 3, 11, 8,
  9, 4, 14, 3, 15, 2, 5, 12, 2, 9, 8, 5, 12, 15, 3, 10,
  7, 11, 0, 14, 4, 1, 10, 7, 1, 6, 13, 0, 11, 8, 6, 13,

  4, 13, 11, 0, 2, 11, 14, 7, 15, 4, 0, 9, 8, 1, 13, 10,
  3, 14, 12, 3, 9, 5, 7, 12, 5, 2, 10, 15, 6, 8, 1, 6,
  1, 6, 4, 11, 11, 13, 13, 8, 12, 1, 3, 4, 7, 10, 14, 7,
  10, 9, 15, 5, 6, 0, 8, 15, 0, 14, 5, 2, 9, 3, 2, 12,

  13, 1, 2, 15, 8, 13, 4, 8, 6, 10, 15, 3, 11, 7, 1, 4,
  10, 12, 9, 5, 3, 6, 14, 11, 5, 0, 0, 14, 12, 9, 7, 2,
  7, 2, 11, 1, 4, 14, 1, 7, 9, 4, 12, 10, 14, 8, 2, 13,
  0, 15, 6, 12, 10, 9, 13, 0, 15, 3, 3, 5, 5, 6, 8, 11
];

exports.substitute = function substitute(inL, inR) {
  var out = 0;
  for (var i = 0; i < 4; i++) {
    var b = (inL >>> (18 - i * 6)) & 0x3f;
    var sb = sTable[i * 0x40 + b];

    out <<= 4;
    out |= sb;
  }
  for (var i = 0; i < 4; i++) {
    var b = (inR >>> (18 - i * 6)) & 0x3f;
    var sb = sTable[4 * 0x40 + i * 0x40 + b];

    out <<= 4;
    out |= sb;
  }
  return out >>> 0;
};

var permuteTable = [
  16, 25, 12, 11, 3, 20, 4, 15, 31, 17, 9, 6, 27, 14, 1, 22,
  30, 24, 8, 18, 0, 5, 29, 23, 13, 19, 2, 26, 10, 21, 28, 7
];

exports.permute = function permute(num) {
  var out = 0;
  for (var i = 0; i < permuteTable.length; i++) {
    out <<= 1;
    out |= (num >>> permuteTable[i]) & 0x1;
  }
  return out >>> 0;
};

exports.padSplit = function padSplit(num, size, group) {
  var str = num.toString(2);
  while (str.length < size)
    str = '0' + str;

  var out = [];
  for (var i = 0; i < size; i += group)
    out.push(str.slice(i, i + group));
  return out.join(' ');
};

},{}],87:[function(require,module,exports){
(function (Buffer){(function (){
var generatePrime = require('./lib/generatePrime')
var primes = require('./lib/primes.json')

var DH = require('./lib/dh')

function getDiffieHellman (mod) {
  var prime = new Buffer(primes[mod].prime, 'hex')
  var gen = new Buffer(primes[mod].gen, 'hex')

  return new DH(prime, gen)
}

var ENCODINGS = {
  'binary': true, 'hex': true, 'base64': true
}

function createDiffieHellman (prime, enc, generator, genc) {
  if (Buffer.isBuffer(enc) || ENCODINGS[enc] === undefined) {
    return createDiffieHellman(prime, 'binary', enc, generator)
  }

  enc = enc || 'binary'
  genc = genc || 'binary'
  generator = generator || new Buffer([2])

  if (!Buffer.isBuffer(generator)) {
    generator = new Buffer(generator, genc)
  }

  if (typeof prime === 'number') {
    return new DH(generatePrime(prime, generator), generator, true)
  }

  if (!Buffer.isBuffer(prime)) {
    prime = new Buffer(prime, enc)
  }

  return new DH(prime, generator, true)
}

exports.DiffieHellmanGroup = exports.createDiffieHellmanGroup = exports.getDiffieHellman = getDiffieHellman
exports.createDiffieHellman = exports.DiffieHellman = createDiffieHellman

}).call(this)}).call(this,require("buffer").Buffer)
},{"./lib/dh":88,"./lib/generatePrime":89,"./lib/primes.json":90,"buffer":72}],88:[function(require,module,exports){
(function (Buffer){(function (){
var BN = require('bn.js');
var MillerRabin = require('miller-rabin');
var millerRabin = new MillerRabin();
var TWENTYFOUR = new BN(24);
var ELEVEN = new BN(11);
var TEN = new BN(10);
var THREE = new BN(3);
var SEVEN = new BN(7);
var primes = require('./generatePrime');
var randomBytes = require('randombytes');
module.exports = DH;

function setPublicKey(pub, enc) {
  enc = enc || 'utf8';
  if (!Buffer.isBuffer(pub)) {
    pub = new Buffer(pub, enc);
  }
  this._pub = new BN(pub);
  return this;
}

function setPrivateKey(priv, enc) {
  enc = enc || 'utf8';
  if (!Buffer.isBuffer(priv)) {
    priv = new Buffer(priv, enc);
  }
  this._priv = new BN(priv);
  return this;
}

var primeCache = {};
function checkPrime(prime, generator) {
  var gen = generator.toString('hex');
  var hex = [gen, prime.toString(16)].join('_');
  if (hex in primeCache) {
    return primeCache[hex];
  }
  var error = 0;

  if (prime.isEven() ||
    !primes.simpleSieve ||
    !primes.fermatTest(prime) ||
    !millerRabin.test(prime)) {
    //not a prime so +1
    error += 1;

    if (gen === '02' || gen === '05') {
      // we'd be able to check the generator
      // it would fail so +8
      error += 8;
    } else {
      //we wouldn't be able to test the generator
      // so +4
      error += 4;
    }
    primeCache[hex] = error;
    return error;
  }
  if (!millerRabin.test(prime.shrn(1))) {
    //not a safe prime
    error += 2;
  }
  var rem;
  switch (gen) {
    case '02':
      if (prime.mod(TWENTYFOUR).cmp(ELEVEN)) {
        // unsuidable generator
        error += 8;
      }
      break;
    case '05':
      rem = prime.mod(TEN);
      if (rem.cmp(THREE) && rem.cmp(SEVEN)) {
        // prime mod 10 needs to equal 3 or 7
        error += 8;
      }
      break;
    default:
      error += 4;
  }
  primeCache[hex] = error;
  return error;
}

function DH(prime, generator, malleable) {
  this.setGenerator(generator);
  this.__prime = new BN(prime);
  this._prime = BN.mont(this.__prime);
  this._primeLen = prime.length;
  this._pub = undefined;
  this._priv = undefined;
  this._primeCode = undefined;
  if (malleable) {
    this.setPublicKey = setPublicKey;
    this.setPrivateKey = setPrivateKey;
  } else {
    this._primeCode = 8;
  }
}
Object.defineProperty(DH.prototype, 'verifyError', {
  enumerable: true,
  get: function () {
    if (typeof this._primeCode !== 'number') {
      this._primeCode = checkPrime(this.__prime, this.__gen);
    }
    return this._primeCode;
  }
});
DH.prototype.generateKeys = function () {
  if (!this._priv) {
    this._priv = new BN(randomBytes(this._primeLen));
  }
  this._pub = this._gen.toRed(this._prime).redPow(this._priv).fromRed();
  return this.getPublicKey();
};

DH.prototype.computeSecret = function (other) {
  other = new BN(other);
  other = other.toRed(this._prime);
  var secret = other.redPow(this._priv).fromRed();
  var out = new Buffer(secret.toArray());
  var prime = this.getPrime();
  if (out.length < prime.length) {
    var front = new Buffer(prime.length - out.length);
    front.fill(0);
    out = Buffer.concat([front, out]);
  }
  return out;
};

DH.prototype.getPublicKey = function getPublicKey(enc) {
  return formatReturnValue(this._pub, enc);
};

DH.prototype.getPrivateKey = function getPrivateKey(enc) {
  return formatReturnValue(this._priv, enc);
};

DH.prototype.getPrime = function (enc) {
  return formatReturnValue(this.__prime, enc);
};

DH.prototype.getGenerator = function (enc) {
  return formatReturnValue(this._gen, enc);
};

DH.prototype.setGenerator = function (gen, enc) {
  enc = enc || 'utf8';
  if (!Buffer.isBuffer(gen)) {
    gen = new Buffer(gen, enc);
  }
  this.__gen = gen;
  this._gen = new BN(gen);
  return this;
};

function formatReturnValue(bn, enc) {
  var buf = new Buffer(bn.toArray());
  if (!enc) {
    return buf;
  } else {
    return buf.toString(enc);
  }
}

}).call(this)}).call(this,require("buffer").Buffer)
},{"./generatePrime":89,"bn.js":91,"buffer":72,"miller-rabin":143,"randombytes":167}],89:[function(require,module,exports){
var randomBytes = require('randombytes');
module.exports = findPrime;
findPrime.simpleSieve = simpleSieve;
findPrime.fermatTest = fermatTest;
var BN = require('bn.js');
var TWENTYFOUR = new BN(24);
var MillerRabin = require('miller-rabin');
var millerRabin = new MillerRabin();
var ONE = new BN(1);
var TWO = new BN(2);
var FIVE = new BN(5);
var SIXTEEN = new BN(16);
var EIGHT = new BN(8);
var TEN = new BN(10);
var THREE = new BN(3);
var SEVEN = new BN(7);
var ELEVEN = new BN(11);
var FOUR = new BN(4);
var TWELVE = new BN(12);
var primes = null;

function _getPrimes() {
  if (primes !== null)
    return primes;

  var limit = 0x100000;
  var res = [];
  res[0] = 2;
  for (var i = 1, k = 3; k < limit; k += 2) {
    var sqrt = Math.ceil(Math.sqrt(k));
    for (var j = 0; j < i && res[j] <= sqrt; j++)
      if (k % res[j] === 0)
        break;

    if (i !== j && res[j] <= sqrt)
      continue;

    res[i++] = k;
  }
  primes = res;
  return res;
}

function simpleSieve(p) {
  var primes = _getPrimes();

  for (var i = 0; i < primes.length; i++)
    if (p.modn(primes[i]) === 0) {
      if (p.cmpn(primes[i]) === 0) {
        return true;
      } else {
        return false;
      }
    }

  return true;
}

function fermatTest(p) {
  var red = BN.mont(p);
  return TWO.toRed(red).redPow(p.subn(1)).fromRed().cmpn(1) === 0;
}

function findPrime(bits, gen) {
  if (bits < 16) {
    // this is what openssl does
    if (gen === 2 || gen === 5) {
      return new BN([0x8c, 0x7b]);
    } else {
      return new BN([0x8c, 0x27]);
    }
  }
  gen = new BN(gen);

  var num, n2;

  while (true) {
    num = new BN(randomBytes(Math.ceil(bits / 8)));
    while (num.bitLength() > bits) {
      num.ishrn(1);
    }
    if (num.isEven()) {
      num.iadd(ONE);
    }
    if (!num.testn(1)) {
      num.iadd(TWO);
    }
    if (!gen.cmp(TWO)) {
      while (num.mod(TWENTYFOUR).cmp(ELEVEN)) {
        num.iadd(FOUR);
      }
    } else if (!gen.cmp(FIVE)) {
      while (num.mod(TEN).cmp(THREE)) {
        num.iadd(FOUR);
      }
    }
    n2 = num.shrn(1);
    if (simpleSieve(n2) && simpleSieve(num) &&
      fermatTest(n2) && fermatTest(num) &&
      millerRabin.test(n2) && millerRabin.test(num)) {
      return num;
    }
  }

}

},{"bn.js":91,"miller-rabin":143,"randombytes":167}],90:[function(require,module,exports){
module.exports={
    "modp1": {
        "gen": "02",
        "prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a63a3620ffffffffffffffff"
    },
    "modp2": {
        "gen": "02",
        "prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece65381ffffffffffffffff"
    },
    "modp5": {
        "gen": "02",
        "prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca237327ffffffffffffffff"
    },
    "modp14": {
        "gen": "02",
        "prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aacaa68ffffffffffffffff"
    },
    "modp15": {
        "gen": "02",
        "prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a93ad2caffffffffffffffff"
    },
    "modp16": {
        "gen": "02",
        "prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c934063199ffffffffffffffff"
    },
    "modp17": {
        "gen": "02",
        "prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dcc4024ffffffffffffffff"
    },
    "modp18": {
        "gen": "02",
        "prime": "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dbe115974a3926f12fee5e438777cb6a932df8cd8bec4d073b931ba3bc832b68d9dd300741fa7bf8afc47ed2576f6936ba424663aab639c5ae4f5683423b4742bf1c978238f16cbe39d652de3fdb8befc848ad922222e04a4037c0713eb57a81a23f0c73473fc646cea306b4bcbc8862f8385ddfa9d4b7fa2c087e879683303ed5bdd3a062b3cf5b3a278a66d2a13f83f44f82ddf310ee074ab6a364597e899a0255dc164f31cc50846851df9ab48195ded7ea1b1d510bd7ee74d73faf36bc31ecfa268359046f4eb879f924009438b481c6cd7889a002ed5ee382bc9190da6fc026e479558e4475677e9aa9e3050e2765694dfc81f56e880b96e7160c980dd98edd3dfffffffffffffffff"
    }
}
},{}],91:[function(require,module,exports){
arguments[4][23][0].apply(exports,arguments)
},{"buffer":27,"dup":23}],92:[function(require,module,exports){
'use strict';

var elliptic = exports;

elliptic.version = require('../package.json').version;
elliptic.utils = require('./elliptic/utils');
elliptic.rand = require('brorand');
elliptic.curve = require('./elliptic/curve');
elliptic.curves = require('./elliptic/curves');

// Protocols
elliptic.ec = require('./elliptic/ec');
elliptic.eddsa = require('./elliptic/eddsa');

},{"../package.json":108,"./elliptic/curve":95,"./elliptic/curves":98,"./elliptic/ec":99,"./elliptic/eddsa":102,"./elliptic/utils":106,"brorand":26}],93:[function(require,module,exports){
'use strict';

var BN = require('bn.js');
var utils = require('../utils');
var getNAF = utils.getNAF;
var getJSF = utils.getJSF;
var assert = utils.assert;

function BaseCurve(type, conf) {
  this.type = type;
  this.p = new BN(conf.p, 16);

  // Use Montgomery, when there is no fast reduction for the prime
  this.red = conf.prime ? BN.red(conf.prime) : BN.mont(this.p);

  // Useful for many curves
  this.zero = new BN(0).toRed(this.red);
  this.one = new BN(1).toRed(this.red);
  this.two = new BN(2).toRed(this.red);

  // Curve configuration, optional
  this.n = conf.n && new BN(conf.n, 16);
  this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed);

  // Temporary arrays
  this._wnafT1 = new Array(4);
  this._wnafT2 = new Array(4);
  this._wnafT3 = new Array(4);
  this._wnafT4 = new Array(4);

  this._bitLength = this.n ? this.n.bitLength() : 0;

  // Generalized Greg Maxwell's trick
  var adjustCount = this.n && this.p.div(this.n);
  if (!adjustCount || adjustCount.cmpn(100) > 0) {
    this.redN = null;
  } else {
    this._maxwellTrick = true;
    this.redN = this.n.toRed(this.red);
  }
}
module.exports = BaseCurve;

BaseCurve.prototype.point = function point() {
  throw new Error('Not implemented');
};

BaseCurve.prototype.validate = function validate() {
  throw new Error('Not implemented');
};

BaseCurve.prototype._fixedNafMul = function _fixedNafMul(p, k) {
  assert(p.precomputed);
  var doubles = p._getDoubles();

  var naf = getNAF(k, 1, this._bitLength);
  var I = (1 << (doubles.step + 1)) - (doubles.step % 2 === 0 ? 2 : 1);
  I /= 3;

  // Translate into more windowed form
  var repr = [];
  var j;
  var nafW;
  for (j = 0; j < naf.length; j += doubles.step) {
    nafW = 0;
    for (var l = j + doubles.step - 1; l >= j; l--)
      nafW = (nafW << 1) + naf[l];
    repr.push(nafW);
  }

  var a = this.jpoint(null, null, null);
  var b = this.jpoint(null, null, null);
  for (var i = I; i > 0; i--) {
    for (j = 0; j < repr.length; j++) {
      nafW = repr[j];
      if (nafW === i)
        b = b.mixedAdd(doubles.points[j]);
      else if (nafW === -i)
        b = b.mixedAdd(doubles.points[j].neg());
    }
    a = a.add(b);
  }
  return a.toP();
};

BaseCurve.prototype._wnafMul = function _wnafMul(p, k) {
  var w = 4;

  // Precompute window
  var nafPoints = p._getNAFPoints(w);
  w = nafPoints.wnd;
  var wnd = nafPoints.points;

  // Get NAF form
  var naf = getNAF(k, w, this._bitLength);

  // Add `this`*(N+1) for every w-NAF index
  var acc = this.jpoint(null, null, null);
  for (var i = naf.length - 1; i >= 0; i--) {
    // Count zeroes
    for (var l = 0; i >= 0 && naf[i] === 0; i--)
      l++;
    if (i >= 0)
      l++;
    acc = acc.dblp(l);

    if (i < 0)
      break;
    var z = naf[i];
    assert(z !== 0);
    if (p.type === 'affine') {
      // J +- P
      if (z > 0)
        acc = acc.mixedAdd(wnd[(z - 1) >> 1]);
      else
        acc = acc.mixedAdd(wnd[(-z - 1) >> 1].neg());
    } else {
      // J +- J
      if (z > 0)
        acc = acc.add(wnd[(z - 1) >> 1]);
      else
        acc = acc.add(wnd[(-z - 1) >> 1].neg());
    }
  }
  return p.type === 'affine' ? acc.toP() : acc;
};

BaseCurve.prototype._wnafMulAdd = function _wnafMulAdd(defW,
  points,
  coeffs,
  len,
  jacobianResult) {
  var wndWidth = this._wnafT1;
  var wnd = this._wnafT2;
  var naf = this._wnafT3;

  // Fill all arrays
  var max = 0;
  var i;
  var j;
  var p;
  for (i = 0; i < len; i++) {
    p = points[i];
    var nafPoints = p._getNAFPoints(defW);
    wndWidth[i] = nafPoints.wnd;
    wnd[i] = nafPoints.points;
  }

  // Comb small window NAFs
  for (i = len - 1; i >= 1; i -= 2) {
    var a = i - 1;
    var b = i;
    if (wndWidth[a] !== 1 || wndWidth[b] !== 1) {
      naf[a] = getNAF(coeffs[a], wndWidth[a], this._bitLength);
      naf[b] = getNAF(coeffs[b], wndWidth[b], this._bitLength);
      max = Math.max(naf[a].length, max);
      max = Math.max(naf[b].length, max);
      continue;
    }

    var comb = [
      points[a], /* 1 */
      null, /* 3 */
      null, /* 5 */
      points[b], /* 7 */
    ];

    // Try to avoid Projective points, if possible
    if (points[a].y.cmp(points[b].y) === 0) {
      comb[1] = points[a].add(points[b]);
      comb[2] = points[a].toJ().mixedAdd(points[b].neg());
    } else if (points[a].y.cmp(points[b].y.redNeg()) === 0) {
      comb[1] = points[a].toJ().mixedAdd(points[b]);
      comb[2] = points[a].add(points[b].neg());
    } else {
      comb[1] = points[a].toJ().mixedAdd(points[b]);
      comb[2] = points[a].toJ().mixedAdd(points[b].neg());
    }

    var index = [
      -3, /* -1 -1 */
      -1, /* -1 0 */
      -5, /* -1 1 */
      -7, /* 0 -1 */
      0, /* 0 0 */
      7, /* 0 1 */
      5, /* 1 -1 */
      1, /* 1 0 */
      3,  /* 1 1 */
    ];

    var jsf = getJSF(coeffs[a], coeffs[b]);
    max = Math.max(jsf[0].length, max);
    naf[a] = new Array(max);
    naf[b] = new Array(max);
    for (j = 0; j < max; j++) {
      var ja = jsf[0][j] | 0;
      var jb = jsf[1][j] | 0;

      naf[a][j] = index[(ja + 1) * 3 + (jb + 1)];
      naf[b][j] = 0;
      wnd[a] = comb;
    }
  }

  var acc = this.jpoint(null, null, null);
  var tmp = this._wnafT4;
  for (i = max; i >= 0; i--) {
    var k = 0;

    while (i >= 0) {
      var zero = true;
      for (j = 0; j < len; j++) {
        tmp[j] = naf[j][i] | 0;
        if (tmp[j] !== 0)
          zero = false;
      }
      if (!zero)
        break;
      k++;
      i--;
    }
    if (i >= 0)
      k++;
    acc = acc.dblp(k);
    if (i < 0)
      break;

    for (j = 0; j < len; j++) {
      var z = tmp[j];
      p;
      if (z === 0)
        continue;
      else if (z > 0)
        p = wnd[j][(z - 1) >> 1];
      else if (z < 0)
        p = wnd[j][(-z - 1) >> 1].neg();

      if (p.type === 'affine')
        acc = acc.mixedAdd(p);
      else
        acc = acc.add(p);
    }
  }
  // Zeroify references
  for (i = 0; i < len; i++)
    wnd[i] = null;

  if (jacobianResult)
    return acc;
  else
    return acc.toP();
};

function BasePoint(curve, type) {
  this.curve = curve;
  this.type = type;
  this.precomputed = null;
}
BaseCurve.BasePoint = BasePoint;

BasePoint.prototype.eq = function eq(/*other*/) {
  throw new Error('Not implemented');
};

BasePoint.prototype.validate = function validate() {
  return this.curve.validate(this);
};

BaseCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
  bytes = utils.toArray(bytes, enc);

  var len = this.p.byteLength();

  // uncompressed, hybrid-odd, hybrid-even
  if ((bytes[0] === 0x04 || bytes[0] === 0x06 || bytes[0] === 0x07) &&
      bytes.length - 1 === 2 * len) {
    if (bytes[0] === 0x06)
      assert(bytes[bytes.length - 1] % 2 === 0);
    else if (bytes[0] === 0x07)
      assert(bytes[bytes.length - 1] % 2 === 1);

    var res =  this.point(bytes.slice(1, 1 + len),
      bytes.slice(1 + len, 1 + 2 * len));

    return res;
  } else if ((bytes[0] === 0x02 || bytes[0] === 0x03) &&
              bytes.length - 1 === len) {
    return this.pointFromX(bytes.slice(1, 1 + len), bytes[0] === 0x03);
  }
  throw new Error('Unknown point format');
};

BasePoint.prototype.encodeCompressed = function encodeCompressed(enc) {
  return this.encode(enc, true);
};

BasePoint.prototype._encode = function _encode(compact) {
  var len = this.curve.p.byteLength();
  var x = this.getX().toArray('be', len);

  if (compact)
    return [ this.getY().isEven() ? 0x02 : 0x03 ].concat(x);

  return [ 0x04 ].concat(x, this.getY().toArray('be', len));
};

BasePoint.prototype.encode = function encode(enc, compact) {
  return utils.encode(this._encode(compact), enc);
};

BasePoint.prototype.precompute = function precompute(power) {
  if (this.precomputed)
    return this;

  var precomputed = {
    doubles: null,
    naf: null,
    beta: null,
  };
  precomputed.naf = this._getNAFPoints(8);
  precomputed.doubles = this._getDoubles(4, power);
  precomputed.beta = this._getBeta();
  this.precomputed = precomputed;

  return this;
};

BasePoint.prototype._hasDoubles = function _hasDoubles(k) {
  if (!this.precomputed)
    return false;

  var doubles = this.precomputed.doubles;
  if (!doubles)
    return false;

  return doubles.points.length >= Math.ceil((k.bitLength() + 1) / doubles.step);
};

BasePoint.prototype._getDoubles = function _getDoubles(step, power) {
  if (this.precomputed && this.precomputed.doubles)
    return this.precomputed.doubles;

  var doubles = [ this ];
  var acc = this;
  for (var i = 0; i < power; i += step) {
    for (var j = 0; j < step; j++)
      acc = acc.dbl();
    doubles.push(acc);
  }
  return {
    step: step,
    points: doubles,
  };
};

BasePoint.prototype._getNAFPoints = function _getNAFPoints(wnd) {
  if (this.precomputed && this.precomputed.naf)
    return this.precomputed.naf;

  var res = [ this ];
  var max = (1 << wnd) - 1;
  var dbl = max === 1 ? null : this.dbl();
  for (var i = 1; i < max; i++)
    res[i] = res[i - 1].add(dbl);
  return {
    wnd: wnd,
    points: res,
  };
};

BasePoint.prototype._getBeta = function _getBeta() {
  return null;
};

BasePoint.prototype.dblp = function dblp(k) {
  var r = this;
  for (var i = 0; i < k; i++)
    r = r.dbl();
  return r;
};

},{"../utils":106,"bn.js":107}],94:[function(require,module,exports){
'use strict';

var utils = require('../utils');
var BN = require('bn.js');
var inherits = require('inherits');
var Base = require('./base');

var assert = utils.assert;

function EdwardsCurve(conf) {
  // NOTE: Important as we are creating point in Base.call()
  this.twisted = (conf.a | 0) !== 1;
  this.mOneA = this.twisted && (conf.a | 0) === -1;
  this.extended = this.mOneA;

  Base.call(this, 'edwards', conf);

  this.a = new BN(conf.a, 16).umod(this.red.m);
  this.a = this.a.toRed(this.red);
  this.c = new BN(conf.c, 16).toRed(this.red);
  this.c2 = this.c.redSqr();
  this.d = new BN(conf.d, 16).toRed(this.red);
  this.dd = this.d.redAdd(this.d);

  assert(!this.twisted || this.c.fromRed().cmpn(1) === 0);
  this.oneC = (conf.c | 0) === 1;
}
inherits(EdwardsCurve, Base);
module.exports = EdwardsCurve;

EdwardsCurve.prototype._mulA = function _mulA(num) {
  if (this.mOneA)
    return num.redNeg();
  else
    return this.a.redMul(num);
};

EdwardsCurve.prototype._mulC = function _mulC(num) {
  if (this.oneC)
    return num;
  else
    return this.c.redMul(num);
};

// Just for compatibility with Short curve
EdwardsCurve.prototype.jpoint = function jpoint(x, y, z, t) {
  return this.point(x, y, z, t);
};

EdwardsCurve.prototype.pointFromX = function pointFromX(x, odd) {
  x = new BN(x, 16);
  if (!x.red)
    x = x.toRed(this.red);

  var x2 = x.redSqr();
  var rhs = this.c2.redSub(this.a.redMul(x2));
  var lhs = this.one.redSub(this.c2.redMul(this.d).redMul(x2));

  var y2 = rhs.redMul(lhs.redInvm());
  var y = y2.redSqrt();
  if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)
    throw new Error('invalid point');

  var isOdd = y.fromRed().isOdd();
  if (odd && !isOdd || !odd && isOdd)
    y = y.redNeg();

  return this.point(x, y);
};

EdwardsCurve.prototype.pointFromY = function pointFromY(y, odd) {
  y = new BN(y, 16);
  if (!y.red)
    y = y.toRed(this.red);

  // x^2 = (y^2 - c^2) / (c^2 d y^2 - a)
  var y2 = y.redSqr();
  var lhs = y2.redSub(this.c2);
  var rhs = y2.redMul(this.d).redMul(this.c2).redSub(this.a);
  var x2 = lhs.redMul(rhs.redInvm());

  if (x2.cmp(this.zero) === 0) {
    if (odd)
      throw new Error('invalid point');
    else
      return this.point(this.zero, y);
  }

  var x = x2.redSqrt();
  if (x.redSqr().redSub(x2).cmp(this.zero) !== 0)
    throw new Error('invalid point');

  if (x.fromRed().isOdd() !== odd)
    x = x.redNeg();

  return this.point(x, y);
};

EdwardsCurve.prototype.validate = function validate(point) {
  if (point.isInfinity())
    return true;

  // Curve: A * X^2 + Y^2 = C^2 * (1 + D * X^2 * Y^2)
  point.normalize();

  var x2 = point.x.redSqr();
  var y2 = point.y.redSqr();
  var lhs = x2.redMul(this.a).redAdd(y2);
  var rhs = this.c2.redMul(this.one.redAdd(this.d.redMul(x2).redMul(y2)));

  return lhs.cmp(rhs) === 0;
};

function Point(curve, x, y, z, t) {
  Base.BasePoint.call(this, curve, 'projective');
  if (x === null && y === null && z === null) {
    this.x = this.curve.zero;
    this.y = this.curve.one;
    this.z = this.curve.one;
    this.t = this.curve.zero;
    this.zOne = true;
  } else {
    this.x = new BN(x, 16);
    this.y = new BN(y, 16);
    this.z = z ? new BN(z, 16) : this.curve.one;
    this.t = t && new BN(t, 16);
    if (!this.x.red)
      this.x = this.x.toRed(this.curve.red);
    if (!this.y.red)
      this.y = this.y.toRed(this.curve.red);
    if (!this.z.red)
      this.z = this.z.toRed(this.curve.red);
    if (this.t && !this.t.red)
      this.t = this.t.toRed(this.curve.red);
    this.zOne = this.z === this.curve.one;

    // Use extended coordinates
    if (this.curve.extended && !this.t) {
      this.t = this.x.redMul(this.y);
      if (!this.zOne)
        this.t = this.t.redMul(this.z.redInvm());
    }
  }
}
inherits(Point, Base.BasePoint);

EdwardsCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
  return Point.fromJSON(this, obj);
};

EdwardsCurve.prototype.point = function point(x, y, z, t) {
  return new Point(this, x, y, z, t);
};

Point.fromJSON = function fromJSON(curve, obj) {
  return new Point(curve, obj[0], obj[1], obj[2]);
};

Point.prototype.inspect = function inspect() {
  if (this.isInfinity())
    return '<EC Point Infinity>';
  return '<EC Point x: ' + this.x.fromRed().toString(16, 2) +
      ' y: ' + this.y.fromRed().toString(16, 2) +
      ' z: ' + this.z.fromRed().toString(16, 2) + '>';
};

Point.prototype.isInfinity = function isInfinity() {
  // XXX This code assumes that zero is always zero in red
  return this.x.cmpn(0) === 0 &&
    (this.y.cmp(this.z) === 0 ||
    (this.zOne && this.y.cmp(this.curve.c) === 0));
};

Point.prototype._extDbl = function _extDbl() {
  // hyperelliptic.org/EFD/g1p/auto-twisted-extended-1.html
  //     #doubling-dbl-2008-hwcd
  // 4M + 4S

  // A = X1^2
  var a = this.x.redSqr();
  // B = Y1^2
  var b = this.y.redSqr();
  // C = 2 * Z1^2
  var c = this.z.redSqr();
  c = c.redIAdd(c);
  // D = a * A
  var d = this.curve._mulA(a);
  // E = (X1 + Y1)^2 - A - B
  var e = this.x.redAdd(this.y).redSqr().redISub(a).redISub(b);
  // G = D + B
  var g = d.redAdd(b);
  // F = G - C
  var f = g.redSub(c);
  // H = D - B
  var h = d.redSub(b);
  // X3 = E * F
  var nx = e.redMul(f);
  // Y3 = G * H
  var ny = g.redMul(h);
  // T3 = E * H
  var nt = e.redMul(h);
  // Z3 = F * G
  var nz = f.redMul(g);
  return this.curve.point(nx, ny, nz, nt);
};

Point.prototype._projDbl = function _projDbl() {
  // hyperelliptic.org/EFD/g1p/auto-twisted-projective.html
  //     #doubling-dbl-2008-bbjlp
  //     #doubling-dbl-2007-bl
  // and others
  // Generally 3M + 4S or 2M + 4S

  // B = (X1 + Y1)^2
  var b = this.x.redAdd(this.y).redSqr();
  // C = X1^2
  var c = this.x.redSqr();
  // D = Y1^2
  var d = this.y.redSqr();

  var nx;
  var ny;
  var nz;
  var e;
  var h;
  var j;
  if (this.curve.twisted) {
    // E = a * C
    e = this.curve._mulA(c);
    // F = E + D
    var f = e.redAdd(d);
    if (this.zOne) {
      // X3 = (B - C - D) * (F - 2)
      nx = b.redSub(c).redSub(d).redMul(f.redSub(this.curve.two));
      // Y3 = F * (E - D)
      ny = f.redMul(e.redSub(d));
      // Z3 = F^2 - 2 * F
      nz = f.redSqr().redSub(f).redSub(f);
    } else {
      // H = Z1^2
      h = this.z.redSqr();
      // J = F - 2 * H
      j = f.redSub(h).redISub(h);
      // X3 = (B-C-D)*J
      nx = b.redSub(c).redISub(d).redMul(j);
      // Y3 = F * (E - D)
      ny = f.redMul(e.redSub(d));
      // Z3 = F * J
      nz = f.redMul(j);
    }
  } else {
    // E = C + D
    e = c.redAdd(d);
    // H = (c * Z1)^2
    h = this.curve._mulC(this.z).redSqr();
    // J = E - 2 * H
    j = e.redSub(h).redSub(h);
    // X3 = c * (B - E) * J
    nx = this.curve._mulC(b.redISub(e)).redMul(j);
    // Y3 = c * E * (C - D)
    ny = this.curve._mulC(e).redMul(c.redISub(d));
    // Z3 = E * J
    nz = e.redMul(j);
  }
  return this.curve.point(nx, ny, nz);
};

Point.prototype.dbl = function dbl() {
  if (this.isInfinity())
    return this;

  // Double in extended coordinates
  if (this.curve.extended)
    return this._extDbl();
  else
    return this._projDbl();
};

Point.prototype._extAdd = function _extAdd(p) {
  // hyperelliptic.org/EFD/g1p/auto-twisted-extended-1.html
  //     #addition-add-2008-hwcd-3
  // 8M

  // A = (Y1 - X1) * (Y2 - X2)
  var a = this.y.redSub(this.x).redMul(p.y.redSub(p.x));
  // B = (Y1 + X1) * (Y2 + X2)
  var b = this.y.redAdd(this.x).redMul(p.y.redAdd(p.x));
  // C = T1 * k * T2
  var c = this.t.redMul(this.curve.dd).redMul(p.t);
  // D = Z1 * 2 * Z2
  var d = this.z.redMul(p.z.redAdd(p.z));
  // E = B - A
  var e = b.redSub(a);
  // F = D - C
  var f = d.redSub(c);
  // G = D + C
  var g = d.redAdd(c);
  // H = B + A
  var h = b.redAdd(a);
  // X3 = E * F
  var nx = e.redMul(f);
  // Y3 = G * H
  var ny = g.redMul(h);
  // T3 = E * H
  var nt = e.redMul(h);
  // Z3 = F * G
  var nz = f.redMul(g);
  return this.curve.point(nx, ny, nz, nt);
};

Point.prototype._projAdd = function _projAdd(p) {
  // hyperelliptic.org/EFD/g1p/auto-twisted-projective.html
  //     #addition-add-2008-bbjlp
  //     #addition-add-2007-bl
  // 10M + 1S

  // A = Z1 * Z2
  var a = this.z.redMul(p.z);
  // B = A^2
  var b = a.redSqr();
  // C = X1 * X2
  var c = this.x.redMul(p.x);
  // D = Y1 * Y2
  var d = this.y.redMul(p.y);
  // E = d * C * D
  var e = this.curve.d.redMul(c).redMul(d);
  // F = B - E
  var f = b.redSub(e);
  // G = B + E
  var g = b.redAdd(e);
  // X3 = A * F * ((X1 + Y1) * (X2 + Y2) - C - D)
  var tmp = this.x.redAdd(this.y).redMul(p.x.redAdd(p.y)).redISub(c).redISub(d);
  var nx = a.redMul(f).redMul(tmp);
  var ny;
  var nz;
  if (this.curve.twisted) {
    // Y3 = A * G * (D - a * C)
    ny = a.redMul(g).redMul(d.redSub(this.curve._mulA(c)));
    // Z3 = F * G
    nz = f.redMul(g);
  } else {
    // Y3 = A * G * (D - C)
    ny = a.redMul(g).redMul(d.redSub(c));
    // Z3 = c * F * G
    nz = this.curve._mulC(f).redMul(g);
  }
  return this.curve.point(nx, ny, nz);
};

Point.prototype.add = function add(p) {
  if (this.isInfinity())
    return p;
  if (p.isInfinity())
    return this;

  if (this.curve.extended)
    return this._extAdd(p);
  else
    return this._projAdd(p);
};

Point.prototype.mul = function mul(k) {
  if (this._hasDoubles(k))
    return this.curve._fixedNafMul(this, k);
  else
    return this.curve._wnafMul(this, k);
};

Point.prototype.mulAdd = function mulAdd(k1, p, k2) {
  return this.curve._wnafMulAdd(1, [ this, p ], [ k1, k2 ], 2, false);
};

Point.prototype.jmulAdd = function jmulAdd(k1, p, k2) {
  return this.curve._wnafMulAdd(1, [ this, p ], [ k1, k2 ], 2, true);
};

Point.prototype.normalize = function normalize() {
  if (this.zOne)
    return this;

  // Normalize coordinates
  var zi = this.z.redInvm();
  this.x = this.x.redMul(zi);
  this.y = this.y.redMul(zi);
  if (this.t)
    this.t = this.t.redMul(zi);
  this.z = this.curve.one;
  this.zOne = true;
  return this;
};

Point.prototype.neg = function neg() {
  return this.curve.point(this.x.redNeg(),
    this.y,
    this.z,
    this.t && this.t.redNeg());
};

Point.prototype.getX = function getX() {
  this.normalize();
  return this.x.fromRed();
};

Point.prototype.getY = function getY() {
  this.normalize();
  return this.y.fromRed();
};

Point.prototype.eq = function eq(other) {
  return this === other ||
         this.getX().cmp(other.getX()) === 0 &&
         this.getY().cmp(other.getY()) === 0;
};

Point.prototype.eqXToP = function eqXToP(x) {
  var rx = x.toRed(this.curve.red).redMul(this.z);
  if (this.x.cmp(rx) === 0)
    return true;

  var xc = x.clone();
  var t = this.curve.redN.redMul(this.z);
  for (;;) {
    xc.iadd(this.curve.n);
    if (xc.cmp(this.curve.p) >= 0)
      return false;

    rx.redIAdd(t);
    if (this.x.cmp(rx) === 0)
      return true;
  }
};

// Compatibility with BaseCurve
Point.prototype.toP = Point.prototype.normalize;
Point.prototype.mixedAdd = Point.prototype.add;

},{"../utils":106,"./base":93,"bn.js":107,"inherits":141}],95:[function(require,module,exports){
'use strict';

var curve = exports;

curve.base = require('./base');
curve.short = require('./short');
curve.mont = require('./mont');
curve.edwards = require('./edwards');

},{"./base":93,"./edwards":94,"./mont":96,"./short":97}],96:[function(require,module,exports){
'use strict';

var BN = require('bn.js');
var inherits = require('inherits');
var Base = require('./base');

var utils = require('../utils');

function MontCurve(conf) {
  Base.call(this, 'mont', conf);

  this.a = new BN(conf.a, 16).toRed(this.red);
  this.b = new BN(conf.b, 16).toRed(this.red);
  this.i4 = new BN(4).toRed(this.red).redInvm();
  this.two = new BN(2).toRed(this.red);
  this.a24 = this.i4.redMul(this.a.redAdd(this.two));
}
inherits(MontCurve, Base);
module.exports = MontCurve;

MontCurve.prototype.validate = function validate(point) {
  var x = point.normalize().x;
  var x2 = x.redSqr();
  var rhs = x2.redMul(x).redAdd(x2.redMul(this.a)).redAdd(x);
  var y = rhs.redSqrt();

  return y.redSqr().cmp(rhs) === 0;
};

function Point(curve, x, z) {
  Base.BasePoint.call(this, curve, 'projective');
  if (x === null && z === null) {
    this.x = this.curve.one;
    this.z = this.curve.zero;
  } else {
    this.x = new BN(x, 16);
    this.z = new BN(z, 16);
    if (!this.x.red)
      this.x = this.x.toRed(this.curve.red);
    if (!this.z.red)
      this.z = this.z.toRed(this.curve.red);
  }
}
inherits(Point, Base.BasePoint);

MontCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
  return this.point(utils.toArray(bytes, enc), 1);
};

MontCurve.prototype.point = function point(x, z) {
  return new Point(this, x, z);
};

MontCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
  return Point.fromJSON(this, obj);
};

Point.prototype.precompute = function precompute() {
  // No-op
};

Point.prototype._encode = function _encode() {
  return this.getX().toArray('be', this.curve.p.byteLength());
};

Point.fromJSON = function fromJSON(curve, obj) {
  return new Point(curve, obj[0], obj[1] || curve.one);
};

Point.prototype.inspect = function inspect() {
  if (this.isInfinity())
    return '<EC Point Infinity>';
  return '<EC Point x: ' + this.x.fromRed().toString(16, 2) +
      ' z: ' + this.z.fromRed().toString(16, 2) + '>';
};

Point.prototype.isInfinity = function isInfinity() {
  // XXX This code assumes that zero is always zero in red
  return this.z.cmpn(0) === 0;
};

Point.prototype.dbl = function dbl() {
  // http://hyperelliptic.org/EFD/g1p/auto-montgom-xz.html#doubling-dbl-1987-m-3
  // 2M + 2S + 4A

  // A = X1 + Z1
  var a = this.x.redAdd(this.z);
  // AA = A^2
  var aa = a.redSqr();
  // B = X1 - Z1
  var b = this.x.redSub(this.z);
  // BB = B^2
  var bb = b.redSqr();
  // C = AA - BB
  var c = aa.redSub(bb);
  // X3 = AA * BB
  var nx = aa.redMul(bb);
  // Z3 = C * (BB + A24 * C)
  var nz = c.redMul(bb.redAdd(this.curve.a24.redMul(c)));
  return this.curve.point(nx, nz);
};

Point.prototype.add = function add() {
  throw new Error('Not supported on Montgomery curve');
};

Point.prototype.diffAdd = function diffAdd(p, diff) {
  // http://hyperelliptic.org/EFD/g1p/auto-montgom-xz.html#diffadd-dadd-1987-m-3
  // 4M + 2S + 6A

  // A = X2 + Z2
  var a = this.x.redAdd(this.z);
  // B = X2 - Z2
  var b = this.x.redSub(this.z);
  // C = X3 + Z3
  var c = p.x.redAdd(p.z);
  // D = X3 - Z3
  var d = p.x.redSub(p.z);
  // DA = D * A
  var da = d.redMul(a);
  // CB = C * B
  var cb = c.redMul(b);
  // X5 = Z1 * (DA + CB)^2
  var nx = diff.z.redMul(da.redAdd(cb).redSqr());
  // Z5 = X1 * (DA - CB)^2
  var nz = diff.x.redMul(da.redISub(cb).redSqr());
  return this.curve.point(nx, nz);
};

Point.prototype.mul = function mul(k) {
  var t = k.clone();
  var a = this; // (N / 2) * Q + Q
  var b = this.curve.point(null, null); // (N / 2) * Q
  var c = this; // Q

  for (var bits = []; t.cmpn(0) !== 0; t.iushrn(1))
    bits.push(t.andln(1));

  for (var i = bits.length - 1; i >= 0; i--) {
    if (bits[i] === 0) {
      // N * Q + Q = ((N / 2) * Q + Q)) + (N / 2) * Q
      a = a.diffAdd(b, c);
      // N * Q = 2 * ((N / 2) * Q + Q))
      b = b.dbl();
    } else {
      // N * Q = ((N / 2) * Q + Q) + ((N / 2) * Q)
      b = a.diffAdd(b, c);
      // N * Q + Q = 2 * ((N / 2) * Q + Q)
      a = a.dbl();
    }
  }
  return b;
};

Point.prototype.mulAdd = function mulAdd() {
  throw new Error('Not supported on Montgomery curve');
};

Point.prototype.jumlAdd = function jumlAdd() {
  throw new Error('Not supported on Montgomery curve');
};

Point.prototype.eq = function eq(other) {
  return this.getX().cmp(other.getX()) === 0;
};

Point.prototype.normalize = function normalize() {
  this.x = this.x.redMul(this.z.redInvm());
  this.z = this.curve.one;
  return this;
};

Point.prototype.getX = function getX() {
  // Normalize coordinates
  this.normalize();

  return this.x.fromRed();
};

},{"../utils":106,"./base":93,"bn.js":107,"inherits":141}],97:[function(require,module,exports){
'use strict';

var utils = require('../utils');
var BN = require('bn.js');
var inherits = require('inherits');
var Base = require('./base');

var assert = utils.assert;

function ShortCurve(conf) {
  Base.call(this, 'short', conf);

  this.a = new BN(conf.a, 16).toRed(this.red);
  this.b = new BN(conf.b, 16).toRed(this.red);
  this.tinv = this.two.redInvm();

  this.zeroA = this.a.fromRed().cmpn(0) === 0;
  this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0;

  // If the curve is endomorphic, precalculate beta and lambda
  this.endo = this._getEndomorphism(conf);
  this._endoWnafT1 = new Array(4);
  this._endoWnafT2 = new Array(4);
}
inherits(ShortCurve, Base);
module.exports = ShortCurve;

ShortCurve.prototype._getEndomorphism = function _getEndomorphism(conf) {
  // No efficient endomorphism
  if (!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)
    return;

  // Compute beta and lambda, that lambda * P = (beta * Px; Py)
  var beta;
  var lambda;
  if (conf.beta) {
    beta = new BN(conf.beta, 16).toRed(this.red);
  } else {
    var betas = this._getEndoRoots(this.p);
    // Choose the smallest beta
    beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1];
    beta = beta.toRed(this.red);
  }
  if (conf.lambda) {
    lambda = new BN(conf.lambda, 16);
  } else {
    // Choose the lambda that is matching selected beta
    var lambdas = this._getEndoRoots(this.n);
    if (this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) === 0) {
      lambda = lambdas[0];
    } else {
      lambda = lambdas[1];
      assert(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta)) === 0);
    }
  }

  // Get basis vectors, used for balanced length-two representation
  var basis;
  if (conf.basis) {
    basis = conf.basis.map(function(vec) {
      return {
        a: new BN(vec.a, 16),
        b: new BN(vec.b, 16),
      };
    });
  } else {
    basis = this._getEndoBasis(lambda);
  }

  return {
    beta: beta,
    lambda: lambda,
    basis: basis,
  };
};

ShortCurve.prototype._getEndoRoots = function _getEndoRoots(num) {
  // Find roots of for x^2 + x + 1 in F
  // Root = (-1 +- Sqrt(-3)) / 2
  //
  var red = num === this.p ? this.red : BN.mont(num);
  var tinv = new BN(2).toRed(red).redInvm();
  var ntinv = tinv.redNeg();

  var s = new BN(3).toRed(red).redNeg().redSqrt().redMul(tinv);

  var l1 = ntinv.redAdd(s).fromRed();
  var l2 = ntinv.redSub(s).fromRed();
  return [ l1, l2 ];
};

ShortCurve.prototype._getEndoBasis = function _getEndoBasis(lambda) {
  // aprxSqrt >= sqrt(this.n)
  var aprxSqrt = this.n.ushrn(Math.floor(this.n.bitLength() / 2));

  // 3.74
  // Run EGCD, until r(L + 1) < aprxSqrt
  var u = lambda;
  var v = this.n.clone();
  var x1 = new BN(1);
  var y1 = new BN(0);
  var x2 = new BN(0);
  var y2 = new BN(1);

  // NOTE: all vectors are roots of: a + b * lambda = 0 (mod n)
  var a0;
  var b0;
  // First vector
  var a1;
  var b1;
  // Second vector
  var a2;
  var b2;

  var prevR;
  var i = 0;
  var r;
  var x;
  while (u.cmpn(0) !== 0) {
    var q = v.div(u);
    r = v.sub(q.mul(u));
    x = x2.sub(q.mul(x1));
    var y = y2.sub(q.mul(y1));

    if (!a1 && r.cmp(aprxSqrt) < 0) {
      a0 = prevR.neg();
      b0 = x1;
      a1 = r.neg();
      b1 = x;
    } else if (a1 && ++i === 2) {
      break;
    }
    prevR = r;

    v = u;
    u = r;
    x2 = x1;
    x1 = x;
    y2 = y1;
    y1 = y;
  }
  a2 = r.neg();
  b2 = x;

  var len1 = a1.sqr().add(b1.sqr());
  var len2 = a2.sqr().add(b2.sqr());
  if (len2.cmp(len1) >= 0) {
    a2 = a0;
    b2 = b0;
  }

  // Normalize signs
  if (a1.negative) {
    a1 = a1.neg();
    b1 = b1.neg();
  }
  if (a2.negative) {
    a2 = a2.neg();
    b2 = b2.neg();
  }

  return [
    { a: a1, b: b1 },
    { a: a2, b: b2 },
  ];
};

ShortCurve.prototype._endoSplit = function _endoSplit(k) {
  var basis = this.endo.basis;
  var v1 = basis[0];
  var v2 = basis[1];

  var c1 = v2.b.mul(k).divRound(this.n);
  var c2 = v1.b.neg().mul(k).divRound(this.n);

  var p1 = c1.mul(v1.a);
  var p2 = c2.mul(v2.a);
  var q1 = c1.mul(v1.b);
  var q2 = c2.mul(v2.b);

  // Calculate answer
  var k1 = k.sub(p1).sub(p2);
  var k2 = q1.add(q2).neg();
  return { k1: k1, k2: k2 };
};

ShortCurve.prototype.pointFromX = function pointFromX(x, odd) {
  x = new BN(x, 16);
  if (!x.red)
    x = x.toRed(this.red);

  var y2 = x.redSqr().redMul(x).redIAdd(x.redMul(this.a)).redIAdd(this.b);
  var y = y2.redSqrt();
  if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)
    throw new Error('invalid point');

  // XXX Is there any way to tell if the number is odd without converting it
  // to non-red form?
  var isOdd = y.fromRed().isOdd();
  if (odd && !isOdd || !odd && isOdd)
    y = y.redNeg();

  return this.point(x, y);
};

ShortCurve.prototype.validate = function validate(point) {
  if (point.inf)
    return true;

  var x = point.x;
  var y = point.y;

  var ax = this.a.redMul(x);
  var rhs = x.redSqr().redMul(x).redIAdd(ax).redIAdd(this.b);
  return y.redSqr().redISub(rhs).cmpn(0) === 0;
};

ShortCurve.prototype._endoWnafMulAdd =
    function _endoWnafMulAdd(points, coeffs, jacobianResult) {
      var npoints = this._endoWnafT1;
      var ncoeffs = this._endoWnafT2;
      for (var i = 0; i < points.length; i++) {
        var split = this._endoSplit(coeffs[i]);
        var p = points[i];
        var beta = p._getBeta();

        if (split.k1.negative) {
          split.k1.ineg();
          p = p.neg(true);
        }
        if (split.k2.negative) {
          split.k2.ineg();
          beta = beta.neg(true);
        }

        npoints[i * 2] = p;
        npoints[i * 2 + 1] = beta;
        ncoeffs[i * 2] = split.k1;
        ncoeffs[i * 2 + 1] = split.k2;
      }
      var res = this._wnafMulAdd(1, npoints, ncoeffs, i * 2, jacobianResult);

      // Clean-up references to points and coefficients
      for (var j = 0; j < i * 2; j++) {
        npoints[j] = null;
        ncoeffs[j] = null;
      }
      return res;
    };

function Point(curve, x, y, isRed) {
  Base.BasePoint.call(this, curve, 'affine');
  if (x === null && y === null) {
    this.x = null;
    this.y = null;
    this.inf = true;
  } else {
    this.x = new BN(x, 16);
    this.y = new BN(y, 16);
    // Force redgomery representation when loading from JSON
    if (isRed) {
      this.x.forceRed(this.curve.red);
      this.y.forceRed(this.curve.red);
    }
    if (!this.x.red)
      this.x = this.x.toRed(this.curve.red);
    if (!this.y.red)
      this.y = this.y.toRed(this.curve.red);
    this.inf = false;
  }
}
inherits(Point, Base.BasePoint);

ShortCurve.prototype.point = function point(x, y, isRed) {
  return new Point(this, x, y, isRed);
};

ShortCurve.prototype.pointFromJSON = function pointFromJSON(obj, red) {
  return Point.fromJSON(this, obj, red);
};

Point.prototype._getBeta = function _getBeta() {
  if (!this.curve.endo)
    return;

  var pre = this.precomputed;
  if (pre && pre.beta)
    return pre.beta;

  var beta = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
  if (pre) {
    var curve = this.curve;
    var endoMul = function(p) {
      return curve.point(p.x.redMul(curve.endo.beta), p.y);
    };
    pre.beta = beta;
    beta.precomputed = {
      beta: null,
      naf: pre.naf && {
        wnd: pre.naf.wnd,
        points: pre.naf.points.map(endoMul),
      },
      doubles: pre.doubles && {
        step: pre.doubles.step,
        points: pre.doubles.points.map(endoMul),
      },
    };
  }
  return beta;
};

Point.prototype.toJSON = function toJSON() {
  if (!this.precomputed)
    return [ this.x, this.y ];

  return [ this.x, this.y, this.precomputed && {
    doubles: this.precomputed.doubles && {
      step: this.precomputed.doubles.step,
      points: this.precomputed.doubles.points.slice(1),
    },
    naf: this.precomputed.naf && {
      wnd: this.precomputed.naf.wnd,
      points: this.precomputed.naf.points.slice(1),
    },
  } ];
};

Point.fromJSON = function fromJSON(curve, obj, red) {
  if (typeof obj === 'string')
    obj = JSON.parse(obj);
  var res = curve.point(obj[0], obj[1], red);
  if (!obj[2])
    return res;

  function obj2point(obj) {
    return curve.point(obj[0], obj[1], red);
  }

  var pre = obj[2];
  res.precomputed = {
    beta: null,
    doubles: pre.doubles && {
      step: pre.doubles.step,
      points: [ res ].concat(pre.doubles.points.map(obj2point)),
    },
    naf: pre.naf && {
      wnd: pre.naf.wnd,
      points: [ res ].concat(pre.naf.points.map(obj2point)),
    },
  };
  return res;
};

Point.prototype.inspect = function inspect() {
  if (this.isInfinity())
    return '<EC Point Infinity>';
  return '<EC Point x: ' + this.x.fromRed().toString(16, 2) +
      ' y: ' + this.y.fromRed().toString(16, 2) + '>';
};

Point.prototype.isInfinity = function isInfinity() {
  return this.inf;
};

Point.prototype.add = function add(p) {
  // O + P = P
  if (this.inf)
    return p;

  // P + O = P
  if (p.inf)
    return this;

  // P + P = 2P
  if (this.eq(p))
    return this.dbl();

  // P + (-P) = O
  if (this.neg().eq(p))
    return this.curve.point(null, null);

  // P + Q = O
  if (this.x.cmp(p.x) === 0)
    return this.curve.point(null, null);

  var c = this.y.redSub(p.y);
  if (c.cmpn(0) !== 0)
    c = c.redMul(this.x.redSub(p.x).redInvm());
  var nx = c.redSqr().redISub(this.x).redISub(p.x);
  var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
  return this.curve.point(nx, ny);
};

Point.prototype.dbl = function dbl() {
  if (this.inf)
    return this;

  // 2P = O
  var ys1 = this.y.redAdd(this.y);
  if (ys1.cmpn(0) === 0)
    return this.curve.point(null, null);

  var a = this.curve.a;

  var x2 = this.x.redSqr();
  var dyinv = ys1.redInvm();
  var c = x2.redAdd(x2).redIAdd(x2).redIAdd(a).redMul(dyinv);

  var nx = c.redSqr().redISub(this.x.redAdd(this.x));
  var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
  return this.curve.point(nx, ny);
};

Point.prototype.getX = function getX() {
  return this.x.fromRed();
};

Point.prototype.getY = function getY() {
  return this.y.fromRed();
};

Point.prototype.mul = function mul(k) {
  k = new BN(k, 16);
  if (this.isInfinity())
    return this;
  else if (this._hasDoubles(k))
    return this.curve._fixedNafMul(this, k);
  else if (this.curve.endo)
    return this.curve._endoWnafMulAdd([ this ], [ k ]);
  else
    return this.curve._wnafMul(this, k);
};

Point.prototype.mulAdd = function mulAdd(k1, p2, k2) {
  var points = [ this, p2 ];
  var coeffs = [ k1, k2 ];
  if (this.curve.endo)
    return this.curve._endoWnafMulAdd(points, coeffs);
  else
    return this.curve._wnafMulAdd(1, points, coeffs, 2);
};

Point.prototype.jmulAdd = function jmulAdd(k1, p2, k2) {
  var points = [ this, p2 ];
  var coeffs = [ k1, k2 ];
  if (this.curve.endo)
    return this.curve._endoWnafMulAdd(points, coeffs, true);
  else
    return this.curve._wnafMulAdd(1, points, coeffs, 2, true);
};

Point.prototype.eq = function eq(p) {
  return this === p ||
         this.inf === p.inf &&
             (this.inf || this.x.cmp(p.x) === 0 && this.y.cmp(p.y) === 0);
};

Point.prototype.neg = function neg(_precompute) {
  if (this.inf)
    return this;

  var res = this.curve.point(this.x, this.y.redNeg());
  if (_precompute && this.precomputed) {
    var pre = this.precomputed;
    var negate = function(p) {
      return p.neg();
    };
    res.precomputed = {
      naf: pre.naf && {
        wnd: pre.naf.wnd,
        points: pre.naf.points.map(negate),
      },
      doubles: pre.doubles && {
        step: pre.doubles.step,
        points: pre.doubles.points.map(negate),
      },
    };
  }
  return res;
};

Point.prototype.toJ = function toJ() {
  if (this.inf)
    return this.curve.jpoint(null, null, null);

  var res = this.curve.jpoint(this.x, this.y, this.curve.one);
  return res;
};

function JPoint(curve, x, y, z) {
  Base.BasePoint.call(this, curve, 'jacobian');
  if (x === null && y === null && z === null) {
    this.x = this.curve.one;
    this.y = this.curve.one;
    this.z = new BN(0);
  } else {
    this.x = new BN(x, 16);
    this.y = new BN(y, 16);
    this.z = new BN(z, 16);
  }
  if (!this.x.red)
    this.x = this.x.toRed(this.curve.red);
  if (!this.y.red)
    this.y = this.y.toRed(this.curve.red);
  if (!this.z.red)
    this.z = this.z.toRed(this.curve.red);

  this.zOne = this.z === this.curve.one;
}
inherits(JPoint, Base.BasePoint);

ShortCurve.prototype.jpoint = function jpoint(x, y, z) {
  return new JPoint(this, x, y, z);
};

JPoint.prototype.toP = function toP() {
  if (this.isInfinity())
    return this.curve.point(null, null);

  var zinv = this.z.redInvm();
  var zinv2 = zinv.redSqr();
  var ax = this.x.redMul(zinv2);
  var ay = this.y.redMul(zinv2).redMul(zinv);

  return this.curve.point(ax, ay);
};

JPoint.prototype.neg = function neg() {
  return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
};

JPoint.prototype.add = function add(p) {
  // O + P = P
  if (this.isInfinity())
    return p;

  // P + O = P
  if (p.isInfinity())
    return this;

  // 12M + 4S + 7A
  var pz2 = p.z.redSqr();
  var z2 = this.z.redSqr();
  var u1 = this.x.redMul(pz2);
  var u2 = p.x.redMul(z2);
  var s1 = this.y.redMul(pz2.redMul(p.z));
  var s2 = p.y.redMul(z2.redMul(this.z));

  var h = u1.redSub(u2);
  var r = s1.redSub(s2);
  if (h.cmpn(0) === 0) {
    if (r.cmpn(0) !== 0)
      return this.curve.jpoint(null, null, null);
    else
      return this.dbl();
  }

  var h2 = h.redSqr();
  var h3 = h2.redMul(h);
  var v = u1.redMul(h2);

  var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
  var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
  var nz = this.z.redMul(p.z).redMul(h);

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype.mixedAdd = function mixedAdd(p) {
  // O + P = P
  if (this.isInfinity())
    return p.toJ();

  // P + O = P
  if (p.isInfinity())
    return this;

  // 8M + 3S + 7A
  var z2 = this.z.redSqr();
  var u1 = this.x;
  var u2 = p.x.redMul(z2);
  var s1 = this.y;
  var s2 = p.y.redMul(z2).redMul(this.z);

  var h = u1.redSub(u2);
  var r = s1.redSub(s2);
  if (h.cmpn(0) === 0) {
    if (r.cmpn(0) !== 0)
      return this.curve.jpoint(null, null, null);
    else
      return this.dbl();
  }

  var h2 = h.redSqr();
  var h3 = h2.redMul(h);
  var v = u1.redMul(h2);

  var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
  var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
  var nz = this.z.redMul(h);

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype.dblp = function dblp(pow) {
  if (pow === 0)
    return this;
  if (this.isInfinity())
    return this;
  if (!pow)
    return this.dbl();

  var i;
  if (this.curve.zeroA || this.curve.threeA) {
    var r = this;
    for (i = 0; i < pow; i++)
      r = r.dbl();
    return r;
  }

  // 1M + 2S + 1A + N * (4S + 5M + 8A)
  // N = 1 => 6M + 6S + 9A
  var a = this.curve.a;
  var tinv = this.curve.tinv;

  var jx = this.x;
  var jy = this.y;
  var jz = this.z;
  var jz4 = jz.redSqr().redSqr();

  // Reuse results
  var jyd = jy.redAdd(jy);
  for (i = 0; i < pow; i++) {
    var jx2 = jx.redSqr();
    var jyd2 = jyd.redSqr();
    var jyd4 = jyd2.redSqr();
    var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));

    var t1 = jx.redMul(jyd2);
    var nx = c.redSqr().redISub(t1.redAdd(t1));
    var t2 = t1.redISub(nx);
    var dny = c.redMul(t2);
    dny = dny.redIAdd(dny).redISub(jyd4);
    var nz = jyd.redMul(jz);
    if (i + 1 < pow)
      jz4 = jz4.redMul(jyd4);

    jx = nx;
    jz = nz;
    jyd = dny;
  }

  return this.curve.jpoint(jx, jyd.redMul(tinv), jz);
};

JPoint.prototype.dbl = function dbl() {
  if (this.isInfinity())
    return this;

  if (this.curve.zeroA)
    return this._zeroDbl();
  else if (this.curve.threeA)
    return this._threeDbl();
  else
    return this._dbl();
};

JPoint.prototype._zeroDbl = function _zeroDbl() {
  var nx;
  var ny;
  var nz;
  // Z = 1
  if (this.zOne) {
    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html
    //     #doubling-mdbl-2007-bl
    // 1M + 5S + 14A

    // XX = X1^2
    var xx = this.x.redSqr();
    // YY = Y1^2
    var yy = this.y.redSqr();
    // YYYY = YY^2
    var yyyy = yy.redSqr();
    // S = 2 * ((X1 + YY)^2 - XX - YYYY)
    var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
    s = s.redIAdd(s);
    // M = 3 * XX + a; a = 0
    var m = xx.redAdd(xx).redIAdd(xx);
    // T = M ^ 2 - 2*S
    var t = m.redSqr().redISub(s).redISub(s);

    // 8 * YYYY
    var yyyy8 = yyyy.redIAdd(yyyy);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    yyyy8 = yyyy8.redIAdd(yyyy8);

    // X3 = T
    nx = t;
    // Y3 = M * (S - T) - 8 * YYYY
    ny = m.redMul(s.redISub(t)).redISub(yyyy8);
    // Z3 = 2*Y1
    nz = this.y.redAdd(this.y);
  } else {
    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html
    //     #doubling-dbl-2009-l
    // 2M + 5S + 13A

    // A = X1^2
    var a = this.x.redSqr();
    // B = Y1^2
    var b = this.y.redSqr();
    // C = B^2
    var c = b.redSqr();
    // D = 2 * ((X1 + B)^2 - A - C)
    var d = this.x.redAdd(b).redSqr().redISub(a).redISub(c);
    d = d.redIAdd(d);
    // E = 3 * A
    var e = a.redAdd(a).redIAdd(a);
    // F = E^2
    var f = e.redSqr();

    // 8 * C
    var c8 = c.redIAdd(c);
    c8 = c8.redIAdd(c8);
    c8 = c8.redIAdd(c8);

    // X3 = F - 2 * D
    nx = f.redISub(d).redISub(d);
    // Y3 = E * (D - X3) - 8 * C
    ny = e.redMul(d.redISub(nx)).redISub(c8);
    // Z3 = 2 * Y1 * Z1
    nz = this.y.redMul(this.z);
    nz = nz.redIAdd(nz);
  }

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype._threeDbl = function _threeDbl() {
  var nx;
  var ny;
  var nz;
  // Z = 1
  if (this.zOne) {
    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html
    //     #doubling-mdbl-2007-bl
    // 1M + 5S + 15A

    // XX = X1^2
    var xx = this.x.redSqr();
    // YY = Y1^2
    var yy = this.y.redSqr();
    // YYYY = YY^2
    var yyyy = yy.redSqr();
    // S = 2 * ((X1 + YY)^2 - XX - YYYY)
    var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
    s = s.redIAdd(s);
    // M = 3 * XX + a
    var m = xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a);
    // T = M^2 - 2 * S
    var t = m.redSqr().redISub(s).redISub(s);
    // X3 = T
    nx = t;
    // Y3 = M * (S - T) - 8 * YYYY
    var yyyy8 = yyyy.redIAdd(yyyy);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    ny = m.redMul(s.redISub(t)).redISub(yyyy8);
    // Z3 = 2 * Y1
    nz = this.y.redAdd(this.y);
  } else {
    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html#doubling-dbl-2001-b
    // 3M + 5S

    // delta = Z1^2
    var delta = this.z.redSqr();
    // gamma = Y1^2
    var gamma = this.y.redSqr();
    // beta = X1 * gamma
    var beta = this.x.redMul(gamma);
    // alpha = 3 * (X1 - delta) * (X1 + delta)
    var alpha = this.x.redSub(delta).redMul(this.x.redAdd(delta));
    alpha = alpha.redAdd(alpha).redIAdd(alpha);
    // X3 = alpha^2 - 8 * beta
    var beta4 = beta.redIAdd(beta);
    beta4 = beta4.redIAdd(beta4);
    var beta8 = beta4.redAdd(beta4);
    nx = alpha.redSqr().redISub(beta8);
    // Z3 = (Y1 + Z1)^2 - gamma - delta
    nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);
    // Y3 = alpha * (4 * beta - X3) - 8 * gamma^2
    var ggamma8 = gamma.redSqr();
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ny = alpha.redMul(beta4.redISub(nx)).redISub(ggamma8);
  }

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype._dbl = function _dbl() {
  var a = this.curve.a;

  // 4M + 6S + 10A
  var jx = this.x;
  var jy = this.y;
  var jz = this.z;
  var jz4 = jz.redSqr().redSqr();

  var jx2 = jx.redSqr();
  var jy2 = jy.redSqr();

  var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));

  var jxd4 = jx.redAdd(jx);
  jxd4 = jxd4.redIAdd(jxd4);
  var t1 = jxd4.redMul(jy2);
  var nx = c.redSqr().redISub(t1.redAdd(t1));
  var t2 = t1.redISub(nx);

  var jyd8 = jy2.redSqr();
  jyd8 = jyd8.redIAdd(jyd8);
  jyd8 = jyd8.redIAdd(jyd8);
  jyd8 = jyd8.redIAdd(jyd8);
  var ny = c.redMul(t2).redISub(jyd8);
  var nz = jy.redAdd(jy).redMul(jz);

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype.trpl = function trpl() {
  if (!this.curve.zeroA)
    return this.dbl().add(this);

  // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html#tripling-tpl-2007-bl
  // 5M + 10S + ...

  // XX = X1^2
  var xx = this.x.redSqr();
  // YY = Y1^2
  var yy = this.y.redSqr();
  // ZZ = Z1^2
  var zz = this.z.redSqr();
  // YYYY = YY^2
  var yyyy = yy.redSqr();
  // M = 3 * XX + a * ZZ2; a = 0
  var m = xx.redAdd(xx).redIAdd(xx);
  // MM = M^2
  var mm = m.redSqr();
  // E = 6 * ((X1 + YY)^2 - XX - YYYY) - MM
  var e = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
  e = e.redIAdd(e);
  e = e.redAdd(e).redIAdd(e);
  e = e.redISub(mm);
  // EE = E^2
  var ee = e.redSqr();
  // T = 16*YYYY
  var t = yyyy.redIAdd(yyyy);
  t = t.redIAdd(t);
  t = t.redIAdd(t);
  t = t.redIAdd(t);
  // U = (M + E)^2 - MM - EE - T
  var u = m.redIAdd(e).redSqr().redISub(mm).redISub(ee).redISub(t);
  // X3 = 4 * (X1 * EE - 4 * YY * U)
  var yyu4 = yy.redMul(u);
  yyu4 = yyu4.redIAdd(yyu4);
  yyu4 = yyu4.redIAdd(yyu4);
  var nx = this.x.redMul(ee).redISub(yyu4);
  nx = nx.redIAdd(nx);
  nx = nx.redIAdd(nx);
  // Y3 = 8 * Y1 * (U * (T - U) - E * EE)
  var ny = this.y.redMul(u.redMul(t.redISub(u)).redISub(e.redMul(ee)));
  ny = ny.redIAdd(ny);
  ny = ny.redIAdd(ny);
  ny = ny.redIAdd(ny);
  // Z3 = (Z1 + E)^2 - ZZ - EE
  var nz = this.z.redAdd(e).redSqr().redISub(zz).redISub(ee);

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype.mul = function mul(k, kbase) {
  k = new BN(k, kbase);

  return this.curve._wnafMul(this, k);
};

JPoint.prototype.eq = function eq(p) {
  if (p.type === 'affine')
    return this.eq(p.toJ());

  if (this === p)
    return true;

  // x1 * z2^2 == x2 * z1^2
  var z2 = this.z.redSqr();
  var pz2 = p.z.redSqr();
  if (this.x.redMul(pz2).redISub(p.x.redMul(z2)).cmpn(0) !== 0)
    return false;

  // y1 * z2^3 == y2 * z1^3
  var z3 = z2.redMul(this.z);
  var pz3 = pz2.redMul(p.z);
  return this.y.redMul(pz3).redISub(p.y.redMul(z3)).cmpn(0) === 0;
};

JPoint.prototype.eqXToP = function eqXToP(x) {
  var zs = this.z.redSqr();
  var rx = x.toRed(this.curve.red).redMul(zs);
  if (this.x.cmp(rx) === 0)
    return true;

  var xc = x.clone();
  var t = this.curve.redN.redMul(zs);
  for (;;) {
    xc.iadd(this.curve.n);
    if (xc.cmp(this.curve.p) >= 0)
      return false;

    rx.redIAdd(t);
    if (this.x.cmp(rx) === 0)
      return true;
  }
};

JPoint.prototype.inspect = function inspect() {
  if (this.isInfinity())
    return '<EC JPoint Infinity>';
  return '<EC JPoint x: ' + this.x.toString(16, 2) +
      ' y: ' + this.y.toString(16, 2) +
      ' z: ' + this.z.toString(16, 2) + '>';
};

JPoint.prototype.isInfinity = function isInfinity() {
  // XXX This code assumes that zero is always zero in red
  return this.z.cmpn(0) === 0;
};

},{"../utils":106,"./base":93,"bn.js":107,"inherits":141}],98:[function(require,module,exports){
'use strict';

var curves = exports;

var hash = require('hash.js');
var curve = require('./curve');
var utils = require('./utils');

var assert = utils.assert;

function PresetCurve(options) {
  if (options.type === 'short')
    this.curve = new curve.short(options);
  else if (options.type === 'edwards')
    this.curve = new curve.edwards(options);
  else
    this.curve = new curve.mont(options);
  this.g = this.curve.g;
  this.n = this.curve.n;
  this.hash = options.hash;

  assert(this.g.validate(), 'Invalid curve');
  assert(this.g.mul(this.n).isInfinity(), 'Invalid curve, G*N != O');
}
curves.PresetCurve = PresetCurve;

function defineCurve(name, options) {
  Object.defineProperty(curves, name, {
    configurable: true,
    enumerable: true,
    get: function() {
      var curve = new PresetCurve(options);
      Object.defineProperty(curves, name, {
        configurable: true,
        enumerable: true,
        value: curve,
      });
      return curve;
    },
  });
}

defineCurve('p192', {
  type: 'short',
  prime: 'p192',
  p: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff',
  a: 'ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc',
  b: '64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1',
  n: 'ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831',
  hash: hash.sha256,
  gRed: false,
  g: [
    '188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012',
    '07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811',
  ],
});

defineCurve('p224', {
  type: 'short',
  prime: 'p224',
  p: 'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001',
  a: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe',
  b: 'b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4',
  n: 'ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d',
  hash: hash.sha256,
  gRed: false,
  g: [
    'b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21',
    'bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34',
  ],
});

defineCurve('p256', {
  type: 'short',
  prime: null,
  p: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff',
  a: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc',
  b: '5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b',
  n: 'ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551',
  hash: hash.sha256,
  gRed: false,
  g: [
    '6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296',
    '4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5',
  ],
});

defineCurve('p384', {
  type: 'short',
  prime: null,
  p: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'fffffffe ffffffff 00000000 00000000 ffffffff',
  a: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'fffffffe ffffffff 00000000 00000000 fffffffc',
  b: 'b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f ' +
     '5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef',
  n: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 ' +
     'f4372ddf 581a0db2 48b0a77a ecec196a ccc52973',
  hash: hash.sha384,
  gRed: false,
  g: [
    'aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 ' +
    '5502f25d bf55296c 3a545e38 72760ab7',
    '3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 ' +
    '0a60b1ce 1d7e819d 7a431d7c 90ea0e5f',
  ],
});

defineCurve('p521', {
  type: 'short',
  prime: null,
  p: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'ffffffff ffffffff ffffffff ffffffff ffffffff',
  a: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'ffffffff ffffffff ffffffff ffffffff fffffffc',
  b: '00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b ' +
     '99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd ' +
     '3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00',
  n: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 ' +
     'f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409',
  hash: hash.sha512,
  gRed: false,
  g: [
    '000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 ' +
    '053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 ' +
    'a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66',
    '00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 ' +
    '579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 ' +
    '3fad0761 353c7086 a272c240 88be9476 9fd16650',
  ],
});

defineCurve('curve25519', {
  type: 'mont',
  prime: 'p25519',
  p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',
  a: '76d06',
  b: '1',
  n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',
  hash: hash.sha256,
  gRed: false,
  g: [
    '9',
  ],
});

defineCurve('ed25519', {
  type: 'edwards',
  prime: 'p25519',
  p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',
  a: '-1',
  c: '1',
  // -121665 * (121666^(-1)) (mod P)
  d: '52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3',
  n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',
  hash: hash.sha256,
  gRed: false,
  g: [
    '216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a',

    // 4/5
    '6666666666666666666666666666666666666666666666666666666666666658',
  ],
});

var pre;
try {
  pre = require('./precomputed/secp256k1');
} catch (e) {
  pre = undefined;
}

defineCurve('secp256k1', {
  type: 'short',
  prime: 'k256',
  p: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f',
  a: '0',
  b: '7',
  n: 'ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141',
  h: '1',
  hash: hash.sha256,

  // Precomputed endomorphism
  beta: '7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee',
  lambda: '5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72',
  basis: [
    {
      a: '3086d221a7d46bcde86c90e49284eb15',
      b: '-e4437ed6010e88286f547fa90abfe4c3',
    },
    {
      a: '114ca50f7a8e2f3f657c1108d9d44cfd8',
      b: '3086d221a7d46bcde86c90e49284eb15',
    },
  ],

  gRed: false,
  g: [
    '79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798',
    '483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8',
    pre,
  ],
});

},{"./curve":95,"./precomputed/secp256k1":105,"./utils":106,"hash.js":127}],99:[function(require,module,exports){
'use strict';

var BN = require('bn.js');
var HmacDRBG = require('hmac-drbg');
var utils = require('../utils');
var curves = require('../curves');
var rand = require('brorand');
var assert = utils.assert;

var KeyPair = require('./key');
var Signature = require('./signature');

function EC(options) {
  if (!(this instanceof EC))
    return new EC(options);

  // Shortcut `elliptic.ec(curve-name)`
  if (typeof options === 'string') {
    assert(Object.prototype.hasOwnProperty.call(curves, options),
      'Unknown curve ' + options);

    options = curves[options];
  }

  // Shortcut for `elliptic.ec(elliptic.curves.curveName)`
  if (options instanceof curves.PresetCurve)
    options = { curve: options };

  this.curve = options.curve.curve;
  this.n = this.curve.n;
  this.nh = this.n.ushrn(1);
  this.g = this.curve.g;

  // Point on curve
  this.g = options.curve.g;
  this.g.precompute(options.curve.n.bitLength() + 1);

  // Hash for function for DRBG
  this.hash = options.hash || options.curve.hash;
}
module.exports = EC;

EC.prototype.keyPair = function keyPair(options) {
  return new KeyPair(this, options);
};

EC.prototype.keyFromPrivate = function keyFromPrivate(priv, enc) {
  return KeyPair.fromPrivate(this, priv, enc);
};

EC.prototype.keyFromPublic = function keyFromPublic(pub, enc) {
  return KeyPair.fromPublic(this, pub, enc);
};

EC.prototype.genKeyPair = function genKeyPair(options) {
  if (!options)
    options = {};

  // Instantiate Hmac_DRBG
  var drbg = new HmacDRBG({
    hash: this.hash,
    pers: options.pers,
    persEnc: options.persEnc || 'utf8',
    entropy: options.entropy || rand(this.hash.hmacStrength),
    entropyEnc: options.entropy && options.entropyEnc || 'utf8',
    nonce: this.n.toArray(),
  });

  var bytes = this.n.byteLength();
  var ns2 = this.n.sub(new BN(2));
  for (;;) {
    var priv = new BN(drbg.generate(bytes));
    if (priv.cmp(ns2) > 0)
      continue;

    priv.iaddn(1);
    return this.keyFromPrivate(priv);
  }
};

EC.prototype._truncateToN = function _truncateToN(msg, truncOnly) {
  var delta = msg.byteLength() * 8 - this.n.bitLength();
  if (delta > 0)
    msg = msg.ushrn(delta);
  if (!truncOnly && msg.cmp(this.n) >= 0)
    return msg.sub(this.n);
  else
    return msg;
};

EC.prototype.sign = function sign(msg, key, enc, options) {
  if (typeof enc === 'object') {
    options = enc;
    enc = null;
  }
  if (!options)
    options = {};

  key = this.keyFromPrivate(key, enc);
  msg = this._truncateToN(new BN(msg, 16));

  // Zero-extend key to provide enough entropy
  var bytes = this.n.byteLength();
  var bkey = key.getPrivate().toArray('be', bytes);

  // Zero-extend nonce to have the same byte size as N
  var nonce = msg.toArray('be', bytes);

  // Instantiate Hmac_DRBG
  var drbg = new HmacDRBG({
    hash: this.hash,
    entropy: bkey,
    nonce: nonce,
    pers: options.pers,
    persEnc: options.persEnc || 'utf8',
  });

  // Number of bytes to generate
  var ns1 = this.n.sub(new BN(1));

  for (var iter = 0; ; iter++) {
    var k = options.k ?
      options.k(iter) :
      new BN(drbg.generate(this.n.byteLength()));
    k = this._truncateToN(k, true);
    if (k.cmpn(1) <= 0 || k.cmp(ns1) >= 0)
      continue;

    var kp = this.g.mul(k);
    if (kp.isInfinity())
      continue;

    var kpX = kp.getX();
    var r = kpX.umod(this.n);
    if (r.cmpn(0) === 0)
      continue;

    var s = k.invm(this.n).mul(r.mul(key.getPrivate()).iadd(msg));
    s = s.umod(this.n);
    if (s.cmpn(0) === 0)
      continue;

    var recoveryParam = (kp.getY().isOdd() ? 1 : 0) |
                        (kpX.cmp(r) !== 0 ? 2 : 0);

    // Use complement of `s`, if it is > `n / 2`
    if (options.canonical && s.cmp(this.nh) > 0) {
      s = this.n.sub(s);
      recoveryParam ^= 1;
    }

    return new Signature({ r: r, s: s, recoveryParam: recoveryParam });
  }
};

EC.prototype.verify = function verify(msg, signature, key, enc) {
  msg = this._truncateToN(new BN(msg, 16));
  key = this.keyFromPublic(key, enc);
  signature = new Signature(signature, 'hex');

  // Perform primitive values validation
  var r = signature.r;
  var s = signature.s;
  if (r.cmpn(1) < 0 || r.cmp(this.n) >= 0)
    return false;
  if (s.cmpn(1) < 0 || s.cmp(this.n) >= 0)
    return false;

  // Validate signature
  var sinv = s.invm(this.n);
  var u1 = sinv.mul(msg).umod(this.n);
  var u2 = sinv.mul(r).umod(this.n);
  var p;

  if (!this.curve._maxwellTrick) {
    p = this.g.mulAdd(u1, key.getPublic(), u2);
    if (p.isInfinity())
      return false;

    return p.getX().umod(this.n).cmp(r) === 0;
  }

  // NOTE: Greg Maxwell's trick, inspired by:
  // https://git.io/vad3K

  p = this.g.jmulAdd(u1, key.getPublic(), u2);
  if (p.isInfinity())
    return false;

  // Compare `p.x` of Jacobian point with `r`,
  // this will do `p.x == r * p.z^2` instead of multiplying `p.x` by the
  // inverse of `p.z^2`
  return p.eqXToP(r);
};

EC.prototype.recoverPubKey = function(msg, signature, j, enc) {
  assert((3 & j) === j, 'The recovery param is more than two bits');
  signature = new Signature(signature, enc);

  var n = this.n;
  var e = new BN(msg);
  var r = signature.r;
  var s = signature.s;

  // A set LSB signifies that the y-coordinate is odd
  var isYOdd = j & 1;
  var isSecondKey = j >> 1;
  if (r.cmp(this.curve.p.umod(this.curve.n)) >= 0 && isSecondKey)
    throw new Error('Unable to find sencond key candinate');

  // 1.1. Let x = r + jn.
  if (isSecondKey)
    r = this.curve.pointFromX(r.add(this.curve.n), isYOdd);
  else
    r = this.curve.pointFromX(r, isYOdd);

  var rInv = signature.r.invm(n);
  var s1 = n.sub(e).mul(rInv).umod(n);
  var s2 = s.mul(rInv).umod(n);

  // 1.6.1 Compute Q = r^-1 (sR -  eG)
  //               Q = r^-1 (sR + -eG)
  return this.g.mulAdd(s1, r, s2);
};

EC.prototype.getKeyRecoveryParam = function(e, signature, Q, enc) {
  signature = new Signature(signature, enc);
  if (signature.recoveryParam !== null)
    return signature.recoveryParam;

  for (var i = 0; i < 4; i++) {
    var Qprime;
    try {
      Qprime = this.recoverPubKey(e, signature, i);
    } catch (e) {
      continue;
    }

    if (Qprime.eq(Q))
      return i;
  }
  throw new Error('Unable to find valid recovery factor');
};

},{"../curves":98,"../utils":106,"./key":100,"./signature":101,"bn.js":107,"brorand":26,"hmac-drbg":139}],100:[function(require,module,exports){
'use strict';

var BN = require('bn.js');
var utils = require('../utils');
var assert = utils.assert;

function KeyPair(ec, options) {
  this.ec = ec;
  this.priv = null;
  this.pub = null;

  // KeyPair(ec, { priv: ..., pub: ... })
  if (options.priv)
    this._importPrivate(options.priv, options.privEnc);
  if (options.pub)
    this._importPublic(options.pub, options.pubEnc);
}
module.exports = KeyPair;

KeyPair.fromPublic = function fromPublic(ec, pub, enc) {
  if (pub instanceof KeyPair)
    return pub;

  return new KeyPair(ec, {
    pub: pub,
    pubEnc: enc,
  });
};

KeyPair.fromPrivate = function fromPrivate(ec, priv, enc) {
  if (priv instanceof KeyPair)
    return priv;

  return new KeyPair(ec, {
    priv: priv,
    privEnc: enc,
  });
};

KeyPair.prototype.validate = function validate() {
  var pub = this.getPublic();

  if (pub.isInfinity())
    return { result: false, reason: 'Invalid public key' };
  if (!pub.validate())
    return { result: false, reason: 'Public key is not a point' };
  if (!pub.mul(this.ec.curve.n).isInfinity())
    return { result: false, reason: 'Public key * N != O' };

  return { result: true, reason: null };
};

KeyPair.prototype.getPublic = function getPublic(compact, enc) {
  // compact is optional argument
  if (typeof compact === 'string') {
    enc = compact;
    compact = null;
  }

  if (!this.pub)
    this.pub = this.ec.g.mul(this.priv);

  if (!enc)
    return this.pub;

  return this.pub.encode(enc, compact);
};

KeyPair.prototype.getPrivate = function getPrivate(enc) {
  if (enc === 'hex')
    return this.priv.toString(16, 2);
  else
    return this.priv;
};

KeyPair.prototype._importPrivate = function _importPrivate(key, enc) {
  this.priv = new BN(key, enc || 16);

  // Ensure that the priv won't be bigger than n, otherwise we may fail
  // in fixed multiplication method
  this.priv = this.priv.umod(this.ec.curve.n);
};

KeyPair.prototype._importPublic = function _importPublic(key, enc) {
  if (key.x || key.y) {
    // Montgomery points only have an `x` coordinate.
    // Weierstrass/Edwards points on the other hand have both `x` and
    // `y` coordinates.
    if (this.ec.curve.type === 'mont') {
      assert(key.x, 'Need x coordinate');
    } else if (this.ec.curve.type === 'short' ||
               this.ec.curve.type === 'edwards') {
      assert(key.x && key.y, 'Need both x and y coordinate');
    }
    this.pub = this.ec.curve.point(key.x, key.y);
    return;
  }
  this.pub = this.ec.curve.decodePoint(key, enc);
};

// ECDH
KeyPair.prototype.derive = function derive(pub) {
  if(!pub.validate()) {
    assert(pub.validate(), 'public point not validated');
  }
  return pub.mul(this.priv).getX();
};

// ECDSA
KeyPair.prototype.sign = function sign(msg, enc, options) {
  return this.ec.sign(msg, this, enc, options);
};

KeyPair.prototype.verify = function verify(msg, signature) {
  return this.ec.verify(msg, signature, this);
};

KeyPair.prototype.inspect = function inspect() {
  return '<Key priv: ' + (this.priv && this.priv.toString(16, 2)) +
         ' pub: ' + (this.pub && this.pub.inspect()) + ' >';
};

},{"../utils":106,"bn.js":107}],101:[function(require,module,exports){
'use strict';

var BN = require('bn.js');

var utils = require('../utils');
var assert = utils.assert;

function Signature(options, enc) {
  if (options instanceof Signature)
    return options;

  if (this._importDER(options, enc))
    return;

  assert(options.r && options.s, 'Signature without r or s');
  this.r = new BN(options.r, 16);
  this.s = new BN(options.s, 16);
  if (options.recoveryParam === undefined)
    this.recoveryParam = null;
  else
    this.recoveryParam = options.recoveryParam;
}
module.exports = Signature;

function Position() {
  this.place = 0;
}

function getLength(buf, p) {
  var initial = buf[p.place++];
  if (!(initial & 0x80)) {
    return initial;
  }
  var octetLen = initial & 0xf;

  // Indefinite length or overflow
  if (octetLen === 0 || octetLen > 4) {
    return false;
  }

  var val = 0;
  for (var i = 0, off = p.place; i < octetLen; i++, off++) {
    val <<= 8;
    val |= buf[off];
    val >>>= 0;
  }

  // Leading zeroes
  if (val <= 0x7f) {
    return false;
  }

  p.place = off;
  return val;
}

function rmPadding(buf) {
  var i = 0;
  var len = buf.length - 1;
  while (!buf[i] && !(buf[i + 1] & 0x80) && i < len) {
    i++;
  }
  if (i === 0) {
    return buf;
  }
  return buf.slice(i);
}

Signature.prototype._importDER = function _importDER(data, enc) {
  data = utils.toArray(data, enc);
  var p = new Position();
  if (data[p.place++] !== 0x30) {
    return false;
  }
  var len = getLength(data, p);
  if (len === false) {
    return false;
  }
  if ((len + p.place) !== data.length) {
    return false;
  }
  if (data[p.place++] !== 0x02) {
    return false;
  }
  var rlen = getLength(data, p);
  if (rlen === false) {
    return false;
  }
  var r = data.slice(p.place, rlen + p.place);
  p.place += rlen;
  if (data[p.place++] !== 0x02) {
    return false;
  }
  var slen = getLength(data, p);
  if (slen === false) {
    return false;
  }
  if (data.length !== slen + p.place) {
    return false;
  }
  var s = data.slice(p.place, slen + p.place);
  if (r[0] === 0) {
    if (r[1] & 0x80) {
      r = r.slice(1);
    } else {
      // Leading zeroes
      return false;
    }
  }
  if (s[0] === 0) {
    if (s[1] & 0x80) {
      s = s.slice(1);
    } else {
      // Leading zeroes
      return false;
    }
  }

  this.r = new BN(r);
  this.s = new BN(s);
  this.recoveryParam = null;

  return true;
};

function constructLength(arr, len) {
  if (len < 0x80) {
    arr.push(len);
    return;
  }
  var octets = 1 + (Math.log(len) / Math.LN2 >>> 3);
  arr.push(octets | 0x80);
  while (--octets) {
    arr.push((len >>> (octets << 3)) & 0xff);
  }
  arr.push(len);
}

Signature.prototype.toDER = function toDER(enc) {
  var r = this.r.toArray();
  var s = this.s.toArray();

  // Pad values
  if (r[0] & 0x80)
    r = [ 0 ].concat(r);
  // Pad values
  if (s[0] & 0x80)
    s = [ 0 ].concat(s);

  r = rmPadding(r);
  s = rmPadding(s);

  while (!s[0] && !(s[1] & 0x80)) {
    s = s.slice(1);
  }
  var arr = [ 0x02 ];
  constructLength(arr, r.length);
  arr = arr.concat(r);
  arr.push(0x02);
  constructLength(arr, s.length);
  var backHalf = arr.concat(s);
  var res = [ 0x30 ];
  constructLength(res, backHalf.length);
  res = res.concat(backHalf);
  return utils.encode(res, enc);
};

},{"../utils":106,"bn.js":107}],102:[function(require,module,exports){
'use strict';

var hash = require('hash.js');
var curves = require('../curves');
var utils = require('../utils');
var assert = utils.assert;
var parseBytes = utils.parseBytes;
var KeyPair = require('./key');
var Signature = require('./signature');

function EDDSA(curve) {
  assert(curve === 'ed25519', 'only tested with ed25519 so far');

  if (!(this instanceof EDDSA))
    return new EDDSA(curve);

  curve = curves[curve].curve;
  this.curve = curve;
  this.g = curve.g;
  this.g.precompute(curve.n.bitLength() + 1);

  this.pointClass = curve.point().constructor;
  this.encodingLength = Math.ceil(curve.n.bitLength() / 8);
  this.hash = hash.sha512;
}

module.exports = EDDSA;

/**
* @param {Array|String} message - message bytes
* @param {Array|String|KeyPair} secret - secret bytes or a keypair
* @returns {Signature} - signature
*/
EDDSA.prototype.sign = function sign(message, secret) {
  message = parseBytes(message);
  var key = this.keyFromSecret(secret);
  var r = this.hashInt(key.messagePrefix(), message);
  var R = this.g.mul(r);
  var Rencoded = this.encodePoint(R);
  var s_ = this.hashInt(Rencoded, key.pubBytes(), message)
    .mul(key.priv());
  var S = r.add(s_).umod(this.curve.n);
  return this.makeSignature({ R: R, S: S, Rencoded: Rencoded });
};

/**
* @param {Array} message - message bytes
* @param {Array|String|Signature} sig - sig bytes
* @param {Array|String|Point|KeyPair} pub - public key
* @returns {Boolean} - true if public key matches sig of message
*/
EDDSA.prototype.verify = function verify(message, sig, pub) {
  message = parseBytes(message);
  sig = this.makeSignature(sig);
  var key = this.keyFromPublic(pub);
  var h = this.hashInt(sig.Rencoded(), key.pubBytes(), message);
  var SG = this.g.mul(sig.S());
  var RplusAh = sig.R().add(key.pub().mul(h));
  return RplusAh.eq(SG);
};

EDDSA.prototype.hashInt = function hashInt() {
  var hash = this.hash();
  for (var i = 0; i < arguments.length; i++)
    hash.update(arguments[i]);
  return utils.intFromLE(hash.digest()).umod(this.curve.n);
};

EDDSA.prototype.keyFromPublic = function keyFromPublic(pub) {
  return KeyPair.fromPublic(this, pub);
};

EDDSA.prototype.keyFromSecret = function keyFromSecret(secret) {
  return KeyPair.fromSecret(this, secret);
};

EDDSA.prototype.makeSignature = function makeSignature(sig) {
  if (sig instanceof Signature)
    return sig;
  return new Signature(this, sig);
};

/**
* * https://tools.ietf.org/html/draft-josefsson-eddsa-ed25519-03#section-5.2
*
* EDDSA defines methods for encoding and decoding points and integers. These are
* helper convenience methods, that pass along to utility functions implied
* parameters.
*
*/
EDDSA.prototype.encodePoint = function encodePoint(point) {
  var enc = point.getY().toArray('le', this.encodingLength);
  enc[this.encodingLength - 1] |= point.getX().isOdd() ? 0x80 : 0;
  return enc;
};

EDDSA.prototype.decodePoint = function decodePoint(bytes) {
  bytes = utils.parseBytes(bytes);

  var lastIx = bytes.length - 1;
  var normed = bytes.slice(0, lastIx).concat(bytes[lastIx] & ~0x80);
  var xIsOdd = (bytes[lastIx] & 0x80) !== 0;

  var y = utils.intFromLE(normed);
  return this.curve.pointFromY(y, xIsOdd);
};

EDDSA.prototype.encodeInt = function encodeInt(num) {
  return num.toArray('le', this.encodingLength);
};

EDDSA.prototype.decodeInt = function decodeInt(bytes) {
  return utils.intFromLE(bytes);
};

EDDSA.prototype.isPoint = function isPoint(val) {
  return val instanceof this.pointClass;
};

},{"../curves":98,"../utils":106,"./key":103,"./signature":104,"hash.js":127}],103:[function(require,module,exports){
'use strict';

var utils = require('../utils');
var assert = utils.assert;
var parseBytes = utils.parseBytes;
var cachedProperty = utils.cachedProperty;

/**
* @param {EDDSA} eddsa - instance
* @param {Object} params - public/private key parameters
*
* @param {Array<Byte>} [params.secret] - secret seed bytes
* @param {Point} [params.pub] - public key point (aka `A` in eddsa terms)
* @param {Array<Byte>} [params.pub] - public key point encoded as bytes
*
*/
function KeyPair(eddsa, params) {
  this.eddsa = eddsa;
  this._secret = parseBytes(params.secret);
  if (eddsa.isPoint(params.pub))
    this._pub = params.pub;
  else
    this._pubBytes = parseBytes(params.pub);
}

KeyPair.fromPublic = function fromPublic(eddsa, pub) {
  if (pub instanceof KeyPair)
    return pub;
  return new KeyPair(eddsa, { pub: pub });
};

KeyPair.fromSecret = function fromSecret(eddsa, secret) {
  if (secret instanceof KeyPair)
    return secret;
  return new KeyPair(eddsa, { secret: secret });
};

KeyPair.prototype.secret = function secret() {
  return this._secret;
};

cachedProperty(KeyPair, 'pubBytes', function pubBytes() {
  return this.eddsa.encodePoint(this.pub());
});

cachedProperty(KeyPair, 'pub', function pub() {
  if (this._pubBytes)
    return this.eddsa.decodePoint(this._pubBytes);
  return this.eddsa.g.mul(this.priv());
});

cachedProperty(KeyPair, 'privBytes', function privBytes() {
  var eddsa = this.eddsa;
  var hash = this.hash();
  var lastIx = eddsa.encodingLength - 1;

  var a = hash.slice(0, eddsa.encodingLength);
  a[0] &= 248;
  a[lastIx] &= 127;
  a[lastIx] |= 64;

  return a;
});

cachedProperty(KeyPair, 'priv', function priv() {
  return this.eddsa.decodeInt(this.privBytes());
});

cachedProperty(KeyPair, 'hash', function hash() {
  return this.eddsa.hash().update(this.secret()).digest();
});

cachedProperty(KeyPair, 'messagePrefix', function messagePrefix() {
  return this.hash().slice(this.eddsa.encodingLength);
});

KeyPair.prototype.sign = function sign(message) {
  assert(this._secret, 'KeyPair can only verify');
  return this.eddsa.sign(message, this);
};

KeyPair.prototype.verify = function verify(message, sig) {
  return this.eddsa.verify(message, sig, this);
};

KeyPair.prototype.getSecret = function getSecret(enc) {
  assert(this._secret, 'KeyPair is public only');
  return utils.encode(this.secret(), enc);
};

KeyPair.prototype.getPublic = function getPublic(enc) {
  return utils.encode(this.pubBytes(), enc);
};

module.exports = KeyPair;

},{"../utils":106}],104:[function(require,module,exports){
'use strict';

var BN = require('bn.js');
var utils = require('../utils');
var assert = utils.assert;
var cachedProperty = utils.cachedProperty;
var parseBytes = utils.parseBytes;

/**
* @param {EDDSA} eddsa - eddsa instance
* @param {Array<Bytes>|Object} sig -
* @param {Array<Bytes>|Point} [sig.R] - R point as Point or bytes
* @param {Array<Bytes>|bn} [sig.S] - S scalar as bn or bytes
* @param {Array<Bytes>} [sig.Rencoded] - R point encoded
* @param {Array<Bytes>} [sig.Sencoded] - S scalar encoded
*/
function Signature(eddsa, sig) {
  this.eddsa = eddsa;

  if (typeof sig !== 'object')
    sig = parseBytes(sig);

  if (Array.isArray(sig)) {
    sig = {
      R: sig.slice(0, eddsa.encodingLength),
      S: sig.slice(eddsa.encodingLength),
    };
  }

  assert(sig.R && sig.S, 'Signature without R or S');

  if (eddsa.isPoint(sig.R))
    this._R = sig.R;
  if (sig.S instanceof BN)
    this._S = sig.S;

  this._Rencoded = Array.isArray(sig.R) ? sig.R : sig.Rencoded;
  this._Sencoded = Array.isArray(sig.S) ? sig.S : sig.Sencoded;
}

cachedProperty(Signature, 'S', function S() {
  return this.eddsa.decodeInt(this.Sencoded());
});

cachedProperty(Signature, 'R', function R() {
  return this.eddsa.decodePoint(this.Rencoded());
});

cachedProperty(Signature, 'Rencoded', function Rencoded() {
  return this.eddsa.encodePoint(this.R());
});

cachedProperty(Signature, 'Sencoded', function Sencoded() {
  return this.eddsa.encodeInt(this.S());
});

Signature.prototype.toBytes = function toBytes() {
  return this.Rencoded().concat(this.Sencoded());
};

Signature.prototype.toHex = function toHex() {
  return utils.encode(this.toBytes(), 'hex').toUpperCase();
};

module.exports = Signature;

},{"../utils":106,"bn.js":107}],105:[function(require,module,exports){
module.exports = {
  doubles: {
    step: 4,
    points: [
      [
        'e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a',
        'f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821',
      ],
      [
        '8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508',
        '11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf',
      ],
      [
        '175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739',
        'd3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695',
      ],
      [
        '363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640',
        '4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9',
      ],
      [
        '8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c',
        '4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36',
      ],
      [
        '723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda',
        '96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f',
      ],
      [
        'eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa',
        '5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999',
      ],
      [
        '100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0',
        'cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09',
      ],
      [
        'e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d',
        '9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d',
      ],
      [
        'feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d',
        'e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088',
      ],
      [
        'da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1',
        '9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d',
      ],
      [
        '53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0',
        '5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8',
      ],
      [
        '8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047',
        '10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a',
      ],
      [
        '385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862',
        '283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453',
      ],
      [
        '6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7',
        '7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160',
      ],
      [
        '3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd',
        '56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0',
      ],
      [
        '85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83',
        '7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6',
      ],
      [
        '948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a',
        '53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589',
      ],
      [
        '6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8',
        'bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17',
      ],
      [
        'e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d',
        '4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda',
      ],
      [
        'e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725',
        '7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd',
      ],
      [
        '213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754',
        '4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2',
      ],
      [
        '4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c',
        '17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6',
      ],
      [
        'fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6',
        '6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f',
      ],
      [
        '76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39',
        'c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01',
      ],
      [
        'c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891',
        '893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3',
      ],
      [
        'd895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b',
        'febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f',
      ],
      [
        'b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03',
        '2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7',
      ],
      [
        'e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d',
        'eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78',
      ],
      [
        'a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070',
        '7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1',
      ],
      [
        '90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4',
        'e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150',
      ],
      [
        '8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da',
        '662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82',
      ],
      [
        'e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11',
        '1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc',
      ],
      [
        '8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e',
        'efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b',
      ],
      [
        'e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41',
        '2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51',
      ],
      [
        'b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef',
        '67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45',
      ],
      [
        'd68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8',
        'db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120',
      ],
      [
        '324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d',
        '648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84',
      ],
      [
        '4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96',
        '35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d',
      ],
      [
        '9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd',
        'ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d',
      ],
      [
        '6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5',
        '9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8',
      ],
      [
        'a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266',
        '40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8',
      ],
      [
        '7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71',
        '34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac',
      ],
      [
        '928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac',
        'c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f',
      ],
      [
        '85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751',
        '1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962',
      ],
      [
        'ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e',
        '493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907',
      ],
      [
        '827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241',
        'c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec',
      ],
      [
        'eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3',
        'be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d',
      ],
      [
        'e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f',
        '4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414',
      ],
      [
        '1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19',
        'aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd',
      ],
      [
        '146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be',
        'b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0',
      ],
      [
        'fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9',
        '6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811',
      ],
      [
        'da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2',
        '8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1',
      ],
      [
        'a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13',
        '7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c',
      ],
      [
        '174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c',
        'ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73',
      ],
      [
        '959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba',
        '2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd',
      ],
      [
        'd2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151',
        'e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405',
      ],
      [
        '64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073',
        'd99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589',
      ],
      [
        '8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458',
        '38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e',
      ],
      [
        '13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b',
        '69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27',
      ],
      [
        'bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366',
        'd3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1',
      ],
      [
        '8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa',
        '40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482',
      ],
      [
        '8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0',
        '620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945',
      ],
      [
        'dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787',
        '7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573',
      ],
      [
        'f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e',
        'ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82',
      ],
    ],
  },
  naf: {
    wnd: 7,
    points: [
      [
        'f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9',
        '388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672',
      ],
      [
        '2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4',
        'd8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6',
      ],
      [
        '5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc',
        '6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da',
      ],
      [
        'acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe',
        'cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37',
      ],
      [
        '774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb',
        'd984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b',
      ],
      [
        'f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8',
        'ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81',
      ],
      [
        'd7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e',
        '581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58',
      ],
      [
        'defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34',
        '4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77',
      ],
      [
        '2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c',
        '85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a',
      ],
      [
        '352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5',
        '321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c',
      ],
      [
        '2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f',
        '2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67',
      ],
      [
        '9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714',
        '73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402',
      ],
      [
        'daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729',
        'a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55',
      ],
      [
        'c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db',
        '2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482',
      ],
      [
        '6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4',
        'e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82',
      ],
      [
        '1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5',
        'b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396',
      ],
      [
        '605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479',
        '2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49',
      ],
      [
        '62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d',
        '80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf',
      ],
      [
        '80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f',
        '1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a',
      ],
      [
        '7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb',
        'd0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7',
      ],
      [
        'd528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9',
        'eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933',
      ],
      [
        '49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963',
        '758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a',
      ],
      [
        '77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74',
        '958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6',
      ],
      [
        'f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530',
        'e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37',
      ],
      [
        '463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b',
        '5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e',
      ],
      [
        'f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247',
        'cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6',
      ],
      [
        'caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1',
        'cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476',
      ],
      [
        '2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120',
        '4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40',
      ],
      [
        '7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435',
        '91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61',
      ],
      [
        '754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18',
        '673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683',
      ],
      [
        'e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8',
        '59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5',
      ],
      [
        '186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb',
        '3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b',
      ],
      [
        'df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f',
        '55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417',
      ],
      [
        '5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143',
        'efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868',
      ],
      [
        '290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba',
        'e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a',
      ],
      [
        'af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45',
        'f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6',
      ],
      [
        '766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a',
        '744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996',
      ],
      [
        '59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e',
        'c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e',
      ],
      [
        'f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8',
        'e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d',
      ],
      [
        '7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c',
        '30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2',
      ],
      [
        '948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519',
        'e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e',
      ],
      [
        '7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab',
        '100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437',
      ],
      [
        '3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca',
        'ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311',
      ],
      [
        'd3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf',
        '8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4',
      ],
      [
        '1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610',
        '68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575',
      ],
      [
        '733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4',
        'f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d',
      ],
      [
        '15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c',
        'd56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d',
      ],
      [
        'a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940',
        'edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629',
      ],
      [
        'e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980',
        'a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06',
      ],
      [
        '311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3',
        '66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374',
      ],
      [
        '34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf',
        '9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee',
      ],
      [
        'f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63',
        '4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1',
      ],
      [
        'd7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448',
        'fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b',
      ],
      [
        '32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf',
        '5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661',
      ],
      [
        '7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5',
        '8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6',
      ],
      [
        'ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6',
        '8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e',
      ],
      [
        '16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5',
        '5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d',
      ],
      [
        'eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99',
        'f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc',
      ],
      [
        '78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51',
        'f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4',
      ],
      [
        '494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5',
        '42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c',
      ],
      [
        'a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5',
        '204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b',
      ],
      [
        'c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997',
        '4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913',
      ],
      [
        '841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881',
        '73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154',
      ],
      [
        '5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5',
        '39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865',
      ],
      [
        '36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66',
        'd2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc',
      ],
      [
        '336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726',
        'ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224',
      ],
      [
        '8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede',
        '6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e',
      ],
      [
        '1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94',
        '60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6',
      ],
      [
        '85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31',
        '3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511',
      ],
      [
        '29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51',
        'b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b',
      ],
      [
        'a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252',
        'ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2',
      ],
      [
        '4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5',
        'cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c',
      ],
      [
        'd24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b',
        '6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3',
      ],
      [
        'ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4',
        '322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d',
      ],
      [
        'af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f',
        '6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700',
      ],
      [
        'e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889',
        '2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4',
      ],
      [
        '591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246',
        'b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196',
      ],
      [
        '11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984',
        '998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4',
      ],
      [
        '3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a',
        'b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257',
      ],
      [
        'cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030',
        'bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13',
      ],
      [
        'c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197',
        '6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096',
      ],
      [
        'c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593',
        'c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38',
      ],
      [
        'a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef',
        '21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f',
      ],
      [
        '347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38',
        '60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448',
      ],
      [
        'da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a',
        '49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a',
      ],
      [
        'c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111',
        '5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4',
      ],
      [
        '4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502',
        '7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437',
      ],
      [
        '3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea',
        'be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7',
      ],
      [
        'cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26',
        '8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d',
      ],
      [
        'b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986',
        '39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a',
      ],
      [
        'd4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e',
        '62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54',
      ],
      [
        '48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4',
        '25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77',
      ],
      [
        'dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda',
        'ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517',
      ],
      [
        '6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859',
        'cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10',
      ],
      [
        'e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f',
        'f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125',
      ],
      [
        'eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c',
        '6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e',
      ],
      [
        '13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942',
        'fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1',
      ],
      [
        'ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a',
        '1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2',
      ],
      [
        'b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80',
        '5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423',
      ],
      [
        'ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d',
        '438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8',
      ],
      [
        '8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1',
        'cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758',
      ],
      [
        '52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63',
        'c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375',
      ],
      [
        'e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352',
        '6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d',
      ],
      [
        '7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193',
        'ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec',
      ],
      [
        '5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00',
        '9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0',
      ],
      [
        '32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58',
        'ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c',
      ],
      [
        'e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7',
        'd3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4',
      ],
      [
        '8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8',
        'c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f',
      ],
      [
        '4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e',
        '67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649',
      ],
      [
        '3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d',
        'cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826',
      ],
      [
        '674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b',
        '299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5',
      ],
      [
        'd32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f',
        'f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87',
      ],
      [
        '30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6',
        '462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b',
      ],
      [
        'be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297',
        '62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc',
      ],
      [
        '93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a',
        '7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c',
      ],
      [
        'b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c',
        'ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f',
      ],
      [
        'd5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52',
        '4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a',
      ],
      [
        'd3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb',
        'bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46',
      ],
      [
        '463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065',
        'bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f',
      ],
      [
        '7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917',
        '603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03',
      ],
      [
        '74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9',
        'cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08',
      ],
      [
        '30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3',
        '553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8',
      ],
      [
        '9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57',
        '712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373',
      ],
      [
        '176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66',
        'ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3',
      ],
      [
        '75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8',
        '9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8',
      ],
      [
        '809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721',
        '9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1',
      ],
      [
        '1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180',
        '4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9',
      ],
    ],
  },
};

},{}],106:[function(require,module,exports){
'use strict';

var utils = exports;
var BN = require('bn.js');
var minAssert = require('minimalistic-assert');
var minUtils = require('minimalistic-crypto-utils');

utils.assert = minAssert;
utils.toArray = minUtils.toArray;
utils.zero2 = minUtils.zero2;
utils.toHex = minUtils.toHex;
utils.encode = minUtils.encode;

// Represent num in a w-NAF form
function getNAF(num, w, bits) {
  var naf = new Array(Math.max(num.bitLength(), bits) + 1);
  naf.fill(0);

  var ws = 1 << (w + 1);
  var k = num.clone();

  for (var i = 0; i < naf.length; i++) {
    var z;
    var mod = k.andln(ws - 1);
    if (k.isOdd()) {
      if (mod > (ws >> 1) - 1)
        z = (ws >> 1) - mod;
      else
        z = mod;
      k.isubn(z);
    } else {
      z = 0;
    }

    naf[i] = z;
    k.iushrn(1);
  }

  return naf;
}
utils.getNAF = getNAF;

// Represent k1, k2 in a Joint Sparse Form
function getJSF(k1, k2) {
  var jsf = [
    [],
    [],
  ];

  k1 = k1.clone();
  k2 = k2.clone();
  var d1 = 0;
  var d2 = 0;
  var m8;
  while (k1.cmpn(-d1) > 0 || k2.cmpn(-d2) > 0) {
    // First phase
    var m14 = (k1.andln(3) + d1) & 3;
    var m24 = (k2.andln(3) + d2) & 3;
    if (m14 === 3)
      m14 = -1;
    if (m24 === 3)
      m24 = -1;
    var u1;
    if ((m14 & 1) === 0) {
      u1 = 0;
    } else {
      m8 = (k1.andln(7) + d1) & 7;
      if ((m8 === 3 || m8 === 5) && m24 === 2)
        u1 = -m14;
      else
        u1 = m14;
    }
    jsf[0].push(u1);

    var u2;
    if ((m24 & 1) === 0) {
      u2 = 0;
    } else {
      m8 = (k2.andln(7) + d2) & 7;
      if ((m8 === 3 || m8 === 5) && m14 === 2)
        u2 = -m24;
      else
        u2 = m24;
    }
    jsf[1].push(u2);

    // Second phase
    if (2 * d1 === u1 + 1)
      d1 = 1 - d1;
    if (2 * d2 === u2 + 1)
      d2 = 1 - d2;
    k1.iushrn(1);
    k2.iushrn(1);
  }

  return jsf;
}
utils.getJSF = getJSF;

function cachedProperty(obj, name, computer) {
  var key = '_' + name;
  obj.prototype[name] = function cachedProperty() {
    return this[key] !== undefined ? this[key] :
      this[key] = computer.call(this);
  };
}
utils.cachedProperty = cachedProperty;

function parseBytes(bytes) {
  return typeof bytes === 'string' ? utils.toArray(bytes, 'hex') :
    bytes;
}
utils.parseBytes = parseBytes;

function intFromLE(bytes) {
  return new BN(bytes, 'hex', 'le');
}
utils.intFromLE = intFromLE;


},{"bn.js":107,"minimalistic-assert":145,"minimalistic-crypto-utils":146}],107:[function(require,module,exports){
arguments[4][23][0].apply(exports,arguments)
},{"buffer":27,"dup":23}],108:[function(require,module,exports){
module.exports={
  "name": "elliptic",
  "version": "6.5.4",
  "description": "EC cryptography",
  "main": "lib/elliptic.js",
  "files": [
    "lib"
  ],
  "scripts": {
    "lint": "eslint lib test",
    "lint:fix": "npm run lint -- --fix",
    "unit": "istanbul test _mocha --reporter=spec test/index.js",
    "test": "npm run lint && npm run unit",
    "version": "grunt dist && git add dist/"
  },
  "repository": {
    "type": "git",
    "url": "git@github.com:indutny/elliptic"
  },
  "keywords": [
    "EC",
    "Elliptic",
    "curve",
    "Cryptography"
  ],
  "author": "Fedor Indutny <fedor@indutny.com>",
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/indutny/elliptic/issues"
  },
  "homepage": "https://github.com/indutny/elliptic",
  "devDependencies": {
    "brfs": "^2.0.2",
    "coveralls": "^3.1.0",
    "eslint": "^7.6.0",
    "grunt": "^1.2.1",
    "grunt-browserify": "^5.3.0",
    "grunt-cli": "^1.3.2",
    "grunt-contrib-connect": "^3.0.0",
    "grunt-contrib-copy": "^1.0.0",
    "grunt-contrib-uglify": "^5.0.0",
    "grunt-mocha-istanbul": "^5.0.2",
    "grunt-saucelabs": "^9.0.1",
    "istanbul": "^0.4.5",
    "mocha": "^8.0.1"
  },
  "dependencies": {
    "bn.js": "^4.11.9",
    "brorand": "^1.1.0",
    "hash.js": "^1.0.0",
    "hmac-drbg": "^1.0.1",
    "inherits": "^2.0.4",
    "minimalistic-assert": "^1.0.1",
    "minimalistic-crypto-utils": "^1.0.1"
  }
}

},{}],109:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

var R = typeof Reflect === 'object' ? Reflect : null
var ReflectApply = R && typeof R.apply === 'function'
  ? R.apply
  : function ReflectApply(target, receiver, args) {
    return Function.prototype.apply.call(target, receiver, args);
  }

var ReflectOwnKeys
if (R && typeof R.ownKeys === 'function') {
  ReflectOwnKeys = R.ownKeys
} else if (Object.getOwnPropertySymbols) {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target)
      .concat(Object.getOwnPropertySymbols(target));
  };
} else {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target);
  };
}

function ProcessEmitWarning(warning) {
  if (console && console.warn) console.warn(warning);
}

var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
  return value !== value;
}

function EventEmitter() {
  EventEmitter.init.call(this);
}
module.exports = EventEmitter;
module.exports.once = once;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
var defaultMaxListeners = 10;

function checkListener(listener) {
  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }
}

Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
  enumerable: true,
  get: function() {
    return defaultMaxListeners;
  },
  set: function(arg) {
    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + '.');
    }
    defaultMaxListeners = arg;
  }
});

EventEmitter.init = function() {

  if (this._events === undefined ||
      this._events === Object.getPrototypeOf(this)._events) {
    this._events = Object.create(null);
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
};

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.');
  }
  this._maxListeners = n;
  return this;
};

function _getMaxListeners(that) {
  if (that._maxListeners === undefined)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return _getMaxListeners(this);
};

EventEmitter.prototype.emit = function emit(type) {
  var args = [];
  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
  var doError = (type === 'error');

  var events = this._events;
  if (events !== undefined)
    doError = (doError && events.error === undefined);
  else if (!doError)
    return false;

  // If there is no 'error' event listener then throw.
  if (doError) {
    var er;
    if (args.length > 0)
      er = args[0];
    if (er instanceof Error) {
      // Note: The comments on the `throw` lines are intentional, they show
      // up in Node's output if this results in an unhandled exception.
      throw er; // Unhandled 'error' event
    }
    // At least give some kind of context to the user
    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
    err.context = er;
    throw err; // Unhandled 'error' event
  }

  var handler = events[type];

  if (handler === undefined)
    return false;

  if (typeof handler === 'function') {
    ReflectApply(handler, this, args);
  } else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      ReflectApply(listeners[i], this, args);
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;

  checkListener(listener);

  events = target._events;
  if (events === undefined) {
    events = target._events = Object.create(null);
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener !== undefined) {
      target.emit('newListener', type,
                  listener.listener ? listener.listener : listener);

      // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object
      events = target._events;
    }
    existing = events[type];
  }

  if (existing === undefined) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] =
        prepend ? [listener, existing] : [existing, listener];
      // If we've already got an array, just append.
    } else if (prepend) {
      existing.unshift(listener);
    } else {
      existing.push(listener);
    }

    // Check for listener leak
    m = _getMaxListeners(target);
    if (m > 0 && existing.length > m && !existing.warned) {
      existing.warned = true;
      // No error code for this since it is a Warning
      // eslint-disable-next-line no-restricted-syntax
      var w = new Error('Possible EventEmitter memory leak detected. ' +
                          existing.length + ' ' + String(type) + ' listeners ' +
                          'added. Use emitter.setMaxListeners() to ' +
                          'increase limit');
      w.name = 'MaxListenersExceededWarning';
      w.emitter = target;
      w.type = type;
      w.count = existing.length;
      ProcessEmitWarning(w);
    }
  }

  return target;
}

EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener =
    function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };

function onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    if (arguments.length === 0)
      return this.listener.call(this.target);
    return this.listener.apply(this.target, arguments);
  }
}

function _onceWrap(target, type, listener) {
  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };
  var wrapped = onceWrapper.bind(state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}

EventEmitter.prototype.once = function once(type, listener) {
  checkListener(listener);
  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener =
    function prependOnceListener(type, listener) {
      checkListener(listener);
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };

// Emits a 'removeListener' event if and only if the listener was removed.
EventEmitter.prototype.removeListener =
    function removeListener(type, listener) {
      var list, events, position, i, originalListener;

      checkListener(listener);

      events = this._events;
      if (events === undefined)
        return this;

      list = events[type];
      if (list === undefined)
        return this;

      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = Object.create(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit('removeListener', type, list.listener || listener);
        }
      } else if (typeof list !== 'function') {
        position = -1;

        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }

        if (position < 0)
          return this;

        if (position === 0)
          list.shift();
        else {
          spliceOne(list, position);
        }

        if (list.length === 1)
          events[type] = list[0];

        if (events.removeListener !== undefined)
          this.emit('removeListener', type, originalListener || listener);
      }

      return this;
    };

EventEmitter.prototype.off = EventEmitter.prototype.removeListener;

EventEmitter.prototype.removeAllListeners =
    function removeAllListeners(type) {
      var listeners, events, i;

      events = this._events;
      if (events === undefined)
        return this;

      // not listening for removeListener, no need to emit
      if (events.removeListener === undefined) {
        if (arguments.length === 0) {
          this._events = Object.create(null);
          this._eventsCount = 0;
        } else if (events[type] !== undefined) {
          if (--this._eventsCount === 0)
            this._events = Object.create(null);
          else
            delete events[type];
        }
        return this;
      }

      // emit removeListener for all listeners on all events
      if (arguments.length === 0) {
        var keys = Object.keys(events);
        var key;
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          if (key === 'removeListener') continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners('removeListener');
        this._events = Object.create(null);
        this._eventsCount = 0;
        return this;
      }

      listeners = events[type];

      if (typeof listeners === 'function') {
        this.removeListener(type, listeners);
      } else if (listeners !== undefined) {
        // LIFO order
        for (i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners[i]);
        }
      }

      return this;
    };

function _listeners(target, type, unwrap) {
  var events = target._events;

  if (events === undefined)
    return [];

  var evlistener = events[type];
  if (evlistener === undefined)
    return [];

  if (typeof evlistener === 'function')
    return unwrap ? [evlistener.listener || evlistener] : [evlistener];

  return unwrap ?
    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}

EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};

EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};

EventEmitter.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events = this._events;

  if (events !== undefined) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener !== undefined) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};

function arrayClone(arr, n) {
  var copy = new Array(n);
  for (var i = 0; i < n; ++i)
    copy[i] = arr[i];
  return copy;
}

function spliceOne(list, index) {
  for (; index + 1 < list.length; index++)
    list[index] = list[index + 1];
  list.pop();
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}

function once(emitter, name) {
  return new Promise(function (resolve, reject) {
    function errorListener(err) {
      emitter.removeListener(name, resolver);
      reject(err);
    }

    function resolver() {
      if (typeof emitter.removeListener === 'function') {
        emitter.removeListener('error', errorListener);
      }
      resolve([].slice.call(arguments));
    };

    eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });
    if (name !== 'error') {
      addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
    }
  });
}

function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
  if (typeof emitter.on === 'function') {
    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);
  }
}

function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
  if (typeof emitter.on === 'function') {
    if (flags.once) {
      emitter.once(name, listener);
    } else {
      emitter.on(name, listener);
    }
  } else if (typeof emitter.addEventListener === 'function') {
    // EventTarget does not have `error` event semantics like Node
    // EventEmitters, we do not listen for `error` events here.
    emitter.addEventListener(name, function wrapListener(arg) {
      // IE does not have builtin `{ once: true }` support so we
      // have to do it manually.
      if (flags.once) {
        emitter.removeEventListener(name, wrapListener);
      }
      listener(arg);
    });
  } else {
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
  }
}

},{}],110:[function(require,module,exports){
var Buffer = require('safe-buffer').Buffer
var MD5 = require('md5.js')

/* eslint-disable camelcase */
function EVP_BytesToKey (password, salt, keyBits, ivLen) {
  if (!Buffer.isBuffer(password)) password = Buffer.from(password, 'binary')
  if (salt) {
    if (!Buffer.isBuffer(salt)) salt = Buffer.from(salt, 'binary')
    if (salt.length !== 8) throw new RangeError('salt should be Buffer with 8 byte length')
  }

  var keyLen = keyBits / 8
  var key = Buffer.alloc(keyLen)
  var iv = Buffer.alloc(ivLen || 0)
  var tmp = Buffer.alloc(0)

  while (keyLen > 0 || ivLen > 0) {
    var hash = new MD5()
    hash.update(tmp)
    hash.update(password)
    if (salt) hash.update(salt)
    tmp = hash.digest()

    var used = 0

    if (keyLen > 0) {
      var keyStart = key.length - keyLen
      used = Math.min(keyLen, tmp.length)
      tmp.copy(key, keyStart, 0, used)
      keyLen -= used
    }

    if (used < tmp.length && ivLen > 0) {
      var ivStart = iv.length - ivLen
      var length = Math.min(ivLen, tmp.length - used)
      tmp.copy(iv, ivStart, used, used + length)
      ivLen -= length
    }
  }

  tmp.fill(0)
  return { key: key, iv: iv }
}

module.exports = EVP_BytesToKey

},{"md5.js":142,"safe-buffer":170}],111:[function(require,module,exports){
'use strict'
var Buffer = require('safe-buffer').Buffer
var Transform = require('readable-stream').Transform
var inherits = require('inherits')

function throwIfNotStringOrBuffer (val, prefix) {
  if (!Buffer.isBuffer(val) && typeof val !== 'string') {
    throw new TypeError(prefix + ' must be a string or a buffer')
  }
}

function HashBase (blockSize) {
  Transform.call(this)

  this._block = Buffer.allocUnsafe(blockSize)
  this._blockSize = blockSize
  this._blockOffset = 0
  this._length = [0, 0, 0, 0]

  this._finalized = false
}

inherits(HashBase, Transform)

HashBase.prototype._transform = function (chunk, encoding, callback) {
  var error = null
  try {
    this.update(chunk, encoding)
  } catch (err) {
    error = err
  }

  callback(error)
}

HashBase.prototype._flush = function (callback) {
  var error = null
  try {
    this.push(this.digest())
  } catch (err) {
    error = err
  }

  callback(error)
}

HashBase.prototype.update = function (data, encoding) {
  throwIfNotStringOrBuffer(data, 'Data')
  if (this._finalized) throw new Error('Digest already called')
  if (!Buffer.isBuffer(data)) data = Buffer.from(data, encoding)

  // consume data
  var block = this._block
  var offset = 0
  while (this._blockOffset + data.length - offset >= this._blockSize) {
    for (var i = this._blockOffset; i < this._blockSize;) block[i++] = data[offset++]
    this._update()
    this._blockOffset = 0
  }
  while (offset < data.length) block[this._blockOffset++] = data[offset++]

  // update length
  for (var j = 0, carry = data.length * 8; carry > 0; ++j) {
    this._length[j] += carry
    carry = (this._length[j] / 0x0100000000) | 0
    if (carry > 0) this._length[j] -= 0x0100000000 * carry
  }

  return this
}

HashBase.prototype._update = function () {
  throw new Error('_update is not implemented')
}

HashBase.prototype.digest = function (encoding) {
  if (this._finalized) throw new Error('Digest already called')
  this._finalized = true

  var digest = this._digest()
  if (encoding !== undefined) digest = digest.toString(encoding)

  // reset state
  this._block.fill(0)
  this._blockOffset = 0
  for (var i = 0; i < 4; ++i) this._length[i] = 0

  return digest
}

HashBase.prototype._digest = function () {
  throw new Error('_digest is not implemented')
}

module.exports = HashBase

},{"inherits":141,"readable-stream":126,"safe-buffer":170}],112:[function(require,module,exports){
arguments[4][55][0].apply(exports,arguments)
},{"dup":55}],113:[function(require,module,exports){
arguments[4][56][0].apply(exports,arguments)
},{"./_stream_readable":115,"./_stream_writable":117,"_process":159,"dup":56,"inherits":141}],114:[function(require,module,exports){
arguments[4][57][0].apply(exports,arguments)
},{"./_stream_transform":116,"dup":57,"inherits":141}],115:[function(require,module,exports){
arguments[4][58][0].apply(exports,arguments)
},{"../errors":112,"./_stream_duplex":113,"./internal/streams/async_iterator":118,"./internal/streams/buffer_list":119,"./internal/streams/destroy":120,"./internal/streams/from":122,"./internal/streams/state":124,"./internal/streams/stream":125,"_process":159,"buffer":72,"dup":58,"events":109,"inherits":141,"string_decoder/":195,"util":27}],116:[function(require,module,exports){
arguments[4][59][0].apply(exports,arguments)
},{"../errors":112,"./_stream_duplex":113,"dup":59,"inherits":141}],117:[function(require,module,exports){
arguments[4][60][0].apply(exports,arguments)
},{"../errors":112,"./_stream_duplex":113,"./internal/streams/destroy":120,"./internal/streams/state":124,"./internal/streams/stream":125,"_process":159,"buffer":72,"dup":60,"inherits":141,"util-deprecate":196}],118:[function(require,module,exports){
arguments[4][61][0].apply(exports,arguments)
},{"./end-of-stream":121,"_process":159,"dup":61}],119:[function(require,module,exports){
arguments[4][62][0].apply(exports,arguments)
},{"buffer":72,"dup":62,"util":27}],120:[function(require,module,exports){
arguments[4][63][0].apply(exports,arguments)
},{"_process":159,"dup":63}],121:[function(require,module,exports){
arguments[4][64][0].apply(exports,arguments)
},{"../../../errors":112,"dup":64}],122:[function(require,module,exports){
arguments[4][65][0].apply(exports,arguments)
},{"dup":65}],123:[function(require,module,exports){
arguments[4][66][0].apply(exports,arguments)
},{"../../../errors":112,"./end-of-stream":121,"dup":66}],124:[function(require,module,exports){
arguments[4][67][0].apply(exports,arguments)
},{"../../../errors":112,"dup":67}],125:[function(require,module,exports){
arguments[4][68][0].apply(exports,arguments)
},{"dup":68,"events":109}],126:[function(require,module,exports){
arguments[4][69][0].apply(exports,arguments)
},{"./lib/_stream_duplex.js":113,"./lib/_stream_passthrough.js":114,"./lib/_stream_readable.js":115,"./lib/_stream_transform.js":116,"./lib/_stream_writable.js":117,"./lib/internal/streams/end-of-stream.js":121,"./lib/internal/streams/pipeline.js":123,"dup":69}],127:[function(require,module,exports){
var hash = exports;

hash.utils = require('./hash/utils');
hash.common = require('./hash/common');
hash.sha = require('./hash/sha');
hash.ripemd = require('./hash/ripemd');
hash.hmac = require('./hash/hmac');

// Proxy hash functions to the main object
hash.sha1 = hash.sha.sha1;
hash.sha256 = hash.sha.sha256;
hash.sha224 = hash.sha.sha224;
hash.sha384 = hash.sha.sha384;
hash.sha512 = hash.sha.sha512;
hash.ripemd160 = hash.ripemd.ripemd160;

},{"./hash/common":128,"./hash/hmac":129,"./hash/ripemd":130,"./hash/sha":131,"./hash/utils":138}],128:[function(require,module,exports){
'use strict';

var utils = require('./utils');
var assert = require('minimalistic-assert');

function BlockHash() {
  this.pending = null;
  this.pendingTotal = 0;
  this.blockSize = this.constructor.blockSize;
  this.outSize = this.constructor.outSize;
  this.hmacStrength = this.constructor.hmacStrength;
  this.padLength = this.constructor.padLength / 8;
  this.endian = 'big';

  this._delta8 = this.blockSize / 8;
  this._delta32 = this.blockSize / 32;
}
exports.BlockHash = BlockHash;

BlockHash.prototype.update = function update(msg, enc) {
  // Convert message to array, pad it, and join into 32bit blocks
  msg = utils.toArray(msg, enc);
  if (!this.pending)
    this.pending = msg;
  else
    this.pending = this.pending.concat(msg);
  this.pendingTotal += msg.length;

  // Enough data, try updating
  if (this.pending.length >= this._delta8) {
    msg = this.pending;

    // Process pending data in blocks
    var r = msg.length % this._delta8;
    this.pending = msg.slice(msg.length - r, msg.length);
    if (this.pending.length === 0)
      this.pending = null;

    msg = utils.join32(msg, 0, msg.length - r, this.endian);
    for (var i = 0; i < msg.length; i += this._delta32)
      this._update(msg, i, i + this._delta32);
  }

  return this;
};

BlockHash.prototype.digest = function digest(enc) {
  this.update(this._pad());
  assert(this.pending === null);

  return this._digest(enc);
};

BlockHash.prototype._pad = function pad() {
  var len = this.pendingTotal;
  var bytes = this._delta8;
  var k = bytes - ((len + this.padLength) % bytes);
  var res = new Array(k + this.padLength);
  res[0] = 0x80;
  for (var i = 1; i < k; i++)
    res[i] = 0;

  // Append length
  len <<= 3;
  if (this.endian === 'big') {
    for (var t = 8; t < this.padLength; t++)
      res[i++] = 0;

    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = (len >>> 24) & 0xff;
    res[i++] = (len >>> 16) & 0xff;
    res[i++] = (len >>> 8) & 0xff;
    res[i++] = len & 0xff;
  } else {
    res[i++] = len & 0xff;
    res[i++] = (len >>> 8) & 0xff;
    res[i++] = (len >>> 16) & 0xff;
    res[i++] = (len >>> 24) & 0xff;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;

    for (t = 8; t < this.padLength; t++)
      res[i++] = 0;
  }

  return res;
};

},{"./utils":138,"minimalistic-assert":145}],129:[function(require,module,exports){
'use strict';

var utils = require('./utils');
var assert = require('minimalistic-assert');

function Hmac(hash, key, enc) {
  if (!(this instanceof Hmac))
    return new Hmac(hash, key, enc);
  this.Hash = hash;
  this.blockSize = hash.blockSize / 8;
  this.outSize = hash.outSize / 8;
  this.inner = null;
  this.outer = null;

  this._init(utils.toArray(key, enc));
}
module.exports = Hmac;

Hmac.prototype._init = function init(key) {
  // Shorten key, if needed
  if (key.length > this.blockSize)
    key = new this.Hash().update(key).digest();
  assert(key.length <= this.blockSize);

  // Add padding to key
  for (var i = key.length; i < this.blockSize; i++)
    key.push(0);

  for (i = 0; i < key.length; i++)
    key[i] ^= 0x36;
  this.inner = new this.Hash().update(key);

  // 0x36 ^ 0x5c = 0x6a
  for (i = 0; i < key.length; i++)
    key[i] ^= 0x6a;
  this.outer = new this.Hash().update(key);
};

Hmac.prototype.update = function update(msg, enc) {
  this.inner.update(msg, enc);
  return this;
};

Hmac.prototype.digest = function digest(enc) {
  this.outer.update(this.inner.digest());
  return this.outer.digest(enc);
};

},{"./utils":138,"minimalistic-assert":145}],130:[function(require,module,exports){
'use strict';

var utils = require('./utils');
var common = require('./common');

var rotl32 = utils.rotl32;
var sum32 = utils.sum32;
var sum32_3 = utils.sum32_3;
var sum32_4 = utils.sum32_4;
var BlockHash = common.BlockHash;

function RIPEMD160() {
  if (!(this instanceof RIPEMD160))
    return new RIPEMD160();

  BlockHash.call(this);

  this.h = [ 0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0 ];
  this.endian = 'little';
}
utils.inherits(RIPEMD160, BlockHash);
exports.ripemd160 = RIPEMD160;

RIPEMD160.blockSize = 512;
RIPEMD160.outSize = 160;
RIPEMD160.hmacStrength = 192;
RIPEMD160.padLength = 64;

RIPEMD160.prototype._update = function update(msg, start) {
  var A = this.h[0];
  var B = this.h[1];
  var C = this.h[2];
  var D = this.h[3];
  var E = this.h[4];
  var Ah = A;
  var Bh = B;
  var Ch = C;
  var Dh = D;
  var Eh = E;
  for (var j = 0; j < 80; j++) {
    var T = sum32(
      rotl32(
        sum32_4(A, f(j, B, C, D), msg[r[j] + start], K(j)),
        s[j]),
      E);
    A = E;
    E = D;
    D = rotl32(C, 10);
    C = B;
    B = T;
    T = sum32(
      rotl32(
        sum32_4(Ah, f(79 - j, Bh, Ch, Dh), msg[rh[j] + start], Kh(j)),
        sh[j]),
      Eh);
    Ah = Eh;
    Eh = Dh;
    Dh = rotl32(Ch, 10);
    Ch = Bh;
    Bh = T;
  }
  T = sum32_3(this.h[1], C, Dh);
  this.h[1] = sum32_3(this.h[2], D, Eh);
  this.h[2] = sum32_3(this.h[3], E, Ah);
  this.h[3] = sum32_3(this.h[4], A, Bh);
  this.h[4] = sum32_3(this.h[0], B, Ch);
  this.h[0] = T;
};

RIPEMD160.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils.toHex32(this.h, 'little');
  else
    return utils.split32(this.h, 'little');
};

function f(j, x, y, z) {
  if (j <= 15)
    return x ^ y ^ z;
  else if (j <= 31)
    return (x & y) | ((~x) & z);
  else if (j <= 47)
    return (x | (~y)) ^ z;
  else if (j <= 63)
    return (x & z) | (y & (~z));
  else
    return x ^ (y | (~z));
}

function K(j) {
  if (j <= 15)
    return 0x00000000;
  else if (j <= 31)
    return 0x5a827999;
  else if (j <= 47)
    return 0x6ed9eba1;
  else if (j <= 63)
    return 0x8f1bbcdc;
  else
    return 0xa953fd4e;
}

function Kh(j) {
  if (j <= 15)
    return 0x50a28be6;
  else if (j <= 31)
    return 0x5c4dd124;
  else if (j <= 47)
    return 0x6d703ef3;
  else if (j <= 63)
    return 0x7a6d76e9;
  else
    return 0x00000000;
}

var r = [
  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
  7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8,
  3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12,
  1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2,
  4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13
];

var rh = [
  5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12,
  6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2,
  15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13,
  8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14,
  12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11
];

var s = [
  11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8,
  7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12,
  11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5,
  11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12,
  9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6
];

var sh = [
  8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6,
  9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11,
  9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5,
  15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8,
  8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11
];

},{"./common":128,"./utils":138}],131:[function(require,module,exports){
'use strict';

exports.sha1 = require('./sha/1');
exports.sha224 = require('./sha/224');
exports.sha256 = require('./sha/256');
exports.sha384 = require('./sha/384');
exports.sha512 = require('./sha/512');

},{"./sha/1":132,"./sha/224":133,"./sha/256":134,"./sha/384":135,"./sha/512":136}],132:[function(require,module,exports){
'use strict';

var utils = require('../utils');
var common = require('../common');
var shaCommon = require('./common');

var rotl32 = utils.rotl32;
var sum32 = utils.sum32;
var sum32_5 = utils.sum32_5;
var ft_1 = shaCommon.ft_1;
var BlockHash = common.BlockHash;

var sha1_K = [
  0x5A827999, 0x6ED9EBA1,
  0x8F1BBCDC, 0xCA62C1D6
];

function SHA1() {
  if (!(this instanceof SHA1))
    return new SHA1();

  BlockHash.call(this);
  this.h = [
    0x67452301, 0xefcdab89, 0x98badcfe,
    0x10325476, 0xc3d2e1f0 ];
  this.W = new Array(80);
}

utils.inherits(SHA1, BlockHash);
module.exports = SHA1;

SHA1.blockSize = 512;
SHA1.outSize = 160;
SHA1.hmacStrength = 80;
SHA1.padLength = 64;

SHA1.prototype._update = function _update(msg, start) {
  var W = this.W;

  for (var i = 0; i < 16; i++)
    W[i] = msg[start + i];

  for(; i < W.length; i++)
    W[i] = rotl32(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16], 1);

  var a = this.h[0];
  var b = this.h[1];
  var c = this.h[2];
  var d = this.h[3];
  var e = this.h[4];

  for (i = 0; i < W.length; i++) {
    var s = ~~(i / 20);
    var t = sum32_5(rotl32(a, 5), ft_1(s, b, c, d), e, W[i], sha1_K[s]);
    e = d;
    d = c;
    c = rotl32(b, 30);
    b = a;
    a = t;
  }

  this.h[0] = sum32(this.h[0], a);
  this.h[1] = sum32(this.h[1], b);
  this.h[2] = sum32(this.h[2], c);
  this.h[3] = sum32(this.h[3], d);
  this.h[4] = sum32(this.h[4], e);
};

SHA1.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils.toHex32(this.h, 'big');
  else
    return utils.split32(this.h, 'big');
};

},{"../common":128,"../utils":138,"./common":137}],133:[function(require,module,exports){
'use strict';

var utils = require('../utils');
var SHA256 = require('./256');

function SHA224() {
  if (!(this instanceof SHA224))
    return new SHA224();

  SHA256.call(this);
  this.h = [
    0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939,
    0xffc00b31, 0x68581511, 0x64f98fa7, 0xbefa4fa4 ];
}
utils.inherits(SHA224, SHA256);
module.exports = SHA224;

SHA224.blockSize = 512;
SHA224.outSize = 224;
SHA224.hmacStrength = 192;
SHA224.padLength = 64;

SHA224.prototype._digest = function digest(enc) {
  // Just truncate output
  if (enc === 'hex')
    return utils.toHex32(this.h.slice(0, 7), 'big');
  else
    return utils.split32(this.h.slice(0, 7), 'big');
};


},{"../utils":138,"./256":134}],134:[function(require,module,exports){
'use strict';

var utils = require('../utils');
var common = require('../common');
var shaCommon = require('./common');
var assert = require('minimalistic-assert');

var sum32 = utils.sum32;
var sum32_4 = utils.sum32_4;
var sum32_5 = utils.sum32_5;
var ch32 = shaCommon.ch32;
var maj32 = shaCommon.maj32;
var s0_256 = shaCommon.s0_256;
var s1_256 = shaCommon.s1_256;
var g0_256 = shaCommon.g0_256;
var g1_256 = shaCommon.g1_256;

var BlockHash = common.BlockHash;

var sha256_K = [
  0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5,
  0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
  0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,
  0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
  0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,
  0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
  0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7,
  0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
  0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,
  0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
  0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3,
  0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
  0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5,
  0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
  0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,
  0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
];

function SHA256() {
  if (!(this instanceof SHA256))
    return new SHA256();

  BlockHash.call(this);
  this.h = [
    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a,
    0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19
  ];
  this.k = sha256_K;
  this.W = new Array(64);
}
utils.inherits(SHA256, BlockHash);
module.exports = SHA256;

SHA256.blockSize = 512;
SHA256.outSize = 256;
SHA256.hmacStrength = 192;
SHA256.padLength = 64;

SHA256.prototype._update = function _update(msg, start) {
  var W = this.W;

  for (var i = 0; i < 16; i++)
    W[i] = msg[start + i];
  for (; i < W.length; i++)
    W[i] = sum32_4(g1_256(W[i - 2]), W[i - 7], g0_256(W[i - 15]), W[i - 16]);

  var a = this.h[0];
  var b = this.h[1];
  var c = this.h[2];
  var d = this.h[3];
  var e = this.h[4];
  var f = this.h[5];
  var g = this.h[6];
  var h = this.h[7];

  assert(this.k.length === W.length);
  for (i = 0; i < W.length; i++) {
    var T1 = sum32_5(h, s1_256(e), ch32(e, f, g), this.k[i], W[i]);
    var T2 = sum32(s0_256(a), maj32(a, b, c));
    h = g;
    g = f;
    f = e;
    e = sum32(d, T1);
    d = c;
    c = b;
    b = a;
    a = sum32(T1, T2);
  }

  this.h[0] = sum32(this.h[0], a);
  this.h[1] = sum32(this.h[1], b);
  this.h[2] = sum32(this.h[2], c);
  this.h[3] = sum32(this.h[3], d);
  this.h[4] = sum32(this.h[4], e);
  this.h[5] = sum32(this.h[5], f);
  this.h[6] = sum32(this.h[6], g);
  this.h[7] = sum32(this.h[7], h);
};

SHA256.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils.toHex32(this.h, 'big');
  else
    return utils.split32(this.h, 'big');
};

},{"../common":128,"../utils":138,"./common":137,"minimalistic-assert":145}],135:[function(require,module,exports){
'use strict';

var utils = require('../utils');

var SHA512 = require('./512');

function SHA384() {
  if (!(this instanceof SHA384))
    return new SHA384();

  SHA512.call(this);
  this.h = [
    0xcbbb9d5d, 0xc1059ed8,
    0x629a292a, 0x367cd507,
    0x9159015a, 0x3070dd17,
    0x152fecd8, 0xf70e5939,
    0x67332667, 0xffc00b31,
    0x8eb44a87, 0x68581511,
    0xdb0c2e0d, 0x64f98fa7,
    0x47b5481d, 0xbefa4fa4 ];
}
utils.inherits(SHA384, SHA512);
module.exports = SHA384;

SHA384.blockSize = 1024;
SHA384.outSize = 384;
SHA384.hmacStrength = 192;
SHA384.padLength = 128;

SHA384.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils.toHex32(this.h.slice(0, 12), 'big');
  else
    return utils.split32(this.h.slice(0, 12), 'big');
};

},{"../utils":138,"./512":136}],136:[function(require,module,exports){
'use strict';

var utils = require('../utils');
var common = require('../common');
var assert = require('minimalistic-assert');

var rotr64_hi = utils.rotr64_hi;
var rotr64_lo = utils.rotr64_lo;
var shr64_hi = utils.shr64_hi;
var shr64_lo = utils.shr64_lo;
var sum64 = utils.sum64;
var sum64_hi = utils.sum64_hi;
var sum64_lo = utils.sum64_lo;
var sum64_4_hi = utils.sum64_4_hi;
var sum64_4_lo = utils.sum64_4_lo;
var sum64_5_hi = utils.sum64_5_hi;
var sum64_5_lo = utils.sum64_5_lo;

var BlockHash = common.BlockHash;

var sha512_K = [
  0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd,
  0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc,
  0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019,
  0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118,
  0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe,
  0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2,
  0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1,
  0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694,
  0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3,
  0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65,
  0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483,
  0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5,
  0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210,
  0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4,
  0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725,
  0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70,
  0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926,
  0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df,
  0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8,
  0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b,
  0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001,
  0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30,
  0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910,
  0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8,
  0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53,
  0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8,
  0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb,
  0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3,
  0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60,
  0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec,
  0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9,
  0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b,
  0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207,
  0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178,
  0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6,
  0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b,
  0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493,
  0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c,
  0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a,
  0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817
];

function SHA512() {
  if (!(this instanceof SHA512))
    return new SHA512();

  BlockHash.call(this);
  this.h = [
    0x6a09e667, 0xf3bcc908,
    0xbb67ae85, 0x84caa73b,
    0x3c6ef372, 0xfe94f82b,
    0xa54ff53a, 0x5f1d36f1,
    0x510e527f, 0xade682d1,
    0x9b05688c, 0x2b3e6c1f,
    0x1f83d9ab, 0xfb41bd6b,
    0x5be0cd19, 0x137e2179 ];
  this.k = sha512_K;
  this.W = new Array(160);
}
utils.inherits(SHA512, BlockHash);
module.exports = SHA512;

SHA512.blockSize = 1024;
SHA512.outSize = 512;
SHA512.hmacStrength = 192;
SHA512.padLength = 128;

SHA512.prototype._prepareBlock = function _prepareBlock(msg, start) {
  var W = this.W;

  // 32 x 32bit words
  for (var i = 0; i < 32; i++)
    W[i] = msg[start + i];
  for (; i < W.length; i += 2) {
    var c0_hi = g1_512_hi(W[i - 4], W[i - 3]);  // i - 2
    var c0_lo = g1_512_lo(W[i - 4], W[i - 3]);
    var c1_hi = W[i - 14];  // i - 7
    var c1_lo = W[i - 13];
    var c2_hi = g0_512_hi(W[i - 30], W[i - 29]);  // i - 15
    var c2_lo = g0_512_lo(W[i - 30], W[i - 29]);
    var c3_hi = W[i - 32];  // i - 16
    var c3_lo = W[i - 31];

    W[i] = sum64_4_hi(
      c0_hi, c0_lo,
      c1_hi, c1_lo,
      c2_hi, c2_lo,
      c3_hi, c3_lo);
    W[i + 1] = sum64_4_lo(
      c0_hi, c0_lo,
      c1_hi, c1_lo,
      c2_hi, c2_lo,
      c3_hi, c3_lo);
  }
};

SHA512.prototype._update = function _update(msg, start) {
  this._prepareBlock(msg, start);

  var W = this.W;

  var ah = this.h[0];
  var al = this.h[1];
  var bh = this.h[2];
  var bl = this.h[3];
  var ch = this.h[4];
  var cl = this.h[5];
  var dh = this.h[6];
  var dl = this.h[7];
  var eh = this.h[8];
  var el = this.h[9];
  var fh = this.h[10];
  var fl = this.h[11];
  var gh = this.h[12];
  var gl = this.h[13];
  var hh = this.h[14];
  var hl = this.h[15];

  assert(this.k.length === W.length);
  for (var i = 0; i < W.length; i += 2) {
    var c0_hi = hh;
    var c0_lo = hl;
    var c1_hi = s1_512_hi(eh, el);
    var c1_lo = s1_512_lo(eh, el);
    var c2_hi = ch64_hi(eh, el, fh, fl, gh, gl);
    var c2_lo = ch64_lo(eh, el, fh, fl, gh, gl);
    var c3_hi = this.k[i];
    var c3_lo = this.k[i + 1];
    var c4_hi = W[i];
    var c4_lo = W[i + 1];

    var T1_hi = sum64_5_hi(
      c0_hi, c0_lo,
      c1_hi, c1_lo,
      c2_hi, c2_lo,
      c3_hi, c3_lo,
      c4_hi, c4_lo);
    var T1_lo = sum64_5_lo(
      c0_hi, c0_lo,
      c1_hi, c1_lo,
      c2_hi, c2_lo,
      c3_hi, c3_lo,
      c4_hi, c4_lo);

    c0_hi = s0_512_hi(ah, al);
    c0_lo = s0_512_lo(ah, al);
    c1_hi = maj64_hi(ah, al, bh, bl, ch, cl);
    c1_lo = maj64_lo(ah, al, bh, bl, ch, cl);

    var T2_hi = sum64_hi(c0_hi, c0_lo, c1_hi, c1_lo);
    var T2_lo = sum64_lo(c0_hi, c0_lo, c1_hi, c1_lo);

    hh = gh;
    hl = gl;

    gh = fh;
    gl = fl;

    fh = eh;
    fl = el;

    eh = sum64_hi(dh, dl, T1_hi, T1_lo);
    el = sum64_lo(dl, dl, T1_hi, T1_lo);

    dh = ch;
    dl = cl;

    ch = bh;
    cl = bl;

    bh = ah;
    bl = al;

    ah = sum64_hi(T1_hi, T1_lo, T2_hi, T2_lo);
    al = sum64_lo(T1_hi, T1_lo, T2_hi, T2_lo);
  }

  sum64(this.h, 0, ah, al);
  sum64(this.h, 2, bh, bl);
  sum64(this.h, 4, ch, cl);
  sum64(this.h, 6, dh, dl);
  sum64(this.h, 8, eh, el);
  sum64(this.h, 10, fh, fl);
  sum64(this.h, 12, gh, gl);
  sum64(this.h, 14, hh, hl);
};

SHA512.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils.toHex32(this.h, 'big');
  else
    return utils.split32(this.h, 'big');
};

function ch64_hi(xh, xl, yh, yl, zh) {
  var r = (xh & yh) ^ ((~xh) & zh);
  if (r < 0)
    r += 0x100000000;
  return r;
}

function ch64_lo(xh, xl, yh, yl, zh, zl) {
  var r = (xl & yl) ^ ((~xl) & zl);
  if (r < 0)
    r += 0x100000000;
  return r;
}

function maj64_hi(xh, xl, yh, yl, zh) {
  var r = (xh & yh) ^ (xh & zh) ^ (yh & zh);
  if (r < 0)
    r += 0x100000000;
  return r;
}

function maj64_lo(xh, xl, yh, yl, zh, zl) {
  var r = (xl & yl) ^ (xl & zl) ^ (yl & zl);
  if (r < 0)
    r += 0x100000000;
  return r;
}

function s0_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 28);
  var c1_hi = rotr64_hi(xl, xh, 2);  // 34
  var c2_hi = rotr64_hi(xl, xh, 7);  // 39

  var r = c0_hi ^ c1_hi ^ c2_hi;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function s0_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 28);
  var c1_lo = rotr64_lo(xl, xh, 2);  // 34
  var c2_lo = rotr64_lo(xl, xh, 7);  // 39

  var r = c0_lo ^ c1_lo ^ c2_lo;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function s1_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 14);
  var c1_hi = rotr64_hi(xh, xl, 18);
  var c2_hi = rotr64_hi(xl, xh, 9);  // 41

  var r = c0_hi ^ c1_hi ^ c2_hi;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function s1_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 14);
  var c1_lo = rotr64_lo(xh, xl, 18);
  var c2_lo = rotr64_lo(xl, xh, 9);  // 41

  var r = c0_lo ^ c1_lo ^ c2_lo;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function g0_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 1);
  var c1_hi = rotr64_hi(xh, xl, 8);
  var c2_hi = shr64_hi(xh, xl, 7);

  var r = c0_hi ^ c1_hi ^ c2_hi;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function g0_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 1);
  var c1_lo = rotr64_lo(xh, xl, 8);
  var c2_lo = shr64_lo(xh, xl, 7);

  var r = c0_lo ^ c1_lo ^ c2_lo;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function g1_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 19);
  var c1_hi = rotr64_hi(xl, xh, 29);  // 61
  var c2_hi = shr64_hi(xh, xl, 6);

  var r = c0_hi ^ c1_hi ^ c2_hi;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function g1_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 19);
  var c1_lo = rotr64_lo(xl, xh, 29);  // 61
  var c2_lo = shr64_lo(xh, xl, 6);

  var r = c0_lo ^ c1_lo ^ c2_lo;
  if (r < 0)
    r += 0x100000000;
  return r;
}

},{"../common":128,"../utils":138,"minimalistic-assert":145}],137:[function(require,module,exports){
'use strict';

var utils = require('../utils');
var rotr32 = utils.rotr32;

function ft_1(s, x, y, z) {
  if (s === 0)
    return ch32(x, y, z);
  if (s === 1 || s === 3)
    return p32(x, y, z);
  if (s === 2)
    return maj32(x, y, z);
}
exports.ft_1 = ft_1;

function ch32(x, y, z) {
  return (x & y) ^ ((~x) & z);
}
exports.ch32 = ch32;

function maj32(x, y, z) {
  return (x & y) ^ (x & z) ^ (y & z);
}
exports.maj32 = maj32;

function p32(x, y, z) {
  return x ^ y ^ z;
}
exports.p32 = p32;

function s0_256(x) {
  return rotr32(x, 2) ^ rotr32(x, 13) ^ rotr32(x, 22);
}
exports.s0_256 = s0_256;

function s1_256(x) {
  return rotr32(x, 6) ^ rotr32(x, 11) ^ rotr32(x, 25);
}
exports.s1_256 = s1_256;

function g0_256(x) {
  return rotr32(x, 7) ^ rotr32(x, 18) ^ (x >>> 3);
}
exports.g0_256 = g0_256;

function g1_256(x) {
  return rotr32(x, 17) ^ rotr32(x, 19) ^ (x >>> 10);
}
exports.g1_256 = g1_256;

},{"../utils":138}],138:[function(require,module,exports){
'use strict';

var assert = require('minimalistic-assert');
var inherits = require('inherits');

exports.inherits = inherits;

function isSurrogatePair(msg, i) {
  if ((msg.charCodeAt(i) & 0xFC00) !== 0xD800) {
    return false;
  }
  if (i < 0 || i + 1 >= msg.length) {
    return false;
  }
  return (msg.charCodeAt(i + 1) & 0xFC00) === 0xDC00;
}

function toArray(msg, enc) {
  if (Array.isArray(msg))
    return msg.slice();
  if (!msg)
    return [];
  var res = [];
  if (typeof msg === 'string') {
    if (!enc) {
      // Inspired by stringToUtf8ByteArray() in closure-library by Google
      // https://github.com/google/closure-library/blob/8598d87242af59aac233270742c8984e2b2bdbe0/closure/goog/crypt/crypt.js#L117-L143
      // Apache License 2.0
      // https://github.com/google/closure-library/blob/master/LICENSE
      var p = 0;
      for (var i = 0; i < msg.length; i++) {
        var c = msg.charCodeAt(i);
        if (c < 128) {
          res[p++] = c;
        } else if (c < 2048) {
          res[p++] = (c >> 6) | 192;
          res[p++] = (c & 63) | 128;
        } else if (isSurrogatePair(msg, i)) {
          c = 0x10000 + ((c & 0x03FF) << 10) + (msg.charCodeAt(++i) & 0x03FF);
          res[p++] = (c >> 18) | 240;
          res[p++] = ((c >> 12) & 63) | 128;
          res[p++] = ((c >> 6) & 63) | 128;
          res[p++] = (c & 63) | 128;
        } else {
          res[p++] = (c >> 12) | 224;
          res[p++] = ((c >> 6) & 63) | 128;
          res[p++] = (c & 63) | 128;
        }
      }
    } else if (enc === 'hex') {
      msg = msg.replace(/[^a-z0-9]+/ig, '');
      if (msg.length % 2 !== 0)
        msg = '0' + msg;
      for (i = 0; i < msg.length; i += 2)
        res.push(parseInt(msg[i] + msg[i + 1], 16));
    }
  } else {
    for (i = 0; i < msg.length; i++)
      res[i] = msg[i] | 0;
  }
  return res;
}
exports.toArray = toArray;

function toHex(msg) {
  var res = '';
  for (var i = 0; i < msg.length; i++)
    res += zero2(msg[i].toString(16));
  return res;
}
exports.toHex = toHex;

function htonl(w) {
  var res = (w >>> 24) |
            ((w >>> 8) & 0xff00) |
            ((w << 8) & 0xff0000) |
            ((w & 0xff) << 24);
  return res >>> 0;
}
exports.htonl = htonl;

function toHex32(msg, endian) {
  var res = '';
  for (var i = 0; i < msg.length; i++) {
    var w = msg[i];
    if (endian === 'little')
      w = htonl(w);
    res += zero8(w.toString(16));
  }
  return res;
}
exports.toHex32 = toHex32;

function zero2(word) {
  if (word.length === 1)
    return '0' + word;
  else
    return word;
}
exports.zero2 = zero2;

function zero8(word) {
  if (word.length === 7)
    return '0' + word;
  else if (word.length === 6)
    return '00' + word;
  else if (word.length === 5)
    return '000' + word;
  else if (word.length === 4)
    return '0000' + word;
  else if (word.length === 3)
    return '00000' + word;
  else if (word.length === 2)
    return '000000' + word;
  else if (word.length === 1)
    return '0000000' + word;
  else
    return word;
}
exports.zero8 = zero8;

function join32(msg, start, end, endian) {
  var len = end - start;
  assert(len % 4 === 0);
  var res = new Array(len / 4);
  for (var i = 0, k = start; i < res.length; i++, k += 4) {
    var w;
    if (endian === 'big')
      w = (msg[k] << 24) | (msg[k + 1] << 16) | (msg[k + 2] << 8) | msg[k + 3];
    else
      w = (msg[k + 3] << 24) | (msg[k + 2] << 16) | (msg[k + 1] << 8) | msg[k];
    res[i] = w >>> 0;
  }
  return res;
}
exports.join32 = join32;

function split32(msg, endian) {
  var res = new Array(msg.length * 4);
  for (var i = 0, k = 0; i < msg.length; i++, k += 4) {
    var m = msg[i];
    if (endian === 'big') {
      res[k] = m >>> 24;
      res[k + 1] = (m >>> 16) & 0xff;
      res[k + 2] = (m >>> 8) & 0xff;
      res[k + 3] = m & 0xff;
    } else {
      res[k + 3] = m >>> 24;
      res[k + 2] = (m >>> 16) & 0xff;
      res[k + 1] = (m >>> 8) & 0xff;
      res[k] = m & 0xff;
    }
  }
  return res;
}
exports.split32 = split32;

function rotr32(w, b) {
  return (w >>> b) | (w << (32 - b));
}
exports.rotr32 = rotr32;

function rotl32(w, b) {
  return (w << b) | (w >>> (32 - b));
}
exports.rotl32 = rotl32;

function sum32(a, b) {
  return (a + b) >>> 0;
}
exports.sum32 = sum32;

function sum32_3(a, b, c) {
  return (a + b + c) >>> 0;
}
exports.sum32_3 = sum32_3;

function sum32_4(a, b, c, d) {
  return (a + b + c + d) >>> 0;
}
exports.sum32_4 = sum32_4;

function sum32_5(a, b, c, d, e) {
  return (a + b + c + d + e) >>> 0;
}
exports.sum32_5 = sum32_5;

function sum64(buf, pos, ah, al) {
  var bh = buf[pos];
  var bl = buf[pos + 1];

  var lo = (al + bl) >>> 0;
  var hi = (lo < al ? 1 : 0) + ah + bh;
  buf[pos] = hi >>> 0;
  buf[pos + 1] = lo;
}
exports.sum64 = sum64;

function sum64_hi(ah, al, bh, bl) {
  var lo = (al + bl) >>> 0;
  var hi = (lo < al ? 1 : 0) + ah + bh;
  return hi >>> 0;
}
exports.sum64_hi = sum64_hi;

function sum64_lo(ah, al, bh, bl) {
  var lo = al + bl;
  return lo >>> 0;
}
exports.sum64_lo = sum64_lo;

function sum64_4_hi(ah, al, bh, bl, ch, cl, dh, dl) {
  var carry = 0;
  var lo = al;
  lo = (lo + bl) >>> 0;
  carry += lo < al ? 1 : 0;
  lo = (lo + cl) >>> 0;
  carry += lo < cl ? 1 : 0;
  lo = (lo + dl) >>> 0;
  carry += lo < dl ? 1 : 0;

  var hi = ah + bh + ch + dh + carry;
  return hi >>> 0;
}
exports.sum64_4_hi = sum64_4_hi;

function sum64_4_lo(ah, al, bh, bl, ch, cl, dh, dl) {
  var lo = al + bl + cl + dl;
  return lo >>> 0;
}
exports.sum64_4_lo = sum64_4_lo;

function sum64_5_hi(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
  var carry = 0;
  var lo = al;
  lo = (lo + bl) >>> 0;
  carry += lo < al ? 1 : 0;
  lo = (lo + cl) >>> 0;
  carry += lo < cl ? 1 : 0;
  lo = (lo + dl) >>> 0;
  carry += lo < dl ? 1 : 0;
  lo = (lo + el) >>> 0;
  carry += lo < el ? 1 : 0;

  var hi = ah + bh + ch + dh + eh + carry;
  return hi >>> 0;
}
exports.sum64_5_hi = sum64_5_hi;

function sum64_5_lo(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
  var lo = al + bl + cl + dl + el;

  return lo >>> 0;
}
exports.sum64_5_lo = sum64_5_lo;

function rotr64_hi(ah, al, num) {
  var r = (al << (32 - num)) | (ah >>> num);
  return r >>> 0;
}
exports.rotr64_hi = rotr64_hi;

function rotr64_lo(ah, al, num) {
  var r = (ah << (32 - num)) | (al >>> num);
  return r >>> 0;
}
exports.rotr64_lo = rotr64_lo;

function shr64_hi(ah, al, num) {
  return ah >>> num;
}
exports.shr64_hi = shr64_hi;

function shr64_lo(ah, al, num) {
  var r = (ah << (32 - num)) | (al >>> num);
  return r >>> 0;
}
exports.shr64_lo = shr64_lo;

},{"inherits":141,"minimalistic-assert":145}],139:[function(require,module,exports){
'use strict';

var hash = require('hash.js');
var utils = require('minimalistic-crypto-utils');
var assert = require('minimalistic-assert');

function HmacDRBG(options) {
  if (!(this instanceof HmacDRBG))
    return new HmacDRBG(options);
  this.hash = options.hash;
  this.predResist = !!options.predResist;

  this.outLen = this.hash.outSize;
  this.minEntropy = options.minEntropy || this.hash.hmacStrength;

  this._reseed = null;
  this.reseedInterval = null;
  this.K = null;
  this.V = null;

  var entropy = utils.toArray(options.entropy, options.entropyEnc || 'hex');
  var nonce = utils.toArray(options.nonce, options.nonceEnc || 'hex');
  var pers = utils.toArray(options.pers, options.persEnc || 'hex');
  assert(entropy.length >= (this.minEntropy / 8),
         'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits');
  this._init(entropy, nonce, pers);
}
module.exports = HmacDRBG;

HmacDRBG.prototype._init = function init(entropy, nonce, pers) {
  var seed = entropy.concat(nonce).concat(pers);

  this.K = new Array(this.outLen / 8);
  this.V = new Array(this.outLen / 8);
  for (var i = 0; i < this.V.length; i++) {
    this.K[i] = 0x00;
    this.V[i] = 0x01;
  }

  this._update(seed);
  this._reseed = 1;
  this.reseedInterval = 0x1000000000000;  // 2^48
};

HmacDRBG.prototype._hmac = function hmac() {
  return new hash.hmac(this.hash, this.K);
};

HmacDRBG.prototype._update = function update(seed) {
  var kmac = this._hmac()
                 .update(this.V)
                 .update([ 0x00 ]);
  if (seed)
    kmac = kmac.update(seed);
  this.K = kmac.digest();
  this.V = this._hmac().update(this.V).digest();
  if (!seed)
    return;

  this.K = this._hmac()
               .update(this.V)
               .update([ 0x01 ])
               .update(seed)
               .digest();
  this.V = this._hmac().update(this.V).digest();
};

HmacDRBG.prototype.reseed = function reseed(entropy, entropyEnc, add, addEnc) {
  // Optional entropy enc
  if (typeof entropyEnc !== 'string') {
    addEnc = add;
    add = entropyEnc;
    entropyEnc = null;
  }

  entropy = utils.toArray(entropy, entropyEnc);
  add = utils.toArray(add, addEnc);

  assert(entropy.length >= (this.minEntropy / 8),
         'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits');

  this._update(entropy.concat(add || []));
  this._reseed = 1;
};

HmacDRBG.prototype.generate = function generate(len, enc, add, addEnc) {
  if (this._reseed > this.reseedInterval)
    throw new Error('Reseed is required');

  // Optional encoding
  if (typeof enc !== 'string') {
    addEnc = add;
    add = enc;
    enc = null;
  }

  // Optional additional data
  if (add) {
    add = utils.toArray(add, addEnc || 'hex');
    this._update(add);
  }

  var temp = [];
  while (temp.length < len) {
    this.V = this._hmac().update(this.V).digest();
    temp = temp.concat(this.V);
  }

  var res = temp.slice(0, len);
  this._update(add);
  this._reseed++;
  return utils.encode(res, enc);
};

},{"hash.js":127,"minimalistic-assert":145,"minimalistic-crypto-utils":146}],140:[function(require,module,exports){
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],141:[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      })
    }
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      var TempCtor = function () {}
      TempCtor.prototype = superCtor.prototype
      ctor.prototype = new TempCtor()
      ctor.prototype.constructor = ctor
    }
  }
}

},{}],142:[function(require,module,exports){
'use strict'
var inherits = require('inherits')
var HashBase = require('hash-base')
var Buffer = require('safe-buffer').Buffer

var ARRAY16 = new Array(16)

function MD5 () {
  HashBase.call(this, 64)

  // state
  this._a = 0x67452301
  this._b = 0xefcdab89
  this._c = 0x98badcfe
  this._d = 0x10325476
}

inherits(MD5, HashBase)

MD5.prototype._update = function () {
  var M = ARRAY16
  for (var i = 0; i < 16; ++i) M[i] = this._block.readInt32LE(i * 4)

  var a = this._a
  var b = this._b
  var c = this._c
  var d = this._d

  a = fnF(a, b, c, d, M[0], 0xd76aa478, 7)
  d = fnF(d, a, b, c, M[1], 0xe8c7b756, 12)
  c = fnF(c, d, a, b, M[2], 0x242070db, 17)
  b = fnF(b, c, d, a, M[3], 0xc1bdceee, 22)
  a = fnF(a, b, c, d, M[4], 0xf57c0faf, 7)
  d = fnF(d, a, b, c, M[5], 0x4787c62a, 12)
  c = fnF(c, d, a, b, M[6], 0xa8304613, 17)
  b = fnF(b, c, d, a, M[7], 0xfd469501, 22)
  a = fnF(a, b, c, d, M[8], 0x698098d8, 7)
  d = fnF(d, a, b, c, M[9], 0x8b44f7af, 12)
  c = fnF(c, d, a, b, M[10], 0xffff5bb1, 17)
  b = fnF(b, c, d, a, M[11], 0x895cd7be, 22)
  a = fnF(a, b, c, d, M[12], 0x6b901122, 7)
  d = fnF(d, a, b, c, M[13], 0xfd987193, 12)
  c = fnF(c, d, a, b, M[14], 0xa679438e, 17)
  b = fnF(b, c, d, a, M[15], 0x49b40821, 22)

  a = fnG(a, b, c, d, M[1], 0xf61e2562, 5)
  d = fnG(d, a, b, c, M[6], 0xc040b340, 9)
  c = fnG(c, d, a, b, M[11], 0x265e5a51, 14)
  b = fnG(b, c, d, a, M[0], 0xe9b6c7aa, 20)
  a = fnG(a, b, c, d, M[5], 0xd62f105d, 5)
  d = fnG(d, a, b, c, M[10], 0x02441453, 9)
  c = fnG(c, d, a, b, M[15], 0xd8a1e681, 14)
  b = fnG(b, c, d, a, M[4], 0xe7d3fbc8, 20)
  a = fnG(a, b, c, d, M[9], 0x21e1cde6, 5)
  d = fnG(d, a, b, c, M[14], 0xc33707d6, 9)
  c = fnG(c, d, a, b, M[3], 0xf4d50d87, 14)
  b = fnG(b, c, d, a, M[8], 0x455a14ed, 20)
  a = fnG(a, b, c, d, M[13], 0xa9e3e905, 5)
  d = fnG(d, a, b, c, M[2], 0xfcefa3f8, 9)
  c = fnG(c, d, a, b, M[7], 0x676f02d9, 14)
  b = fnG(b, c, d, a, M[12], 0x8d2a4c8a, 20)

  a = fnH(a, b, c, d, M[5], 0xfffa3942, 4)
  d = fnH(d, a, b, c, M[8], 0x8771f681, 11)
  c = fnH(c, d, a, b, M[11], 0x6d9d6122, 16)
  b = fnH(b, c, d, a, M[14], 0xfde5380c, 23)
  a = fnH(a, b, c, d, M[1], 0xa4beea44, 4)
  d = fnH(d, a, b, c, M[4], 0x4bdecfa9, 11)
  c = fnH(c, d, a, b, M[7], 0xf6bb4b60, 16)
  b = fnH(b, c, d, a, M[10], 0xbebfbc70, 23)
  a = fnH(a, b, c, d, M[13], 0x289b7ec6, 4)
  d = fnH(d, a, b, c, M[0], 0xeaa127fa, 11)
  c = fnH(c, d, a, b, M[3], 0xd4ef3085, 16)
  b = fnH(b, c, d, a, M[6], 0x04881d05, 23)
  a = fnH(a, b, c, d, M[9], 0xd9d4d039, 4)
  d = fnH(d, a, b, c, M[12], 0xe6db99e5, 11)
  c = fnH(c, d, a, b, M[15], 0x1fa27cf8, 16)
  b = fnH(b, c, d, a, M[2], 0xc4ac5665, 23)

  a = fnI(a, b, c, d, M[0], 0xf4292244, 6)
  d = fnI(d, a, b, c, M[7], 0x432aff97, 10)
  c = fnI(c, d, a, b, M[14], 0xab9423a7, 15)
  b = fnI(b, c, d, a, M[5], 0xfc93a039, 21)
  a = fnI(a, b, c, d, M[12], 0x655b59c3, 6)
  d = fnI(d, a, b, c, M[3], 0x8f0ccc92, 10)
  c = fnI(c, d, a, b, M[10], 0xffeff47d, 15)
  b = fnI(b, c, d, a, M[1], 0x85845dd1, 21)
  a = fnI(a, b, c, d, M[8], 0x6fa87e4f, 6)
  d = fnI(d, a, b, c, M[15], 0xfe2ce6e0, 10)
  c = fnI(c, d, a, b, M[6], 0xa3014314, 15)
  b = fnI(b, c, d, a, M[13], 0x4e0811a1, 21)
  a = fnI(a, b, c, d, M[4], 0xf7537e82, 6)
  d = fnI(d, a, b, c, M[11], 0xbd3af235, 10)
  c = fnI(c, d, a, b, M[2], 0x2ad7d2bb, 15)
  b = fnI(b, c, d, a, M[9], 0xeb86d391, 21)

  this._a = (this._a + a) | 0
  this._b = (this._b + b) | 0
  this._c = (this._c + c) | 0
  this._d = (this._d + d) | 0
}

MD5.prototype._digest = function () {
  // create padding and handle blocks
  this._block[this._blockOffset++] = 0x80
  if (this._blockOffset > 56) {
    this._block.fill(0, this._blockOffset, 64)
    this._update()
    this._blockOffset = 0
  }

  this._block.fill(0, this._blockOffset, 56)
  this._block.writeUInt32LE(this._length[0], 56)
  this._block.writeUInt32LE(this._length[1], 60)
  this._update()

  // produce result
  var buffer = Buffer.allocUnsafe(16)
  buffer.writeInt32LE(this._a, 0)
  buffer.writeInt32LE(this._b, 4)
  buffer.writeInt32LE(this._c, 8)
  buffer.writeInt32LE(this._d, 12)
  return buffer
}

function rotl (x, n) {
  return (x << n) | (x >>> (32 - n))
}

function fnF (a, b, c, d, m, k, s) {
  return (rotl((a + ((b & c) | ((~b) & d)) + m + k) | 0, s) + b) | 0
}

function fnG (a, b, c, d, m, k, s) {
  return (rotl((a + ((b & d) | (c & (~d))) + m + k) | 0, s) + b) | 0
}

function fnH (a, b, c, d, m, k, s) {
  return (rotl((a + (b ^ c ^ d) + m + k) | 0, s) + b) | 0
}

function fnI (a, b, c, d, m, k, s) {
  return (rotl((a + ((c ^ (b | (~d)))) + m + k) | 0, s) + b) | 0
}

module.exports = MD5

},{"hash-base":111,"inherits":141,"safe-buffer":170}],143:[function(require,module,exports){
var bn = require('bn.js');
var brorand = require('brorand');

function MillerRabin(rand) {
  this.rand = rand || new brorand.Rand();
}
module.exports = MillerRabin;

MillerRabin.create = function create(rand) {
  return new MillerRabin(rand);
};

MillerRabin.prototype._randbelow = function _randbelow(n) {
  var len = n.bitLength();
  var min_bytes = Math.ceil(len / 8);

  // Generage random bytes until a number less than n is found.
  // This ensures that 0..n-1 have an equal probability of being selected.
  do
    var a = new bn(this.rand.generate(min_bytes));
  while (a.cmp(n) >= 0);

  return a;
};

MillerRabin.prototype._randrange = function _randrange(start, stop) {
  // Generate a random number greater than or equal to start and less than stop.
  var size = stop.sub(start);
  return start.add(this._randbelow(size));
};

MillerRabin.prototype.test = function test(n, k, cb) {
  var len = n.bitLength();
  var red = bn.mont(n);
  var rone = new bn(1).toRed(red);

  if (!k)
    k = Math.max(1, (len / 48) | 0);

  // Find d and s, (n - 1) = (2 ^ s) * d;
  var n1 = n.subn(1);
  for (var s = 0; !n1.testn(s); s++) {}
  var d = n.shrn(s);

  var rn1 = n1.toRed(red);

  var prime = true;
  for (; k > 0; k--) {
    var a = this._randrange(new bn(2), n1);
    if (cb)
      cb(a);

    var x = a.toRed(red).redPow(d);
    if (x.cmp(rone) === 0 || x.cmp(rn1) === 0)
      continue;

    for (var i = 1; i < s; i++) {
      x = x.redSqr();

      if (x.cmp(rone) === 0)
        return false;
      if (x.cmp(rn1) === 0)
        break;
    }

    if (i === s)
      return false;
  }

  return prime;
};

MillerRabin.prototype.getDivisor = function getDivisor(n, k) {
  var len = n.bitLength();
  var red = bn.mont(n);
  var rone = new bn(1).toRed(red);

  if (!k)
    k = Math.max(1, (len / 48) | 0);

  // Find d and s, (n - 1) = (2 ^ s) * d;
  var n1 = n.subn(1);
  for (var s = 0; !n1.testn(s); s++) {}
  var d = n.shrn(s);

  var rn1 = n1.toRed(red);

  for (; k > 0; k--) {
    var a = this._randrange(new bn(2), n1);

    var g = n.gcd(a);
    if (g.cmpn(1) !== 0)
      return g;

    var x = a.toRed(red).redPow(d);
    if (x.cmp(rone) === 0 || x.cmp(rn1) === 0)
      continue;

    for (var i = 1; i < s; i++) {
      x = x.redSqr();

      if (x.cmp(rone) === 0)
        return x.fromRed().subn(1).gcd(n);
      if (x.cmp(rn1) === 0)
        break;
    }

    if (i === s) {
      x = x.redSqr();
      return x.fromRed().subn(1).gcd(n);
    }
  }

  return false;
};

},{"bn.js":144,"brorand":26}],144:[function(require,module,exports){
arguments[4][23][0].apply(exports,arguments)
},{"buffer":27,"dup":23}],145:[function(require,module,exports){
module.exports = assert;

function assert(val, msg) {
  if (!val)
    throw new Error(msg || 'Assertion failed');
}

assert.equal = function assertEqual(l, r, msg) {
  if (l != r)
    throw new Error(msg || ('Assertion failed: ' + l + ' != ' + r));
};

},{}],146:[function(require,module,exports){
'use strict';

var utils = exports;

function toArray(msg, enc) {
  if (Array.isArray(msg))
    return msg.slice();
  if (!msg)
    return [];
  var res = [];
  if (typeof msg !== 'string') {
    for (var i = 0; i < msg.length; i++)
      res[i] = msg[i] | 0;
    return res;
  }
  if (enc === 'hex') {
    msg = msg.replace(/[^a-z0-9]+/ig, '');
    if (msg.length % 2 !== 0)
      msg = '0' + msg;
    for (var i = 0; i < msg.length; i += 2)
      res.push(parseInt(msg[i] + msg[i + 1], 16));
  } else {
    for (var i = 0; i < msg.length; i++) {
      var c = msg.charCodeAt(i);
      var hi = c >> 8;
      var lo = c & 0xff;
      if (hi)
        res.push(hi, lo);
      else
        res.push(lo);
    }
  }
  return res;
}
utils.toArray = toArray;

function zero2(word) {
  if (word.length === 1)
    return '0' + word;
  else
    return word;
}
utils.zero2 = zero2;

function toHex(msg) {
  var res = '';
  for (var i = 0; i < msg.length; i++)
    res += zero2(msg[i].toString(16));
  return res;
}
utils.toHex = toHex;

utils.encode = function encode(arr, enc) {
  if (enc === 'hex')
    return toHex(arr);
  else
    return arr;
};

},{}],147:[function(require,module,exports){
module.exports={"2.16.840.1.101.3.4.1.1": "aes-128-ecb",
"2.16.840.1.101.3.4.1.2": "aes-128-cbc",
"2.16.840.1.101.3.4.1.3": "aes-128-ofb",
"2.16.840.1.101.3.4.1.4": "aes-128-cfb",
"2.16.840.1.101.3.4.1.21": "aes-192-ecb",
"2.16.840.1.101.3.4.1.22": "aes-192-cbc",
"2.16.840.1.101.3.4.1.23": "aes-192-ofb",
"2.16.840.1.101.3.4.1.24": "aes-192-cfb",
"2.16.840.1.101.3.4.1.41": "aes-256-ecb",
"2.16.840.1.101.3.4.1.42": "aes-256-cbc",
"2.16.840.1.101.3.4.1.43": "aes-256-ofb",
"2.16.840.1.101.3.4.1.44": "aes-256-cfb"
}
},{}],148:[function(require,module,exports){
// from https://github.com/indutny/self-signed/blob/gh-pages/lib/asn1.js
// Fedor, you are amazing.
'use strict'

var asn1 = require('asn1.js')

exports.certificate = require('./certificate')

var RSAPrivateKey = asn1.define('RSAPrivateKey', function () {
  this.seq().obj(
    this.key('version').int(),
    this.key('modulus').int(),
    this.key('publicExponent').int(),
    this.key('privateExponent').int(),
    this.key('prime1').int(),
    this.key('prime2').int(),
    this.key('exponent1').int(),
    this.key('exponent2').int(),
    this.key('coefficient').int()
  )
})
exports.RSAPrivateKey = RSAPrivateKey

var RSAPublicKey = asn1.define('RSAPublicKey', function () {
  this.seq().obj(
    this.key('modulus').int(),
    this.key('publicExponent').int()
  )
})
exports.RSAPublicKey = RSAPublicKey

var PublicKey = asn1.define('SubjectPublicKeyInfo', function () {
  this.seq().obj(
    this.key('algorithm').use(AlgorithmIdentifier),
    this.key('subjectPublicKey').bitstr()
  )
})
exports.PublicKey = PublicKey

var AlgorithmIdentifier = asn1.define('AlgorithmIdentifier', function () {
  this.seq().obj(
    this.key('algorithm').objid(),
    this.key('none').null_().optional(),
    this.key('curve').objid().optional(),
    this.key('params').seq().obj(
      this.key('p').int(),
      this.key('q').int(),
      this.key('g').int()
    ).optional()
  )
})

var PrivateKeyInfo = asn1.define('PrivateKeyInfo', function () {
  this.seq().obj(
    this.key('version').int(),
    this.key('algorithm').use(AlgorithmIdentifier),
    this.key('subjectPrivateKey').octstr()
  )
})
exports.PrivateKey = PrivateKeyInfo
var EncryptedPrivateKeyInfo = asn1.define('EncryptedPrivateKeyInfo', function () {
  this.seq().obj(
    this.key('algorithm').seq().obj(
      this.key('id').objid(),
      this.key('decrypt').seq().obj(
        this.key('kde').seq().obj(
          this.key('id').objid(),
          this.key('kdeparams').seq().obj(
            this.key('salt').octstr(),
            this.key('iters').int()
          )
        ),
        this.key('cipher').seq().obj(
          this.key('algo').objid(),
          this.key('iv').octstr()
        )
      )
    ),
    this.key('subjectPrivateKey').octstr()
  )
})

exports.EncryptedPrivateKey = EncryptedPrivateKeyInfo

var DSAPrivateKey = asn1.define('DSAPrivateKey', function () {
  this.seq().obj(
    this.key('version').int(),
    this.key('p').int(),
    this.key('q').int(),
    this.key('g').int(),
    this.key('pub_key').int(),
    this.key('priv_key').int()
  )
})
exports.DSAPrivateKey = DSAPrivateKey

exports.DSAparam = asn1.define('DSAparam', function () {
  this.int()
})

var ECPrivateKey = asn1.define('ECPrivateKey', function () {
  this.seq().obj(
    this.key('version').int(),
    this.key('privateKey').octstr(),
    this.key('parameters').optional().explicit(0).use(ECParameters),
    this.key('publicKey').optional().explicit(1).bitstr()
  )
})
exports.ECPrivateKey = ECPrivateKey

var ECParameters = asn1.define('ECParameters', function () {
  this.choice({
    namedCurve: this.objid()
  })
})

exports.signature = asn1.define('signature', function () {
  this.seq().obj(
    this.key('r').int(),
    this.key('s').int()
  )
})

},{"./certificate":149,"asn1.js":9}],149:[function(require,module,exports){
// from https://github.com/Rantanen/node-dtls/blob/25a7dc861bda38cfeac93a723500eea4f0ac2e86/Certificate.js
// thanks to @Rantanen

'use strict'

var asn = require('asn1.js')

var Time = asn.define('Time', function () {
  this.choice({
    utcTime: this.utctime(),
    generalTime: this.gentime()
  })
})

var AttributeTypeValue = asn.define('AttributeTypeValue', function () {
  this.seq().obj(
    this.key('type').objid(),
    this.key('value').any()
  )
})

var AlgorithmIdentifier = asn.define('AlgorithmIdentifier', function () {
  this.seq().obj(
    this.key('algorithm').objid(),
    this.key('parameters').optional(),
    this.key('curve').objid().optional()
  )
})

var SubjectPublicKeyInfo = asn.define('SubjectPublicKeyInfo', function () {
  this.seq().obj(
    this.key('algorithm').use(AlgorithmIdentifier),
    this.key('subjectPublicKey').bitstr()
  )
})

var RelativeDistinguishedName = asn.define('RelativeDistinguishedName', function () {
  this.setof(AttributeTypeValue)
})

var RDNSequence = asn.define('RDNSequence', function () {
  this.seqof(RelativeDistinguishedName)
})

var Name = asn.define('Name', function () {
  this.choice({
    rdnSequence: this.use(RDNSequence)
  })
})

var Validity = asn.define('Validity', function () {
  this.seq().obj(
    this.key('notBefore').use(Time),
    this.key('notAfter').use(Time)
  )
})

var Extension = asn.define('Extension', function () {
  this.seq().obj(
    this.key('extnID').objid(),
    this.key('critical').bool().def(false),
    this.key('extnValue').octstr()
  )
})

var TBSCertificate = asn.define('TBSCertificate', function () {
  this.seq().obj(
    this.key('version').explicit(0).int().optional(),
    this.key('serialNumber').int(),
    this.key('signature').use(AlgorithmIdentifier),
    this.key('issuer').use(Name),
    this.key('validity').use(Validity),
    this.key('subject').use(Name),
    this.key('subjectPublicKeyInfo').use(SubjectPublicKeyInfo),
    this.key('issuerUniqueID').implicit(1).bitstr().optional(),
    this.key('subjectUniqueID').implicit(2).bitstr().optional(),
    this.key('extensions').explicit(3).seqof(Extension).optional()
  )
})

var X509Certificate = asn.define('X509Certificate', function () {
  this.seq().obj(
    this.key('tbsCertificate').use(TBSCertificate),
    this.key('signatureAlgorithm').use(AlgorithmIdentifier),
    this.key('signatureValue').bitstr()
  )
})

module.exports = X509Certificate

},{"asn1.js":9}],150:[function(require,module,exports){
// adapted from https://github.com/apatil/pemstrip
var findProc = /Proc-Type: 4,ENCRYPTED[\n\r]+DEK-Info: AES-((?:128)|(?:192)|(?:256))-CBC,([0-9A-H]+)[\n\r]+([0-9A-z\n\r+/=]+)[\n\r]+/m
var startRegex = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----/m
var fullRegex = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----([0-9A-z\n\r+/=]+)-----END \1-----$/m
var evp = require('evp_bytestokey')
var ciphers = require('browserify-aes')
var Buffer = require('safe-buffer').Buffer
module.exports = function (okey, password) {
  var key = okey.toString()
  var match = key.match(findProc)
  var decrypted
  if (!match) {
    var match2 = key.match(fullRegex)
    decrypted = Buffer.from(match2[2].replace(/[\r\n]/g, ''), 'base64')
  } else {
    var suite = 'aes' + match[1]
    var iv = Buffer.from(match[2], 'hex')
    var cipherText = Buffer.from(match[3].replace(/[\r\n]/g, ''), 'base64')
    var cipherKey = evp(password, iv.slice(0, 8), parseInt(match[1], 10)).key
    var out = []
    var cipher = ciphers.createDecipheriv(suite, cipherKey, iv)
    out.push(cipher.update(cipherText))
    out.push(cipher.final())
    decrypted = Buffer.concat(out)
  }
  var tag = key.match(startRegex)[1]
  return {
    tag: tag,
    data: decrypted
  }
}

},{"browserify-aes":30,"evp_bytestokey":110,"safe-buffer":170}],151:[function(require,module,exports){
var asn1 = require('./asn1')
var aesid = require('./aesid.json')
var fixProc = require('./fixProc')
var ciphers = require('browserify-aes')
var compat = require('pbkdf2')
var Buffer = require('safe-buffer').Buffer
module.exports = parseKeys

function parseKeys (buffer) {
  var password
  if (typeof buffer === 'object' && !Buffer.isBuffer(buffer)) {
    password = buffer.passphrase
    buffer = buffer.key
  }
  if (typeof buffer === 'string') {
    buffer = Buffer.from(buffer)
  }

  var stripped = fixProc(buffer, password)

  var type = stripped.tag
  var data = stripped.data
  var subtype, ndata
  switch (type) {
    case 'CERTIFICATE':
      ndata = asn1.certificate.decode(data, 'der').tbsCertificate.subjectPublicKeyInfo
      // falls through
    case 'PUBLIC KEY':
      if (!ndata) {
        ndata = asn1.PublicKey.decode(data, 'der')
      }
      subtype = ndata.algorithm.algorithm.join('.')
      switch (subtype) {
        case '1.2.840.113549.1.1.1':
          return asn1.RSAPublicKey.decode(ndata.subjectPublicKey.data, 'der')
        case '1.2.840.10045.2.1':
          ndata.subjectPrivateKey = ndata.subjectPublicKey
          return {
            type: 'ec',
            data: ndata
          }
        case '1.2.840.10040.4.1':
          ndata.algorithm.params.pub_key = asn1.DSAparam.decode(ndata.subjectPublicKey.data, 'der')
          return {
            type: 'dsa',
            data: ndata.algorithm.params
          }
        default: throw new Error('unknown key id ' + subtype)
      }
      // throw new Error('unknown key type ' + type)
    case 'ENCRYPTED PRIVATE KEY':
      data = asn1.EncryptedPrivateKey.decode(data, 'der')
      data = decrypt(data, password)
      // falls through
    case 'PRIVATE KEY':
      ndata = asn1.PrivateKey.decode(data, 'der')
      subtype = ndata.algorithm.algorithm.join('.')
      switch (subtype) {
        case '1.2.840.113549.1.1.1':
          return asn1.RSAPrivateKey.decode(ndata.subjectPrivateKey, 'der')
        case '1.2.840.10045.2.1':
          return {
            curve: ndata.algorithm.curve,
            privateKey: asn1.ECPrivateKey.decode(ndata.subjectPrivateKey, 'der').privateKey
          }
        case '1.2.840.10040.4.1':
          ndata.algorithm.params.priv_key = asn1.DSAparam.decode(ndata.subjectPrivateKey, 'der')
          return {
            type: 'dsa',
            params: ndata.algorithm.params
          }
        default: throw new Error('unknown key id ' + subtype)
      }
      // throw new Error('unknown key type ' + type)
    case 'RSA PUBLIC KEY':
      return asn1.RSAPublicKey.decode(data, 'der')
    case 'RSA PRIVATE KEY':
      return asn1.RSAPrivateKey.decode(data, 'der')
    case 'DSA PRIVATE KEY':
      return {
        type: 'dsa',
        params: asn1.DSAPrivateKey.decode(data, 'der')
      }
    case 'EC PRIVATE KEY':
      data = asn1.ECPrivateKey.decode(data, 'der')
      return {
        curve: data.parameters.value,
        privateKey: data.privateKey
      }
    default: throw new Error('unknown key type ' + type)
  }
}
parseKeys.signature = asn1.signature
function decrypt (data, password) {
  var salt = data.algorithm.decrypt.kde.kdeparams.salt
  var iters = parseInt(data.algorithm.decrypt.kde.kdeparams.iters.toString(), 10)
  var algo = aesid[data.algorithm.decrypt.cipher.algo.join('.')]
  var iv = data.algorithm.decrypt.cipher.iv
  var cipherText = data.subjectPrivateKey
  var keylen = parseInt(algo.split('-')[1], 10) / 8
  var key = compat.pbkdf2Sync(password, salt, iters, keylen, 'sha1')
  var cipher = ciphers.createDecipheriv(algo, key, iv)
  var out = []
  out.push(cipher.update(cipherText))
  out.push(cipher.final())
  return Buffer.concat(out)
}

},{"./aesid.json":147,"./asn1":148,"./fixProc":150,"browserify-aes":30,"pbkdf2":153,"safe-buffer":170}],152:[function(require,module,exports){
(function (process){(function (){
// 'path' module extracted from Node.js v8.11.1 (only the posix part)
// transplited with Babel

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

function assertPath(path) {
  if (typeof path !== 'string') {
    throw new TypeError('Path must be a string. Received ' + JSON.stringify(path));
  }
}

// Resolves . and .. elements in a path with directory names
function normalizeStringPosix(path, allowAboveRoot) {
  var res = '';
  var lastSegmentLength = 0;
  var lastSlash = -1;
  var dots = 0;
  var code;
  for (var i = 0; i <= path.length; ++i) {
    if (i < path.length)
      code = path.charCodeAt(i);
    else if (code === 47 /*/*/)
      break;
    else
      code = 47 /*/*/;
    if (code === 47 /*/*/) {
      if (lastSlash === i - 1 || dots === 1) {
        // NOOP
      } else if (lastSlash !== i - 1 && dots === 2) {
        if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 /*.*/ || res.charCodeAt(res.length - 2) !== 46 /*.*/) {
          if (res.length > 2) {
            var lastSlashIndex = res.lastIndexOf('/');
            if (lastSlashIndex !== res.length - 1) {
              if (lastSlashIndex === -1) {
                res = '';
                lastSegmentLength = 0;
              } else {
                res = res.slice(0, lastSlashIndex);
                lastSegmentLength = res.length - 1 - res.lastIndexOf('/');
              }
              lastSlash = i;
              dots = 0;
              continue;
            }
          } else if (res.length === 2 || res.length === 1) {
            res = '';
            lastSegmentLength = 0;
            lastSlash = i;
            dots = 0;
            continue;
          }
        }
        if (allowAboveRoot) {
          if (res.length > 0)
            res += '/..';
          else
            res = '..';
          lastSegmentLength = 2;
        }
      } else {
        if (res.length > 0)
          res += '/' + path.slice(lastSlash + 1, i);
        else
          res = path.slice(lastSlash + 1, i);
        lastSegmentLength = i - lastSlash - 1;
      }
      lastSlash = i;
      dots = 0;
    } else if (code === 46 /*.*/ && dots !== -1) {
      ++dots;
    } else {
      dots = -1;
    }
  }
  return res;
}

function _format(sep, pathObject) {
  var dir = pathObject.dir || pathObject.root;
  var base = pathObject.base || (pathObject.name || '') + (pathObject.ext || '');
  if (!dir) {
    return base;
  }
  if (dir === pathObject.root) {
    return dir + base;
  }
  return dir + sep + base;
}

var posix = {
  // path.resolve([from ...], to)
  resolve: function resolve() {
    var resolvedPath = '';
    var resolvedAbsolute = false;
    var cwd;

    for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
      var path;
      if (i >= 0)
        path = arguments[i];
      else {
        if (cwd === undefined)
          cwd = process.cwd();
        path = cwd;
      }

      assertPath(path);

      // Skip empty entries
      if (path.length === 0) {
        continue;
      }

      resolvedPath = path + '/' + resolvedPath;
      resolvedAbsolute = path.charCodeAt(0) === 47 /*/*/;
    }

    // At this point the path should be resolved to a full absolute path, but
    // handle relative paths to be safe (might happen when process.cwd() fails)

    // Normalize the path
    resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);

    if (resolvedAbsolute) {
      if (resolvedPath.length > 0)
        return '/' + resolvedPath;
      else
        return '/';
    } else if (resolvedPath.length > 0) {
      return resolvedPath;
    } else {
      return '.';
    }
  },

  normalize: function normalize(path) {
    assertPath(path);

    if (path.length === 0) return '.';

    var isAbsolute = path.charCodeAt(0) === 47 /*/*/;
    var trailingSeparator = path.charCodeAt(path.length - 1) === 47 /*/*/;

    // Normalize the path
    path = normalizeStringPosix(path, !isAbsolute);

    if (path.length === 0 && !isAbsolute) path = '.';
    if (path.length > 0 && trailingSeparator) path += '/';

    if (isAbsolute) return '/' + path;
    return path;
  },

  isAbsolute: function isAbsolute(path) {
    assertPath(path);
    return path.length > 0 && path.charCodeAt(0) === 47 /*/*/;
  },

  join: function join() {
    if (arguments.length === 0)
      return '.';
    var joined;
    for (var i = 0; i < arguments.length; ++i) {
      var arg = arguments[i];
      assertPath(arg);
      if (arg.length > 0) {
        if (joined === undefined)
          joined = arg;
        else
          joined += '/' + arg;
      }
    }
    if (joined === undefined)
      return '.';
    return posix.normalize(joined);
  },

  relative: function relative(from, to) {
    assertPath(from);
    assertPath(to);

    if (from === to) return '';

    from = posix.resolve(from);
    to = posix.resolve(to);

    if (from === to) return '';

    // Trim any leading backslashes
    var fromStart = 1;
    for (; fromStart < from.length; ++fromStart) {
      if (from.charCodeAt(fromStart) !== 47 /*/*/)
        break;
    }
    var fromEnd = from.length;
    var fromLen = fromEnd - fromStart;

    // Trim any leading backslashes
    var toStart = 1;
    for (; toStart < to.length; ++toStart) {
      if (to.charCodeAt(toStart) !== 47 /*/*/)
        break;
    }
    var toEnd = to.length;
    var toLen = toEnd - toStart;

    // Compare paths to find the longest common path from root
    var length = fromLen < toLen ? fromLen : toLen;
    var lastCommonSep = -1;
    var i = 0;
    for (; i <= length; ++i) {
      if (i === length) {
        if (toLen > length) {
          if (to.charCodeAt(toStart + i) === 47 /*/*/) {
            // We get here if `from` is the exact base path for `to`.
            // For example: from='/foo/bar'; to='/foo/bar/baz'
            return to.slice(toStart + i + 1);
          } else if (i === 0) {
            // We get here if `from` is the root
            // For example: from='/'; to='/foo'
            return to.slice(toStart + i);
          }
        } else if (fromLen > length) {
          if (from.charCodeAt(fromStart + i) === 47 /*/*/) {
            // We get here if `to` is the exact base path for `from`.
            // For example: from='/foo/bar/baz'; to='/foo/bar'
            lastCommonSep = i;
          } else if (i === 0) {
            // We get here if `to` is the root.
            // For example: from='/foo'; to='/'
            lastCommonSep = 0;
          }
        }
        break;
      }
      var fromCode = from.charCodeAt(fromStart + i);
      var toCode = to.charCodeAt(toStart + i);
      if (fromCode !== toCode)
        break;
      else if (fromCode === 47 /*/*/)
        lastCommonSep = i;
    }

    var out = '';
    // Generate the relative path based on the path difference between `to`
    // and `from`
    for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {
      if (i === fromEnd || from.charCodeAt(i) === 47 /*/*/) {
        if (out.length === 0)
          out += '..';
        else
          out += '/..';
      }
    }

    // Lastly, append the rest of the destination (`to`) path that comes after
    // the common path parts
    if (out.length > 0)
      return out + to.slice(toStart + lastCommonSep);
    else {
      toStart += lastCommonSep;
      if (to.charCodeAt(toStart) === 47 /*/*/)
        ++toStart;
      return to.slice(toStart);
    }
  },

  _makeLong: function _makeLong(path) {
    return path;
  },

  dirname: function dirname(path) {
    assertPath(path);
    if (path.length === 0) return '.';
    var code = path.charCodeAt(0);
    var hasRoot = code === 47 /*/*/;
    var end = -1;
    var matchedSlash = true;
    for (var i = path.length - 1; i >= 1; --i) {
      code = path.charCodeAt(i);
      if (code === 47 /*/*/) {
          if (!matchedSlash) {
            end = i;
            break;
          }
        } else {
        // We saw the first non-path separator
        matchedSlash = false;
      }
    }

    if (end === -1) return hasRoot ? '/' : '.';
    if (hasRoot && end === 1) return '//';
    return path.slice(0, end);
  },

  basename: function basename(path, ext) {
    if (ext !== undefined && typeof ext !== 'string') throw new TypeError('"ext" argument must be a string');
    assertPath(path);

    var start = 0;
    var end = -1;
    var matchedSlash = true;
    var i;

    if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {
      if (ext.length === path.length && ext === path) return '';
      var extIdx = ext.length - 1;
      var firstNonSlashEnd = -1;
      for (i = path.length - 1; i >= 0; --i) {
        var code = path.charCodeAt(i);
        if (code === 47 /*/*/) {
            // If we reached a path separator that was not part of a set of path
            // separators at the end of the string, stop now
            if (!matchedSlash) {
              start = i + 1;
              break;
            }
          } else {
          if (firstNonSlashEnd === -1) {
            // We saw the first non-path separator, remember this index in case
            // we need it if the extension ends up not matching
            matchedSlash = false;
            firstNonSlashEnd = i + 1;
          }
          if (extIdx >= 0) {
            // Try to match the explicit extension
            if (code === ext.charCodeAt(extIdx)) {
              if (--extIdx === -1) {
                // We matched the extension, so mark this as the end of our path
                // component
                end = i;
              }
            } else {
              // Extension does not match, so our result is the entire path
              // component
              extIdx = -1;
              end = firstNonSlashEnd;
            }
          }
        }
      }

      if (start === end) end = firstNonSlashEnd;else if (end === -1) end = path.length;
      return path.slice(start, end);
    } else {
      for (i = path.length - 1; i >= 0; --i) {
        if (path.charCodeAt(i) === 47 /*/*/) {
            // If we reached a path separator that was not part of a set of path
            // separators at the end of the string, stop now
            if (!matchedSlash) {
              start = i + 1;
              break;
            }
          } else if (end === -1) {
          // We saw the first non-path separator, mark this as the end of our
          // path component
          matchedSlash = false;
          end = i + 1;
        }
      }

      if (end === -1) return '';
      return path.slice(start, end);
    }
  },

  extname: function extname(path) {
    assertPath(path);
    var startDot = -1;
    var startPart = 0;
    var end = -1;
    var matchedSlash = true;
    // Track the state of characters (if any) we see before our first dot and
    // after any path separator we find
    var preDotState = 0;
    for (var i = path.length - 1; i >= 0; --i) {
      var code = path.charCodeAt(i);
      if (code === 47 /*/*/) {
          // If we reached a path separator that was not part of a set of path
          // separators at the end of the string, stop now
          if (!matchedSlash) {
            startPart = i + 1;
            break;
          }
          continue;
        }
      if (end === -1) {
        // We saw the first non-path separator, mark this as the end of our
        // extension
        matchedSlash = false;
        end = i + 1;
      }
      if (code === 46 /*.*/) {
          // If this is our first dot, mark it as the start of our extension
          if (startDot === -1)
            startDot = i;
          else if (preDotState !== 1)
            preDotState = 1;
      } else if (startDot !== -1) {
        // We saw a non-dot and non-path separator before our dot, so we should
        // have a good chance at having a non-empty extension
        preDotState = -1;
      }
    }

    if (startDot === -1 || end === -1 ||
        // We saw a non-dot character immediately before the dot
        preDotState === 0 ||
        // The (right-most) trimmed path component is exactly '..'
        preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
      return '';
    }
    return path.slice(startDot, end);
  },

  format: function format(pathObject) {
    if (pathObject === null || typeof pathObject !== 'object') {
      throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof pathObject);
    }
    return _format('/', pathObject);
  },

  parse: function parse(path) {
    assertPath(path);

    var ret = { root: '', dir: '', base: '', ext: '', name: '' };
    if (path.length === 0) return ret;
    var code = path.charCodeAt(0);
    var isAbsolute = code === 47 /*/*/;
    var start;
    if (isAbsolute) {
      ret.root = '/';
      start = 1;
    } else {
      start = 0;
    }
    var startDot = -1;
    var startPart = 0;
    var end = -1;
    var matchedSlash = true;
    var i = path.length - 1;

    // Track the state of characters (if any) we see before our first dot and
    // after any path separator we find
    var preDotState = 0;

    // Get non-dir info
    for (; i >= start; --i) {
      code = path.charCodeAt(i);
      if (code === 47 /*/*/) {
          // If we reached a path separator that was not part of a set of path
          // separators at the end of the string, stop now
          if (!matchedSlash) {
            startPart = i + 1;
            break;
          }
          continue;
        }
      if (end === -1) {
        // We saw the first non-path separator, mark this as the end of our
        // extension
        matchedSlash = false;
        end = i + 1;
      }
      if (code === 46 /*.*/) {
          // If this is our first dot, mark it as the start of our extension
          if (startDot === -1) startDot = i;else if (preDotState !== 1) preDotState = 1;
        } else if (startDot !== -1) {
        // We saw a non-dot and non-path separator before our dot, so we should
        // have a good chance at having a non-empty extension
        preDotState = -1;
      }
    }

    if (startDot === -1 || end === -1 ||
    // We saw a non-dot character immediately before the dot
    preDotState === 0 ||
    // The (right-most) trimmed path component is exactly '..'
    preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {
      if (end !== -1) {
        if (startPart === 0 && isAbsolute) ret.base = ret.name = path.slice(1, end);else ret.base = ret.name = path.slice(startPart, end);
      }
    } else {
      if (startPart === 0 && isAbsolute) {
        ret.name = path.slice(1, startDot);
        ret.base = path.slice(1, end);
      } else {
        ret.name = path.slice(startPart, startDot);
        ret.base = path.slice(startPart, end);
      }
      ret.ext = path.slice(startDot, end);
    }

    if (startPart > 0) ret.dir = path.slice(0, startPart - 1);else if (isAbsolute) ret.dir = '/';

    return ret;
  },

  sep: '/',
  delimiter: ':',
  win32: null,
  posix: null
};

posix.posix = posix;

module.exports = posix;

}).call(this)}).call(this,require('_process'))
},{"_process":159}],153:[function(require,module,exports){
exports.pbkdf2 = require('./lib/async')
exports.pbkdf2Sync = require('./lib/sync')

},{"./lib/async":154,"./lib/sync":157}],154:[function(require,module,exports){
(function (global){(function (){
var Buffer = require('safe-buffer').Buffer

var checkParameters = require('./precondition')
var defaultEncoding = require('./default-encoding')
var sync = require('./sync')
var toBuffer = require('./to-buffer')

var ZERO_BUF
var subtle = global.crypto && global.crypto.subtle
var toBrowser = {
  sha: 'SHA-1',
  'sha-1': 'SHA-1',
  sha1: 'SHA-1',
  sha256: 'SHA-256',
  'sha-256': 'SHA-256',
  sha384: 'SHA-384',
  'sha-384': 'SHA-384',
  'sha-512': 'SHA-512',
  sha512: 'SHA-512'
}
var checks = []
function checkNative (algo) {
  if (global.process && !global.process.browser) {
    return Promise.resolve(false)
  }
  if (!subtle || !subtle.importKey || !subtle.deriveBits) {
    return Promise.resolve(false)
  }
  if (checks[algo] !== undefined) {
    return checks[algo]
  }
  ZERO_BUF = ZERO_BUF || Buffer.alloc(8)
  var prom = browserPbkdf2(ZERO_BUF, ZERO_BUF, 10, 128, algo)
    .then(function () {
      return true
    }).catch(function () {
      return false
    })
  checks[algo] = prom
  return prom
}
var nextTick
function getNextTick () {
  if (nextTick) {
    return nextTick
  }
  if (global.process && global.process.nextTick) {
    nextTick = global.process.nextTick
  } else if (global.queueMicrotask) {
    nextTick = global.queueMicrotask
  } else if (global.setImmediate) {
    nextTick = global.setImmediate
  } else {
    nextTick = global.setTimeout
  }
  return nextTick
}
function browserPbkdf2 (password, salt, iterations, length, algo) {
  return subtle.importKey(
    'raw', password, { name: 'PBKDF2' }, false, ['deriveBits']
  ).then(function (key) {
    return subtle.deriveBits({
      name: 'PBKDF2',
      salt: salt,
      iterations: iterations,
      hash: {
        name: algo
      }
    }, key, length << 3)
  }).then(function (res) {
    return Buffer.from(res)
  })
}

function resolvePromise (promise, callback) {
  promise.then(function (out) {
    getNextTick()(function () {
      callback(null, out)
    })
  }, function (e) {
    getNextTick()(function () {
      callback(e)
    })
  })
}
module.exports = function (password, salt, iterations, keylen, digest, callback) {
  if (typeof digest === 'function') {
    callback = digest
    digest = undefined
  }

  digest = digest || 'sha1'
  var algo = toBrowser[digest.toLowerCase()]

  if (!algo || typeof global.Promise !== 'function') {
    getNextTick()(function () {
      var out
      try {
        out = sync(password, salt, iterations, keylen, digest)
      } catch (e) {
        return callback(e)
      }
      callback(null, out)
    })
    return
  }

  checkParameters(iterations, keylen)
  password = toBuffer(password, defaultEncoding, 'Password')
  salt = toBuffer(salt, defaultEncoding, 'Salt')
  if (typeof callback !== 'function') throw new Error('No callback provided to pbkdf2')

  resolvePromise(checkNative(algo).then(function (resp) {
    if (resp) return browserPbkdf2(password, salt, iterations, keylen, algo)

    return sync(password, salt, iterations, keylen, digest)
  }), callback)
}

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./default-encoding":155,"./precondition":156,"./sync":157,"./to-buffer":158,"safe-buffer":170}],155:[function(require,module,exports){
(function (process,global){(function (){
var defaultEncoding
/* istanbul ignore next */
if (global.process && global.process.browser) {
  defaultEncoding = 'utf-8'
} else if (global.process && global.process.version) {
  var pVersionMajor = parseInt(process.version.split('.')[0].slice(1), 10)

  defaultEncoding = pVersionMajor >= 6 ? 'utf-8' : 'binary'
} else {
  defaultEncoding = 'utf-8'
}
module.exports = defaultEncoding

}).call(this)}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"_process":159}],156:[function(require,module,exports){
var MAX_ALLOC = Math.pow(2, 30) - 1 // default in iojs

module.exports = function (iterations, keylen) {
  if (typeof iterations !== 'number') {
    throw new TypeError('Iterations not a number')
  }

  if (iterations < 0) {
    throw new TypeError('Bad iterations')
  }

  if (typeof keylen !== 'number') {
    throw new TypeError('Key length not a number')
  }

  if (keylen < 0 || keylen > MAX_ALLOC || keylen !== keylen) { /* eslint no-self-compare: 0 */
    throw new TypeError('Bad key length')
  }
}

},{}],157:[function(require,module,exports){
var md5 = require('create-hash/md5')
var RIPEMD160 = require('ripemd160')
var sha = require('sha.js')
var Buffer = require('safe-buffer').Buffer

var checkParameters = require('./precondition')
var defaultEncoding = require('./default-encoding')
var toBuffer = require('./to-buffer')

var ZEROS = Buffer.alloc(128)
var sizes = {
  md5: 16,
  sha1: 20,
  sha224: 28,
  sha256: 32,
  sha384: 48,
  sha512: 64,
  rmd160: 20,
  ripemd160: 20
}

function Hmac (alg, key, saltLen) {
  var hash = getDigest(alg)
  var blocksize = (alg === 'sha512' || alg === 'sha384') ? 128 : 64

  if (key.length > blocksize) {
    key = hash(key)
  } else if (key.length < blocksize) {
    key = Buffer.concat([key, ZEROS], blocksize)
  }

  var ipad = Buffer.allocUnsafe(blocksize + sizes[alg])
  var opad = Buffer.allocUnsafe(blocksize + sizes[alg])
  for (var i = 0; i < blocksize; i++) {
    ipad[i] = key[i] ^ 0x36
    opad[i] = key[i] ^ 0x5C
  }

  var ipad1 = Buffer.allocUnsafe(blocksize + saltLen + 4)
  ipad.copy(ipad1, 0, 0, blocksize)
  this.ipad1 = ipad1
  this.ipad2 = ipad
  this.opad = opad
  this.alg = alg
  this.blocksize = blocksize
  this.hash = hash
  this.size = sizes[alg]
}

Hmac.prototype.run = function (data, ipad) {
  data.copy(ipad, this.blocksize)
  var h = this.hash(ipad)
  h.copy(this.opad, this.blocksize)
  return this.hash(this.opad)
}

function getDigest (alg) {
  function shaFunc (data) {
    return sha(alg).update(data).digest()
  }
  function rmd160Func (data) {
    return new RIPEMD160().update(data).digest()
  }

  if (alg === 'rmd160' || alg === 'ripemd160') return rmd160Func
  if (alg === 'md5') return md5
  return shaFunc
}

function pbkdf2 (password, salt, iterations, keylen, digest) {
  checkParameters(iterations, keylen)
  password = toBuffer(password, defaultEncoding, 'Password')
  salt = toBuffer(salt, defaultEncoding, 'Salt')

  digest = digest || 'sha1'

  var hmac = new Hmac(digest, password, salt.length)

  var DK = Buffer.allocUnsafe(keylen)
  var block1 = Buffer.allocUnsafe(salt.length + 4)
  salt.copy(block1, 0, 0, salt.length)

  var destPos = 0
  var hLen = sizes[digest]
  var l = Math.ceil(keylen / hLen)

  for (var i = 1; i <= l; i++) {
    block1.writeUInt32BE(i, salt.length)

    var T = hmac.run(block1, hmac.ipad1)
    var U = T

    for (var j = 1; j < iterations; j++) {
      U = hmac.run(U, hmac.ipad2)
      for (var k = 0; k < hLen; k++) T[k] ^= U[k]
    }

    T.copy(DK, destPos)
    destPos += hLen
  }

  return DK
}

module.exports = pbkdf2

},{"./default-encoding":155,"./precondition":156,"./to-buffer":158,"create-hash/md5":77,"ripemd160":169,"safe-buffer":170,"sha.js":173}],158:[function(require,module,exports){
var Buffer = require('safe-buffer').Buffer

module.exports = function (thing, encoding, name) {
  if (Buffer.isBuffer(thing)) {
    return thing
  } else if (typeof thing === 'string') {
    return Buffer.from(thing, encoding)
  } else if (ArrayBuffer.isView(thing)) {
    return Buffer.from(thing.buffer)
  } else {
    throw new TypeError(name + ' must be a string, a Buffer, a typed array or a DataView')
  }
}

},{"safe-buffer":170}],159:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],160:[function(require,module,exports){
exports.publicEncrypt = require('./publicEncrypt')
exports.privateDecrypt = require('./privateDecrypt')

exports.privateEncrypt = function privateEncrypt (key, buf) {
  return exports.publicEncrypt(key, buf, true)
}

exports.publicDecrypt = function publicDecrypt (key, buf) {
  return exports.privateDecrypt(key, buf, true)
}

},{"./privateDecrypt":163,"./publicEncrypt":164}],161:[function(require,module,exports){
var createHash = require('create-hash')
var Buffer = require('safe-buffer').Buffer

module.exports = function (seed, len) {
  var t = Buffer.alloc(0)
  var i = 0
  var c
  while (t.length < len) {
    c = i2ops(i++)
    t = Buffer.concat([t, createHash('sha1').update(seed).update(c).digest()])
  }
  return t.slice(0, len)
}

function i2ops (c) {
  var out = Buffer.allocUnsafe(4)
  out.writeUInt32BE(c, 0)
  return out
}

},{"create-hash":76,"safe-buffer":170}],162:[function(require,module,exports){
arguments[4][23][0].apply(exports,arguments)
},{"buffer":27,"dup":23}],163:[function(require,module,exports){
var parseKeys = require('parse-asn1')
var mgf = require('./mgf')
var xor = require('./xor')
var BN = require('bn.js')
var crt = require('browserify-rsa')
var createHash = require('create-hash')
var withPublic = require('./withPublic')
var Buffer = require('safe-buffer').Buffer

module.exports = function privateDecrypt (privateKey, enc, reverse) {
  var padding
  if (privateKey.padding) {
    padding = privateKey.padding
  } else if (reverse) {
    padding = 1
  } else {
    padding = 4
  }

  var key = parseKeys(privateKey)
  var k = key.modulus.byteLength()
  if (enc.length > k || new BN(enc).cmp(key.modulus) >= 0) {
    throw new Error('decryption error')
  }
  var msg
  if (reverse) {
    msg = withPublic(new BN(enc), key)
  } else {
    msg = crt(enc, key)
  }
  var zBuffer = Buffer.alloc(k - msg.length)
  msg = Buffer.concat([zBuffer, msg], k)
  if (padding === 4) {
    return oaep(key, msg)
  } else if (padding === 1) {
    return pkcs1(key, msg, reverse)
  } else if (padding === 3) {
    return msg
  } else {
    throw new Error('unknown padding')
  }
}

function oaep (key, msg) {
  var k = key.modulus.byteLength()
  var iHash = createHash('sha1').update(Buffer.alloc(0)).digest()
  var hLen = iHash.length
  if (msg[0] !== 0) {
    throw new Error('decryption error')
  }
  var maskedSeed = msg.slice(1, hLen + 1)
  var maskedDb = msg.slice(hLen + 1)
  var seed = xor(maskedSeed, mgf(maskedDb, hLen))
  var db = xor(maskedDb, mgf(seed, k - hLen - 1))
  if (compare(iHash, db.slice(0, hLen))) {
    throw new Error('decryption error')
  }
  var i = hLen
  while (db[i] === 0) {
    i++
  }
  if (db[i++] !== 1) {
    throw new Error('decryption error')
  }
  return db.slice(i)
}

function pkcs1 (key, msg, reverse) {
  var p1 = msg.slice(0, 2)
  var i = 2
  var status = 0
  while (msg[i++] !== 0) {
    if (i >= msg.length) {
      status++
      break
    }
  }
  var ps = msg.slice(2, i - 1)

  if ((p1.toString('hex') !== '0002' && !reverse) || (p1.toString('hex') !== '0001' && reverse)) {
    status++
  }
  if (ps.length < 8) {
    status++
  }
  if (status) {
    throw new Error('decryption error')
  }
  return msg.slice(i)
}
function compare (a, b) {
  a = Buffer.from(a)
  b = Buffer.from(b)
  var dif = 0
  var len = a.length
  if (a.length !== b.length) {
    dif++
    len = Math.min(a.length, b.length)
  }
  var i = -1
  while (++i < len) {
    dif += (a[i] ^ b[i])
  }
  return dif
}

},{"./mgf":161,"./withPublic":165,"./xor":166,"bn.js":162,"browserify-rsa":48,"create-hash":76,"parse-asn1":151,"safe-buffer":170}],164:[function(require,module,exports){
var parseKeys = require('parse-asn1')
var randomBytes = require('randombytes')
var createHash = require('create-hash')
var mgf = require('./mgf')
var xor = require('./xor')
var BN = require('bn.js')
var withPublic = require('./withPublic')
var crt = require('browserify-rsa')
var Buffer = require('safe-buffer').Buffer

module.exports = function publicEncrypt (publicKey, msg, reverse) {
  var padding
  if (publicKey.padding) {
    padding = publicKey.padding
  } else if (reverse) {
    padding = 1
  } else {
    padding = 4
  }
  var key = parseKeys(publicKey)
  var paddedMsg
  if (padding === 4) {
    paddedMsg = oaep(key, msg)
  } else if (padding === 1) {
    paddedMsg = pkcs1(key, msg, reverse)
  } else if (padding === 3) {
    paddedMsg = new BN(msg)
    if (paddedMsg.cmp(key.modulus) >= 0) {
      throw new Error('data too long for modulus')
    }
  } else {
    throw new Error('unknown padding')
  }
  if (reverse) {
    return crt(paddedMsg, key)
  } else {
    return withPublic(paddedMsg, key)
  }
}

function oaep (key, msg) {
  var k = key.modulus.byteLength()
  var mLen = msg.length
  var iHash = createHash('sha1').update(Buffer.alloc(0)).digest()
  var hLen = iHash.length
  var hLen2 = 2 * hLen
  if (mLen > k - hLen2 - 2) {
    throw new Error('message too long')
  }
  var ps = Buffer.alloc(k - mLen - hLen2 - 2)
  var dblen = k - hLen - 1
  var seed = randomBytes(hLen)
  var maskedDb = xor(Buffer.concat([iHash, ps, Buffer.alloc(1, 1), msg], dblen), mgf(seed, dblen))
  var maskedSeed = xor(seed, mgf(maskedDb, hLen))
  return new BN(Buffer.concat([Buffer.alloc(1), maskedSeed, maskedDb], k))
}
function pkcs1 (key, msg, reverse) {
  var mLen = msg.length
  var k = key.modulus.byteLength()
  if (mLen > k - 11) {
    throw new Error('message too long')
  }
  var ps
  if (reverse) {
    ps = Buffer.alloc(k - mLen - 3, 0xff)
  } else {
    ps = nonZero(k - mLen - 3)
  }
  return new BN(Buffer.concat([Buffer.from([0, reverse ? 1 : 2]), ps, Buffer.alloc(1), msg], k))
}
function nonZero (len) {
  var out = Buffer.allocUnsafe(len)
  var i = 0
  var cache = randomBytes(len * 2)
  var cur = 0
  var num
  while (i < len) {
    if (cur === cache.length) {
      cache = randomBytes(len * 2)
      cur = 0
    }
    num = cache[cur++]
    if (num) {
      out[i++] = num
    }
  }
  return out
}

},{"./mgf":161,"./withPublic":165,"./xor":166,"bn.js":162,"browserify-rsa":48,"create-hash":76,"parse-asn1":151,"randombytes":167,"safe-buffer":170}],165:[function(require,module,exports){
var BN = require('bn.js')
var Buffer = require('safe-buffer').Buffer

function withPublic (paddedMsg, key) {
  return Buffer.from(paddedMsg
    .toRed(BN.mont(key.modulus))
    .redPow(new BN(key.publicExponent))
    .fromRed()
    .toArray())
}

module.exports = withPublic

},{"bn.js":162,"safe-buffer":170}],166:[function(require,module,exports){
module.exports = function xor (a, b) {
  var len = a.length
  var i = -1
  while (++i < len) {
    a[i] ^= b[i]
  }
  return a
}

},{}],167:[function(require,module,exports){
(function (process,global){(function (){
'use strict'

// limit of Crypto.getRandomValues()
// https://developer.mozilla.org/en-US/docs/Web/API/Crypto/getRandomValues
var MAX_BYTES = 65536

// Node supports requesting up to this number of bytes
// https://github.com/nodejs/node/blob/master/lib/internal/crypto/random.js#L48
var MAX_UINT32 = 4294967295

function oldBrowser () {
  throw new Error('Secure random number generation is not supported by this browser.\nUse Chrome, Firefox or Internet Explorer 11')
}

var Buffer = require('safe-buffer').Buffer
var crypto = global.crypto || global.msCrypto

if (crypto && crypto.getRandomValues) {
  module.exports = randomBytes
} else {
  module.exports = oldBrowser
}

function randomBytes (size, cb) {
  // phantomjs needs to throw
  if (size > MAX_UINT32) throw new RangeError('requested too many random bytes')

  var bytes = Buffer.allocUnsafe(size)

  if (size > 0) {  // getRandomValues fails on IE if size == 0
    if (size > MAX_BYTES) { // this is the max bytes crypto.getRandomValues
      // can do at once see https://developer.mozilla.org/en-US/docs/Web/API/window.crypto.getRandomValues
      for (var generated = 0; generated < size; generated += MAX_BYTES) {
        // buffer.slice automatically checks if the end is past the end of
        // the buffer so we don't have to here
        crypto.getRandomValues(bytes.slice(generated, generated + MAX_BYTES))
      }
    } else {
      crypto.getRandomValues(bytes)
    }
  }

  if (typeof cb === 'function') {
    return process.nextTick(function () {
      cb(null, bytes)
    })
  }

  return bytes
}

}).call(this)}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"_process":159,"safe-buffer":170}],168:[function(require,module,exports){
(function (process,global){(function (){
'use strict'

function oldBrowser () {
  throw new Error('secure random number generation not supported by this browser\nuse chrome, FireFox or Internet Explorer 11')
}
var safeBuffer = require('safe-buffer')
var randombytes = require('randombytes')
var Buffer = safeBuffer.Buffer
var kBufferMaxLength = safeBuffer.kMaxLength
var crypto = global.crypto || global.msCrypto
var kMaxUint32 = Math.pow(2, 32) - 1
function assertOffset (offset, length) {
  if (typeof offset !== 'number' || offset !== offset) { // eslint-disable-line no-self-compare
    throw new TypeError('offset must be a number')
  }

  if (offset > kMaxUint32 || offset < 0) {
    throw new TypeError('offset must be a uint32')
  }

  if (offset > kBufferMaxLength || offset > length) {
    throw new RangeError('offset out of range')
  }
}

function assertSize (size, offset, length) {
  if (typeof size !== 'number' || size !== size) { // eslint-disable-line no-self-compare
    throw new TypeError('size must be a number')
  }

  if (size > kMaxUint32 || size < 0) {
    throw new TypeError('size must be a uint32')
  }

  if (size + offset > length || size > kBufferMaxLength) {
    throw new RangeError('buffer too small')
  }
}
if ((crypto && crypto.getRandomValues) || !process.browser) {
  exports.randomFill = randomFill
  exports.randomFillSync = randomFillSync
} else {
  exports.randomFill = oldBrowser
  exports.randomFillSync = oldBrowser
}
function randomFill (buf, offset, size, cb) {
  if (!Buffer.isBuffer(buf) && !(buf instanceof global.Uint8Array)) {
    throw new TypeError('"buf" argument must be a Buffer or Uint8Array')
  }

  if (typeof offset === 'function') {
    cb = offset
    offset = 0
    size = buf.length
  } else if (typeof size === 'function') {
    cb = size
    size = buf.length - offset
  } else if (typeof cb !== 'function') {
    throw new TypeError('"cb" argument must be a function')
  }
  assertOffset(offset, buf.length)
  assertSize(size, offset, buf.length)
  return actualFill(buf, offset, size, cb)
}

function actualFill (buf, offset, size, cb) {
  if (process.browser) {
    var ourBuf = buf.buffer
    var uint = new Uint8Array(ourBuf, offset, size)
    crypto.getRandomValues(uint)
    if (cb) {
      process.nextTick(function () {
        cb(null, buf)
      })
      return
    }
    return buf
  }
  if (cb) {
    randombytes(size, function (err, bytes) {
      if (err) {
        return cb(err)
      }
      bytes.copy(buf, offset)
      cb(null, buf)
    })
    return
  }
  var bytes = randombytes(size)
  bytes.copy(buf, offset)
  return buf
}
function randomFillSync (buf, offset, size) {
  if (typeof offset === 'undefined') {
    offset = 0
  }
  if (!Buffer.isBuffer(buf) && !(buf instanceof global.Uint8Array)) {
    throw new TypeError('"buf" argument must be a Buffer or Uint8Array')
  }

  assertOffset(offset, buf.length)

  if (size === undefined) size = buf.length - offset

  assertSize(size, offset, buf.length)

  return actualFill(buf, offset, size)
}

}).call(this)}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"_process":159,"randombytes":167,"safe-buffer":170}],169:[function(require,module,exports){
'use strict'
var Buffer = require('buffer').Buffer
var inherits = require('inherits')
var HashBase = require('hash-base')

var ARRAY16 = new Array(16)

var zl = [
  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
  7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8,
  3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12,
  1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2,
  4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13
]

var zr = [
  5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12,
  6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2,
  15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13,
  8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14,
  12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11
]

var sl = [
  11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8,
  7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12,
  11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5,
  11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12,
  9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6
]

var sr = [
  8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6,
  9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11,
  9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5,
  15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8,
  8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11
]

var hl = [0x00000000, 0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xa953fd4e]
var hr = [0x50a28be6, 0x5c4dd124, 0x6d703ef3, 0x7a6d76e9, 0x00000000]

function RIPEMD160 () {
  HashBase.call(this, 64)

  // state
  this._a = 0x67452301
  this._b = 0xefcdab89
  this._c = 0x98badcfe
  this._d = 0x10325476
  this._e = 0xc3d2e1f0
}

inherits(RIPEMD160, HashBase)

RIPEMD160.prototype._update = function () {
  var words = ARRAY16
  for (var j = 0; j < 16; ++j) words[j] = this._block.readInt32LE(j * 4)

  var al = this._a | 0
  var bl = this._b | 0
  var cl = this._c | 0
  var dl = this._d | 0
  var el = this._e | 0

  var ar = this._a | 0
  var br = this._b | 0
  var cr = this._c | 0
  var dr = this._d | 0
  var er = this._e | 0

  // computation
  for (var i = 0; i < 80; i += 1) {
    var tl
    var tr
    if (i < 16) {
      tl = fn1(al, bl, cl, dl, el, words[zl[i]], hl[0], sl[i])
      tr = fn5(ar, br, cr, dr, er, words[zr[i]], hr[0], sr[i])
    } else if (i < 32) {
      tl = fn2(al, bl, cl, dl, el, words[zl[i]], hl[1], sl[i])
      tr = fn4(ar, br, cr, dr, er, words[zr[i]], hr[1], sr[i])
    } else if (i < 48) {
      tl = fn3(al, bl, cl, dl, el, words[zl[i]], hl[2], sl[i])
      tr = fn3(ar, br, cr, dr, er, words[zr[i]], hr[2], sr[i])
    } else if (i < 64) {
      tl = fn4(al, bl, cl, dl, el, words[zl[i]], hl[3], sl[i])
      tr = fn2(ar, br, cr, dr, er, words[zr[i]], hr[3], sr[i])
    } else { // if (i<80) {
      tl = fn5(al, bl, cl, dl, el, words[zl[i]], hl[4], sl[i])
      tr = fn1(ar, br, cr, dr, er, words[zr[i]], hr[4], sr[i])
    }

    al = el
    el = dl
    dl = rotl(cl, 10)
    cl = bl
    bl = tl

    ar = er
    er = dr
    dr = rotl(cr, 10)
    cr = br
    br = tr
  }

  // update state
  var t = (this._b + cl + dr) | 0
  this._b = (this._c + dl + er) | 0
  this._c = (this._d + el + ar) | 0
  this._d = (this._e + al + br) | 0
  this._e = (this._a + bl + cr) | 0
  this._a = t
}

RIPEMD160.prototype._digest = function () {
  // create padding and handle blocks
  this._block[this._blockOffset++] = 0x80
  if (this._blockOffset > 56) {
    this._block.fill(0, this._blockOffset, 64)
    this._update()
    this._blockOffset = 0
  }

  this._block.fill(0, this._blockOffset, 56)
  this._block.writeUInt32LE(this._length[0], 56)
  this._block.writeUInt32LE(this._length[1], 60)
  this._update()

  // produce result
  var buffer = Buffer.alloc ? Buffer.alloc(20) : new Buffer(20)
  buffer.writeInt32LE(this._a, 0)
  buffer.writeInt32LE(this._b, 4)
  buffer.writeInt32LE(this._c, 8)
  buffer.writeInt32LE(this._d, 12)
  buffer.writeInt32LE(this._e, 16)
  return buffer
}

function rotl (x, n) {
  return (x << n) | (x >>> (32 - n))
}

function fn1 (a, b, c, d, e, m, k, s) {
  return (rotl((a + (b ^ c ^ d) + m + k) | 0, s) + e) | 0
}

function fn2 (a, b, c, d, e, m, k, s) {
  return (rotl((a + ((b & c) | ((~b) & d)) + m + k) | 0, s) + e) | 0
}

function fn3 (a, b, c, d, e, m, k, s) {
  return (rotl((a + ((b | (~c)) ^ d) + m + k) | 0, s) + e) | 0
}

function fn4 (a, b, c, d, e, m, k, s) {
  return (rotl((a + ((b & d) | (c & (~d))) + m + k) | 0, s) + e) | 0
}

function fn5 (a, b, c, d, e, m, k, s) {
  return (rotl((a + (b ^ (c | (~d))) + m + k) | 0, s) + e) | 0
}

module.exports = RIPEMD160

},{"buffer":72,"hash-base":111,"inherits":141}],170:[function(require,module,exports){
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
/* eslint-disable node/no-deprecated-api */
var buffer = require('buffer')
var Buffer = buffer.Buffer

// alternative to using Object.keys for old browsers
function copyProps (src, dst) {
  for (var key in src) {
    dst[key] = src[key]
  }
}
if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
  module.exports = buffer
} else {
  // Copy properties from require('buffer')
  copyProps(buffer, exports)
  exports.Buffer = SafeBuffer
}

function SafeBuffer (arg, encodingOrOffset, length) {
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.prototype = Object.create(Buffer.prototype)

// Copy static methods from Buffer
copyProps(Buffer, SafeBuffer)

SafeBuffer.from = function (arg, encodingOrOffset, length) {
  if (typeof arg === 'number') {
    throw new TypeError('Argument must not be a number')
  }
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.alloc = function (size, fill, encoding) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  var buf = Buffer(size)
  if (fill !== undefined) {
    if (typeof encoding === 'string') {
      buf.fill(fill, encoding)
    } else {
      buf.fill(fill)
    }
  } else {
    buf.fill(0)
  }
  return buf
}

SafeBuffer.allocUnsafe = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return Buffer(size)
}

SafeBuffer.allocUnsafeSlow = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return buffer.SlowBuffer(size)
}

},{"buffer":72}],171:[function(require,module,exports){
(function (process){(function (){
/* eslint-disable node/no-deprecated-api */

'use strict'

var buffer = require('buffer')
var Buffer = buffer.Buffer

var safer = {}

var key

for (key in buffer) {
  if (!buffer.hasOwnProperty(key)) continue
  if (key === 'SlowBuffer' || key === 'Buffer') continue
  safer[key] = buffer[key]
}

var Safer = safer.Buffer = {}
for (key in Buffer) {
  if (!Buffer.hasOwnProperty(key)) continue
  if (key === 'allocUnsafe' || key === 'allocUnsafeSlow') continue
  Safer[key] = Buffer[key]
}

safer.Buffer.prototype = Buffer.prototype

if (!Safer.from || Safer.from === Uint8Array.from) {
  Safer.from = function (value, encodingOrOffset, length) {
    if (typeof value === 'number') {
      throw new TypeError('The "value" argument must not be of type number. Received type ' + typeof value)
    }
    if (value && typeof value.length === 'undefined') {
      throw new TypeError('The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type ' + typeof value)
    }
    return Buffer(value, encodingOrOffset, length)
  }
}

if (!Safer.alloc) {
  Safer.alloc = function (size, fill, encoding) {
    if (typeof size !== 'number') {
      throw new TypeError('The "size" argument must be of type number. Received type ' + typeof size)
    }
    if (size < 0 || size >= 2 * (1 << 30)) {
      throw new RangeError('The value "' + size + '" is invalid for option "size"')
    }
    var buf = Buffer(size)
    if (!fill || fill.length === 0) {
      buf.fill(0)
    } else if (typeof encoding === 'string') {
      buf.fill(fill, encoding)
    } else {
      buf.fill(fill)
    }
    return buf
  }
}

if (!safer.kStringMaxLength) {
  try {
    safer.kStringMaxLength = process.binding('buffer').kStringMaxLength
  } catch (e) {
    // we can't determine kStringMaxLength in environments where process.binding
    // is unsupported, so let's not set it
  }
}

if (!safer.constants) {
  safer.constants = {
    MAX_LENGTH: safer.kMaxLength
  }
  if (safer.kStringMaxLength) {
    safer.constants.MAX_STRING_LENGTH = safer.kStringMaxLength
  }
}

module.exports = safer

}).call(this)}).call(this,require('_process'))
},{"_process":159,"buffer":72}],172:[function(require,module,exports){
var Buffer = require('safe-buffer').Buffer

// prototype class for hash functions
function Hash (blockSize, finalSize) {
  this._block = Buffer.alloc(blockSize)
  this._finalSize = finalSize
  this._blockSize = blockSize
  this._len = 0
}

Hash.prototype.update = function (data, enc) {
  if (typeof data === 'string') {
    enc = enc || 'utf8'
    data = Buffer.from(data, enc)
  }

  var block = this._block
  var blockSize = this._blockSize
  var length = data.length
  var accum = this._len

  for (var offset = 0; offset < length;) {
    var assigned = accum % blockSize
    var remainder = Math.min(length - offset, blockSize - assigned)

    for (var i = 0; i < remainder; i++) {
      block[assigned + i] = data[offset + i]
    }

    accum += remainder
    offset += remainder

    if ((accum % blockSize) === 0) {
      this._update(block)
    }
  }

  this._len += length
  return this
}

Hash.prototype.digest = function (enc) {
  var rem = this._len % this._blockSize

  this._block[rem] = 0x80

  // zero (rem + 1) trailing bits, where (rem + 1) is the smallest
  // non-negative solution to the equation (length + 1 + (rem + 1)) === finalSize mod blockSize
  this._block.fill(0, rem + 1)

  if (rem >= this._finalSize) {
    this._update(this._block)
    this._block.fill(0)
  }

  var bits = this._len * 8

  // uint32
  if (bits <= 0xffffffff) {
    this._block.writeUInt32BE(bits, this._blockSize - 4)

  // uint64
  } else {
    var lowBits = (bits & 0xffffffff) >>> 0
    var highBits = (bits - lowBits) / 0x100000000

    this._block.writeUInt32BE(highBits, this._blockSize - 8)
    this._block.writeUInt32BE(lowBits, this._blockSize - 4)
  }

  this._update(this._block)
  var hash = this._hash()

  return enc ? hash.toString(enc) : hash
}

Hash.prototype._update = function () {
  throw new Error('_update must be implemented by subclass')
}

module.exports = Hash

},{"safe-buffer":170}],173:[function(require,module,exports){
var exports = module.exports = function SHA (algorithm) {
  algorithm = algorithm.toLowerCase()

  var Algorithm = exports[algorithm]
  if (!Algorithm) throw new Error(algorithm + ' is not supported (we accept pull requests)')

  return new Algorithm()
}

exports.sha = require('./sha')
exports.sha1 = require('./sha1')
exports.sha224 = require('./sha224')
exports.sha256 = require('./sha256')
exports.sha384 = require('./sha384')
exports.sha512 = require('./sha512')

},{"./sha":174,"./sha1":175,"./sha224":176,"./sha256":177,"./sha384":178,"./sha512":179}],174:[function(require,module,exports){
/*
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-0, as defined
 * in FIPS PUB 180-1
 * This source code is derived from sha1.js of the same repository.
 * The difference between SHA-0 and SHA-1 is just a bitwise rotate left
 * operation was added.
 */

var inherits = require('inherits')
var Hash = require('./hash')
var Buffer = require('safe-buffer').Buffer

var K = [
  0x5a827999, 0x6ed9eba1, 0x8f1bbcdc | 0, 0xca62c1d6 | 0
]

var W = new Array(80)

function Sha () {
  this.init()
  this._w = W

  Hash.call(this, 64, 56)
}

inherits(Sha, Hash)

Sha.prototype.init = function () {
  this._a = 0x67452301
  this._b = 0xefcdab89
  this._c = 0x98badcfe
  this._d = 0x10325476
  this._e = 0xc3d2e1f0

  return this
}

function rotl5 (num) {
  return (num << 5) | (num >>> 27)
}

function rotl30 (num) {
  return (num << 30) | (num >>> 2)
}

function ft (s, b, c, d) {
  if (s === 0) return (b & c) | ((~b) & d)
  if (s === 2) return (b & c) | (b & d) | (c & d)
  return b ^ c ^ d
}

Sha.prototype._update = function (M) {
  var W = this._w

  var a = this._a | 0
  var b = this._b | 0
  var c = this._c | 0
  var d = this._d | 0
  var e = this._e | 0

  for (var i = 0; i < 16; ++i) W[i] = M.readInt32BE(i * 4)
  for (; i < 80; ++i) W[i] = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16]

  for (var j = 0; j < 80; ++j) {
    var s = ~~(j / 20)
    var t = (rotl5(a) + ft(s, b, c, d) + e + W[j] + K[s]) | 0

    e = d
    d = c
    c = rotl30(b)
    b = a
    a = t
  }

  this._a = (a + this._a) | 0
  this._b = (b + this._b) | 0
  this._c = (c + this._c) | 0
  this._d = (d + this._d) | 0
  this._e = (e + this._e) | 0
}

Sha.prototype._hash = function () {
  var H = Buffer.allocUnsafe(20)

  H.writeInt32BE(this._a | 0, 0)
  H.writeInt32BE(this._b | 0, 4)
  H.writeInt32BE(this._c | 0, 8)
  H.writeInt32BE(this._d | 0, 12)
  H.writeInt32BE(this._e | 0, 16)

  return H
}

module.exports = Sha

},{"./hash":172,"inherits":141,"safe-buffer":170}],175:[function(require,module,exports){
/*
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined
 * in FIPS PUB 180-1
 * Version 2.1a Copyright Paul Johnston 2000 - 2002.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for details.
 */

var inherits = require('inherits')
var Hash = require('./hash')
var Buffer = require('safe-buffer').Buffer

var K = [
  0x5a827999, 0x6ed9eba1, 0x8f1bbcdc | 0, 0xca62c1d6 | 0
]

var W = new Array(80)

function Sha1 () {
  this.init()
  this._w = W

  Hash.call(this, 64, 56)
}

inherits(Sha1, Hash)

Sha1.prototype.init = function () {
  this._a = 0x67452301
  this._b = 0xefcdab89
  this._c = 0x98badcfe
  this._d = 0x10325476
  this._e = 0xc3d2e1f0

  return this
}

function rotl1 (num) {
  return (num << 1) | (num >>> 31)
}

function rotl5 (num) {
  return (num << 5) | (num >>> 27)
}

function rotl30 (num) {
  return (num << 30) | (num >>> 2)
}

function ft (s, b, c, d) {
  if (s === 0) return (b & c) | ((~b) & d)
  if (s === 2) return (b & c) | (b & d) | (c & d)
  return b ^ c ^ d
}

Sha1.prototype._update = function (M) {
  var W = this._w

  var a = this._a | 0
  var b = this._b | 0
  var c = this._c | 0
  var d = this._d | 0
  var e = this._e | 0

  for (var i = 0; i < 16; ++i) W[i] = M.readInt32BE(i * 4)
  for (; i < 80; ++i) W[i] = rotl1(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16])

  for (var j = 0; j < 80; ++j) {
    var s = ~~(j / 20)
    var t = (rotl5(a) + ft(s, b, c, d) + e + W[j] + K[s]) | 0

    e = d
    d = c
    c = rotl30(b)
    b = a
    a = t
  }

  this._a = (a + this._a) | 0
  this._b = (b + this._b) | 0
  this._c = (c + this._c) | 0
  this._d = (d + this._d) | 0
  this._e = (e + this._e) | 0
}

Sha1.prototype._hash = function () {
  var H = Buffer.allocUnsafe(20)

  H.writeInt32BE(this._a | 0, 0)
  H.writeInt32BE(this._b | 0, 4)
  H.writeInt32BE(this._c | 0, 8)
  H.writeInt32BE(this._d | 0, 12)
  H.writeInt32BE(this._e | 0, 16)

  return H
}

module.exports = Sha1

},{"./hash":172,"inherits":141,"safe-buffer":170}],176:[function(require,module,exports){
/**
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined
 * in FIPS 180-2
 * Version 2.2-beta Copyright Angel Marin, Paul Johnston 2000 - 2009.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 *
 */

var inherits = require('inherits')
var Sha256 = require('./sha256')
var Hash = require('./hash')
var Buffer = require('safe-buffer').Buffer

var W = new Array(64)

function Sha224 () {
  this.init()

  this._w = W // new Array(64)

  Hash.call(this, 64, 56)
}

inherits(Sha224, Sha256)

Sha224.prototype.init = function () {
  this._a = 0xc1059ed8
  this._b = 0x367cd507
  this._c = 0x3070dd17
  this._d = 0xf70e5939
  this._e = 0xffc00b31
  this._f = 0x68581511
  this._g = 0x64f98fa7
  this._h = 0xbefa4fa4

  return this
}

Sha224.prototype._hash = function () {
  var H = Buffer.allocUnsafe(28)

  H.writeInt32BE(this._a, 0)
  H.writeInt32BE(this._b, 4)
  H.writeInt32BE(this._c, 8)
  H.writeInt32BE(this._d, 12)
  H.writeInt32BE(this._e, 16)
  H.writeInt32BE(this._f, 20)
  H.writeInt32BE(this._g, 24)

  return H
}

module.exports = Sha224

},{"./hash":172,"./sha256":177,"inherits":141,"safe-buffer":170}],177:[function(require,module,exports){
/**
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-256, as defined
 * in FIPS 180-2
 * Version 2.2-beta Copyright Angel Marin, Paul Johnston 2000 - 2009.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 *
 */

var inherits = require('inherits')
var Hash = require('./hash')
var Buffer = require('safe-buffer').Buffer

var K = [
  0x428A2F98, 0x71374491, 0xB5C0FBCF, 0xE9B5DBA5,
  0x3956C25B, 0x59F111F1, 0x923F82A4, 0xAB1C5ED5,
  0xD807AA98, 0x12835B01, 0x243185BE, 0x550C7DC3,
  0x72BE5D74, 0x80DEB1FE, 0x9BDC06A7, 0xC19BF174,
  0xE49B69C1, 0xEFBE4786, 0x0FC19DC6, 0x240CA1CC,
  0x2DE92C6F, 0x4A7484AA, 0x5CB0A9DC, 0x76F988DA,
  0x983E5152, 0xA831C66D, 0xB00327C8, 0xBF597FC7,
  0xC6E00BF3, 0xD5A79147, 0x06CA6351, 0x14292967,
  0x27B70A85, 0x2E1B2138, 0x4D2C6DFC, 0x53380D13,
  0x650A7354, 0x766A0ABB, 0x81C2C92E, 0x92722C85,
  0xA2BFE8A1, 0xA81A664B, 0xC24B8B70, 0xC76C51A3,
  0xD192E819, 0xD6990624, 0xF40E3585, 0x106AA070,
  0x19A4C116, 0x1E376C08, 0x2748774C, 0x34B0BCB5,
  0x391C0CB3, 0x4ED8AA4A, 0x5B9CCA4F, 0x682E6FF3,
  0x748F82EE, 0x78A5636F, 0x84C87814, 0x8CC70208,
  0x90BEFFFA, 0xA4506CEB, 0xBEF9A3F7, 0xC67178F2
]

var W = new Array(64)

function Sha256 () {
  this.init()

  this._w = W // new Array(64)

  Hash.call(this, 64, 56)
}

inherits(Sha256, Hash)

Sha256.prototype.init = function () {
  this._a = 0x6a09e667
  this._b = 0xbb67ae85
  this._c = 0x3c6ef372
  this._d = 0xa54ff53a
  this._e = 0x510e527f
  this._f = 0x9b05688c
  this._g = 0x1f83d9ab
  this._h = 0x5be0cd19

  return this
}

function ch (x, y, z) {
  return z ^ (x & (y ^ z))
}

function maj (x, y, z) {
  return (x & y) | (z & (x | y))
}

function sigma0 (x) {
  return (x >>> 2 | x << 30) ^ (x >>> 13 | x << 19) ^ (x >>> 22 | x << 10)
}

function sigma1 (x) {
  return (x >>> 6 | x << 26) ^ (x >>> 11 | x << 21) ^ (x >>> 25 | x << 7)
}

function gamma0 (x) {
  return (x >>> 7 | x << 25) ^ (x >>> 18 | x << 14) ^ (x >>> 3)
}

function gamma1 (x) {
  return (x >>> 17 | x << 15) ^ (x >>> 19 | x << 13) ^ (x >>> 10)
}

Sha256.prototype._update = function (M) {
  var W = this._w

  var a = this._a | 0
  var b = this._b | 0
  var c = this._c | 0
  var d = this._d | 0
  var e = this._e | 0
  var f = this._f | 0
  var g = this._g | 0
  var h = this._h | 0

  for (var i = 0; i < 16; ++i) W[i] = M.readInt32BE(i * 4)
  for (; i < 64; ++i) W[i] = (gamma1(W[i - 2]) + W[i - 7] + gamma0(W[i - 15]) + W[i - 16]) | 0

  for (var j = 0; j < 64; ++j) {
    var T1 = (h + sigma1(e) + ch(e, f, g) + K[j] + W[j]) | 0
    var T2 = (sigma0(a) + maj(a, b, c)) | 0

    h = g
    g = f
    f = e
    e = (d + T1) | 0
    d = c
    c = b
    b = a
    a = (T1 + T2) | 0
  }

  this._a = (a + this._a) | 0
  this._b = (b + this._b) | 0
  this._c = (c + this._c) | 0
  this._d = (d + this._d) | 0
  this._e = (e + this._e) | 0
  this._f = (f + this._f) | 0
  this._g = (g + this._g) | 0
  this._h = (h + this._h) | 0
}

Sha256.prototype._hash = function () {
  var H = Buffer.allocUnsafe(32)

  H.writeInt32BE(this._a, 0)
  H.writeInt32BE(this._b, 4)
  H.writeInt32BE(this._c, 8)
  H.writeInt32BE(this._d, 12)
  H.writeInt32BE(this._e, 16)
  H.writeInt32BE(this._f, 20)
  H.writeInt32BE(this._g, 24)
  H.writeInt32BE(this._h, 28)

  return H
}

module.exports = Sha256

},{"./hash":172,"inherits":141,"safe-buffer":170}],178:[function(require,module,exports){
var inherits = require('inherits')
var SHA512 = require('./sha512')
var Hash = require('./hash')
var Buffer = require('safe-buffer').Buffer

var W = new Array(160)

function Sha384 () {
  this.init()
  this._w = W

  Hash.call(this, 128, 112)
}

inherits(Sha384, SHA512)

Sha384.prototype.init = function () {
  this._ah = 0xcbbb9d5d
  this._bh = 0x629a292a
  this._ch = 0x9159015a
  this._dh = 0x152fecd8
  this._eh = 0x67332667
  this._fh = 0x8eb44a87
  this._gh = 0xdb0c2e0d
  this._hh = 0x47b5481d

  this._al = 0xc1059ed8
  this._bl = 0x367cd507
  this._cl = 0x3070dd17
  this._dl = 0xf70e5939
  this._el = 0xffc00b31
  this._fl = 0x68581511
  this._gl = 0x64f98fa7
  this._hl = 0xbefa4fa4

  return this
}

Sha384.prototype._hash = function () {
  var H = Buffer.allocUnsafe(48)

  function writeInt64BE (h, l, offset) {
    H.writeInt32BE(h, offset)
    H.writeInt32BE(l, offset + 4)
  }

  writeInt64BE(this._ah, this._al, 0)
  writeInt64BE(this._bh, this._bl, 8)
  writeInt64BE(this._ch, this._cl, 16)
  writeInt64BE(this._dh, this._dl, 24)
  writeInt64BE(this._eh, this._el, 32)
  writeInt64BE(this._fh, this._fl, 40)

  return H
}

module.exports = Sha384

},{"./hash":172,"./sha512":179,"inherits":141,"safe-buffer":170}],179:[function(require,module,exports){
var inherits = require('inherits')
var Hash = require('./hash')
var Buffer = require('safe-buffer').Buffer

var K = [
  0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd,
  0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc,
  0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019,
  0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118,
  0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe,
  0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2,
  0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1,
  0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694,
  0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3,
  0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65,
  0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483,
  0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5,
  0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210,
  0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4,
  0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725,
  0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70,
  0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926,
  0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df,
  0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8,
  0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b,
  0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001,
  0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30,
  0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910,
  0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8,
  0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53,
  0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8,
  0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb,
  0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3,
  0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60,
  0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec,
  0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9,
  0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b,
  0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207,
  0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178,
  0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6,
  0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b,
  0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493,
  0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c,
  0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a,
  0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817
]

var W = new Array(160)

function Sha512 () {
  this.init()
  this._w = W

  Hash.call(this, 128, 112)
}

inherits(Sha512, Hash)

Sha512.prototype.init = function () {
  this._ah = 0x6a09e667
  this._bh = 0xbb67ae85
  this._ch = 0x3c6ef372
  this._dh = 0xa54ff53a
  this._eh = 0x510e527f
  this._fh = 0x9b05688c
  this._gh = 0x1f83d9ab
  this._hh = 0x5be0cd19

  this._al = 0xf3bcc908
  this._bl = 0x84caa73b
  this._cl = 0xfe94f82b
  this._dl = 0x5f1d36f1
  this._el = 0xade682d1
  this._fl = 0x2b3e6c1f
  this._gl = 0xfb41bd6b
  this._hl = 0x137e2179

  return this
}

function Ch (x, y, z) {
  return z ^ (x & (y ^ z))
}

function maj (x, y, z) {
  return (x & y) | (z & (x | y))
}

function sigma0 (x, xl) {
  return (x >>> 28 | xl << 4) ^ (xl >>> 2 | x << 30) ^ (xl >>> 7 | x << 25)
}

function sigma1 (x, xl) {
  return (x >>> 14 | xl << 18) ^ (x >>> 18 | xl << 14) ^ (xl >>> 9 | x << 23)
}

function Gamma0 (x, xl) {
  return (x >>> 1 | xl << 31) ^ (x >>> 8 | xl << 24) ^ (x >>> 7)
}

function Gamma0l (x, xl) {
  return (x >>> 1 | xl << 31) ^ (x >>> 8 | xl << 24) ^ (x >>> 7 | xl << 25)
}

function Gamma1 (x, xl) {
  return (x >>> 19 | xl << 13) ^ (xl >>> 29 | x << 3) ^ (x >>> 6)
}

function Gamma1l (x, xl) {
  return (x >>> 19 | xl << 13) ^ (xl >>> 29 | x << 3) ^ (x >>> 6 | xl << 26)
}

function getCarry (a, b) {
  return (a >>> 0) < (b >>> 0) ? 1 : 0
}

Sha512.prototype._update = function (M) {
  var W = this._w

  var ah = this._ah | 0
  var bh = this._bh | 0
  var ch = this._ch | 0
  var dh = this._dh | 0
  var eh = this._eh | 0
  var fh = this._fh | 0
  var gh = this._gh | 0
  var hh = this._hh | 0

  var al = this._al | 0
  var bl = this._bl | 0
  var cl = this._cl | 0
  var dl = this._dl | 0
  var el = this._el | 0
  var fl = this._fl | 0
  var gl = this._gl | 0
  var hl = this._hl | 0

  for (var i = 0; i < 32; i += 2) {
    W[i] = M.readInt32BE(i * 4)
    W[i + 1] = M.readInt32BE(i * 4 + 4)
  }
  for (; i < 160; i += 2) {
    var xh = W[i - 15 * 2]
    var xl = W[i - 15 * 2 + 1]
    var gamma0 = Gamma0(xh, xl)
    var gamma0l = Gamma0l(xl, xh)

    xh = W[i - 2 * 2]
    xl = W[i - 2 * 2 + 1]
    var gamma1 = Gamma1(xh, xl)
    var gamma1l = Gamma1l(xl, xh)

    // W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16]
    var Wi7h = W[i - 7 * 2]
    var Wi7l = W[i - 7 * 2 + 1]

    var Wi16h = W[i - 16 * 2]
    var Wi16l = W[i - 16 * 2 + 1]

    var Wil = (gamma0l + Wi7l) | 0
    var Wih = (gamma0 + Wi7h + getCarry(Wil, gamma0l)) | 0
    Wil = (Wil + gamma1l) | 0
    Wih = (Wih + gamma1 + getCarry(Wil, gamma1l)) | 0
    Wil = (Wil + Wi16l) | 0
    Wih = (Wih + Wi16h + getCarry(Wil, Wi16l)) | 0

    W[i] = Wih
    W[i + 1] = Wil
  }

  for (var j = 0; j < 160; j += 2) {
    Wih = W[j]
    Wil = W[j + 1]

    var majh = maj(ah, bh, ch)
    var majl = maj(al, bl, cl)

    var sigma0h = sigma0(ah, al)
    var sigma0l = sigma0(al, ah)
    var sigma1h = sigma1(eh, el)
    var sigma1l = sigma1(el, eh)

    // t1 = h + sigma1 + ch + K[j] + W[j]
    var Kih = K[j]
    var Kil = K[j + 1]

    var chh = Ch(eh, fh, gh)
    var chl = Ch(el, fl, gl)

    var t1l = (hl + sigma1l) | 0
    var t1h = (hh + sigma1h + getCarry(t1l, hl)) | 0
    t1l = (t1l + chl) | 0
    t1h = (t1h + chh + getCarry(t1l, chl)) | 0
    t1l = (t1l + Kil) | 0
    t1h = (t1h + Kih + getCarry(t1l, Kil)) | 0
    t1l = (t1l + Wil) | 0
    t1h = (t1h + Wih + getCarry(t1l, Wil)) | 0

    // t2 = sigma0 + maj
    var t2l = (sigma0l + majl) | 0
    var t2h = (sigma0h + majh + getCarry(t2l, sigma0l)) | 0

    hh = gh
    hl = gl
    gh = fh
    gl = fl
    fh = eh
    fl = el
    el = (dl + t1l) | 0
    eh = (dh + t1h + getCarry(el, dl)) | 0
    dh = ch
    dl = cl
    ch = bh
    cl = bl
    bh = ah
    bl = al
    al = (t1l + t2l) | 0
    ah = (t1h + t2h + getCarry(al, t1l)) | 0
  }

  this._al = (this._al + al) | 0
  this._bl = (this._bl + bl) | 0
  this._cl = (this._cl + cl) | 0
  this._dl = (this._dl + dl) | 0
  this._el = (this._el + el) | 0
  this._fl = (this._fl + fl) | 0
  this._gl = (this._gl + gl) | 0
  this._hl = (this._hl + hl) | 0

  this._ah = (this._ah + ah + getCarry(this._al, al)) | 0
  this._bh = (this._bh + bh + getCarry(this._bl, bl)) | 0
  this._ch = (this._ch + ch + getCarry(this._cl, cl)) | 0
  this._dh = (this._dh + dh + getCarry(this._dl, dl)) | 0
  this._eh = (this._eh + eh + getCarry(this._el, el)) | 0
  this._fh = (this._fh + fh + getCarry(this._fl, fl)) | 0
  this._gh = (this._gh + gh + getCarry(this._gl, gl)) | 0
  this._hh = (this._hh + hh + getCarry(this._hl, hl)) | 0
}

Sha512.prototype._hash = function () {
  var H = Buffer.allocUnsafe(64)

  function writeInt64BE (h, l, offset) {
    H.writeInt32BE(h, offset)
    H.writeInt32BE(l, offset + 4)
  }

  writeInt64BE(this._ah, this._al, 0)
  writeInt64BE(this._bh, this._bl, 8)
  writeInt64BE(this._ch, this._cl, 16)
  writeInt64BE(this._dh, this._dl, 24)
  writeInt64BE(this._eh, this._el, 32)
  writeInt64BE(this._fh, this._fl, 40)
  writeInt64BE(this._gh, this._gl, 48)
  writeInt64BE(this._hh, this._hl, 56)

  return H
}

module.exports = Sha512

},{"./hash":172,"inherits":141,"safe-buffer":170}],180:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

module.exports = Stream;

var EE = require('events').EventEmitter;
var inherits = require('inherits');

inherits(Stream, EE);
Stream.Readable = require('readable-stream/lib/_stream_readable.js');
Stream.Writable = require('readable-stream/lib/_stream_writable.js');
Stream.Duplex = require('readable-stream/lib/_stream_duplex.js');
Stream.Transform = require('readable-stream/lib/_stream_transform.js');
Stream.PassThrough = require('readable-stream/lib/_stream_passthrough.js');
Stream.finished = require('readable-stream/lib/internal/streams/end-of-stream.js')
Stream.pipeline = require('readable-stream/lib/internal/streams/pipeline.js')

// Backwards-compat with node 0.4.x
Stream.Stream = Stream;



// old-style streams.  Note that the pipe method (the only relevant
// part of this class) is overridden in the Readable class.

function Stream() {
  EE.call(this);
}

Stream.prototype.pipe = function(dest, options) {
  var source = this;

  function ondata(chunk) {
    if (dest.writable) {
      if (false === dest.write(chunk) && source.pause) {
        source.pause();
      }
    }
  }

  source.on('data', ondata);

  function ondrain() {
    if (source.readable && source.resume) {
      source.resume();
    }
  }

  dest.on('drain', ondrain);

  // If the 'end' option is not supplied, dest.end() will be called when
  // source gets the 'end' or 'close' events.  Only dest.end() once.
  if (!dest._isStdio && (!options || options.end !== false)) {
    source.on('end', onend);
    source.on('close', onclose);
  }

  var didOnEnd = false;
  function onend() {
    if (didOnEnd) return;
    didOnEnd = true;

    dest.end();
  }


  function onclose() {
    if (didOnEnd) return;
    didOnEnd = true;

    if (typeof dest.destroy === 'function') dest.destroy();
  }

  // don't leave dangling pipes when there are errors.
  function onerror(er) {
    cleanup();
    if (EE.listenerCount(this, 'error') === 0) {
      throw er; // Unhandled stream error in pipe.
    }
  }

  source.on('error', onerror);
  dest.on('error', onerror);

  // remove all the event listeners that were added.
  function cleanup() {
    source.removeListener('data', ondata);
    dest.removeListener('drain', ondrain);

    source.removeListener('end', onend);
    source.removeListener('close', onclose);

    source.removeListener('error', onerror);
    dest.removeListener('error', onerror);

    source.removeListener('end', cleanup);
    source.removeListener('close', cleanup);

    dest.removeListener('close', cleanup);
  }

  source.on('end', cleanup);
  source.on('close', cleanup);

  dest.on('close', cleanup);

  dest.emit('pipe', source);

  // Allow for unix-like usage: A.pipe(B).pipe(C)
  return dest;
};

},{"events":109,"inherits":141,"readable-stream/lib/_stream_duplex.js":182,"readable-stream/lib/_stream_passthrough.js":183,"readable-stream/lib/_stream_readable.js":184,"readable-stream/lib/_stream_transform.js":185,"readable-stream/lib/_stream_writable.js":186,"readable-stream/lib/internal/streams/end-of-stream.js":190,"readable-stream/lib/internal/streams/pipeline.js":192}],181:[function(require,module,exports){
arguments[4][55][0].apply(exports,arguments)
},{"dup":55}],182:[function(require,module,exports){
arguments[4][56][0].apply(exports,arguments)
},{"./_stream_readable":184,"./_stream_writable":186,"_process":159,"dup":56,"inherits":141}],183:[function(require,module,exports){
arguments[4][57][0].apply(exports,arguments)
},{"./_stream_transform":185,"dup":57,"inherits":141}],184:[function(require,module,exports){
arguments[4][58][0].apply(exports,arguments)
},{"../errors":181,"./_stream_duplex":182,"./internal/streams/async_iterator":187,"./internal/streams/buffer_list":188,"./internal/streams/destroy":189,"./internal/streams/from":191,"./internal/streams/state":193,"./internal/streams/stream":194,"_process":159,"buffer":72,"dup":58,"events":109,"inherits":141,"string_decoder/":195,"util":27}],185:[function(require,module,exports){
arguments[4][59][0].apply(exports,arguments)
},{"../errors":181,"./_stream_duplex":182,"dup":59,"inherits":141}],186:[function(require,module,exports){
arguments[4][60][0].apply(exports,arguments)
},{"../errors":181,"./_stream_duplex":182,"./internal/streams/destroy":189,"./internal/streams/state":193,"./internal/streams/stream":194,"_process":159,"buffer":72,"dup":60,"inherits":141,"util-deprecate":196}],187:[function(require,module,exports){
arguments[4][61][0].apply(exports,arguments)
},{"./end-of-stream":190,"_process":159,"dup":61}],188:[function(require,module,exports){
arguments[4][62][0].apply(exports,arguments)
},{"buffer":72,"dup":62,"util":27}],189:[function(require,module,exports){
arguments[4][63][0].apply(exports,arguments)
},{"_process":159,"dup":63}],190:[function(require,module,exports){
arguments[4][64][0].apply(exports,arguments)
},{"../../../errors":181,"dup":64}],191:[function(require,module,exports){
arguments[4][65][0].apply(exports,arguments)
},{"dup":65}],192:[function(require,module,exports){
arguments[4][66][0].apply(exports,arguments)
},{"../../../errors":181,"./end-of-stream":190,"dup":66}],193:[function(require,module,exports){
arguments[4][67][0].apply(exports,arguments)
},{"../../../errors":181,"dup":67}],194:[function(require,module,exports){
arguments[4][68][0].apply(exports,arguments)
},{"dup":68,"events":109}],195:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

/*<replacement>*/

var Buffer = require('safe-buffer').Buffer;
/*</replacement>*/

var isEncoding = Buffer.isEncoding || function (encoding) {
  encoding = '' + encoding;
  switch (encoding && encoding.toLowerCase()) {
    case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':
      return true;
    default:
      return false;
  }
};

function _normalizeEncoding(enc) {
  if (!enc) return 'utf8';
  var retried;
  while (true) {
    switch (enc) {
      case 'utf8':
      case 'utf-8':
        return 'utf8';
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return 'utf16le';
      case 'latin1':
      case 'binary':
        return 'latin1';
      case 'base64':
      case 'ascii':
      case 'hex':
        return enc;
      default:
        if (retried) return; // undefined
        enc = ('' + enc).toLowerCase();
        retried = true;
    }
  }
};

// Do not cache `Buffer.isEncoding` when checking encoding names as some
// modules monkey-patch it to support additional encodings
function normalizeEncoding(enc) {
  var nenc = _normalizeEncoding(enc);
  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);
  return nenc || enc;
}

// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters.
exports.StringDecoder = StringDecoder;
function StringDecoder(encoding) {
  this.encoding = normalizeEncoding(encoding);
  var nb;
  switch (this.encoding) {
    case 'utf16le':
      this.text = utf16Text;
      this.end = utf16End;
      nb = 4;
      break;
    case 'utf8':
      this.fillLast = utf8FillLast;
      nb = 4;
      break;
    case 'base64':
      this.text = base64Text;
      this.end = base64End;
      nb = 3;
      break;
    default:
      this.write = simpleWrite;
      this.end = simpleEnd;
      return;
  }
  this.lastNeed = 0;
  this.lastTotal = 0;
  this.lastChar = Buffer.allocUnsafe(nb);
}

StringDecoder.prototype.write = function (buf) {
  if (buf.length === 0) return '';
  var r;
  var i;
  if (this.lastNeed) {
    r = this.fillLast(buf);
    if (r === undefined) return '';
    i = this.lastNeed;
    this.lastNeed = 0;
  } else {
    i = 0;
  }
  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
  return r || '';
};

StringDecoder.prototype.end = utf8End;

// Returns only complete characters in a Buffer
StringDecoder.prototype.text = utf8Text;

// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer
StringDecoder.prototype.fillLast = function (buf) {
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
  this.lastNeed -= buf.length;
};

// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
// continuation byte. If an invalid byte is detected, -2 is returned.
function utf8CheckByte(byte) {
  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;
  return byte >> 6 === 0x02 ? -1 : -2;
}

// Checks at most 3 bytes at the end of a Buffer in order to detect an
// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
// needed to complete the UTF-8 character (if applicable) are returned.
function utf8CheckIncomplete(self, buf, i) {
  var j = buf.length - 1;
  if (j < i) return 0;
  var nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 1;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 2;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) {
      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;
    }
    return nb;
  }
  return 0;
}

// Validates as many continuation bytes for a multi-byte UTF-8 character as
// needed or are available. If we see a non-continuation byte where we expect
// one, we "replace" the validated continuation bytes we've seen so far with
// a single UTF-8 replacement character ('\ufffd'), to match v8's UTF-8 decoding
// behavior. The continuation byte check is included three times in the case
// where all of the continuation bytes for a character exist in the same buffer.
// It is also done this way as a slight performance increase instead of using a
// loop.
function utf8CheckExtraBytes(self, buf, p) {
  if ((buf[0] & 0xC0) !== 0x80) {
    self.lastNeed = 0;
    return '\ufffd';
  }
  if (self.lastNeed > 1 && buf.length > 1) {
    if ((buf[1] & 0xC0) !== 0x80) {
      self.lastNeed = 1;
      return '\ufffd';
    }
    if (self.lastNeed > 2 && buf.length > 2) {
      if ((buf[2] & 0xC0) !== 0x80) {
        self.lastNeed = 2;
        return '\ufffd';
      }
    }
  }
}

// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.
function utf8FillLast(buf) {
  var p = this.lastTotal - this.lastNeed;
  var r = utf8CheckExtraBytes(this, buf, p);
  if (r !== undefined) return r;
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, p, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, p, 0, buf.length);
  this.lastNeed -= buf.length;
}

// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
// partial character, the character's bytes are buffered until the required
// number of bytes are available.
function utf8Text(buf, i) {
  var total = utf8CheckIncomplete(this, buf, i);
  if (!this.lastNeed) return buf.toString('utf8', i);
  this.lastTotal = total;
  var end = buf.length - (total - this.lastNeed);
  buf.copy(this.lastChar, 0, end);
  return buf.toString('utf8', i, end);
}

// For UTF-8, a replacement character is added when ending on a partial
// character.
function utf8End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + '\ufffd';
  return r;
}

// UTF-16LE typically needs two bytes per character, but even if we have an even
// number of bytes available, we need to check if we end on a leading/high
// surrogate. In that case, we need to wait for the next two bytes in order to
// decode the last character properly.
function utf16Text(buf, i) {
  if ((buf.length - i) % 2 === 0) {
    var r = buf.toString('utf16le', i);
    if (r) {
      var c = r.charCodeAt(r.length - 1);
      if (c >= 0xD800 && c <= 0xDBFF) {
        this.lastNeed = 2;
        this.lastTotal = 4;
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
        return r.slice(0, -1);
      }
    }
    return r;
  }
  this.lastNeed = 1;
  this.lastTotal = 2;
  this.lastChar[0] = buf[buf.length - 1];
  return buf.toString('utf16le', i, buf.length - 1);
}

// For UTF-16LE we do not explicitly append special replacement characters if we
// end on a partial character, we simply let v8 handle that.
function utf16End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) {
    var end = this.lastTotal - this.lastNeed;
    return r + this.lastChar.toString('utf16le', 0, end);
  }
  return r;
}

function base64Text(buf, i) {
  var n = (buf.length - i) % 3;
  if (n === 0) return buf.toString('base64', i);
  this.lastNeed = 3 - n;
  this.lastTotal = 3;
  if (n === 1) {
    this.lastChar[0] = buf[buf.length - 1];
  } else {
    this.lastChar[0] = buf[buf.length - 2];
    this.lastChar[1] = buf[buf.length - 1];
  }
  return buf.toString('base64', i, buf.length - n);
}

function base64End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);
  return r;
}

// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)
function simpleWrite(buf) {
  return buf.toString(this.encoding);
}

function simpleEnd(buf) {
  return buf && buf.length ? this.write(buf) : '';
}
},{"safe-buffer":170}],196:[function(require,module,exports){
(function (global){(function (){

/**
 * Module exports.
 */

module.exports = deprecate;

/**
 * Mark that a method should not be used.
 * Returns a modified function which warns once by default.
 *
 * If `localStorage.noDeprecation = true` is set, then it is a no-op.
 *
 * If `localStorage.throwDeprecation = true` is set, then deprecated functions
 * will throw an Error when invoked.
 *
 * If `localStorage.traceDeprecation = true` is set, then deprecated functions
 * will invoke `console.trace()` instead of `console.error()`.
 *
 * @param {Function} fn - the function to deprecate
 * @param {String} msg - the string to print to the console when `fn` is invoked
 * @returns {Function} a new "deprecated" version of `fn`
 * @api public
 */

function deprecate (fn, msg) {
  if (config('noDeprecation')) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (config('throwDeprecation')) {
        throw new Error(msg);
      } else if (config('traceDeprecation')) {
        console.trace(msg);
      } else {
        console.warn(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
}

/**
 * Checks `localStorage` for boolean values for the given `name`.
 *
 * @param {String} name
 * @returns {Boolean}
 * @api private
 */

function config (name) {
  // accessing global.localStorage can trigger a DOMException in sandboxed iframes
  try {
    if (!global.localStorage) return false;
  } catch (_) {
    return false;
  }
  var val = global.localStorage[name];
  if (null == val) return false;
  return String(val).toLowerCase() === 'true';
}

}).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}]},{},[1]);
